(function () {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
	});

	var _global$1 = /*#__PURE__*/Object.freeze({
		default: _global,
		__moduleExports: _global
	});

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var _has$1 = /*#__PURE__*/Object.freeze({
		default: _has,
		__moduleExports: _has
	});

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	var _fails$1 = /*#__PURE__*/Object.freeze({
		default: _fails,
		__moduleExports: _fails
	});

	var require$$1 = ( _fails$1 && _fails ) || _fails$1;

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !require$$1(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var _descriptors$1 = /*#__PURE__*/Object.freeze({
		default: _descriptors,
		__moduleExports: _descriptors
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.5.3' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _core$1 = /*#__PURE__*/Object.freeze({
		default: _core,
		__moduleExports: _core,
		version: _core_1
	});

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _isObject$1 = /*#__PURE__*/Object.freeze({
		default: _isObject,
		__moduleExports: _isObject
	});

	var isObject = ( _isObject$1 && _isObject ) || _isObject$1;

	var _anObject = function (it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _anObject$1 = /*#__PURE__*/Object.freeze({
		default: _anObject,
		__moduleExports: _anObject
	});

	var require$$2 = ( _global$1 && _global ) || _global$1;

	var document$1 = require$$2.document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document$1) && isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _domCreate$1 = /*#__PURE__*/Object.freeze({
		default: _domCreate,
		__moduleExports: _domCreate
	});

	var require$$0 = ( _descriptors$1 && _descriptors ) || _descriptors$1;

	var require$$2$1 = ( _domCreate$1 && _domCreate ) || _domCreate$1;

	var _ie8DomDefine = !require$$0 && !require$$1(function () {
	  return Object.defineProperty(require$$2$1('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	var _ie8DomDefine$1 = /*#__PURE__*/Object.freeze({
		default: _ie8DomDefine,
		__moduleExports: _ie8DomDefine
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function (it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var _toPrimitive$1 = /*#__PURE__*/Object.freeze({
		default: _toPrimitive,
		__moduleExports: _toPrimitive
	});

	var anObject = ( _anObject$1 && _anObject ) || _anObject$1;

	var IE8_DOM_DEFINE = ( _ie8DomDefine$1 && _ie8DomDefine ) || _ie8DomDefine$1;

	var require$$16 = ( _toPrimitive$1 && _toPrimitive ) || _toPrimitive$1;

	var dP = Object.defineProperty;

	var f = require$$0 ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = require$$16(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _objectDp$1 = /*#__PURE__*/Object.freeze({
		default: _objectDp,
		__moduleExports: _objectDp,
		f: f
	});

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _propertyDesc$1 = /*#__PURE__*/Object.freeze({
		default: _propertyDesc,
		__moduleExports: _propertyDesc
	});

	var require$$37 = ( _objectDp$1 && _objectDp ) || _objectDp$1;

	var descriptor = ( _propertyDesc$1 && _propertyDesc ) || _propertyDesc$1;

	var _hide = require$$0 ? function (object, key, value) {
	  return require$$37.f(object, key, descriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var _hide$1 = /*#__PURE__*/Object.freeze({
		default: _hide,
		__moduleExports: _hide
	});

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _uid$1 = /*#__PURE__*/Object.freeze({
		default: _uid,
		__moduleExports: _uid
	});

	var require$$0$1 = ( _hide$1 && _hide ) || _hide$1;

	var has = ( _has$1 && _has ) || _has$1;

	var uid = ( _uid$1 && _uid ) || _uid$1;

	var require$$1$1 = ( _core$1 && _core ) || _core$1;

	var _redefine = createCommonjsModule(function (module) {
	var SRC = uid('src');
	var TO_STRING = 'toString';
	var $toString = Function[TO_STRING];
	var TPL = ('' + $toString).split(TO_STRING);

	require$$1$1.inspectSource = function (it) {
	  return $toString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) has(val, 'name') || require$$0$1(val, 'name', key);
	  if (O[key] === val) return;
	  if (isFunction) has(val, SRC) || require$$0$1(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if (O === require$$2) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    require$$0$1(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    require$$0$1(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});
	});

	var _redefine$1 = /*#__PURE__*/Object.freeze({
		default: _redefine,
		__moduleExports: _redefine
	});

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	var _aFunction$1 = /*#__PURE__*/Object.freeze({
		default: _aFunction,
		__moduleExports: _aFunction
	});

	var aFunction = ( _aFunction$1 && _aFunction ) || _aFunction$1;

	// optional / simple context binding

	var _ctx = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var _ctx$1 = /*#__PURE__*/Object.freeze({
		default: _ctx,
		__moduleExports: _ctx
	});

	var redefine = ( _redefine$1 && _redefine ) || _redefine$1;

	var ctx = ( _ctx$1 && _ctx ) || _ctx$1;

	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? require$$2 : IS_STATIC ? require$$2[name] || (require$$2[name] = {}) : (require$$2[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? require$$1$1 : require$$1$1[name] || (require$$1$1[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, require$$2) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if (target) redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) require$$0$1(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	require$$2.core = require$$1$1;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	var _export$1 = /*#__PURE__*/Object.freeze({
		default: _export,
		__moduleExports: _export
	});

	var _meta = createCommonjsModule(function (module) {
	var META = uid('meta');


	var setDesc = require$$37.f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !require$$1(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};
	});
	var _meta_1 = _meta.KEY;
	var _meta_2 = _meta.NEED;
	var _meta_3 = _meta.fastKey;
	var _meta_4 = _meta.getWeak;
	var _meta_5 = _meta.onFreeze;

	var _meta$1 = /*#__PURE__*/Object.freeze({
		default: _meta,
		__moduleExports: _meta,
		KEY: _meta_1,
		NEED: _meta_2,
		fastKey: _meta_3,
		getWeak: _meta_4,
		onFreeze: _meta_5
	});

	var SHARED = '__core-js_shared__';
	var store = require$$2[SHARED] || (require$$2[SHARED] = {});
	var _shared = function (key) {
	  return store[key] || (store[key] = {});
	};

	var _shared$1 = /*#__PURE__*/Object.freeze({
		default: _shared,
		__moduleExports: _shared
	});

	var require$$0$2 = ( _shared$1 && _shared ) || _shared$1;

	var _wks = createCommonjsModule(function (module) {
	var store = require$$0$2('wks');

	var Symbol = require$$2.Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;
	});

	var _wks$1 = /*#__PURE__*/Object.freeze({
		default: _wks,
		__moduleExports: _wks
	});

	var require$$0$3 = ( _wks$1 && _wks ) || _wks$1;

	var def = require$$37.f;

	var TAG = require$$0$3('toStringTag');

	var _setToStringTag = function (it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};

	var _setToStringTag$1 = /*#__PURE__*/Object.freeze({
		default: _setToStringTag,
		__moduleExports: _setToStringTag
	});

	var f$1 = require$$0$3;

	var _wksExt = {
		f: f$1
	};

	var _wksExt$1 = /*#__PURE__*/Object.freeze({
		default: _wksExt,
		__moduleExports: _wksExt,
		f: f$1
	});

	var _library = false;

	var _library$1 = /*#__PURE__*/Object.freeze({
		default: _library,
		__moduleExports: _library
	});

	var require$$0$4 = ( _library$1 && _library ) || _library$1;

	var wksExt = ( _wksExt$1 && _wksExt ) || _wksExt$1;

	var defineProperty = require$$37.f;
	var _wksDefine = function (name) {
	  var $Symbol = require$$1$1.Symbol || (require$$1$1.Symbol = require$$0$4 ? {} : require$$2.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
	};

	var _wksDefine$1 = /*#__PURE__*/Object.freeze({
		default: _wksDefine,
		__moduleExports: _wksDefine
	});

	var toString = {}.toString;

	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var _cof$1 = /*#__PURE__*/Object.freeze({
		default: _cof,
		__moduleExports: _cof
	});

	var require$$1$2 = ( _cof$1 && _cof ) || _cof$1;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings

	// eslint-disable-next-line no-prototype-builtins
	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return require$$1$2(it) == 'String' ? it.split('') : Object(it);
	};

	var _iobject$1 = /*#__PURE__*/Object.freeze({
		default: _iobject,
		__moduleExports: _iobject
	});

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	var _defined$1 = /*#__PURE__*/Object.freeze({
		default: _defined,
		__moduleExports: _defined
	});

	var IObject = ( _iobject$1 && _iobject ) || _iobject$1;

	var defined = ( _defined$1 && _defined ) || _defined$1;

	// to indexed object, toObject with fallback for non-array-like ES3 strings


	var _toIobject = function (it) {
	  return IObject(defined(it));
	};

	var _toIobject$1 = /*#__PURE__*/Object.freeze({
		default: _toIobject,
		__moduleExports: _toIobject
	});

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	var _toInteger$1 = /*#__PURE__*/Object.freeze({
		default: _toInteger,
		__moduleExports: _toInteger
	});

	var toInteger = ( _toInteger$1 && _toInteger ) || _toInteger$1;

	// 7.1.15 ToLength

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

	var _toLength$1 = /*#__PURE__*/Object.freeze({
		default: _toLength,
		__moduleExports: _toLength
	});

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	var _toAbsoluteIndex$1 = /*#__PURE__*/Object.freeze({
		default: _toAbsoluteIndex,
		__moduleExports: _toAbsoluteIndex
	});

	var toIObject = ( _toIobject$1 && _toIobject ) || _toIobject$1;

	var toLength = ( _toLength$1 && _toLength ) || _toLength$1;

	var require$$15 = ( _toAbsoluteIndex$1 && _toAbsoluteIndex ) || _toAbsoluteIndex$1;

	// false -> Array#indexOf
	// true  -> Array#includes



	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this);
	    var length = toLength(O.length);
	    var index = require$$15(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var _arrayIncludes$1 = /*#__PURE__*/Object.freeze({
		default: _arrayIncludes,
		__moduleExports: _arrayIncludes
	});

	var shared = require$$0$2('keys');

	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = uid(key));
	};

	var _sharedKey$1 = /*#__PURE__*/Object.freeze({
		default: _sharedKey,
		__moduleExports: _sharedKey
	});

	var require$$0$5 = ( _arrayIncludes$1 && _arrayIncludes ) || _arrayIncludes$1;

	var require$$1$3 = ( _sharedKey$1 && _sharedKey ) || _sharedKey$1;

	var arrayIndexOf = require$$0$5(false);
	var IE_PROTO = require$$1$3('IE_PROTO');

	var _objectKeysInternal = function (object, names) {
	  var O = toIObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	var _objectKeysInternal$1 = /*#__PURE__*/Object.freeze({
		default: _objectKeysInternal,
		__moduleExports: _objectKeysInternal
	});

	// IE 8- don't enum bug keys
	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	var _enumBugKeys$1 = /*#__PURE__*/Object.freeze({
		default: _enumBugKeys,
		__moduleExports: _enumBugKeys
	});

	var $keys = ( _objectKeysInternal$1 && _objectKeysInternal ) || _objectKeysInternal$1;

	var require$$0$6 = ( _enumBugKeys$1 && _enumBugKeys ) || _enumBugKeys$1;

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)



	var _objectKeys = Object.keys || function keys(O) {
	  return $keys(O, require$$0$6);
	};

	var _objectKeys$1 = /*#__PURE__*/Object.freeze({
		default: _objectKeys,
		__moduleExports: _objectKeys
	});

	var f$2 = Object.getOwnPropertySymbols;

	var _objectGops = {
		f: f$2
	};

	var _objectGops$1 = /*#__PURE__*/Object.freeze({
		default: _objectGops,
		__moduleExports: _objectGops,
		f: f$2
	});

	var f$3 = {}.propertyIsEnumerable;

	var _objectPie = {
		f: f$3
	};

	var _objectPie$1 = /*#__PURE__*/Object.freeze({
		default: _objectPie,
		__moduleExports: _objectPie,
		f: f$3
	});

	var getKeys = ( _objectKeys$1 && _objectKeys ) || _objectKeys$1;

	var gOPS = ( _objectGops$1 && _objectGops ) || _objectGops$1;

	var require$$0$7 = ( _objectPie$1 && _objectPie ) || _objectPie$1;

	// all enumerable object keys, includes symbols



	var _enumKeys = function (it) {
	  var result = getKeys(it);
	  var getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = require$$0$7.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};

	var _enumKeys$1 = /*#__PURE__*/Object.freeze({
		default: _enumKeys,
		__moduleExports: _enumKeys
	});

	// 7.2.2 IsArray(argument)

	var _isArray = Array.isArray || function isArray(arg) {
	  return require$$1$2(arg) == 'Array';
	};

	var _isArray$1 = /*#__PURE__*/Object.freeze({
		default: _isArray,
		__moduleExports: _isArray
	});

	var _objectDps = require$$0 ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) require$$37.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

	var _objectDps$1 = /*#__PURE__*/Object.freeze({
		default: _objectDps,
		__moduleExports: _objectDps
	});

	var document$2 = require$$2.document;
	var _html = document$2 && document$2.documentElement;

	var _html$1 = /*#__PURE__*/Object.freeze({
		default: _html,
		__moduleExports: _html
	});

	var dPs = ( _objectDps$1 && _objectDps ) || _objectDps$1;

	var html = ( _html$1 && _html ) || _html$1;

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



	var IE_PROTO$1 = require$$1$3('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE$1 = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = require$$2$1('iframe');
	  var i = require$$0$6.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE$1][require$$0$6[i]];
	  return createDict();
	};

	var _objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE$1] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE$1] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

	var _objectCreate$1 = /*#__PURE__*/Object.freeze({
		default: _objectCreate,
		__moduleExports: _objectCreate
	});

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

	var hiddenKeys = require$$0$6.concat('length', 'prototype');

	var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};

	var _objectGopn = {
		f: f$4
	};

	var _objectGopn$1 = /*#__PURE__*/Object.freeze({
		default: _objectGopn,
		__moduleExports: _objectGopn,
		f: f$4
	});

	var gOPN = ( _objectGopn$1 && _objectGopn ) || _objectGopn$1;

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

	var gOPN$1 = gOPN.f;
	var toString$1 = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return gOPN$1(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(toIObject(it));
	};

	var _objectGopnExt = {
		f: f$5
	};

	var _objectGopnExt$1 = /*#__PURE__*/Object.freeze({
		default: _objectGopnExt,
		__moduleExports: _objectGopnExt,
		f: f$5
	});

	var gOPD = Object.getOwnPropertyDescriptor;

	var f$6 = require$$0 ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = require$$16(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (has(O, P)) return descriptor(!require$$0$7.f.call(O, P), O[P]);
	};

	var _objectGopd = {
		f: f$6
	};

	var _objectGopd$1 = /*#__PURE__*/Object.freeze({
		default: _objectGopd,
		__moduleExports: _objectGopd,
		f: f$6
	});

	var $export$1 = ( _export$1 && _export ) || _export$1;

	var require$$0$8 = ( _meta$1 && _meta ) || _meta$1;

	var setToStringTag = ( _setToStringTag$1 && _setToStringTag ) || _setToStringTag$1;

	var require$$0$9 = ( _wksDefine$1 && _wksDefine ) || _wksDefine$1;

	var enumKeys = ( _enumKeys$1 && _enumKeys ) || _enumKeys$1;

	var isArray = ( _isArray$1 && _isArray ) || _isArray$1;

	var create = ( _objectCreate$1 && _objectCreate ) || _objectCreate$1;

	var require$$1$4 = ( _objectGopnExt$1 && _objectGopnExt ) || _objectGopnExt$1;

	var require$$38 = ( _objectGopd$1 && _objectGopd ) || _objectGopd$1;

	// ECMAScript 6 symbols shim





	var META = require$$0$8.KEY;



















	var gOPD$1 = require$$38.f;
	var dP$1 = require$$37.f;
	var gOPN$2 = require$$1$4.f;
	var $Symbol = require$$2.Symbol;
	var $JSON = require$$2.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE$2 = 'prototype';
	var HIDDEN = require$$0$3('_hidden');
	var TO_PRIMITIVE = require$$0$3('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = require$$0$2('symbol-registry');
	var AllSymbols = require$$0$2('symbols');
	var OPSymbols = require$$0$2('op-symbols');
	var ObjectProto = Object[PROTOTYPE$2];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = require$$2.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = require$$0 && require$$1(function () {
	  return create(dP$1({}, 'a', {
	    get: function () { return dP$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD$1(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP$1(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP$1(ObjectProto, key, protoDesc);
	} : dP$1;

	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = create($Symbol[PROTOTYPE$2]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = require$$16(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP$1(it, HIDDEN, descriptor(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = create(D, { enumerable: descriptor(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP$1(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create$$1(it, P) {
	  return P === undefined ? create(it) : $defineProperties(create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = require$$16(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = require$$16(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD$1(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN$2(toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN$2(IS_OP ? OPSymbols : toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, descriptor(1, value));
	    };
	    if (require$$0 && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
	    return this._k;
	  });

	  require$$38.f = $getOwnPropertyDescriptor;
	  require$$37.f = $defineProperty;
	  gOPN.f = require$$1$4.f = $getOwnPropertyNames;
	  require$$0$7.f = $propertyIsEnumerable;
	  gOPS.f = $getOwnPropertySymbols;

	  if (require$$0 && !require$$0$4) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function (name) {
	    return wrap(require$$0$3(name));
	  };
	}

	$export$1($export$1.G + $export$1.W + $export$1.F * !USE_NATIVE, { Symbol: $Symbol });

	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)require$$0$3(es6Symbols[j++]);

	for (var wellKnownSymbols = getKeys(require$$0$3.store), k = 0; wellKnownSymbols.length > k;) require$$0$9(wellKnownSymbols[k++]);

	$export$1($export$1.S + $export$1.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});

	$export$1($export$1.S + $export$1.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export$1($export$1.S + $export$1.F * (!USE_NATIVE || require$$1(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    $replacer = replacer = args[1];
	    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!isArray(replacer)) replacer = function (key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || require$$0$1($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(require$$2.JSON, 'JSON', true);

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export$1($export$1.S, 'Object', { create: create });

	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export$1($export$1.S + $export$1.F * !require$$0, 'Object', { defineProperty: require$$37.f });

	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export$1($export$1.S + $export$1.F * !require$$0, 'Object', { defineProperties: dPs });

	// most Object methods by ES6 should accept primitives



	var _objectSap = function (KEY, exec) {
	  var fn = (require$$1$1.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  $export$1($export$1.S + $export$1.F * require$$1(function () { fn(1); }), 'Object', exp);
	};

	var _objectSap$1 = /*#__PURE__*/Object.freeze({
		default: _objectSap,
		__moduleExports: _objectSap
	});

	var require$$0$10 = ( _objectSap$1 && _objectSap ) || _objectSap$1;

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)

	var $getOwnPropertyDescriptor$1 = require$$38.f;

	require$$0$10('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor$1(toIObject(it), key);
	  };
	});

	// 7.1.13 ToObject(argument)

	var _toObject = function (it) {
	  return Object(defined(it));
	};

	var _toObject$1 = /*#__PURE__*/Object.freeze({
		default: _toObject,
		__moduleExports: _toObject
	});

	var require$$20 = ( _toObject$1 && _toObject ) || _toObject$1;

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


	var IE_PROTO$2 = require$$1$3('IE_PROTO');
	var ObjectProto$1 = Object.prototype;

	var _objectGpo = Object.getPrototypeOf || function (O) {
	  O = require$$20(O);
	  if (has(O, IE_PROTO$2)) return O[IE_PROTO$2];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto$1 : null;
	};

	var _objectGpo$1 = /*#__PURE__*/Object.freeze({
		default: _objectGpo,
		__moduleExports: _objectGpo
	});

	var require$$23 = ( _objectGpo$1 && _objectGpo ) || _objectGpo$1;

	// 19.1.2.9 Object.getPrototypeOf(O)



	require$$0$10('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return require$$23(require$$20(it));
	  };
	});

	// 19.1.2.14 Object.keys(O)



	require$$0$10('keys', function () {
	  return function keys(it) {
	    return getKeys(require$$20(it));
	  };
	});

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	require$$0$10('getOwnPropertyNames', function () {
	  return require$$1$4.f;
	});

	// 19.1.2.5 Object.freeze(O)

	var meta = require$$0$8.onFreeze;

	require$$0$10('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

	// 19.1.2.17 Object.seal(O)

	var meta$1 = require$$0$8.onFreeze;

	require$$0$10('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && isObject(it) ? $seal(meta$1(it)) : it;
	  };
	});

	// 19.1.2.15 Object.preventExtensions(O)

	var meta$2 = require$$0$8.onFreeze;

	require$$0$10('preventExtensions', function ($preventExtensions) {
	  return function preventExtensions(it) {
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta$2(it)) : it;
	  };
	});

	// 19.1.2.12 Object.isFrozen(O)


	require$$0$10('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

	// 19.1.2.13 Object.isSealed(O)


	require$$0$10('isSealed', function ($isSealed) {
	  return function isSealed(it) {
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

	// 19.1.2.11 Object.isExtensible(O)


	require$$0$10('isExtensible', function ($isExtensible) {
	  return function isExtensible(it) {
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

	// 19.1.2.1 Object.assign(target, source, ...)





	var $assign = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	var _objectAssign = !$assign || require$$1(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = require$$20(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = gOPS.f;
	  var isEnum = require$$0$7.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]);
	    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	  } return T;
	} : $assign;

	var _objectAssign$1 = /*#__PURE__*/Object.freeze({
		default: _objectAssign,
		__moduleExports: _objectAssign
	});

	var assign = ( _objectAssign$1 && _objectAssign ) || _objectAssign$1;

	// 19.1.3.1 Object.assign(target, source)


	$export$1($export$1.S + $export$1.F, 'Object', { assign: assign });

	// 7.2.9 SameValue(x, y)
	var _sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	var _sameValue$1 = /*#__PURE__*/Object.freeze({
		default: _sameValue,
		__moduleExports: _sameValue
	});

	var require$$0$11 = ( _sameValue$1 && _sameValue ) || _sameValue$1;

	// 19.1.3.10 Object.is(value1, value2)

	$export$1($export$1.S, 'Object', { is: require$$0$11 });

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */


	var check = function (O, proto) {
	  anObject(O);
	  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	var _setProto = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = ctx(Function.call, require$$38.f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};
	var _setProto_1 = _setProto.set;
	var _setProto_2 = _setProto.check;

	var _setProto$1 = /*#__PURE__*/Object.freeze({
		default: _setProto,
		__moduleExports: _setProto,
		set: _setProto_1,
		check: _setProto_2
	});

	var require$$0$12 = ( _setProto$1 && _setProto ) || _setProto$1;

	// 19.1.3.19 Object.setPrototypeOf(O, proto)

	$export$1($export$1.S, 'Object', { setPrototypeOf: require$$0$12.set });

	// getting tag from 19.1.3.6 Object.prototype.toString()

	var TAG$1 = require$$0$3('toStringTag');
	// ES3 wrong here
	var ARG = require$$1$2(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};

	var _classof = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
	    // builtinTag case
	    : ARG ? require$$1$2(O)
	    // ES3 arguments fallback
	    : (B = require$$1$2(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

	var _classof$1 = /*#__PURE__*/Object.freeze({
		default: _classof,
		__moduleExports: _classof
	});

	var classof = ( _classof$1 && _classof ) || _classof$1;

	// 19.1.3.6 Object.prototype.toString()

	var test = {};
	test[require$$0$3('toStringTag')] = 'z';
	if (test + '' != '[object z]') {
	  redefine(Object.prototype, 'toString', function toString() {
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	var _invoke = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};

	var _invoke$1 = /*#__PURE__*/Object.freeze({
		default: _invoke,
		__moduleExports: _invoke
	});

	var invoke = ( _invoke$1 && _invoke ) || _invoke$1;

	var arraySlice = [].slice;
	var factories = {};

	var construct = function (F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};

	var _bind = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction(this);
	  var partArgs = arraySlice.call(arguments, 1);
	  var bound = function (/* args... */) {
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
	  return bound;
	};

	var _bind$1 = /*#__PURE__*/Object.freeze({
		default: _bind,
		__moduleExports: _bind
	});

	var bind = ( _bind$1 && _bind ) || _bind$1;

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)


	$export$1($export$1.P, 'Function', { bind: bind });

	var dP$2 = require$$37.f;
	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';

	// 19.2.4.2 name
	NAME in FProto || require$$0 && dP$2(FProto, NAME, {
	  configurable: true,
	  get: function () {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});

	var HAS_INSTANCE = require$$0$3('hasInstance');
	var FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if (!(HAS_INSTANCE in FunctionProto)) require$$37.f(FunctionProto, HAS_INSTANCE, { value: function (O) {
	  if (typeof this != 'function' || !isObject(O)) return false;
	  if (!isObject(this.prototype)) return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while (O = require$$23(O)) if (this.prototype === O) return true;
	  return false;
	} });

	var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var _stringWs$1 = /*#__PURE__*/Object.freeze({
		default: _stringWs,
		__moduleExports: _stringWs
	});

	var spaces = ( _stringWs$1 && _stringWs ) || _stringWs$1;

	var space = '[' + spaces + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');

	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = require$$1(function () {
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  $export$1($export$1.P + $export$1.F * FORCE, 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};

	var _stringTrim = exporter;

	var _stringTrim$1 = /*#__PURE__*/Object.freeze({
		default: _stringTrim,
		__moduleExports: _stringTrim
	});

	var require$$1$5 = ( _stringTrim$1 && _stringTrim ) || _stringTrim$1;

	var $parseInt = require$$2.parseInt;
	var $trim = require$$1$5.trim;

	var hex = /^[-+]?0[xX]/;

	var _parseInt = $parseInt(spaces + '08') !== 8 || $parseInt(spaces + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

	var _parseInt$1 = /*#__PURE__*/Object.freeze({
		default: _parseInt,
		__moduleExports: _parseInt
	});

	var $parseInt$1 = ( _parseInt$1 && _parseInt ) || _parseInt$1;

	// 18.2.5 parseInt(string, radix)
	$export$1($export$1.G + $export$1.F * (parseInt != $parseInt$1), { parseInt: $parseInt$1 });

	var $parseFloat = require$$2.parseFloat;
	var $trim$1 = require$$1$5.trim;

	var _parseFloat = 1 / $parseFloat(spaces + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim$1(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	var _parseFloat$1 = /*#__PURE__*/Object.freeze({
		default: _parseFloat,
		__moduleExports: _parseFloat
	});

	var $parseFloat$1 = ( _parseFloat$1 && _parseFloat ) || _parseFloat$1;

	// 18.2.4 parseFloat(string)
	$export$1($export$1.G + $export$1.F * (parseFloat != $parseFloat$1), { parseFloat: $parseFloat$1 });

	var setPrototypeOf = require$$0$12.set;
	var _inheritIfRequired = function (that, target, C) {
	  var S = target.constructor;
	  var P;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  } return that;
	};

	var _inheritIfRequired$1 = /*#__PURE__*/Object.freeze({
		default: _inheritIfRequired,
		__moduleExports: _inheritIfRequired
	});

	var inheritIfRequired = ( _inheritIfRequired$1 && _inheritIfRequired ) || _inheritIfRequired$1;

	var gOPN$3 = gOPN.f;
	var gOPD$2 = require$$38.f;
	var dP$3 = require$$37.f;
	var $trim$2 = require$$1$5.trim;
	var NUMBER = 'Number';
	var $Number = require$$2[NUMBER];
	var Base = $Number;
	var proto = $Number.prototype;
	// Opera ~12 has broken Object#toString
	var BROKEN_COF = require$$1$2(create(proto)) == NUMBER;
	var TRIM = 'trim' in String.prototype;

	// 7.1.3 ToNumber(argument)
	var toNumber = function (argument) {
	  var it = require$$16(argument, false);
	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim$2(it, 3);
	    var first = it.charCodeAt(0);
	    var third, radix, maxCode;
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default: return +it;
	      }
	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? require$$1(function () { proto.valueOf.call(that); }) : require$$1$2(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for (var keys = require$$0 ? gOPN$3(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j$1 = 0, key; keys.length > j$1; j$1++) {
	    if (has(Base, key = keys[j$1]) && !has($Number, key)) {
	      dP$3($Number, key, gOPD$2(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  redefine(require$$2, NUMBER, $Number);
	}

	var _aNumberValue = function (it, msg) {
	  if (typeof it != 'number' && require$$1$2(it) != 'Number') throw TypeError(msg);
	  return +it;
	};

	var _aNumberValue$1 = /*#__PURE__*/Object.freeze({
		default: _aNumberValue,
		__moduleExports: _aNumberValue
	});

	var _stringRepeat = function repeat(count) {
	  var str = String(defined(this));
	  var res = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
	  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
	  return res;
	};

	var _stringRepeat$1 = /*#__PURE__*/Object.freeze({
		default: _stringRepeat,
		__moduleExports: _stringRepeat
	});

	var aNumberValue = ( _aNumberValue$1 && _aNumberValue ) || _aNumberValue$1;

	var repeat = ( _stringRepeat$1 && _stringRepeat ) || _stringRepeat$1;

	var $toFixed = 1.0.toFixed;
	var floor$1 = Math.floor;
	var data = [0, 0, 0, 0, 0, 0];
	var ERROR = 'Number.toFixed: incorrect invocation!';
	var ZERO = '0';

	var multiply = function (n, c) {
	  var i = -1;
	  var c2 = c;
	  while (++i < 6) {
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor$1(c2 / 1e7);
	  }
	};
	var divide = function (n) {
	  var i = 6;
	  var c = 0;
	  while (--i >= 0) {
	    c += data[i];
	    data[i] = floor$1(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function () {
	  var i = 6;
	  var s = '';
	  while (--i >= 0) {
	    if (s !== '' || i === 0 || data[i] !== 0) {
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};

	$export$1($export$1.P + $export$1.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
	) || !require$$1(function () {
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits) {
	    var x = aNumberValue(this, ERROR);
	    var f = toInteger(fractionDigits);
	    var s = '';
	    var m = ZERO;
	    var e, z, j, k;
	    if (f < 0 || f > 20) throw RangeError(ERROR);
	    // eslint-disable-next-line no-self-compare
	    if (x != x) return 'NaN';
	    if (x <= -1e21 || x >= 1e21) return String(x);
	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }
	    if (x > 1e-21) {
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = f;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if (f > 0) {
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

	var $toPrecision = 1.0.toPrecision;

	$export$1($export$1.P + $export$1.F * (require$$1(function () {
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !require$$1(function () {
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision) {
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
	  }
	});

	// 20.1.2.1 Number.EPSILON


	$export$1($export$1.S, 'Number', { EPSILON: Math.pow(2, -52) });

	// 20.1.2.2 Number.isFinite(number)

	var _isFinite = require$$2.isFinite;

	$export$1($export$1.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

	// 20.1.2.3 Number.isInteger(number)

	var floor$2 = Math.floor;
	var _isInteger = function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor$2(it) === it;
	};

	var _isInteger$1 = /*#__PURE__*/Object.freeze({
		default: _isInteger,
		__moduleExports: _isInteger
	});

	var isInteger = ( _isInteger$1 && _isInteger ) || _isInteger$1;

	// 20.1.2.3 Number.isInteger(number)


	$export$1($export$1.S, 'Number', { isInteger: isInteger });

	// 20.1.2.4 Number.isNaN(number)


	$export$1($export$1.S, 'Number', {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	// 20.1.2.5 Number.isSafeInteger(number)


	var abs = Math.abs;

	$export$1($export$1.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

	// 20.1.2.6 Number.MAX_SAFE_INTEGER


	$export$1($export$1.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

	// 20.1.2.10 Number.MIN_SAFE_INTEGER


	$export$1($export$1.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

	// 20.1.2.12 Number.parseFloat(string)
	$export$1($export$1.S + $export$1.F * (Number.parseFloat != $parseFloat$1), 'Number', { parseFloat: $parseFloat$1 });

	// 20.1.2.13 Number.parseInt(string, radix)
	$export$1($export$1.S + $export$1.F * (Number.parseInt != $parseInt$1), 'Number', { parseInt: $parseInt$1 });

	// 20.2.2.20 Math.log1p(x)
	var _mathLog1p = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

	var _mathLog1p$1 = /*#__PURE__*/Object.freeze({
		default: _mathLog1p,
		__moduleExports: _mathLog1p
	});

	var require$$0$13 = ( _mathLog1p$1 && _mathLog1p ) || _mathLog1p$1;

	// 20.2.2.3 Math.acosh(x)


	var sqrt = Math.sqrt;
	var $acosh = Math.acosh;

	$export$1($export$1.S + $export$1.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : require$$0$13(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

	// 20.2.2.5 Math.asinh(x)

	var $asinh = Math.asinh;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}

	// Tor Browser bug: Math.asinh(0) -> -0
	$export$1($export$1.S + $export$1.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

	// 20.2.2.7 Math.atanh(x)

	var $atanh = Math.atanh;

	// Tor Browser bug: Math.atanh(-0) -> 0
	$export$1($export$1.S + $export$1.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

	// 20.2.2.28 Math.sign(x)
	var _mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	var _mathSign$1 = /*#__PURE__*/Object.freeze({
		default: _mathSign,
		__moduleExports: _mathSign
	});

	var sign = ( _mathSign$1 && _mathSign ) || _mathSign$1;

	// 20.2.2.9 Math.cbrt(x)



	$export$1($export$1.S, 'Math', {
	  cbrt: function cbrt(x) {
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

	// 20.2.2.11 Math.clz32(x)


	$export$1($export$1.S, 'Math', {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

	// 20.2.2.12 Math.cosh(x)

	var exp = Math.exp;

	$export$1($export$1.S, 'Math', {
	  cosh: function cosh(x) {
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	var _mathExpm1 = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

	var _mathExpm1$1 = /*#__PURE__*/Object.freeze({
		default: _mathExpm1,
		__moduleExports: _mathExpm1
	});

	var expm1 = ( _mathExpm1$1 && _mathExpm1 ) || _mathExpm1$1;

	// 20.2.2.14 Math.expm1(x)



	$export$1($export$1.S + $export$1.F * (expm1 != Math.expm1), 'Math', { expm1: expm1 });

	// 20.2.2.16 Math.fround(x)

	var pow$1 = Math.pow;
	var EPSILON = pow$1(2, -52);
	var EPSILON32 = pow$1(2, -23);
	var MAX32 = pow$1(2, 127) * (2 - EPSILON32);
	var MIN32 = pow$1(2, -126);

	var roundTiesToEven = function (n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	var _mathFround = Math.fround || function fround(x) {
	  var $abs = Math.abs(x);
	  var $sign = sign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};

	var _mathFround$1 = /*#__PURE__*/Object.freeze({
		default: _mathFround,
		__moduleExports: _mathFround
	});

	var fround = ( _mathFround$1 && _mathFround ) || _mathFround$1;

	// 20.2.2.16 Math.fround(x)


	$export$1($export$1.S, 'Math', { fround: fround });

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])

	var abs$1 = Math.abs;

	$export$1($export$1.S, 'Math', {
	  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs$1(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

	// 20.2.2.18 Math.imul(x, y)

	var $imul = Math.imul;

	// some WebKit versions fails with big numbers, some has wrong arity
	$export$1($export$1.S + $export$1.F * require$$1(function () {
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y) {
	    var UINT16 = 0xffff;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

	// 20.2.2.21 Math.log10(x)


	$export$1($export$1.S, 'Math', {
	  log10: function log10(x) {
	    return Math.log(x) * Math.LOG10E;
	  }
	});

	// 20.2.2.20 Math.log1p(x)


	$export$1($export$1.S, 'Math', { log1p: require$$0$13 });

	// 20.2.2.22 Math.log2(x)


	$export$1($export$1.S, 'Math', {
	  log2: function log2(x) {
	    return Math.log(x) / Math.LN2;
	  }
	});

	// 20.2.2.28 Math.sign(x)


	$export$1($export$1.S, 'Math', { sign: sign });

	// 20.2.2.30 Math.sinh(x)


	var exp$1 = Math.exp;

	// V8 near Chromium 38 has a problem with very small numbers
	$export$1($export$1.S + $export$1.F * require$$1(function () {
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x) {
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp$1(x - 1) - exp$1(-x - 1)) * (Math.E / 2);
	  }
	});

	// 20.2.2.33 Math.tanh(x)


	var exp$2 = Math.exp;

	$export$1($export$1.S, 'Math', {
	  tanh: function tanh(x) {
	    var a = expm1(x = +x);
	    var b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
	  }
	});

	// 20.2.2.34 Math.trunc(x)


	$export$1($export$1.S, 'Math', {
	  trunc: function trunc(it) {
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	$export$1($export$1.S + $export$1.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments[i++];
	      if (require$$15(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

	$export$1($export$1.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite) {
	    var tpl = toIObject(callSite.raw);
	    var len = toLength(tpl.length);
	    var aLen = arguments.length;
	    var res = [];
	    var i = 0;
	    while (len > i) {
	      res.push(String(tpl[i++]));
	      if (i < aLen) res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

	// 21.1.3.25 String.prototype.trim()
	require$$1$5('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});

	// true  -> String#at
	// false -> String#codePointAt
	var _stringAt = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that));
	    var i = toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var _stringAt$1 = /*#__PURE__*/Object.freeze({
		default: _stringAt,
		__moduleExports: _stringAt
	});

	var _iterators = {};

	var _iterators$1 = /*#__PURE__*/Object.freeze({
		default: _iterators,
		__moduleExports: _iterators
	});

	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	require$$0$1(IteratorPrototype, require$$0$3('iterator'), function () { return this; });

	var _iterCreate = function (Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

	var _iterCreate$1 = /*#__PURE__*/Object.freeze({
		default: _iterCreate,
		__moduleExports: _iterCreate
	});

	var require$$32 = ( _iterators$1 && _iterators ) || _iterators$1;

	var $iterCreate = ( _iterCreate$1 && _iterCreate ) || _iterCreate$1;

	var ITERATOR = require$$0$3('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function () { return this; };

	var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = require$$23($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!require$$0$4 && !has(IteratorPrototype, ITERATOR)) require$$0$1(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ((!require$$0$4 || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    require$$0$1(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  require$$32[NAME] = $default;
	  require$$32[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else $export$1($export$1.P + $export$1.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

	var _iterDefine$1 = /*#__PURE__*/Object.freeze({
		default: _iterDefine,
		__moduleExports: _iterDefine
	});

	var require$$0$14 = ( _stringAt$1 && _stringAt ) || _stringAt$1;

	var $iterDefine = ( _iterDefine$1 && _iterDefine ) || _iterDefine$1;

	var $at = require$$0$14(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	$iterDefine(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});

	var $at$1 = require$$0$14(false);
	$export$1($export$1.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at$1(this, pos);
	  }
	});

	// 7.2.8 IsRegExp(argument)


	var MATCH = require$$0$3('match');
	var _isRegexp = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : require$$1$2(it) == 'RegExp');
	};

	var _isRegexp$1 = /*#__PURE__*/Object.freeze({
		default: _isRegexp,
		__moduleExports: _isRegexp
	});

	var isRegExp = ( _isRegexp$1 && _isRegexp ) || _isRegexp$1;

	// helper for String#{startsWith, endsWith, includes}



	var _stringContext = function (that, searchString, NAME) {
	  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

	var _stringContext$1 = /*#__PURE__*/Object.freeze({
		default: _stringContext,
		__moduleExports: _stringContext
	});

	var MATCH$1 = require$$0$3('match');
	var _failsIsRegexp = function (KEY) {
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH$1] = false;
	      return !'/./'[KEY](re);
	    } catch (f) { /* empty */ }
	  } return true;
	};

	var _failsIsRegexp$1 = /*#__PURE__*/Object.freeze({
		default: _failsIsRegexp,
		__moduleExports: _failsIsRegexp
	});

	var context = ( _stringContext$1 && _stringContext ) || _stringContext$1;

	var require$$0$15 = ( _failsIsRegexp$1 && _failsIsRegexp ) || _failsIsRegexp$1;

	var ENDS_WITH = 'endsWith';
	var $endsWith = ''[ENDS_WITH];

	$export$1($export$1.P + $export$1.F * require$$0$15(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = context(this, searchString, ENDS_WITH);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
	    var search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

	var INCLUDES = 'includes';

	$export$1($export$1.P + $export$1.F * require$$0$15(INCLUDES), 'String', {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	$export$1($export$1.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: repeat
	});

	var STARTS_WITH = 'startsWith';
	var $startsWith = ''[STARTS_WITH];

	$export$1($export$1.P + $export$1.F * require$$0$15(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = context(this, searchString, STARTS_WITH);
	    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

	var quot = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function (string, tag, attribute, value) {
	  var S = String(defined(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	var _stringHtml = function (NAME, exec) {
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export$1($export$1.P + $export$1.F * require$$1(function () {
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

	var _stringHtml$1 = /*#__PURE__*/Object.freeze({
		default: _stringHtml,
		__moduleExports: _stringHtml
	});

	var require$$0$16 = ( _stringHtml$1 && _stringHtml ) || _stringHtml$1;

	// B.2.3.2 String.prototype.anchor(name)
	require$$0$16('anchor', function (createHTML) {
	  return function anchor(name) {
	    return createHTML(this, 'a', 'name', name);
	  };
	});

	// B.2.3.3 String.prototype.big()
	require$$0$16('big', function (createHTML) {
	  return function big() {
	    return createHTML(this, 'big', '', '');
	  };
	});

	// B.2.3.4 String.prototype.blink()
	require$$0$16('blink', function (createHTML) {
	  return function blink() {
	    return createHTML(this, 'blink', '', '');
	  };
	});

	// B.2.3.5 String.prototype.bold()
	require$$0$16('bold', function (createHTML) {
	  return function bold() {
	    return createHTML(this, 'b', '', '');
	  };
	});

	// B.2.3.6 String.prototype.fixed()
	require$$0$16('fixed', function (createHTML) {
	  return function fixed() {
	    return createHTML(this, 'tt', '', '');
	  };
	});

	// B.2.3.7 String.prototype.fontcolor(color)
	require$$0$16('fontcolor', function (createHTML) {
	  return function fontcolor(color) {
	    return createHTML(this, 'font', 'color', color);
	  };
	});

	// B.2.3.8 String.prototype.fontsize(size)
	require$$0$16('fontsize', function (createHTML) {
	  return function fontsize(size) {
	    return createHTML(this, 'font', 'size', size);
	  };
	});

	// B.2.3.9 String.prototype.italics()
	require$$0$16('italics', function (createHTML) {
	  return function italics() {
	    return createHTML(this, 'i', '', '');
	  };
	});

	// B.2.3.10 String.prototype.link(url)
	require$$0$16('link', function (createHTML) {
	  return function link(url) {
	    return createHTML(this, 'a', 'href', url);
	  };
	});

	// B.2.3.11 String.prototype.small()
	require$$0$16('small', function (createHTML) {
	  return function small() {
	    return createHTML(this, 'small', '', '');
	  };
	});

	// B.2.3.12 String.prototype.strike()
	require$$0$16('strike', function (createHTML) {
	  return function strike() {
	    return createHTML(this, 'strike', '', '');
	  };
	});

	// B.2.3.13 String.prototype.sub()
	require$$0$16('sub', function (createHTML) {
	  return function sub() {
	    return createHTML(this, 'sub', '', '');
	  };
	});

	// B.2.3.14 String.prototype.sup()
	require$$0$16('sup', function (createHTML) {
	  return function sup() {
	    return createHTML(this, 'sup', '', '');
	  };
	});

	// 20.3.3.1 / 15.9.4.4 Date.now()


	$export$1($export$1.S, 'Date', { now: function () { return new Date().getTime(); } });

	$export$1($export$1.P + $export$1.F * require$$1(function () {
	  return new Date(NaN).toJSON() !== null
	    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
	}), 'Date', {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = require$$20(this);
	    var pv = require$$16(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

	var getTime = Date.prototype.getTime;
	var $toISOString = Date.prototype.toISOString;

	var lz = function (num) {
	  return num > 9 ? num : '0' + num;
	};

	// PhantomJS / old WebKit has a broken implementations
	var _dateToIsoString = (require$$1(function () {
	  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !require$$1(function () {
	  $toISOString.call(new Date(NaN));
	})) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var d = this;
	  var y = d.getUTCFullYear();
	  var m = d.getUTCMilliseconds();
	  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	} : $toISOString;

	var _dateToIsoString$1 = /*#__PURE__*/Object.freeze({
		default: _dateToIsoString,
		__moduleExports: _dateToIsoString
	});

	var toISOString = ( _dateToIsoString$1 && _dateToIsoString ) || _dateToIsoString$1;

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()



	// PhantomJS / old WebKit has a broken implementations
	$export$1($export$1.P + $export$1.F * (Date.prototype.toISOString !== toISOString), 'Date', {
	  toISOString: toISOString
	});

	var DateProto = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var $toString = DateProto[TO_STRING];
	var getTime$1 = DateProto.getTime;
	if (new Date(NaN) + '' != INVALID_DATE) {
	  redefine(DateProto, TO_STRING, function toString() {
	    var value = getTime$1.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

	var NUMBER$1 = 'number';

	var _dateToPrimitive = function (hint) {
	  if (hint !== 'string' && hint !== NUMBER$1 && hint !== 'default') throw TypeError('Incorrect hint');
	  return require$$16(anObject(this), hint != NUMBER$1);
	};

	var _dateToPrimitive$1 = /*#__PURE__*/Object.freeze({
		default: _dateToPrimitive,
		__moduleExports: _dateToPrimitive
	});

	var require$$2$2 = ( _dateToPrimitive$1 && _dateToPrimitive ) || _dateToPrimitive$1;

	var TO_PRIMITIVE$1 = require$$0$3('toPrimitive');
	var proto$1 = Date.prototype;

	if (!(TO_PRIMITIVE$1 in proto$1)) require$$0$1(proto$1, TO_PRIMITIVE$1, require$$2$2);

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)


	$export$1($export$1.S, 'Array', { isArray: isArray });

	// call something on iterator step with safe closing on error

	var _iterCall = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) anObject(ret.call(iterator));
	    throw e;
	  }
	};

	var _iterCall$1 = /*#__PURE__*/Object.freeze({
		default: _iterCall,
		__moduleExports: _iterCall
	});

	// check on default Array iterator

	var ITERATOR$1 = require$$0$3('iterator');
	var ArrayProto = Array.prototype;

	var _isArrayIter = function (it) {
	  return it !== undefined && (require$$32.Array === it || ArrayProto[ITERATOR$1] === it);
	};

	var _isArrayIter$1 = /*#__PURE__*/Object.freeze({
		default: _isArrayIter,
		__moduleExports: _isArrayIter
	});

	var _createProperty = function (object, index, value) {
	  if (index in object) require$$37.f(object, index, descriptor(0, value));
	  else object[index] = value;
	};

	var _createProperty$1 = /*#__PURE__*/Object.freeze({
		default: _createProperty,
		__moduleExports: _createProperty
	});

	var ITERATOR$2 = require$$0$3('iterator');

	var core_getIteratorMethod = require$$1$1.getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$2]
	    || it['@@iterator']
	    || require$$32[classof(it)];
	};

	var core_getIteratorMethod$1 = /*#__PURE__*/Object.freeze({
		default: core_getIteratorMethod,
		__moduleExports: core_getIteratorMethod
	});

	var ITERATOR$3 = require$$0$3('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR$3]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	} catch (e) { /* empty */ }

	var _iterDetect = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR$3]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR$3] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};

	var _iterDetect$1 = /*#__PURE__*/Object.freeze({
		default: _iterDetect,
		__moduleExports: _iterDetect
	});

	var call = ( _iterCall$1 && _iterCall ) || _iterCall$1;

	var require$$21 = ( _isArrayIter$1 && _isArrayIter ) || _isArrayIter$1;

	var createProperty = ( _createProperty$1 && _createProperty ) || _createProperty$1;

	var require$$25 = ( core_getIteratorMethod$1 && core_getIteratorMethod ) || core_getIteratorMethod$1;

	var require$$33 = ( _iterDetect$1 && _iterDetect ) || _iterDetect$1;

	$export$1($export$1.S + $export$1.F * !require$$33(function (iter) { }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	    var O = require$$20(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = require$$25(O);
	    var length, result, step, iterator;
	    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && require$$21(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});

	// WebKit Array.of isn't generic
	$export$1($export$1.S + $export$1.F * require$$1(function () {
	  function F() { /* empty */ }
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */) {
	    var index = 0;
	    var aLen = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(aLen);
	    while (aLen > index) createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

	var _strictMethod = function (method, arg) {
	  return !!method && require$$1(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
	  });
	};

	var _strictMethod$1 = /*#__PURE__*/Object.freeze({
		default: _strictMethod,
		__moduleExports: _strictMethod
	});

	var require$$0$17 = ( _strictMethod$1 && _strictMethod ) || _strictMethod$1;

	// 22.1.3.13 Array.prototype.join(separator)


	var arrayJoin = [].join;

	// fallback for not array-like strings
	$export$1($export$1.P + $export$1.F * (IObject != Object || !require$$0$17(arrayJoin)), 'Array', {
	  join: function join(separator) {
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

	var arraySlice$1 = [].slice;

	// fallback for not array-like ES3 strings and DOM objects
	$export$1($export$1.P + $export$1.F * require$$1(function () {
	  if (html) arraySlice$1.call(html);
	}), 'Array', {
	  slice: function slice(begin, end) {
	    var len = toLength(this.length);
	    var klass = require$$1$2(this);
	    end = end === undefined ? len : end;
	    if (klass == 'Array') return arraySlice$1.call(this, begin, end);
	    var start = require$$15(begin, len);
	    var upTo = require$$15(end, len);
	    var size = toLength(upTo - start);
	    var cloned = new Array(size);
	    var i = 0;
	    for (; i < size; i++) cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

	var $sort = [].sort;
	var test$1 = [1, 2, 3];

	$export$1($export$1.P + $export$1.F * (require$$1(function () {
	  // IE8-
	  test$1.sort(undefined);
	}) || !require$$1(function () {
	  // V8 bug
	  test$1.sort(null);
	  // Old WebKit
	}) || !require$$0$17($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? $sort.call(require$$20(this))
	      : $sort.call(require$$20(this), aFunction(comparefn));
	  }
	});

	var SPECIES = require$$0$3('species');

	var _arraySpeciesConstructor = function (original) {
	  var C;
	  if (isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

	var _arraySpeciesConstructor$1 = /*#__PURE__*/Object.freeze({
		default: _arraySpeciesConstructor,
		__moduleExports: _arraySpeciesConstructor
	});

	var speciesConstructor = ( _arraySpeciesConstructor$1 && _arraySpeciesConstructor ) || _arraySpeciesConstructor$1;

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


	var _arraySpeciesCreate = function (original, length) {
	  return new (speciesConstructor(original))(length);
	};

	var _arraySpeciesCreate$1 = /*#__PURE__*/Object.freeze({
		default: _arraySpeciesCreate,
		__moduleExports: _arraySpeciesCreate
	});

	var asc = ( _arraySpeciesCreate$1 && _arraySpeciesCreate ) || _arraySpeciesCreate$1;

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex





	var _arrayMethods = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || asc;
	  return function ($this, callbackfn, that) {
	    var O = require$$20($this);
	    var self = IObject(O);
	    var f = ctx(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      val = self[index];
	      res = f(val, index, O);
	      if (TYPE) {
	        if (IS_MAP) result[index] = res;   // map
	        else if (res) switch (TYPE) {
	          case 3: return true;             // some
	          case 5: return val;              // find
	          case 6: return index;            // findIndex
	          case 2: result.push(val);        // filter
	        } else if (IS_EVERY) return false; // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

	var _arrayMethods$1 = /*#__PURE__*/Object.freeze({
		default: _arrayMethods,
		__moduleExports: _arrayMethods
	});

	var require$$28 = ( _arrayMethods$1 && _arrayMethods ) || _arrayMethods$1;

	var $forEach = require$$28(0);
	var STRICT = require$$0$17([].forEach, true);

	$export$1($export$1.P + $export$1.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

	var $map = require$$28(1);

	$export$1($export$1.P + $export$1.F * !require$$0$17([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

	var $filter = require$$28(2);

	$export$1($export$1.P + $export$1.F * !require$$0$17([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

	var $some = require$$28(3);

	$export$1($export$1.P + $export$1.F * !require$$0$17([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

	var $every = require$$28(4);

	$export$1($export$1.P + $export$1.F * !require$$0$17([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

	var _arrayReduce = function (that, callbackfn, aLen, memo, isRight) {
	  aFunction(callbackfn);
	  var O = require$$20(that);
	  var self = IObject(O);
	  var length = toLength(O.length);
	  var index = isRight ? length - 1 : 0;
	  var i = isRight ? -1 : 1;
	  if (aLen < 2) for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

	var _arrayReduce$1 = /*#__PURE__*/Object.freeze({
		default: _arrayReduce,
		__moduleExports: _arrayReduce
	});

	var $reduce = ( _arrayReduce$1 && _arrayReduce ) || _arrayReduce$1;

	$export$1($export$1.P + $export$1.F * !require$$0$17([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

	$export$1($export$1.P + $export$1.F * !require$$0$17([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

	var $indexOf = require$$0$5(false);
	var $native = [].indexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

	$export$1($export$1.P + $export$1.F * (NEGATIVE_ZERO || !require$$0$17($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

	var $native$1 = [].lastIndexOf;
	var NEGATIVE_ZERO$1 = !!$native$1 && 1 / [1].lastIndexOf(1, -0) < 0;

	$export$1($export$1.P + $export$1.F * (NEGATIVE_ZERO$1 || !require$$0$17($native$1)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO$1) return $native$1.apply(this, arguments) || 0;
	    var O = toIObject(this);
	    var length = toLength(O.length);
	    var index = length - 1;
	    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
	    if (index < 0) index = length + index;
	    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
	    return -1;
	  }
	});

	var _arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = require$$20(this);
	  var len = toLength(O.length);
	  var to = require$$15(target, len);
	  var from = require$$15(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = Math.min((end === undefined ? len : require$$15(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];
	    else delete O[to];
	    to += inc;
	    from += inc;
	  } return O;
	};

	var _arrayCopyWithin$1 = /*#__PURE__*/Object.freeze({
		default: _arrayCopyWithin,
		__moduleExports: _arrayCopyWithin
	});

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = require$$0$3('unscopables');
	var ArrayProto$1 = Array.prototype;
	if (ArrayProto$1[UNSCOPABLES] == undefined) require$$0$1(ArrayProto$1, UNSCOPABLES, {});
	var _addToUnscopables = function (key) {
	  ArrayProto$1[UNSCOPABLES][key] = true;
	};

	var _addToUnscopables$1 = /*#__PURE__*/Object.freeze({
		default: _addToUnscopables,
		__moduleExports: _addToUnscopables
	});

	var require$$36 = ( _arrayCopyWithin$1 && _arrayCopyWithin ) || _arrayCopyWithin$1;

	var require$$0$18 = ( _addToUnscopables$1 && _addToUnscopables ) || _addToUnscopables$1;

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


	$export$1($export$1.P, 'Array', { copyWithin: require$$36 });

	require$$0$18('copyWithin');

	var _arrayFill = function fill(value /* , start = 0, end = @length */) {
	  var O = require$$20(this);
	  var length = toLength(O.length);
	  var aLen = arguments.length;
	  var index = require$$15(aLen > 1 ? arguments[1] : undefined, length);
	  var end = aLen > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : require$$15(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};

	var _arrayFill$1 = /*#__PURE__*/Object.freeze({
		default: _arrayFill,
		__moduleExports: _arrayFill
	});

	var require$$35 = ( _arrayFill$1 && _arrayFill ) || _arrayFill$1;

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


	$export$1($export$1.P, 'Array', { fill: require$$35 });

	require$$0$18('fill');

	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

	var $find = require$$28(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	$export$1($export$1.P + $export$1.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	require$$0$18(KEY);

	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

	var $find$1 = require$$28(6);
	var KEY$1 = 'findIndex';
	var forced$1 = true;
	// Shouldn't skip holes
	if (KEY$1 in []) Array(1)[KEY$1](function () { forced$1 = false; });
	$export$1($export$1.P + $export$1.F * forced$1, 'Array', {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	require$$0$18(KEY$1);

	var SPECIES$1 = require$$0$3('species');

	var _setSpecies = function (KEY) {
	  var C = require$$2[KEY];
	  if (require$$0 && C && !C[SPECIES$1]) require$$37.f(C, SPECIES$1, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};

	var _setSpecies$1 = /*#__PURE__*/Object.freeze({
		default: _setSpecies,
		__moduleExports: _setSpecies
	});

	var require$$34 = ( _setSpecies$1 && _setSpecies ) || _setSpecies$1;

	require$$34('Array');

	var _iterStep = function (done, value) {
	  return { value: value, done: !!done };
	};

	var _iterStep$1 = /*#__PURE__*/Object.freeze({
		default: _iterStep,
		__moduleExports: _iterStep
	});

	var step = ( _iterStep$1 && _iterStep ) || _iterStep$1;

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	var es6_array_iterator = $iterDefine(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	require$$32.Arguments = require$$32.Array;

	require$$0$18('keys');
	require$$0$18('values');
	require$$0$18('entries');

	var es6_array_iterator$1 = /*#__PURE__*/Object.freeze({
		default: es6_array_iterator,
		__moduleExports: es6_array_iterator
	});

	// 21.2.5.3 get RegExp.prototype.flags

	var _flags = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	var _flags$1 = /*#__PURE__*/Object.freeze({
		default: _flags,
		__moduleExports: _flags
	});

	var getFlags = ( _flags$1 && _flags ) || _flags$1;

	var dP$4 = require$$37.f;
	var gOPN$4 = gOPN.f;


	var $RegExp = require$$2.RegExp;
	var Base$1 = $RegExp;
	var proto$2 = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;
	// "new" creates a new object, old webkit buggy here
	var CORRECT_NEW = new $RegExp(re1) !== re1;

	if (require$$0 && (!CORRECT_NEW || require$$1(function () {
	  re2[require$$0$3('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = isRegExp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base$1(piRE && !fiU ? p.source : p, f)
	        : Base$1((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? getFlags.call(p) : f)
	      , tiRE ? this : proto$2, $RegExp);
	  };
	  var proxy = function (key) {
	    key in $RegExp || dP$4($RegExp, key, {
	      configurable: true,
	      get: function () { return Base$1[key]; },
	      set: function (it) { Base$1[key] = it; }
	    });
	  };
	  for (var keys$1 = gOPN$4(Base$1), i = 0; keys$1.length > i;) proxy(keys$1[i++]);
	  proto$2.constructor = $RegExp;
	  $RegExp.prototype = proto$2;
	  redefine(require$$2, 'RegExp', $RegExp);
	}

	require$$34('RegExp');

	// 21.2.5.3 get RegExp.prototype.flags()
	if (require$$0 && /./g.flags != 'g') require$$37.f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: getFlags
	});

	var TO_STRING$1 = 'toString';
	var $toString$1 = /./[TO_STRING$1];

	var define = function (fn) {
	  redefine(RegExp.prototype, TO_STRING$1, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if (require$$1(function () { return $toString$1.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
	  define(function toString() {
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !require$$0 && R instanceof RegExp ? getFlags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if ($toString$1.name != TO_STRING$1) {
	  define(function toString() {
	    return $toString$1.call(this);
	  });
	}

	var _fixReWks = function (KEY, length, exec) {
	  var SYMBOL = require$$0$3(KEY);
	  var fns = exec(defined, SYMBOL, ''[KEY]);
	  var strfn = fns[0];
	  var rxfn = fns[1];
	  if (require$$1(function () {
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  })) {
	    redefine(String.prototype, KEY, strfn);
	    require$$0$1(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return rxfn.call(string, this); }
	    );
	  }
	};

	var _fixReWks$1 = /*#__PURE__*/Object.freeze({
		default: _fixReWks,
		__moduleExports: _fixReWks
	});

	var require$$0$19 = ( _fixReWks$1 && _fixReWks ) || _fixReWks$1;

	// @@match logic
	require$$0$19('match', 1, function (defined, MATCH, $match) {
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp) {
	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

	// @@replace logic
	require$$0$19('replace', 2, function (defined, REPLACE, $replace) {
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue) {
	    var O = defined(this);
	    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

	// @@search logic
	require$$0$19('search', 1, function (defined, SEARCH, $search) {
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp) {
	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

	// @@split logic
	require$$0$19('split', 2, function (defined, SPLIT, $split) {
	  var isRegExp$$1 = isRegExp;
	  var _split = $split;
	  var $push = [].push;
	  var $SPLIT = 'split';
	  var LENGTH = 'length';
	  var LAST_INDEX = 'lastIndex';
	  if (
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ) {
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function (separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return [];
	      // If `separator` is not a regex, use native split
	      if (!isRegExp$$1(separator)) return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while (match = separatorCopy.exec(string)) {
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          // eslint-disable-next-line no-loop-func
	          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
	            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
	          });
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }
	        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    $split = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit) {
	    var O = defined(this);
	    var fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

	var _anInstance = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

	var _anInstance$1 = /*#__PURE__*/Object.freeze({
		default: _anInstance,
		__moduleExports: _anInstance
	});

	var _forOf = createCommonjsModule(function (module) {
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : require$$25(iterable);
	  var f = ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (require$$21(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = call(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;
	});

	var _forOf$1 = /*#__PURE__*/Object.freeze({
		default: _forOf,
		__moduleExports: _forOf
	});

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)


	var SPECIES$2 = require$$0$3('species');
	var _speciesConstructor = function (O, D) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$2]) == undefined ? D : aFunction(S);
	};

	var _speciesConstructor$1 = /*#__PURE__*/Object.freeze({
		default: _speciesConstructor,
		__moduleExports: _speciesConstructor
	});

	var process$1 = require$$2.process;
	var setTask = require$$2.setImmediate;
	var clearTask = require$$2.clearImmediate;
	var MessageChannel$1 = require$$2.MessageChannel;
	var Dispatch = require$$2.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (require$$1$2(process$1) == 'process') {
	    defer = function (id) {
	      process$1.nextTick(ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel$1) {
	    channel = new MessageChannel$1();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (require$$2.addEventListener && typeof postMessage == 'function' && !require$$2.importScripts) {
	    defer = function (id) {
	      require$$2.postMessage(id + '', '*');
	    };
	    require$$2.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in require$$2$1('script')) {
	    defer = function (id) {
	      html.appendChild(require$$2$1('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	var _task = {
	  set: setTask,
	  clear: clearTask
	};
	var _task_1 = _task.set;
	var _task_2 = _task.clear;

	var _task$1 = /*#__PURE__*/Object.freeze({
		default: _task,
		__moduleExports: _task,
		set: _task_1,
		clear: _task_2
	});

	var require$$0$20 = ( _task$1 && _task ) || _task$1;

	var macrotask = require$$0$20.set;
	var Observer = require$$2.MutationObserver || require$$2.WebKitMutationObserver;
	var process$2 = require$$2.process;
	var Promise$1 = require$$2.Promise;
	var isNode = require$$1$2(process$2) == 'process';

	var _microtask = function () {
	  var head, last, notify;

	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process$2.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process$2.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(require$$2.navigator && require$$2.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    var promise = Promise$1.resolve();
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(require$$2, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};

	var _microtask$1 = /*#__PURE__*/Object.freeze({
		default: _microtask,
		__moduleExports: _microtask
	});

	// 25.4.1.5 NewPromiseCapability(C)


	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	}

	var f$7 = function (C) {
	  return new PromiseCapability(C);
	};

	var _newPromiseCapability = {
		f: f$7
	};

	var _newPromiseCapability$1 = /*#__PURE__*/Object.freeze({
		default: _newPromiseCapability,
		__moduleExports: _newPromiseCapability,
		f: f$7
	});

	var _perform = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};

	var _perform$1 = /*#__PURE__*/Object.freeze({
		default: _perform,
		__moduleExports: _perform
	});

	var newPromiseCapability = ( _newPromiseCapability$1 && _newPromiseCapability ) || _newPromiseCapability$1;

	var _promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var _promiseResolve$1 = /*#__PURE__*/Object.freeze({
		default: _promiseResolve,
		__moduleExports: _promiseResolve
	});

	var _redefineAll = function (target, src, safe) {
	  for (var key in src) redefine(target, key, src[key], safe);
	  return target;
	};

	var _redefineAll$1 = /*#__PURE__*/Object.freeze({
		default: _redefineAll,
		__moduleExports: _redefineAll
	});

	var require$$8 = ( _anInstance$1 && _anInstance ) || _anInstance$1;

	var forOf = ( _forOf$1 && _forOf ) || _forOf$1;

	var require$$30 = ( _speciesConstructor$1 && _speciesConstructor ) || _speciesConstructor$1;

	var require$$0$21 = ( _microtask$1 && _microtask ) || _microtask$1;

	var perform = ( _perform$1 && _perform ) || _perform$1;

	var promiseResolve = ( _promiseResolve$1 && _promiseResolve ) || _promiseResolve$1;

	var require$$11 = ( _redefineAll$1 && _redefineAll ) || _redefineAll$1;

	var task = require$$0$20.set;
	var microtask = require$$0$21();



	var PROMISE = 'Promise';
	var TypeError$1 = require$$2.TypeError;
	var process$3 = require$$2.process;
	var $Promise = require$$2[PROMISE];
	var isNode$1 = classof(process$3) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability$1 = newGenericPromiseCapability = newPromiseCapability.f;

	var USE_NATIVE$1 = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[require$$0$3('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch (e) { /* empty */ }
	}();

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value);
	            if (domain) domain.exit();
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(require$$2, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = perform(function () {
	        if (isNode$1) {
	          process$3.emit('unhandledRejection', value, promise);
	        } else if (handler = require$$2.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = require$$2.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(require$$2, function () {
	    var handler;
	    if (isNode$1) {
	      process$3.emit('rejectionHandled', promise);
	    } else if (handler = require$$2.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE$1) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    require$$8(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = require$$11($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability$1(require$$30(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode$1 ? process$3.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject = ctx($reject, promise, 1);
	  };
	  newPromiseCapability.f = newPromiseCapability$1 = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	$export$1($export$1.G + $export$1.W + $export$1.F * !USE_NATIVE$1, { Promise: $Promise });
	setToStringTag($Promise, PROMISE);
	require$$34(PROMISE);
	Wrapper = require$$1$1[PROMISE];

	// statics
	$export$1($export$1.S + $export$1.F * !USE_NATIVE$1, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export$1($export$1.S + $export$1.F * (require$$0$4 || !USE_NATIVE$1), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return promiseResolve(require$$0$4 && this === Wrapper ? $Promise : this, x);
	  }
	});
	$export$1($export$1.S + $export$1.F * !(USE_NATIVE$1 && require$$33(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});

	var _validateCollection = function (it, TYPE) {
	  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
	  return it;
	};

	var _validateCollection$1 = /*#__PURE__*/Object.freeze({
		default: _validateCollection,
		__moduleExports: _validateCollection
	});

	var validate = ( _validateCollection$1 && _validateCollection ) || _validateCollection$1;

	var dP$5 = require$$37.f;









	var fastKey = require$$0$8.fastKey;

	var SIZE = require$$0 ? '_s' : 'size';

	var getEntry = function (that, key) {
	  // fast case
	  var index = fastKey(key);
	  var entry;
	  if (index !== 'F') return that._i[index];
	  // frozen object case
	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) return entry;
	  }
	};

	var _collectionStrong = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      require$$8(that, C, NAME, '_i');
	      that._t = NAME;         // collection type
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    require$$11(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = validate(this, NAME);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.n;
	          var prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) prev.n = next;
	          if (next) next.p = prev;
	          if (that._f == entry) that._f = next;
	          if (that._l == entry) that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        validate(this, NAME);
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while (entry && entry.r) entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(validate(this, NAME), key);
	      }
	    });
	    if (require$$0) dP$5(C.prototype, 'size', {
	      get: function () {
	        return validate(this, NAME)[SIZE];
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var entry = getEntry(that, key);
	    var prev, index;
	    // change existing entry
	    if (entry) {
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if (!that._f) that._f = entry;
	      if (prev) prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if (index !== 'F') that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function (C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function (iterated, kind) {
	      this._t = validate(iterated, NAME); // target
	      this._k = kind;                     // kind
	      this._l = undefined;                // previous
	    }, function () {
	      var that = this;
	      var kind = that._k;
	      var entry = that._l;
	      // revert to the last existing entry
	      while (entry && entry.r) entry = entry.p;
	      // get next entry
	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if (kind == 'keys') return step(0, entry.k);
	      if (kind == 'values') return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    require$$34(NAME);
	  }
	};
	var _collectionStrong_1 = _collectionStrong.getConstructor;
	var _collectionStrong_2 = _collectionStrong.def;
	var _collectionStrong_3 = _collectionStrong.getEntry;
	var _collectionStrong_4 = _collectionStrong.setStrong;

	var _collectionStrong$1 = /*#__PURE__*/Object.freeze({
		default: _collectionStrong,
		__moduleExports: _collectionStrong,
		getConstructor: _collectionStrong_1,
		def: _collectionStrong_2,
		getEntry: _collectionStrong_3,
		setStrong: _collectionStrong_4
	});

	var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = require$$2[NAME];
	  var C = Base;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var proto = C && C.prototype;
	  var O = {};
	  var fixMethod = function (KEY) {
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function (a) {
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a) {
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a) {
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !require$$1(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    require$$11(C.prototype, methods);
	    require$$0$8.NEED = true;
	  } else {
	    var instance = new C();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = require$$1(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    var ACCEPT_ITERABLES = require$$33(function (iter) { new C(iter); }); // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && require$$1(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        require$$8(target, C, NAME);
	        var that = inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if (IS_WEAK && proto.clear) delete proto.clear;
	  }

	  setToStringTag(C, NAME);

	  O[NAME] = C;
	  $export$1($export$1.G + $export$1.W + $export$1.F * (C != Base), O);

	  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

	  return C;
	};

	var _collection$1 = /*#__PURE__*/Object.freeze({
		default: _collection,
		__moduleExports: _collection
	});

	var strong = ( _collectionStrong$1 && _collectionStrong ) || _collectionStrong$1;

	var require$$0$22 = ( _collection$1 && _collection ) || _collection$1;

	var MAP = 'Map';

	// 23.1 Map Objects
	var es6_map = require$$0$22(MAP, function (get) {
	  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = strong.getEntry(validate(this, MAP), key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
	  }
	}, strong, true);

	var es6_map$1 = /*#__PURE__*/Object.freeze({
		default: es6_map,
		__moduleExports: es6_map
	});

	var SET = 'Set';

	// 23.2 Set Objects
	var es6_set = require$$0$22(SET, function (get) {
	  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
	  }
	}, strong);

	var es6_set$1 = /*#__PURE__*/Object.freeze({
		default: es6_set,
		__moduleExports: es6_set
	});

	var getWeak = require$$0$8.getWeak;







	var arrayFind = require$$28(5);
	var arrayFindIndex = require$$28(6);
	var id$1 = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function () {
	  this.a = [];
	};
	var findUncaughtFrozen = function (store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function (key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	var _collectionWeak = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      require$$8(that, C, NAME, '_i');
	      that._t = NAME;      // collection type
	      that._i = id$1++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    require$$11(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function (key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
	        return data && has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has$$1(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
	        return data && has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var data = getWeak(anObject(key), true);
	    if (data === true) uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};
	var _collectionWeak_1 = _collectionWeak.getConstructor;
	var _collectionWeak_2 = _collectionWeak.def;
	var _collectionWeak_3 = _collectionWeak.ufstore;

	var _collectionWeak$1 = /*#__PURE__*/Object.freeze({
		default: _collectionWeak,
		__moduleExports: _collectionWeak,
		getConstructor: _collectionWeak_1,
		def: _collectionWeak_2,
		ufstore: _collectionWeak_3
	});

	var weak = ( _collectionWeak$1 && _collectionWeak ) || _collectionWeak$1;

	var es6_weakMap = createCommonjsModule(function (module) {
	var each = require$$28(0);







	var WEAK_MAP = 'WeakMap';
	var getWeak = require$$0$8.getWeak;
	var isExtensible = Object.isExtensible;
	var uncaughtFrozenStore = weak.ufstore;
	var tmp = {};
	var InternalMap;

	var wrapper = function (get) {
	  return function WeakMap() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};

	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key) {
	    if (isObject(key)) {
	      var data = getWeak(key);
	      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value) {
	    return weak.def(validate(this, WEAK_MAP), key, value);
	  }
	};

	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = require$$0$22(WEAK_MAP, wrapper, methods, weak, true, true);

	// IE11 WeakMap frozen keys fix
	if (require$$1(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
	  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
	  assign(InternalMap.prototype, methods);
	  require$$0$8.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function (key) {
	    var proto = $WeakMap.prototype;
	    var method = proto[key];
	    redefine(proto, key, function (a, b) {
	      // store frozen objects on internal weakmap shim
	      if (isObject(a) && !isExtensible(a)) {
	        if (!this._f) this._f = new InternalMap();
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}
	});

	var es6_weakMap$1 = /*#__PURE__*/Object.freeze({
		default: es6_weakMap,
		__moduleExports: es6_weakMap
	});

	var WEAK_SET = 'WeakSet';

	// 23.4 WeakSet Objects
	require$$0$22(WEAK_SET, function (get) {
	  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value) {
	    return weak.def(validate(this, WEAK_SET), value, true);
	  }
	}, weak, false, true);

	var TYPED = uid('typed_array');
	var VIEW = uid('view');
	var ABV = !!(require$$2.ArrayBuffer && require$$2.DataView);
	var CONSTR = ABV;
	var i$1 = 0;
	var l = 9;
	var Typed;

	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');

	while (i$1 < l) {
	  if (Typed = require$$2[TypedArrayConstructors[i$1++]]) {
	    require$$0$1(Typed.prototype, TYPED, true);
	    require$$0$1(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}

	var _typed = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};
	var _typed_1 = _typed.ABV;
	var _typed_2 = _typed.CONSTR;
	var _typed_3 = _typed.TYPED;
	var _typed_4 = _typed.VIEW;

	var _typed$1 = /*#__PURE__*/Object.freeze({
		default: _typed,
		__moduleExports: _typed,
		ABV: _typed_1,
		CONSTR: _typed_2,
		TYPED: _typed_3,
		VIEW: _typed_4
	});

	// https://tc39.github.io/ecma262/#sec-toindex


	var _toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length!');
	  return length;
	};

	var _toIndex$1 = /*#__PURE__*/Object.freeze({
		default: _toIndex,
		__moduleExports: _toIndex
	});

	var require$$5 = ( _typed$1 && _typed ) || _typed$1;

	var require$$14 = ( _toIndex$1 && _toIndex ) || _toIndex$1;

	var _typedBuffer = createCommonjsModule(function (module, exports) {











	var gOPN$$1 = gOPN.f;
	var dP = require$$37.f;


	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH = 'Wrong length!';
	var WRONG_INDEX = 'Wrong index!';
	var $ArrayBuffer = require$$2[ARRAY_BUFFER];
	var $DataView = require$$2[DATA_VIEW];
	var Math = require$$2.Math;
	var RangeError = require$$2.RangeError;
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity = require$$2.Infinity;
	var BaseBuffer = $ArrayBuffer;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;
	var BUFFER = 'buffer';
	var BYTE_LENGTH = 'byteLength';
	var BYTE_OFFSET = 'byteOffset';
	var $BUFFER = require$$0 ? '_b' : BUFFER;
	var $LENGTH = require$$0 ? '_l' : BYTE_LENGTH;
	var $OFFSET = require$$0 ? '_o' : BYTE_OFFSET;

	// IEEE754 conversions based on https://github.com/feross/ieee754
	function packIEEE754(value, mLen, nBytes) {
	  var buffer = new Array(nBytes);
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var i = 0;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  var e, m, c;
	  value = abs(value);
	  // eslint-disable-next-line no-self-compare
	  if (value != value || value === Infinity) {
	    // eslint-disable-next-line no-self-compare
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if (value * (c = pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	}
	function unpackIEEE754(buffer, mLen, nBytes) {
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = eLen - 7;
	  var i = nBytes - 1;
	  var s = buffer[i--];
	  var e = s & 127;
	  var m;
	  s >>= 7;
	  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	}

	function unpackI32(bytes) {
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	}
	function packI8(it) {
	  return [it & 0xff];
	}
	function packI16(it) {
	  return [it & 0xff, it >> 8 & 0xff];
	}
	function packI32(it) {
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	}
	function packF64(it) {
	  return packIEEE754(it, 52, 8);
	}
	function packF32(it) {
	  return packIEEE754(it, 23, 4);
	}

	function addGetter(C, key, internal) {
	  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
	}

	function get(view, bytes, index, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = require$$14(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	}
	function set(view, bytes, index, conversion, value, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = require$$14(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = conversion(+value);
	  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	}

	if (!require$$5.ABV) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    require$$8(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = require$$14(length);
	    this._b = require$$35.call(new Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    require$$8(this, $DataView, DATA_VIEW);
	    require$$8(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH];
	    var offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };

	  if (require$$0) {
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }

	  require$$11($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset) {
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if (!require$$1(function () {
	    $ArrayBuffer(1);
	  }) || !require$$1(function () {
	    new $ArrayBuffer(-1); // eslint-disable-line no-new
	  }) || require$$1(function () {
	    new $ArrayBuffer(); // eslint-disable-line no-new
	    new $ArrayBuffer(1.5); // eslint-disable-line no-new
	    new $ArrayBuffer(NaN); // eslint-disable-line no-new
	    return $ArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      require$$8(this, $ArrayBuffer);
	      return new BaseBuffer(require$$14(length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for (var keys = gOPN$$1(BaseBuffer), j = 0, key; keys.length > j;) {
	      if (!((key = keys[j++]) in $ArrayBuffer)) require$$0$1($ArrayBuffer, key, BaseBuffer[key]);
	    }
	    if (!require$$0$4) ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if (view.getInt8(0) || !view.getInt8(1)) require$$11($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	require$$0$1($DataView[PROTOTYPE], require$$5.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;
	});

	var _typedBuffer$1 = /*#__PURE__*/Object.freeze({
		default: _typedBuffer,
		__moduleExports: _typedBuffer
	});

	var require$$6 = ( _typedBuffer$1 && _typedBuffer ) || _typedBuffer$1;

	var ArrayBuffer$1 = require$$2.ArrayBuffer;

	var $ArrayBuffer = require$$6.ArrayBuffer;
	var $DataView = require$$6.DataView;
	var $isView = require$$5.ABV && ArrayBuffer$1.isView;
	var $slice = $ArrayBuffer.prototype.slice;
	var VIEW$1 = require$$5.VIEW;
	var ARRAY_BUFFER = 'ArrayBuffer';

	$export$1($export$1.G + $export$1.W + $export$1.F * (ArrayBuffer$1 !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

	$export$1($export$1.S + $export$1.F * !require$$5.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it) {
	    return $isView && $isView(it) || isObject(it) && VIEW$1 in it;
	  }
	});

	$export$1($export$1.P + $export$1.U + $export$1.F * require$$1(function () {
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end) {
	    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
	    var len = anObject(this).byteLength;
	    var first = require$$15(start, len);
	    var final = require$$15(end === undefined ? len : end, len);
	    var result = new (require$$30(this, $ArrayBuffer))(toLength(final - first));
	    var viewS = new $DataView(this);
	    var viewT = new $DataView(result);
	    var index = 0;
	    while (first < final) {
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});

	require$$34(ARRAY_BUFFER);

	$export$1($export$1.G + $export$1.W + $export$1.F * !require$$5.ABV, {
	  DataView: require$$6.DataView
	});

	var require$$31 = ( es6_array_iterator$1 && es6_array_iterator ) || es6_array_iterator$1;

	var _typedArray = createCommonjsModule(function (module) {
	if (require$$0) {
	  var LIBRARY = require$$0$4;
	  var global = require$$2;
	  var fails = require$$1;
	  var $export = $export$1;
	  var $typed = require$$5;
	  var $buffer = require$$6;
	  var ctx$$1 = ctx;
	  var anInstance = require$$8;
	  var propertyDesc = descriptor;
	  var hide = require$$0$1;
	  var redefineAll = require$$11;
	  var toInteger$$1 = toInteger;
	  var toLength$$1 = toLength;
	  var toIndex = require$$14;
	  var toAbsoluteIndex = require$$15;
	  var toPrimitive = require$$16;
	  var has$$1 = has;
	  var classof$$1 = classof;
	  var isObject$$1 = isObject;
	  var toObject = require$$20;
	  var isArrayIter = require$$21;
	  var create$$1 = create;
	  var getPrototypeOf = require$$23;
	  var gOPN$$1 = gOPN.f;
	  var getIterFn = require$$25;
	  var uid$$1 = uid;
	  var wks = require$$0$3;
	  var createArrayMethod = require$$28;
	  var createArrayIncludes = require$$0$5;
	  var speciesConstructor = require$$30;
	  var ArrayIterators = require$$31;
	  var Iterators = require$$32;
	  var $iterDetect = require$$33;
	  var setSpecies = require$$34;
	  var arrayFill = require$$35;
	  var arrayCopyWithin = require$$36;
	  var $DP = require$$37;
	  var $GOPD = require$$38;
	  var dP = $DP.f;
	  var gOPD = $GOPD.f;
	  var RangeError = global.RangeError;
	  var TypeError = global.TypeError;
	  var Uint8Array = global.Uint8Array;
	  var ARRAY_BUFFER = 'ArrayBuffer';
	  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
	  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	  var PROTOTYPE = 'prototype';
	  var ArrayProto = Array[PROTOTYPE];
	  var $ArrayBuffer = $buffer.ArrayBuffer;
	  var $DataView = $buffer.DataView;
	  var arrayForEach = createArrayMethod(0);
	  var arrayFilter = createArrayMethod(2);
	  var arraySome = createArrayMethod(3);
	  var arrayEvery = createArrayMethod(4);
	  var arrayFind = createArrayMethod(5);
	  var arrayFindIndex = createArrayMethod(6);
	  var arrayIncludes = createArrayIncludes(true);
	  var arrayIndexOf = createArrayIncludes(false);
	  var arrayValues = ArrayIterators.values;
	  var arrayKeys = ArrayIterators.keys;
	  var arrayEntries = ArrayIterators.entries;
	  var arrayLastIndexOf = ArrayProto.lastIndexOf;
	  var arrayReduce = ArrayProto.reduce;
	  var arrayReduceRight = ArrayProto.reduceRight;
	  var arrayJoin = ArrayProto.join;
	  var arraySort = ArrayProto.sort;
	  var arraySlice = ArrayProto.slice;
	  var arrayToString = ArrayProto.toString;
	  var arrayToLocaleString = ArrayProto.toLocaleString;
	  var ITERATOR = wks('iterator');
	  var TAG = wks('toStringTag');
	  var TYPED_CONSTRUCTOR = uid$$1('typed_constructor');
	  var DEF_CONSTRUCTOR = uid$$1('def_constructor');
	  var ALL_CONSTRUCTORS = $typed.CONSTR;
	  var TYPED_ARRAY = $typed.TYPED;
	  var VIEW = $typed.VIEW;
	  var WRONG_LENGTH = 'Wrong length!';

	  var $map = createArrayMethod(1, function (O, length) {
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });

	  var LITTLE_ENDIAN = fails(function () {
	    // eslint-disable-next-line no-undef
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });

	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	    new Uint8Array(1).set({});
	  });

	  var toOffset = function (it, BYTES) {
	    var offset = toInteger$$1(it);
	    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	    return offset;
	  };

	  var validate = function (it) {
	    if (isObject$$1(it) && TYPED_ARRAY in it) return it;
	    throw TypeError(it + ' is not a typed array!');
	  };

	  var allocate = function (C, length) {
	    if (!(isObject$$1(C) && TYPED_CONSTRUCTOR in C)) {
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };

	  var speciesFromList = function (O, list) {
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };

	  var fromList = function (C, list) {
	    var index = 0;
	    var length = list.length;
	    var result = allocate(C, length);
	    while (length > index) result[index] = list[index++];
	    return result;
	  };

	  var addGetter = function (it, key, internal) {
	    dP(it, key, { get: function () { return this._d[internal]; } });
	  };

	  var $from = function from(source /* , mapfn, thisArg */) {
	    var O = toObject(source);
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var iterFn = getIterFn(O);
	    var i, length, values, result, step, iterator;
	    if (iterFn != undefined && !isArrayIter(iterFn)) {
	      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	        values.push(step.value);
	      } O = values;
	    }
	    if (mapping && aLen > 2) mapfn = ctx$$1(mapfn, arguments[2], 2);
	    for (i = 0, length = toLength$$1(O.length), result = allocate(this, length); length > i; i++) {
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };

	  var $of = function of(/* ...items */) {
	    var index = 0;
	    var length = arguments.length;
	    var result = allocate(this, length);
	    while (length > index) result[index] = arguments[index++];
	    return result;
	  };

	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

	  var $toLocaleString = function toLocaleString() {
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };

	  var proto = {
	    copyWithin: function copyWithin(target, start /* , end */) {
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /* , thisArg */) {
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /* , thisArg */) {
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /* , thisArg */) {
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /* , thisArg */) {
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /* , thisArg */) {
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /* , fromIndex */) {
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /* , fromIndex */) {
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator) { // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /* , thisArg */) {
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse() {
	      var that = this;
	      var length = validate(that).length;
	      var middle = Math.floor(length / 2);
	      var index = 0;
	      var value;
	      while (index < middle) {
	        value = that[index];
	        that[index++] = that[--length];
	        that[length] = value;
	      } return that;
	    },
	    some: function some(callbackfn /* , thisArg */) {
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn) {
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end) {
	      var O = validate(this);
	      var length = O.length;
	      var $begin = toAbsoluteIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength$$1((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
	      );
	    }
	  };

	  var $slice = function slice(start, end) {
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };

	  var $set = function set(arrayLike /* , offset */) {
	    validate(this);
	    var offset = toOffset(arguments[1], 1);
	    var length = this.length;
	    var src = toObject(arrayLike);
	    var len = toLength$$1(src.length);
	    var index = 0;
	    if (len + offset > length) throw RangeError(WRONG_LENGTH);
	    while (index < len) this[offset + index] = src[index++];
	  };

	  var $iterators = {
	    entries: function entries() {
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys() {
	      return arrayKeys.call(validate(this));
	    },
	    values: function values() {
	      return arrayValues.call(validate(this));
	    }
	  };

	  var isTAIndex = function (target, key) {
	    return isObject$$1(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc) {
	    if (isTAIndex(target, key = toPrimitive(key, true))
	      && isObject$$1(desc)
	      && has$$1(desc, 'value')
	      && !has$$1(desc, 'get')
	      && !has$$1(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has$$1(desc, 'writable') || desc.writable)
	      && (!has$$1(desc, 'enumerable') || desc.enumerable)
	    ) {
	      target[key] = desc.value;
	      return target;
	    } return dP(target, key, desc);
	  };

	  if (!ALL_CONSTRUCTORS) {
	    $GOPD.f = $getDesc;
	    $DP.f = $setDesc;
	  }

	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty: $setDesc
	  });

	  if (fails(function () { arrayToString.call({}); })) {
	    arrayToString = arrayToLocaleString = function toString() {
	      return arrayJoin.call(this);
	    };
	  }

	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice: $slice,
	    set: $set,
	    constructor: function () { /* noop */ },
	    toString: arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function () { return this[TYPED_ARRAY]; }
	  });

	  // eslint-disable-next-line max-statements
	  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	    CLAMPED = !!CLAMPED;
	    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + KEY;
	    var SETTER = 'set' + KEY;
	    var TypedArray = global[NAME];
	    var Base = TypedArray || {};
	    var TAC = TypedArray && getPrototypeOf(TypedArray);
	    var FORCED = !TypedArray || !$typed.ABV;
	    var O = {};
	    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function (that, index) {
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function (that, index, value) {
	      var data = that._d;
	      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function (that, index) {
	      dP(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if (FORCED) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME, '_d');
	        var index = 0;
	        var offset = 0;
	        var buffer, byteLength, length, klass;
	        if (!isObject$$1(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new $ArrayBuffer(byteLength);
	        } else if (data instanceof $ArrayBuffer || (klass = classof$$1(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength$$1($length) * BYTES;
	            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (TYPED_ARRAY in data) {
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create$$1($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if (!fails(function () {
	      TypedArray(1);
	    }) || !fails(function () {
	      new TypedArray(-1); // eslint-disable-line no-new
	    }) || !$iterDetect(function (iter) {
	      new TypedArray(); // eslint-disable-line no-new
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(1.5); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if (!isObject$$1(data)) return new Base(toIndex(data));
	        if (data instanceof $ArrayBuffer || (klass = classof$$1(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN$$1(Base).concat(gOPN$$1(TAC)) : gOPN$$1(Base), function (key) {
	        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator = TypedArrayPrototype[ITERATOR];
	    var CORRECT_ITER_NAME = !!$nativeIterator
	      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	    var $iterator = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	      dP(TypedArrayPrototype, TAG, {
	        get: function () { return NAME; }
	      });
	    }

	    O[NAME] = TypedArray;

	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES
	    });

	    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
	      from: $from,
	      of: $of
	    });

	    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

	    $export($export.P, NAME, proto);

	    setSpecies(NAME);

	    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

	    $export($export.P + $export.F * fails(function () {
	      new TypedArray(1).slice();
	    }), NAME, { slice: $slice });

	    $export($export.P + $export.F * (fails(function () {
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	    }) || !fails(function () {
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, { toLocaleString: $toLocaleString });

	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function () { /* empty */ };
	});

	var _typedArray$1 = /*#__PURE__*/Object.freeze({
		default: _typedArray,
		__moduleExports: _typedArray
	});

	var require$$0$23 = ( _typedArray$1 && _typedArray ) || _typedArray$1;

	require$$0$23('Int8', 1, function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Uint8', 1, function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	require$$0$23('Int16', 2, function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Uint16', 2, function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Int32', 4, function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Uint32', 4, function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Float32', 4, function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Float64', 8, function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)



	var rApply = (require$$2.Reflect || {}).apply;
	var fApply = Function.apply;
	// MS Edge argumentsList argument is optional
	$export$1($export$1.S + $export$1.F * !require$$1(function () {
	  rApply(function () { /* empty */ });
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList) {
	    var T = aFunction(target);
	    var L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])







	var rConstruct = (require$$2.Reflect || {}).construct;

	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = require$$1(function () {
	  function F() { /* empty */ }
	  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
	});
	var ARGS_BUG = !require$$1(function () {
	  rConstruct(function () { /* empty */ });
	});

	$export$1($export$1.S + $export$1.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0: return new Target();
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = create(isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)





	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export$1($export$1.S + $export$1.F * require$$1(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(require$$37.f({}, 1, { value: 1 }), 1, { value: 2 });
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    propertyKey = require$$16(propertyKey, true);
	    anObject(attributes);
	    try {
	      require$$37.f(target, propertyKey, attributes);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)

	var gOPD$3 = require$$38.f;


	$export$1($export$1.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var desc = gOPD$3(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

	// 26.1.5 Reflect.enumerate(target)


	var Enumerate = function (iterated) {
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = [];      // keys
	  var key;
	  for (key in iterated) keys.push(key);
	};
	$iterCreate(Enumerate, 'Object', function () {
	  var that = this;
	  var keys = that._k;
	  var key;
	  do {
	    if (that._i >= keys.length) return { value: undefined, done: true };
	  } while (!((key = keys[that._i++]) in that._t));
	  return { value: key, done: false };
	});

	$export$1($export$1.S, 'Reflect', {
	  enumerate: function enumerate(target) {
	    return new Enumerate(target);
	  }
	});

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])







	function get(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var desc, proto;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (desc = require$$38.f(target, propertyKey)) return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if (isObject(proto = require$$23(target))) return get(proto, propertyKey, receiver);
	}

	$export$1($export$1.S, 'Reflect', { get: get });

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)




	$export$1($export$1.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return require$$38.f(anObject(target), propertyKey);
	  }
	});

	// 26.1.8 Reflect.getPrototypeOf(target)




	$export$1($export$1.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return require$$23(anObject(target));
	  }
	});

	// 26.1.9 Reflect.has(target, propertyKey)


	$export$1($export$1.S, 'Reflect', {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

	// 26.1.10 Reflect.isExtensible(target)


	var $isExtensible = Object.isExtensible;

	$export$1($export$1.S, 'Reflect', {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

	// all object keys, includes non-enumerable and symbols



	var Reflect$1 = require$$2.Reflect;
	var _ownKeys = Reflect$1 && Reflect$1.ownKeys || function ownKeys(it) {
	  var keys = gOPN.f(anObject(it));
	  var getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

	var _ownKeys$1 = /*#__PURE__*/Object.freeze({
		default: _ownKeys,
		__moduleExports: _ownKeys
	});

	var ownKeys = ( _ownKeys$1 && _ownKeys ) || _ownKeys$1;

	// 26.1.11 Reflect.ownKeys(target)


	$export$1($export$1.S, 'Reflect', { ownKeys: ownKeys });

	// 26.1.12 Reflect.preventExtensions(target)


	var $preventExtensions = Object.preventExtensions;

	$export$1($export$1.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      if ($preventExtensions) $preventExtensions(target);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])









	function set(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDesc = require$$38.f(anObject(target), propertyKey);
	  var existingDescriptor, proto;
	  if (!ownDesc) {
	    if (isObject(proto = require$$23(target))) {
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = descriptor(0);
	  }
	  if (has(ownDesc, 'value')) {
	    if (ownDesc.writable === false || !isObject(receiver)) return false;
	    existingDescriptor = require$$38.f(receiver, propertyKey) || descriptor(0);
	    existingDescriptor.value = V;
	    require$$37.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	$export$1($export$1.S, 'Reflect', { set: set });

	// 26.1.14 Reflect.setPrototypeOf(target, proto)



	if (require$$0$12) $export$1($export$1.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    require$$0$12.check(target, proto);
	    try {
	      require$$0$12.set(target, proto);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// https://github.com/tc39/Array.prototype.includes

	var $includes = require$$0$5(true);

	$export$1($export$1.P, 'Array', {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	require$$0$18('includes');

	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray




	var IS_CONCAT_SPREADABLE = require$$0$3('isConcatSpreadable');

	function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
	  var element, spreadable;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

	      spreadable = false;
	      if (isObject(element)) {
	        spreadable = element[IS_CONCAT_SPREADABLE];
	        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
	      }

	      if (spreadable && depth > 0) {
	        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	}

	var _flattenIntoArray = flattenIntoArray;

	var _flattenIntoArray$1 = /*#__PURE__*/Object.freeze({
		default: _flattenIntoArray,
		__moduleExports: _flattenIntoArray
	});

	var flattenIntoArray$1 = ( _flattenIntoArray$1 && _flattenIntoArray ) || _flattenIntoArray$1;

	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap







	$export$1($export$1.P, 'Array', {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = require$$20(this);
	    var sourceLen, A;
	    aFunction(callbackfn);
	    sourceLen = toLength(O.length);
	    A = asc(O, 0);
	    flattenIntoArray$1(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
	    return A;
	  }
	});

	require$$0$18('flatMap');

	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten







	$export$1($export$1.P, 'Array', {
	  flatten: function flatten(/* depthArg = 1 */) {
	    var depthArg = arguments[0];
	    var O = require$$20(this);
	    var sourceLen = toLength(O.length);
	    var A = asc(O, 0);
	    flattenIntoArray$1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
	    return A;
	  }
	});

	require$$0$18('flatten');

	// https://github.com/mathiasbynens/String.prototype.at

	var $at$2 = require$$0$14(true);

	$export$1($export$1.P, 'String', {
	  at: function at(pos) {
	    return $at$2(this, pos);
	  }
	});

	// https://github.com/tc39/proposal-string-pad-start-end




	var _stringPad = function (that, maxLength, fillString, left) {
	  var S = String(defined(that));
	  var stringLength = S.length;
	  var fillStr = fillString === undefined ? ' ' : String(fillString);
	  var intMaxLength = toLength(maxLength);
	  if (intMaxLength <= stringLength || fillStr == '') return S;
	  var fillLen = intMaxLength - stringLength;
	  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};

	var _stringPad$1 = /*#__PURE__*/Object.freeze({
		default: _stringPad,
		__moduleExports: _stringPad
	});

	var navigator$1 = require$$2.navigator;

	var _userAgent = navigator$1 && navigator$1.userAgent || '';

	var _userAgent$1 = /*#__PURE__*/Object.freeze({
		default: _userAgent,
		__moduleExports: _userAgent
	});

	var $pad = ( _stringPad$1 && _stringPad ) || _stringPad$1;

	var userAgent = ( _userAgent$1 && _userAgent ) || _userAgent$1;

	// https://github.com/tc39/proposal-string-pad-start-end




	// https://github.com/zloirock/core-js/issues/280
	$export$1($export$1.P + $export$1.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

	// https://github.com/tc39/proposal-string-pad-start-end




	// https://github.com/zloirock/core-js/issues/280
	$export$1($export$1.P + $export$1.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	require$$1$5('trimLeft', function ($trim) {
	  return function trimLeft() {
	    return $trim(this, 1);
	  };
	}, 'trimStart');

	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	require$$1$5('trimRight', function ($trim) {
	  return function trimRight() {
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

	// https://tc39.github.io/String.prototype.matchAll/





	var RegExpProto = RegExp.prototype;

	var $RegExpStringIterator = function (regexp, string) {
	  this._r = regexp;
	  this._s = string;
	};

	$iterCreate($RegExpStringIterator, 'RegExp String', function next() {
	  var match = this._r.exec(this._s);
	  return { value: match, done: match === null };
	});

	$export$1($export$1.P, 'String', {
	  matchAll: function matchAll(regexp) {
	    defined(this);
	    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
	    var S = String(this);
	    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
	    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

	require$$0$9('asyncIterator');

	require$$0$9('observable');

	// https://github.com/tc39/proposal-object-getownpropertydescriptors






	$export$1($export$1.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIObject(object);
	    var getDesc = require$$38.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var i = 0;
	    var key, desc;
	    while (keys.length > i) {
	      desc = getDesc(O, key = keys[i++]);
	      if (desc !== undefined) createProperty(result, key, desc);
	    }
	    return result;
	  }
	});

	var isEnum$1 = require$$0$7.f;
	var _objectToArray = function (isEntries) {
	  return function (it) {
	    var O = toIObject(it);
	    var keys = getKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) if (isEnum$1.call(O, key = keys[i++])) {
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

	var _objectToArray$1 = /*#__PURE__*/Object.freeze({
		default: _objectToArray,
		__moduleExports: _objectToArray
	});

	var require$$0$24 = ( _objectToArray$1 && _objectToArray ) || _objectToArray$1;

	// https://github.com/tc39/proposal-object-values-entries

	var $values = require$$0$24(false);

	$export$1($export$1.S, 'Object', {
	  values: function values(it) {
	    return $values(it);
	  }
	});

	// https://github.com/tc39/proposal-object-values-entries

	var $entries = require$$0$24(true);

	$export$1($export$1.S, 'Object', {
	  entries: function entries(it) {
	    return $entries(it);
	  }
	});

	// Forced replacement prototype accessors methods
	var _objectForcedPam = require$$0$4 || !require$$1(function () {
	  var K = Math.random();
	  // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call
	  __defineSetter__.call(null, K, function () { /* empty */ });
	  delete require$$2[K];
	});

	var _objectForcedPam$1 = /*#__PURE__*/Object.freeze({
		default: _objectForcedPam,
		__moduleExports: _objectForcedPam
	});

	var require$$2$3 = ( _objectForcedPam$1 && _objectForcedPam ) || _objectForcedPam$1;

	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	require$$0 && $export$1($export$1.P + require$$2$3, 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter) {
	    require$$37.f(require$$20(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
	  }
	});

	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	require$$0 && $export$1($export$1.P + require$$2$3, 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter) {
	    require$$37.f(require$$20(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
	  }
	});

	var getOwnPropertyDescriptor = require$$38.f;

	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	require$$0 && $export$1($export$1.P + require$$2$3, 'Object', {
	  __lookupGetter__: function __lookupGetter__(P) {
	    var O = require$$20(this);
	    var K = require$$16(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
	    } while (O = require$$23(O));
	  }
	});

	var getOwnPropertyDescriptor$1 = require$$38.f;

	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	require$$0 && $export$1($export$1.P + require$$2$3, 'Object', {
	  __lookupSetter__: function __lookupSetter__(P) {
	    var O = require$$20(this);
	    var K = require$$16(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor$1(O, K)) return D.set;
	    } while (O = require$$23(O));
	  }
	});

	var _arrayFromIterable = function (iter, ITERATOR) {
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};

	var _arrayFromIterable$1 = /*#__PURE__*/Object.freeze({
		default: _arrayFromIterable,
		__moduleExports: _arrayFromIterable
	});

	var from = ( _arrayFromIterable$1 && _arrayFromIterable ) || _arrayFromIterable$1;

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON


	var _collectionToJson = function (NAME) {
	  return function toJSON() {
	    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

	var _collectionToJson$1 = /*#__PURE__*/Object.freeze({
		default: _collectionToJson,
		__moduleExports: _collectionToJson
	});

	var require$$0$25 = ( _collectionToJson$1 && _collectionToJson ) || _collectionToJson$1;

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON


	$export$1($export$1.P + $export$1.R, 'Map', { toJSON: require$$0$25('Map') });

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON


	$export$1($export$1.P + $export$1.R, 'Set', { toJSON: require$$0$25('Set') });

	// https://tc39.github.io/proposal-setmap-offrom/


	var _setCollectionOf = function (COLLECTION) {
	  $export$1($export$1.S, COLLECTION, { of: function of() {
	    var length = arguments.length;
	    var A = new Array(length);
	    while (length--) A[length] = arguments[length];
	    return new this(A);
	  } });
	};

	var _setCollectionOf$1 = /*#__PURE__*/Object.freeze({
		default: _setCollectionOf,
		__moduleExports: _setCollectionOf
	});

	var require$$0$26 = ( _setCollectionOf$1 && _setCollectionOf ) || _setCollectionOf$1;

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	require$$0$26('Map');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
	require$$0$26('Set');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
	require$$0$26('WeakMap');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
	require$$0$26('WeakSet');

	// https://tc39.github.io/proposal-setmap-offrom/





	var _setCollectionFrom = function (COLLECTION) {
	  $export$1($export$1.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
	    var mapFn = arguments[1];
	    var mapping, A, n, cb;
	    aFunction(this);
	    mapping = mapFn !== undefined;
	    if (mapping) aFunction(mapFn);
	    if (source == undefined) return new this();
	    A = [];
	    if (mapping) {
	      n = 0;
	      cb = ctx(mapFn, arguments[2], 2);
	      forOf(source, false, function (nextItem) {
	        A.push(cb(nextItem, n++));
	      });
	    } else {
	      forOf(source, false, A.push, A);
	    }
	    return new this(A);
	  } });
	};

	var _setCollectionFrom$1 = /*#__PURE__*/Object.freeze({
		default: _setCollectionFrom,
		__moduleExports: _setCollectionFrom
	});

	var require$$0$27 = ( _setCollectionFrom$1 && _setCollectionFrom ) || _setCollectionFrom$1;

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	require$$0$27('Map');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
	require$$0$27('Set');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
	require$$0$27('WeakMap');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
	require$$0$27('WeakSet');

	// https://github.com/tc39/proposal-global


	$export$1($export$1.G, { global: require$$2 });

	// https://github.com/tc39/proposal-global


	$export$1($export$1.S, 'System', { global: require$$2 });

	// https://github.com/ljharb/proposal-is-error



	$export$1($export$1.S, 'Error', {
	  isError: function isError(it) {
	    return require$$1$2(it) === 'Error';
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	$export$1($export$1.S, 'Math', {
	  clamp: function clamp(x, lower, upper) {
	    return Math.min(upper, Math.max(lower, x));
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	$export$1($export$1.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

	// https://rwaldron.github.io/proposal-math-extensions/

	var RAD_PER_DEG = 180 / Math.PI;

	$export$1($export$1.S, 'Math', {
	  degrees: function degrees(radians) {
	    return radians * RAD_PER_DEG;
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/
	var _mathScale = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
	  if (
	    arguments.length === 0
	      // eslint-disable-next-line no-self-compare
	      || x != x
	      // eslint-disable-next-line no-self-compare
	      || inLow != inLow
	      // eslint-disable-next-line no-self-compare
	      || inHigh != inHigh
	      // eslint-disable-next-line no-self-compare
	      || outLow != outLow
	      // eslint-disable-next-line no-self-compare
	      || outHigh != outHigh
	  ) return NaN;
	  if (x === Infinity || x === -Infinity) return x;
	  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
	};

	var _mathScale$1 = /*#__PURE__*/Object.freeze({
		default: _mathScale,
		__moduleExports: _mathScale
	});

	var require$$0$28 = ( _mathScale$1 && _mathScale ) || _mathScale$1;

	// https://rwaldron.github.io/proposal-math-extensions/




	$export$1($export$1.S, 'Math', {
	  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
	    return fround(require$$0$28(x, inLow, inHigh, outLow, outHigh));
	  }
	});

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	$export$1($export$1.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	$export$1($export$1.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	$export$1($export$1.S, 'Math', {
	  imulh: function imulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >> 16;
	    var v1 = $v >> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	$export$1($export$1.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

	// https://rwaldron.github.io/proposal-math-extensions/

	var DEG_PER_RAD = Math.PI / 180;

	$export$1($export$1.S, 'Math', {
	  radians: function radians(degrees) {
	    return degrees * DEG_PER_RAD;
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	$export$1($export$1.S, 'Math', { scale: require$$0$28 });

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	$export$1($export$1.S, 'Math', {
	  umulh: function umulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >>> 16;
	    var v1 = $v >>> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

	// http://jfbastien.github.io/papers/Math.signbit.html


	$export$1($export$1.S, 'Math', { signbit: function signbit(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
	} });

	$export$1($export$1.P + $export$1.R, 'Promise', { 'finally': function (onFinally) {
	  var C = require$$30(this, require$$1$1.Promise || require$$2.Promise);
	  var isFunction = typeof onFinally == 'function';
	  return this.then(
	    isFunction ? function (x) {
	      return promiseResolve(C, onFinally()).then(function () { return x; });
	    } : onFinally,
	    isFunction ? function (e) {
	      return promiseResolve(C, onFinally()).then(function () { throw e; });
	    } : onFinally
	  );
	} });

	// https://github.com/tc39/proposal-promise-try




	$export$1($export$1.S, 'Promise', { 'try': function (callbackfn) {
	  var promiseCapability = newPromiseCapability.f(this);
	  var result = perform(callbackfn);
	  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	  return promiseCapability.promise;
	} });

	var Map$1 = ( es6_map$1 && es6_map ) || es6_map$1;

	var require$$1$6 = ( es6_weakMap$1 && es6_weakMap ) || es6_weakMap$1;

	var shared$1 = require$$0$2('metadata');
	var store$1 = shared$1.store || (shared$1.store = new (require$$1$6)());

	var getOrCreateMetadataMap = function (target, targetKey, create) {
	  var targetMetadata = store$1.get(target);
	  if (!targetMetadata) {
	    if (!create) return undefined;
	    store$1.set(target, targetMetadata = new Map$1());
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if (!keyMetadata) {
	    if (!create) return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map$1());
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function (target, targetKey) {
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
	  var keys = [];
	  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
	  return keys;
	};
	var toMetaKey = function (it) {
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp$3 = function (O) {
	  $export$1($export$1.S, 'Reflect', O);
	};

	var _metadata = {
	  store: store$1,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp$3
	};
	var _metadata_1 = _metadata.store;
	var _metadata_2 = _metadata.map;
	var _metadata_3 = _metadata.has;
	var _metadata_4 = _metadata.get;
	var _metadata_5 = _metadata.set;
	var _metadata_6 = _metadata.keys;
	var _metadata_7 = _metadata.key;
	var _metadata_8 = _metadata.exp;

	var _metadata$1 = /*#__PURE__*/Object.freeze({
		default: _metadata,
		__moduleExports: _metadata,
		store: _metadata_1,
		map: _metadata_2,
		has: _metadata_3,
		get: _metadata_4,
		set: _metadata_5,
		keys: _metadata_6,
		key: _metadata_7,
		exp: _metadata_8
	});

	var $metadata = ( _metadata$1 && _metadata ) || _metadata$1;

	var toMetaKey$1 = $metadata.key;
	var ordinaryDefineOwnMetadata$1 = $metadata.set;

	$metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
	  ordinaryDefineOwnMetadata$1(metadataKey, metadataValue, anObject(target), toMetaKey$1(targetKey));
	} });

	var toMetaKey$2 = $metadata.key;
	var getOrCreateMetadataMap$1 = $metadata.map;
	var store$2 = $metadata.store;

	$metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
	  var targetKey = arguments.length < 3 ? undefined : toMetaKey$2(arguments[2]);
	  var metadataMap = getOrCreateMetadataMap$1(anObject(target), targetKey, false);
	  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
	  if (metadataMap.size) return true;
	  var targetMetadata = store$2.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store$2['delete'](target);
	} });

	var ordinaryHasOwnMetadata$1 = $metadata.has;
	var ordinaryGetOwnMetadata$1 = $metadata.get;
	var toMetaKey$3 = $metadata.key;

	var ordinaryGetMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata$1(MetadataKey, O, P);
	  if (hasOwn) return ordinaryGetOwnMetadata$1(MetadataKey, O, P);
	  var parent = require$$23(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};

	$metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey$3(arguments[2]));
	} });

	var Set$1 = ( es6_set$1 && es6_set ) || es6_set$1;

	var ordinaryOwnMetadataKeys$1 = $metadata.keys;
	var toMetaKey$4 = $metadata.key;

	var ordinaryMetadataKeys = function (O, P) {
	  var oKeys = ordinaryOwnMetadataKeys$1(O, P);
	  var parent = require$$23(O);
	  if (parent === null) return oKeys;
	  var pKeys = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set$1(oKeys.concat(pKeys))) : pKeys : oKeys;
	};

	$metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey$4(arguments[1]));
	} });

	var ordinaryGetOwnMetadata$2 = $metadata.get;
	var toMetaKey$5 = $metadata.key;

	$metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryGetOwnMetadata$2(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey$5(arguments[2]));
	} });

	var ordinaryOwnMetadataKeys$2 = $metadata.keys;
	var toMetaKey$6 = $metadata.key;

	$metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
	  return ordinaryOwnMetadataKeys$2(anObject(target), arguments.length < 2 ? undefined : toMetaKey$6(arguments[1]));
	} });

	var ordinaryHasOwnMetadata$2 = $metadata.has;
	var toMetaKey$7 = $metadata.key;

	var ordinaryHasMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata$2(MetadataKey, O, P);
	  if (hasOwn) return true;
	  var parent = require$$23(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};

	$metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey$7(arguments[2]));
	} });

	var ordinaryHasOwnMetadata$3 = $metadata.has;
	var toMetaKey$8 = $metadata.key;

	$metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryHasOwnMetadata$3(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey$8(arguments[2]));
	} });

	var toMetaKey$9 = $metadata.key;
	var ordinaryDefineOwnMetadata$2 = $metadata.set;

	$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
	  return function decorator(target, targetKey) {
	    ordinaryDefineOwnMetadata$2(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey$9(targetKey)
	    );
	  };
	} });

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask

	var microtask$1 = require$$0$21();
	var process$4 = require$$2.process;
	var isNode$2 = require$$1$2(process$4) == 'process';

	$export$1($export$1.G, {
	  asap: function asap(fn) {
	    var domain = isNode$2 && process$4.domain;
	    microtask$1(domain ? domain.bind(fn) : fn);
	  }
	});

	// https://github.com/zenparsing/es-observable



	var microtask$2 = require$$0$21();
	var OBSERVABLE = require$$0$3('observable');






	var RETURN = forOf.RETURN;

	var getMethod = function (fn) {
	  return fn == null ? undefined : aFunction(fn);
	};

	var cleanupSubscription = function (subscription) {
	  var cleanup = subscription._c;
	  if (cleanup) {
	    subscription._c = undefined;
	    cleanup();
	  }
	};

	var subscriptionClosed = function (subscription) {
	  return subscription._o === undefined;
	};

	var closeSubscription = function (subscription) {
	  if (!subscriptionClosed(subscription)) {
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};

	var Subscription = function (observer, subscriber) {
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup = subscriber(observer);
	    var subscription = cleanup;
	    if (cleanup != null) {
	      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch (e) {
	    observer.error(e);
	    return;
	  } if (subscriptionClosed(this)) cleanupSubscription(this);
	};

	Subscription.prototype = require$$11({}, {
	  unsubscribe: function unsubscribe() { closeSubscription(this); }
	});

	var SubscriptionObserver = function (subscription) {
	  this._s = subscription;
	};

	SubscriptionObserver.prototype = require$$11({}, {
	  next: function next(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if (m) return m.call(observer, value);
	      } catch (e) {
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value) {
	    var subscription = this._s;
	    if (subscriptionClosed(subscription)) throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if (!m) throw value;
	      value = m.call(observer, value);
	    } catch (e) {
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch (e) {
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});

	var $Observable = function Observable(subscriber) {
	  require$$8(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};

	require$$11($Observable.prototype, {
	  subscribe: function subscribe(observer) {
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn) {
	    var that = this;
	    return new (require$$1$1.Promise || require$$2.Promise)(function (resolve, reject) {
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next: function (value) {
	          try {
	            return fn(value);
	          } catch (e) {
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});

	require$$11($Observable, {
	  from: function from(x) {
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if (method) {
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function (observer) {
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function (observer) {
	      var done = false;
	      microtask$2(function () {
	        if (!done) {
	          try {
	            if (forOf(x, false, function (it) {
	              observer.next(it);
	              if (done) return RETURN;
	            }) === RETURN) return;
	          } catch (e) {
	            if (done) throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function () { done = true; };
	    });
	  },
	  of: function of() {
	    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
	      var done = false;
	      microtask$2(function () {
	        if (!done) {
	          for (var j = 0; j < items.length; ++j) {
	            observer.next(items[j]);
	            if (done) return;
	          } observer.complete();
	        }
	      });
	      return function () { done = true; };
	    });
	  }
	});

	require$$0$1($Observable.prototype, OBSERVABLE, function () { return this; });

	$export$1($export$1.G, { Observable: $Observable });

	require$$34('Observable');

	// ie9- setTimeout & setInterval additional parameters fix



	var slice = [].slice;
	var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
	var wrap$1 = function (set) {
	  return function (fn, time /* , ...args */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice.call(arguments, 2) : false;
	    return set(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
	    } : fn, time);
	  };
	};
	$export$1($export$1.G + $export$1.B + $export$1.F * MSIE, {
	  setTimeout: wrap$1(require$$2.setTimeout),
	  setInterval: wrap$1(require$$2.setInterval)
	});

	$export$1($export$1.G + $export$1.B, {
	  setImmediate: require$$0$20.set,
	  clearImmediate: require$$0$20.clear
	});

	var ITERATOR$4 = require$$0$3('iterator');
	var TO_STRING_TAG = require$$0$3('toStringTag');
	var ArrayValues = require$$32.Array;

	var DOMIterables = {
	  CSSRuleList: true, // TODO: Not spec compliant, should be false.
	  CSSStyleDeclaration: false,
	  CSSValueList: false,
	  ClientRectList: false,
	  DOMRectList: false,
	  DOMStringList: false,
	  DOMTokenList: true,
	  DataTransferItemList: false,
	  FileList: false,
	  HTMLAllCollection: false,
	  HTMLCollection: false,
	  HTMLFormElement: false,
	  HTMLSelectElement: false,
	  MediaList: true, // TODO: Not spec compliant, should be false.
	  MimeTypeArray: false,
	  NamedNodeMap: false,
	  NodeList: true,
	  PaintRequestList: false,
	  Plugin: false,
	  PluginArray: false,
	  SVGLengthList: false,
	  SVGNumberList: false,
	  SVGPathSegList: false,
	  SVGPointList: false,
	  SVGStringList: false,
	  SVGTransformList: false,
	  SourceBufferList: false,
	  StyleSheetList: true, // TODO: Not spec compliant, should be false.
	  TextTrackCueList: false,
	  TextTrackList: false,
	  TouchList: false
	};

	for (var collections = getKeys(DOMIterables), i$2 = 0; i$2 < collections.length; i$2++) {
	  var NAME$1 = collections[i$2];
	  var explicit = DOMIterables[NAME$1];
	  var Collection = require$$2[NAME$1];
	  var proto$3 = Collection && Collection.prototype;
	  var key$1;
	  if (proto$3) {
	    if (!proto$3[ITERATOR$4]) require$$0$1(proto$3, ITERATOR$4, ArrayValues);
	    if (!proto$3[TO_STRING_TAG]) require$$0$1(proto$3, TO_STRING_TAG, NAME$1);
	    require$$32[NAME$1] = ArrayValues;
	    if (explicit) for (key$1 in require$$31) if (!proto$3[key$1]) redefine(proto$3, key$1, require$$31[key$1], true);
	  }
	}

	var runtime = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */

	!(function(global) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  var inModule = 'object' === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }

	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  runtime.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }

	    if (typeof global.process === "object" && global.process.domain) {
	      invoke = global.process.domain.bind(invoke);
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  runtime.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;

	  function doneResult() {
	    return { value: undefined, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }

	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof commonjsGlobal === "object" ? commonjsGlobal :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : commonjsGlobal
	);
	});

	var _replacer = function (regExp, replace) {
	  var replacer = replace === Object(replace) ? function (part) {
	    return replace[part];
	  } : replace;
	  return function (it) {
	    return String(it).replace(regExp, replacer);
	  };
	};

	var _replacer$1 = /*#__PURE__*/Object.freeze({
		default: _replacer,
		__moduleExports: _replacer
	});

	var require$$0$29 = ( _replacer$1 && _replacer ) || _replacer$1;

	// https://github.com/benjamingr/RexExp.escape

	var $re = require$$0$29(/[\\^$*+?.()|[\]{}]/g, '\\$&');

	$export$1($export$1.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

	var _escape = require$$1$1.RegExp.escape;

	if (commonjsGlobal._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	commonjsGlobal._babelPolyfill = true;

	var DEFINE_PROPERTY = "defineProperty";
	function define$1(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}

	define$1(String.prototype, "padLeft", "".padStart);
	define$1(String.prototype, "padRight", "".padEnd);

	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define$1(Array, key, Function.call.bind([][key]));
	});

	(function () {
	if (!window.customElements) return;var __FUNC__ = "var NativeHTMLElement = window.HTMLElement; var nativeDefine = window.customElements.define; var nativeGet = window.customElements.get; var tagnameByConstructor = new Map(); var constructorByTagname = new Map(); var browserConstruction = false; var userConstruction = false; window.HTMLElement = function() { if (!browserConstruction) { var tagname = tagnameByConstructor.get(this.constructor); var fakeClass = nativeGet.call(window.customElements, tagname); userConstruction = true; var instance = new (fakeClass)(); return instance; } browserConstruction = false; }; window.HTMLElement.prototype = NativeHTMLElement.prototype; var define = function (tagname, elementClass) { var elementProto = elementClass.prototype; var StandInElement = class extends NativeHTMLElement { constructor() { super(); Object.setPrototypeOf(this, elementProto); if (!userConstruction) {  browserConstruction = true;  elementClass.call(this); } userConstruction = false; } }; var standInProto = StandInElement.prototype; StandInElement.observedAttributes = elementClass.observedAttributes; standInProto.connectedCallback = elementProto.connectedCallback; standInProto.disconnectedCallback = elementProto.disconnectedCallback; standInProto.attributeChangedCallback = elementProto.attributeChangedCallback; standInProto.adoptedCallback = elementProto.adoptedCallback; tagnameByConstructor.set(elementClass, tagname); constructorByTagname.set(tagname, elementClass); nativeDefine.call(window.customElements, tagname, StandInElement); }; var get = function (tagname) {return constructorByTagname.get(tagname)}; Object.defineProperty(window, 'customElements', {value: window.customElements, configurable: true, writable: true}); Object.defineProperty(window.customElements, 'define', {value: define, configurable: true, writable: true}); Object.defineProperty(window.customElements, 'get', {value: get, configurable: true, writable: true});";new Function(__FUNC__)();
	})();

	/* eslint-disable */
	(function() {
	    var t, e = "undefined" != typeof window && window === this ? this : "undefined" != typeof commonjsGlobal && null != commonjsGlobal ? commonjsGlobal : this,
	        n = "function" == typeof Object.defineProperties ? Object.defineProperty : function(t, e, n) {
	            t != Array.prototype && t != Object.prototype && (t[e] = n.value);
	        };

	    function o() {
	        o = function() {}, e.Symbol || (e.Symbol = i);
	    }
	    var r, i = (r = 0, function(t) {
	        return "jscomp_symbol_" + (t || "") + r++
	    });

	    function a() {
	        o();
	        var t = e.Symbol.iterator;
	        t || (t = e.Symbol.iterator = e.Symbol("iterator")), "function" != typeof Array.prototype[t] && n(Array.prototype, t, {
	            configurable: !0,
	            writable: !0,
	            value: function() {
	                return s(this)
	            }
	        }), a = function() {};
	    }

	    function s(t) {
	        var n = 0;
	        return function(t) {
	            return a(), (t = {
	                next: t
	            })[e.Symbol.iterator] = function() {
	                return this
	            }, t
	        }(function() {
	            return n < t.length ? {
	                done: !1,
	                value: t[n++]
	            } : {
	                done: !0
	            }
	        })
	    }! function() {
	        if (! function() {
	                var t = document.createEvent("Event");
	                return t.initEvent("foo", !0, !0), t.preventDefault(), t.defaultPrevented
	            }()) {
	            var t = Event.prototype.preventDefault;
	            Event.prototype.preventDefault = function() {
	                this.cancelable && (t.call(this), Object.defineProperty(this, "defaultPrevented", {
	                    get: function() {
	                        return !0
	                    },
	                    configurable: !0
	                }));
	            };
	        }
	        var e = /Trident/.test(navigator.userAgent);
	        if ((!window.CustomEvent || e && "function" != typeof window.CustomEvent) && (window.CustomEvent = function(t, e) {
	                e = e || {};
	                var n = document.createEvent("CustomEvent");
	                return n.initCustomEvent(t, !!e.bubbles, !!e.cancelable, e.detail), n
	            }, window.CustomEvent.prototype = window.Event.prototype), !window.Event || e && "function" != typeof window.Event) {
	            var n = window.Event;
	            if (window.Event = function(t, e) {
	                    e = e || {};
	                    var n = document.createEvent("Event");
	                    return n.initEvent(t, !!e.bubbles, !!e.cancelable), n
	                }, n)
	                for (var o in n) window.Event[o] = n[o];
	            window.Event.prototype = n.prototype;
	        }
	        if (!window.MouseEvent || e && "function" != typeof window.MouseEvent) {
	            if (e = window.MouseEvent, window.MouseEvent = function(t, e) {
	                    e = e || {};
	                    var n = document.createEvent("MouseEvent");
	                    return n.initMouseEvent(t, !!e.bubbles, !!e.cancelable, e.view || window, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget), n
	                }, e)
	                for (o in e) window.MouseEvent[o] = e[o];
	            window.MouseEvent.prototype = e.prototype;
	        }
	        Array.from || (Array.from = function(t) {
	            return [].slice.call(t)
	        }), Object.assign || (Object.assign = function(t, e) {
	            for (var n, o = [].slice.call(arguments, 1), r = 0; r < o.length; r++)
	                if (n = o[r])
	                    for (var i = t, a = n, s = Object.getOwnPropertyNames(a), l = 0; l < s.length; l++) i[n = s[l]] = a[n];
	            return t
	        });
	    }(window.WebComponents),
	    function() {
	        function t() {}

	        function e(t, e) {
	            if (!t.childNodes.length) return [];
	            switch (t.nodeType) {
	                case Node.DOCUMENT_NODE:
	                    return d.call(t, e);
	                case Node.DOCUMENT_FRAGMENT_NODE:
	                    return f.call(t, e);
	                default:
	                    return h.call(t, e)
	            }
	        }
	        var n = "undefined" == typeof HTMLTemplateElement,
	            o = !(document.createDocumentFragment().cloneNode() instanceof DocumentFragment),
	            r = !1;
	        /Trident/.test(navigator.userAgent) && function() {
	            function t(t, e) {
	                if (t instanceof DocumentFragment)
	                    for (var o; o = t.firstChild;) n.call(this, o, e);
	                else n.call(this, t, e);
	                return t
	            }
	            r = !0;
	            var e = Node.prototype.cloneNode;
	            Node.prototype.cloneNode = function(t) {
	                return t = e.call(this, t), this instanceof DocumentFragment && (t.__proto__ = DocumentFragment.prototype), t
	            }, DocumentFragment.prototype.querySelectorAll = HTMLElement.prototype.querySelectorAll, DocumentFragment.prototype.querySelector = HTMLElement.prototype.querySelector, Object.defineProperties(DocumentFragment.prototype, {
	                nodeType: {
	                    get: function() {
	                        return Node.DOCUMENT_FRAGMENT_NODE
	                    },
	                    configurable: !0
	                },
	                localName: {
	                    get: function() {},
	                    configurable: !0
	                },
	                nodeName: {
	                    get: function() {
	                        return "#document-fragment"
	                    },
	                    configurable: !0
	                }
	            });
	            var n = Node.prototype.insertBefore;
	            Node.prototype.insertBefore = t;
	            var o = Node.prototype.appendChild;
	            Node.prototype.appendChild = function(e) {
	                return e instanceof DocumentFragment ? t.call(this, e, null) : o.call(this, e), e
	            };
	            var i = Node.prototype.removeChild,
	                a = Node.prototype.replaceChild;
	            Node.prototype.replaceChild = function(e, n) {
	                return e instanceof DocumentFragment ? (t.call(this, e, n), i.call(this, n)) : a.call(this, e, n), n
	            }, Document.prototype.createDocumentFragment = function() {
	                var t = this.createElement("df");
	                return t.__proto__ = DocumentFragment.prototype, t
	            };
	            var s = Document.prototype.importNode;
	            Document.prototype.importNode = function(t, e) {
	                return e = s.call(this, t, e || !1), t instanceof DocumentFragment && (e.__proto__ = DocumentFragment.prototype), e
	            };
	        }();
	        var i = Node.prototype.cloneNode,
	            a = Document.prototype.createElement,
	            s = Document.prototype.importNode,
	            l = Node.prototype.removeChild,
	            c = Node.prototype.appendChild,
	            u = Node.prototype.replaceChild,
	            h = Element.prototype.querySelectorAll,
	            d = Document.prototype.querySelectorAll,
	            f = DocumentFragment.prototype.querySelectorAll,
	            p = function() {
	                if (!n) {
	                    var t = document.createElement("template"),
	                        e = document.createElement("template");
	                    return e.content.appendChild(document.createElement("div")), t.content.appendChild(e), 0 === (t = t.cloneNode(!0)).content.childNodes.length || 0 === t.content.firstChild.content.childNodes.length || o
	                }
	            }();
	        if (n) {
	            var m = document.implementation.createHTMLDocument("template"),
	                v = !0,
	                g = document.createElement("style");
	            g.textContent = "template{display:none;}";
	            var y = document.head;
	            y.insertBefore(g, y.firstElementChild), t.prototype = Object.create(HTMLElement.prototype);
	            var b = !document.createElement("div").hasOwnProperty("innerHTML");
	            t.R = function(e) {
	                if (!e.content && e.namespaceURI === document.documentElement.namespaceURI) {
	                    e.content = m.createDocumentFragment();
	                    for (var n; n = e.firstChild;) c.call(e.content, n);
	                    if (b) e.__proto__ = t.prototype;
	                    else if (e.cloneNode = function(e) {
	                            return t.a(this, e)
	                        }, v) try {
	                        w(e), E(e);
	                    } catch (t) {
	                        v = !1;
	                    }
	                    t.b(e.content);
	                }
	            };
	            var w = function(e) {
	                    Object.defineProperty(e, "innerHTML", {
	                        get: function() {
	                            return O(this)
	                        },
	                        set: function(e) {
	                            for (m.body.innerHTML = e, t.b(m); this.content.firstChild;) l.call(this.content, this.content.firstChild);
	                            for (; m.body.firstChild;) c.call(this.content, m.body.firstChild);
	                        },
	                        configurable: !0
	                    });
	                },
	                E = function(t) {
	                    Object.defineProperty(t, "outerHTML", {
	                        get: function() {
	                            return "<template>" + this.innerHTML + "</template>"
	                        },
	                        set: function(t) {
	                            if (!this.parentNode) throw Error("Failed to set the 'outerHTML' property on 'Element': This element has no parent node.");
	                            for (m.body.innerHTML = t, t = this.ownerDocument.createDocumentFragment(); m.body.firstChild;) c.call(t, m.body.firstChild);
	                            u.call(this.parentNode, t, this);
	                        },
	                        configurable: !0
	                    });
	                };
	            w(t.prototype), E(t.prototype), t.b = function(n) {
	                for (var o, r = 0, i = (n = e(n, "template")).length; r < i && (o = n[r]); r++) t.R(o);
	            }, document.addEventListener("DOMContentLoaded", function() {
	                t.b(document);
	            }), Document.prototype.createElement = function() {
	                var e = a.apply(this, arguments);
	                return "template" === e.localName && t.R(e), e
	            };
	            var N = /[&\u00A0"]/g,
	                C = /[&\u00A0<>]/g,
	                S = function(t) {
	                    switch (t) {
	                        case "&":
	                            return "&amp;";
	                        case "<":
	                            return "&lt;";
	                        case ">":
	                            return "&gt;";
	                        case '"':
	                            return "&quot;";
	                        case " ":
	                            return "&nbsp;"
	                    }
	                },
	                _ = (g = function(t) {
	                    for (var e = {}, n = 0; n < t.length; n++) e[t[n]] = !0;
	                    return e
	                })("area base br col command embed hr img input keygen link meta param source track wbr".split(" ")),
	                T = g("style script xmp iframe noembed noframes plaintext noscript".split(" ")),
	                O = function(t, e) {
	                    "template" === t.localName && (t = t.content);
	                    for (var n, o = "", r = e ? e(t) : t.childNodes, i = 0, a = r.length; i < a && (n = r[i]); i++) {
	                        t: {
	                            var s = n,
	                                l = t,
	                                c = e;
	                            switch (s.nodeType) {
	                                case Node.ELEMENT_NODE:
	                                    for (var u = s.localName, h = "<" + u, d = s.attributes, f = 0; l = d[f]; f++) h += " " + l.name + '="' + l.value.replace(N, S) + '"';
	                                    h += ">", s = _[u] ? h : h + O(s, c) + "</" + u + ">";
	                                    break t;
	                                case Node.TEXT_NODE:
	                                    s = s.data, s = l && T[l.localName] ? s : s.replace(C, S);
	                                    break t;
	                                case Node.COMMENT_NODE:
	                                    s = "\x3c!--" + s.data + "--\x3e";
	                                    break t;
	                                default:
	                                    throw window.console.error(s), Error("not implemented")
	                            }
	                        }
	                        o += s;
	                    }
	                    return o
	                };
	        }
	        if (n || p) {
	            t.a = function(t, e) {
	                var n = i.call(t, !1);
	                return this.R && this.R(n), e && (c.call(n.content, i.call(t.content, !0)), D(n.content, t.content)), n
	            };
	            var D = function(n, o) {
	                    if (o.querySelectorAll && 0 !== (o = e(o, "template")).length)
	                        for (var r, i, a = 0, s = (n = e(n, "template")).length; a < s; a++) i = o[a], r = n[a], t && t.R && t.R(i), u.call(r.parentNode, x.call(i, !0), r);
	                },
	                x = Node.prototype.cloneNode = function(e) {
	                    if (!r && o && this instanceof DocumentFragment) {
	                        if (!e) return this.ownerDocument.createDocumentFragment();
	                        var n = M.call(this.ownerDocument, this, !0);
	                    } else n = this.nodeType === Node.ELEMENT_NODE && "template" === this.localName && this.namespaceURI == document.documentElement.namespaceURI ? t.a(this, e) : i.call(this, e);
	                    return e && D(n, this), n
	                },
	                M = Document.prototype.importNode = function(n, o) {
	                    if (o = o || !1, "template" === n.localName) return t.a(n, o);
	                    var r = s.call(this, n, o);
	                    if (o) {
	                        D(r, n), n = e(r, 'script:not([type]),script[type="application/javascript"],script[type="text/javascript"]');
	                        for (var i, l = 0; l < n.length; l++) {
	                            i = n[l], (o = a.call(document, "script")).textContent = i.textContent;
	                            for (var c, h = i.attributes, d = 0; d < h.length; d++) c = h[d], o.setAttribute(c.name, c.value);
	                            u.call(i.parentNode, o, i);
	                        }
	                    }
	                    return r
	                };
	        }
	        n && (window.HTMLTemplateElement = t);
	    }();
	    var l = Array.isArray ? Array.isArray : function(t) {
	            return "[object Array]" === Object.prototype.toString.call(t)
	        },
	        c = 0,
	        u = ("undefined" != typeof window ? window : void 0) || {},
	        h = u.MutationObserver || u.WebKitMutationObserver,
	        d = "undefined" == typeof self && "undefined" != typeof process && "[object process]" === {}.toString.call(process),
	        f = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel;

	    function p() {
	        var t = setTimeout;
	        return function() {
	            return t(y, 1)
	        }
	    }
	    var m, v, g = Array(1e3);

	    function y() {
	        for (var t = 0; t < c; t += 2)(0, g[t])(g[t + 1]), g[t] = void 0, g[t + 1] = void 0;
	        c = 0;
	    }
	    if (d) v = function() {
	        return process.xb(y)
	    };
	    else {
	        var b;
	        if (h) b = function() {
	            var t = 0,
	                e = new h(y),
	                n = document.createTextNode("");
	            return e.observe(n, {
	                    characterData: !0
	                }),
	                function() {
	                    n.data = t = ++t % 2;
	                }
	        }();
	        else {
	            var w;
	            if (f) w = function() {
	                var t = new MessageChannel;
	                return t.port1.onmessage = y,
	                    function() {
	                        return t.port2.postMessage(0)
	                    }
	            }();
	            else w = p();
	            b = w;
	        }
	        v = b;
	    }

	    function E(t, e) {
	        g[c] = t, g[c + 1] = e, 2 === (c += 2) && m();
	    }

	    function N(t, e) {
	        var n = this,
	            o = new this.constructor(_);
	        void 0 === o[S] && I(o);
	        var r = n.o;
	        if (r) {
	            var i = arguments[r - 1];
	            E(function() {
	                return F(r, o, i, n.l)
	            });
	        } else k(n, o, t, e);
	        return o
	    }

	    function C(t) {
	        if (t && "object" == typeof t && t.constructor === this) return t;
	        var e = new this(_);
	        return x(e, t), e
	    }
	    m = v;
	    var S = Math.random().toString(36).substring(16);

	    function _() {}
	    var T = new R;

	    function O(t) {
	        try {
	            return t.then
	        } catch (t) {
	            return T.error = t, T
	        }
	    }

	    function D(t, e, n) {
	        e.constructor === t.constructor && n === N && e.constructor.resolve === C ? function(t, e) {
	            1 === e.o ? A(t, e.l) : 2 === e.o ? L(t, e.l) : k(e, void 0, function(e) {
	                return x(t, e)
	            }, function(e) {
	                return L(t, e)
	            });
	        }(t, e) : n === T ? (L(t, T.error), T.error = null) : void 0 === n ? A(t, e) : "function" == typeof n ? function(t, e, n) {
	            E(function(t) {
	                var o = !1,
	                    r = function(t, e, n, o) {
	                        try {
	                            t.call(e, n, o);
	                        } catch (t) {
	                            return t
	                        }
	                    }(n, e, function(n) {
	                        o || (o = !0, e !== n ? x(t, n) : A(t, n));
	                    }, function(e) {
	                        o || (o = !0, L(t, e));
	                    });
	                !o && r && (o = !0, L(t, r));
	            }, t);
	        }(t, e, n) : A(t, e);
	    }

	    function x(t, e) {
	        if (t === e) L(t, new TypeError("You cannot resolve a promise with itself"));
	        else {
	            var n = typeof e;
	            null === e || "object" !== n && "function" !== n ? A(t, e) : D(t, e, O(e));
	        }
	    }

	    function M(t) {
	        t.xa && t.xa(t.l), j(t);
	    }

	    function A(t, e) {
	        void 0 === t.o && (t.l = e, t.o = 1, 0 !== t.U.length && E(j, t));
	    }

	    function L(t, e) {
	        void 0 === t.o && (t.o = 2, t.l = e, E(M, t));
	    }

	    function k(t, e, n, o) {
	        var r = t.U,
	            i = r.length;
	        t.xa = null, r[i] = e, r[i + 1] = n, r[i + 2] = o, 0 === i && t.o && E(j, t);
	    }

	    function j(t) {
	        var e = t.U,
	            n = t.o;
	        if (0 !== e.length) {
	            for (var o, r, i = t.l, a = 0; a < e.length; a += 3) o = e[a], r = e[a + n], o ? F(n, o, r, i) : r(i);
	            t.U.length = 0;
	        }
	    }

	    function R() {
	        this.error = null;
	    }
	    var P = new R;

	    function F(t, e, n, o) {
	        var r = "function" == typeof n;
	        if (r) {
	            try {
	                var i = n(o);
	            } catch (t) {
	                P.error = t, i = P;
	            }
	            if (i === P) {
	                var a = !0,
	                    s = i.error;
	                i.error = null;
	            } else var l = !0;
	            if (e === i) return void L(e, new TypeError("A promises callback cannot return that same promise."))
	        } else i = o, l = !0;
	        void 0 === e.o && (r && l ? x(e, i) : a ? L(e, s) : 1 === t ? A(e, i) : 2 === t && L(e, i));
	    }
	    var H = 0;

	    function I(t) {
	        t[S] = H++, t.o = void 0, t.l = void 0, t.U = [];
	    }

	    function U(t, e, n) {
	        var o = t.Na,
	            r = o.resolve;
	        r === C ? (r = O(e)) === N && void 0 !== e.o ? q(t, e.o, n, e.l) : "function" != typeof r ? (t.$--, t.l[n] = e) : o === V ? (D(o = new o(_), e, r), B(t, o, n)) : B(t, new o(function(t) {
	            return t(e)
	        }), n) : B(t, r(e), n);
	    }

	    function q(t, e, n, o) {
	        var r = t.N;
	        void 0 === r.o && (t.$--, 2 === e ? L(r, o) : t.l[n] = o), 0 === t.$ && A(r, t.l);
	    }

	    function B(t, e, n) {
	        k(e, void 0, function(e) {
	            return q(t, 1, n, e)
	        }, function(e) {
	            return q(t, 2, n, e)
	        });
	    }

	    function V(t) {
	        if (this[S] = H++, this.l = this.o = void 0, this.U = [], _ !== t) {
	            if ("function" != typeof t) throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
	            if (!(this instanceof V)) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	            ! function(t, e) {
	                try {
	                    e(function(e) {
	                        x(t, e);
	                    }, function(e) {
	                        L(t, e);
	                    });
	                } catch (e) {
	                    L(t, e);
	                }
	            }(this, t);
	        }
	    }
	    V.prototype = {
	        constructor: V,
	        then: N,
	        a: function(t) {
	            return this.then(null, t)
	        }
	    }, window.Promise || (window.Promise = V, V.prototype.catch = V.prototype.a, V.prototype.then = V.prototype.then, V.all = function(t) {
	        return new function(t, e) {
	            if (this.Na = t, this.N = new t(_), this.N[S] || I(this.N), l(e))
	                if (this.$ = this.length = e.length, this.l = Array(this.length), 0 === this.length) A(this.N, this.l);
	                else {
	                    for (this.length = this.length || 0, t = 0; void 0 === this.o && t < e.length; t++) U(this, e[t], t);
	                    0 === this.$ && A(this.N, this.l);
	                }
	            else L(this.N, Error("Array Methods must be provided an Array"));
	        }(this, t).N
	    }, V.race = function(t) {
	        var e = this;
	        return l(t) ? new e(function(n, o) {
	            for (var r = t.length, i = 0; i < r; i++) e.resolve(t[i]).then(n, o);
	        }) : new e(function(t, e) {
	            return e(new TypeError("You must pass an array to race."))
	        })
	    }, V.resolve = C, V.reject = function(t) {
	        var e = new this(_);
	        return L(e, t), e
	    }), window.WebComponents = window.WebComponents || {
	        flags: {}
	    };
	    var W = document.querySelector('script[src*="webcomponents-bundle"]'),
	        G = /wc-(.+)/,
	        K = {};
	    if (!K.noOpts) {
	        if (location.search.slice(1).split("&").forEach(function(t) {
	                var e;
	                (t = t.split("="))[0] && (e = t[0].match(G)) && (K[e[1]] = t[1] || !0);
	            }), W)
	            for (var $, X = 0; $ = W.attributes[X]; X++) "src" !== $.name && (K[$.name] = $.value || !0);
	        if (K.log && K.log.split) {
	            var J = K.log.split(",");
	            K.log = {}, J.forEach(function(t) {
	                K.log[t] = !0;
	            });
	        } else K.log = {};
	    }
	    window.WebComponents.flags = K;
	    var Y = K.shadydom;
	    Y && (window.ShadyDOM = window.ShadyDOM || {}, window.ShadyDOM.force = Y);
	    var z = K.register || K.ce;

	    function Z() {
	        this.Da = this.root = null, this.da = !1, this.L = this.Z = this.pa = this.assignedSlot = this.assignedNodes = this.S = null, this.childNodes = this.nextSibling = this.previousSibling = this.lastChild = this.firstChild = this.parentNode = this.V = void 0, this.Ia = this.va = !1;
	    }

	    function Q(t) {
	        return t.ka || (t.ka = new Z), t.ka
	    }

	    function tt(t) {
	        return t && t.ka
	    }
	    z && window.customElements && (window.customElements.forcePolyfill = z), Z.prototype.toJSON = function() {
	        return {}
	    };
	    var et = window.ShadyDOM || {};
	    et.Ua = !(!Element.prototype.attachShadow || !Node.prototype.getRootNode);
	    var nt = Object.getOwnPropertyDescriptor(Node.prototype, "firstChild");
	    et.I = !!(nt && nt.configurable && nt.get), et.Ba = et.force || !et.Ua;
	    var ot = navigator.userAgent.match("Trident"),
	        rt = navigator.userAgent.match("Edge");

	    var test = document.createElement('div');
	    if (et.I && Object.getOwnPropertyDescriptor(test, 'shadowRoot')) {
	      et.I = false;
	    }

	    function it(t) {
	        return (t = tt(t)) && void 0 !== t.firstChild
	    }

	    function at(t) {
	        return "ShadyRoot" === t.Oa
	    }

	    function st(t) {
	        if (at(t = t.getRootNode())) return t
	    }
	    void 0 === et.Fa && (et.Fa = et.I && (ot || rt));
	    var lt = Element.prototype,
	        ct = lt.matches || lt.matchesSelector || lt.mozMatchesSelector || lt.msMatchesSelector || lt.oMatchesSelector || lt.webkitMatchesSelector;

	    function ut(t, e) {
	        if (t && e)
	            for (var n, o = Object.getOwnPropertyNames(e), r = 0; r < o.length && (n = o[r]); r++) {
	                var i = Object.getOwnPropertyDescriptor(e, n);
	                i && Object.defineProperty(t, n, i);
	            }
	    }

	    function ht(t, e) {
	        for (var n = [], o = 1; o < arguments.length; ++o) n[o - 1] = arguments[o];
	        for (o = 0; o < n.length; o++) ut(t, n[o]);
	        return t
	    }
	    var dt = document.createTextNode(""),
	        ft = 0,
	        pt = [];

	    function mt(t) {
	        pt.push(t), dt.textContent = ft++;
	    }
	    new MutationObserver(function() {
	        for (; pt.length;) try {
	            pt.shift()();
	        } catch (t) {
	            throw dt.textContent = ft++, t
	        }
	    }).observe(dt, {
	        characterData: !0
	    });
	    var vt = !!document.contains;

	    function gt(t, e) {
	        for (; e;) {
	            if (e == t) return !0;
	            e = e.parentNode;
	        }
	        return !1
	    }
	    var yt, bt = [];

	    function wt(t) {
	        yt || (yt = !0, mt(Et)), bt.push(t);
	    }

	    function Et() {
	        yt = !1;
	        for (var t = !!bt.length; bt.length;) bt.shift()();
	        return t
	    }

	    function Nt() {
	        this.a = !1, this.addedNodes = [], this.removedNodes = [], this.ca = new Set;
	    }
	    Et.list = bt, Nt.prototype.takeRecords = function() {
	        if (this.addedNodes.length || this.removedNodes.length) {
	            var t = [{
	                addedNodes: this.addedNodes,
	                removedNodes: this.removedNodes
	            }];
	            return this.addedNodes = [], this.removedNodes = [], t
	        }
	        return []
	    };
	    var Ct = {},
	        St = Element.prototype.insertBefore,
	        _t = Element.prototype.replaceChild,
	        Tt = Element.prototype.removeChild,
	        Ot = Element.prototype.setAttribute,
	        Dt = Element.prototype.removeAttribute,
	        xt = Element.prototype.cloneNode,
	        Mt = Document.prototype.importNode,
	        At = Element.prototype.addEventListener,
	        Lt = Element.prototype.removeEventListener,
	        kt = Window.prototype.addEventListener,
	        jt = Window.prototype.removeEventListener,
	        Rt = Element.prototype.dispatchEvent,
	        Pt = Node.prototype.contains || HTMLElement.prototype.contains,
	        Ft = Document.prototype.getElementById,
	        Ht = Element.prototype.querySelector,
	        It = DocumentFragment.prototype.querySelector,
	        Ut = Document.prototype.querySelector,
	        qt = Element.prototype.querySelectorAll,
	        Bt = DocumentFragment.prototype.querySelectorAll,
	        Vt = Document.prototype.querySelectorAll;
	    Ct.appendChild = Element.prototype.appendChild, Ct.insertBefore = St, Ct.replaceChild = _t, Ct.removeChild = Tt, Ct.setAttribute = Ot, Ct.removeAttribute = Dt, Ct.cloneNode = xt, Ct.importNode = Mt, Ct.addEventListener = At, Ct.removeEventListener = Lt, Ct.eb = kt, Ct.fb = jt, Ct.dispatchEvent = Rt, Ct.contains = Pt, Ct.getElementById = Ft, Ct.ob = Ht, Ct.sb = It, Ct.mb = Ut, Ct.querySelector = function(t) {
	        switch (this.nodeType) {
	            case Node.ELEMENT_NODE:
	                return Ht.call(this, t);
	            case Node.DOCUMENT_NODE:
	                return Ut.call(this, t);
	            default:
	                return It.call(this, t)
	        }
	    }, Ct.pb = qt, Ct.tb = Bt, Ct.nb = Vt, Ct.querySelectorAll = function(t) {
	        switch (this.nodeType) {
	            case Node.ELEMENT_NODE:
	                return qt.call(this, t);
	            case Node.DOCUMENT_NODE:
	                return Vt.call(this, t);
	            default:
	                return Bt.call(this, t)
	        }
	    };
	    var Wt = /[&\u00A0"]/g,
	        Gt = /[&\u00A0<>]/g;

	    function Kt(t) {
	        switch (t) {
	            case "&":
	                return "&amp;";
	            case "<":
	                return "&lt;";
	            case ">":
	                return "&gt;";
	            case '"':
	                return "&quot;";
	            case " ":
	                return "&nbsp;"
	        }
	    }

	    function $t(t) {
	        for (var e = {}, n = 0; n < t.length; n++) e[t[n]] = !0;
	        return e
	    }
	    var Xt = $t("area base br col command embed hr img input keygen link meta param source track wbr".split(" ")),
	        Jt = $t("style script xmp iframe noembed noframes plaintext noscript".split(" "));

	    function Yt(t, e) {
	        "template" === t.localName && (t = t.content);
	        for (var n, o = "", r = e ? e(t) : t.childNodes, i = 0, a = r.length; i < a && (n = r[i]); i++) {
	            t: {
	                var s = n,
	                    l = t,
	                    c = e;
	                switch (s.nodeType) {
	                    case Node.ELEMENT_NODE:
	                        for (var u = s.localName, h = "<" + u, d = s.attributes, f = 0; l = d[f]; f++) h += " " + l.name + '="' + l.value.replace(Wt, Kt) + '"';
	                        h += ">", s = Xt[u] ? h : h + Yt(s, c) + "</" + u + ">";
	                        break t;
	                    case Node.TEXT_NODE:
	                        s = s.data, s = l && Jt[l.localName] ? s : s.replace(Gt, Kt);
	                        break t;
	                    case Node.COMMENT_NODE:
	                        s = "\x3c!--" + s.data + "--\x3e";
	                        break t;
	                    default:
	                        throw window.console.error(s), Error("not implemented")
	                }
	            }
	            o += s;
	        }
	        return o
	    }
	    var zt = {},
	        Zt = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, !1),
	        Qt = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, !1);

	    function te(t) {
	        var e = [];
	        for (Zt.currentNode = t, t = Zt.firstChild(); t;) e.push(t), t = Zt.nextSibling();
	        return e
	    }
	    zt.parentNode = function(t) {
	        return Zt.currentNode = t, Zt.parentNode()
	    }, zt.firstChild = function(t) {
	        return Zt.currentNode = t, Zt.firstChild()
	    }, zt.lastChild = function(t) {
	        return Zt.currentNode = t, Zt.lastChild()
	    }, zt.previousSibling = function(t) {
	        return Zt.currentNode = t, Zt.previousSibling()
	    }, zt.nextSibling = function(t) {
	        return Zt.currentNode = t, Zt.nextSibling()
	    }, zt.childNodes = te, zt.parentElement = function(t) {
	        return Qt.currentNode = t, Qt.parentNode()
	    }, zt.firstElementChild = function(t) {
	        return Qt.currentNode = t, Qt.firstChild()
	    }, zt.lastElementChild = function(t) {
	        return Qt.currentNode = t, Qt.lastChild()
	    }, zt.previousElementSibling = function(t) {
	        return Qt.currentNode = t, Qt.previousSibling()
	    }, zt.nextElementSibling = function(t) {
	        return Qt.currentNode = t, Qt.nextSibling()
	    }, zt.children = function(t) {
	        var e = [];
	        for (Qt.currentNode = t, t = Qt.firstChild(); t;) e.push(t), t = Qt.nextSibling();
	        return e
	    }, zt.innerHTML = function(t) {
	        return Yt(t, function(t) {
	            return te(t)
	        })
	    }, zt.textContent = function(t) {
	        switch (t.nodeType) {
	            case Node.ELEMENT_NODE:
	            case Node.DOCUMENT_FRAGMENT_NODE:
	                t = document.createTreeWalker(t, NodeFilter.SHOW_TEXT, null, !1);
	                for (var e, n = ""; e = t.nextNode();) n += e.nodeValue;
	                return n;
	            default:
	                return t.nodeValue
	        }
	    };
	    var ee = {},
	        ne = et.I,
	        oe = [Node.prototype, Element.prototype, HTMLElement.prototype];

	    function re(t) {
	        var e;
	        t: {
	            for (e = 0; e < oe.length; e++) {
	                var n = oe[e];
	                if (n.hasOwnProperty(t)) {
	                    e = n;
	                    break t
	                }
	            }
	            e = void 0;
	        }
	        if (!e) {
	          return e;
	        }        return Object.getOwnPropertyDescriptor(e, t)
	    }
	    var ie = ne ? {
	            parentNode: re("parentNode"),
	            firstChild: re("firstChild"),
	            lastChild: re("lastChild"),
	            previousSibling: re("previousSibling"),
	            nextSibling: re("nextSibling"),
	            childNodes: re("childNodes"),
	            parentElement: re("parentElement"),
	            previousElementSibling: re("previousElementSibling"),
	            nextElementSibling: re("nextElementSibling"),
	            innerHTML: re("innerHTML"),
	            textContent: re("textContent"),
	            firstElementChild: re("firstElementChild"),
	            lastElementChild: re("lastElementChild"),
	            children: re("children")
	        } : {},
	        ae = ne ? {
	            firstElementChild: Object.getOwnPropertyDescriptor(DocumentFragment.prototype, "firstElementChild"),
	            lastElementChild: Object.getOwnPropertyDescriptor(DocumentFragment.prototype, "lastElementChild"),
	            children: Object.getOwnPropertyDescriptor(DocumentFragment.prototype, "children")
	        } : {},
	        se = ne ? {
	            firstElementChild: Object.getOwnPropertyDescriptor(Document.prototype, "firstElementChild"),
	            lastElementChild: Object.getOwnPropertyDescriptor(Document.prototype, "lastElementChild"),
	            children: Object.getOwnPropertyDescriptor(Document.prototype, "children")
	        } : {};
	    ee.Ca = ie, ee.rb = ae, ee.lb = se, ee.parentNode = function(t) {
	        return ie.parentNode.get.call(t)
	    }, ee.firstChild = function(t) {
	        return ie.firstChild.get.call(t)
	    }, ee.lastChild = function(t) {
	        return ie.lastChild.get.call(t)
	    }, ee.previousSibling = function(t) {
	        return ie.previousSibling.get.call(t)
	    }, ee.nextSibling = function(t) {
	        return ie.nextSibling.get.call(t)
	    }, ee.childNodes = function(t) {
	        return ie.childNodes.get.call(t)
	    }, ee.parentElement = function(t) {
	        return ie.parentElement ? ie.parentElement.get.call(t) : ie.parentNode.get.call(t)
	    }, ee.previousElementSibling = function(t) {
	        if (ie.previousElementSibling) return ie.previousElementSibling.get.call(t)
	        for (;;) {
	          var previousSibling = ie.previousSibling.get.call(t);
	          if (previousSibling.nodeType === 1 || previousSibling === null) {
	            return previousSibling
	          }
	          t = previousSibling;
	        }
	    }, ee.nextElementSibling = function(t) {
	        if (ie.nextElementSibling) return ie.nextElementSibling.get.call(t)
	        for (;;) {
	          var nextSibling = ie.nextSibling.get.call(t);
	          if (nextSibling.nodeType === 1 || nextSibling === null) {
	            return nextSibling
	          }
	          t = nextSibling;
	        }
	    }, ee.innerHTML = function(t) {
	        return ie.innerHTML.get.call(t)
	    }, ee.textContent = function(t) {
	        return ie.textContent.get.call(t)
	    }, ee.children = function(t) {
	        switch (t.nodeType) {
	            case Node.DOCUMENT_FRAGMENT_NODE:
	                t = ae.children.get.call(t);
	                break;
	            case Node.DOCUMENT_NODE:
	                t = se.children.get.call(t);
	                break;
	            default:
	                t = ie.children.get.call(t);
	        }
	        return Array.prototype.slice.call(t)
	    }, ee.firstElementChild = function(t) {
	        switch (t.nodeType) {
	            case Node.DOCUMENT_FRAGMENT_NODE:
	                return ae.firstElementChild.get.call(t);
	            case Node.DOCUMENT_NODE:
	                return se.firstElementChild.get.call(t);
	            default:
	                return ie.firstElementChild.get.call(t)
	        }
	    }, ee.lastElementChild = function(t) {
	        switch (t.nodeType) {
	            case Node.DOCUMENT_FRAGMENT_NODE:
	                return ae.lastElementChild.get.call(t);
	            case Node.DOCUMENT_NODE:
	                return se.lastElementChild.get.call(t);
	            default:
	                return ie.lastElementChild.get.call(t)
	        }
	    };
	    var le = et.I ? ee : zt;

	    function ce(t) {
	        for (; t.firstChild;) t.removeChild(t.firstChild);
	    }
	    var ue = et.I,
	        he = document.implementation.createHTMLDocument("inert"),
	        de = Object.getOwnPropertyDescriptor(Node.prototype, "isConnected"),
	        fe = de && de.get,
	        pe = Object.getOwnPropertyDescriptor(Document.prototype, "activeElement"),
	        me = {
	            parentElement: {
	                get: function() {
	                    var t = tt(this);
	                    return (t = t && t.parentNode) && t.nodeType !== Node.ELEMENT_NODE && (t = null), void 0 !== t ? t : le.parentElement(this)
	                },
	                configurable: !0
	            },
	            parentNode: {
	                get: function() {
	                    var t = tt(this);
	                    return void 0 !== (t = t && t.parentNode) ? t : le.parentNode(this)
	                },
	                configurable: !0
	            },
	            nextSibling: {
	                get: function() {
	                    var t = tt(this);
	                    return void 0 !== (t = t && t.nextSibling) ? t : le.nextSibling(this)
	                },
	                configurable: !0
	            },
	            previousSibling: {
	                get: function() {
	                    var t = tt(this);
	                    return void 0 !== (t = t && t.previousSibling) ? t : le.previousSibling(this)
	                },
	                configurable: !0
	            },
	            nextElementSibling: {
	                get: function() {
	                    var t = tt(this);
	                    if (t && void 0 !== t.nextSibling) {
	                        for (t = this.nextSibling; t && t.nodeType !== Node.ELEMENT_NODE;) t = t.nextSibling;
	                        return t
	                    }
	                    return le.nextElementSibling(this)
	                },
	                configurable: !0
	            },
	            previousElementSibling: {
	                get: function() {
	                    var t = tt(this);
	                    if (t && void 0 !== t.previousSibling) {
	                        for (t = this.previousSibling; t && t.nodeType !== Node.ELEMENT_NODE;) t = t.previousSibling;
	                        return t
	                    }
	                    return le.previousElementSibling(this)
	                },
	                configurable: !0
	            }
	        },
	        ve = {
	            className: {
	                get: function() {
	                    return this.getAttribute("class") || ""
	                },
	                set: function(t) {
	                    this.setAttribute("class", t);
	                },
	                configurable: !0
	            }
	        },
	        ge = {
	            childNodes: {
	                get: function() {
	                    if (it(this)) {
	                        var t = tt(this);
	                        if (!t.childNodes) {
	                            t.childNodes = [];
	                            for (var e = this.firstChild; e; e = e.nextSibling) t.childNodes.push(e);
	                        }
	                        var n = t.childNodes;
	                    } else n = le.childNodes(this);
	                    return n.item = function(t) {
	                        return n[t]
	                    }, n
	                },
	                configurable: !0
	            },
	            childElementCount: {
	                get: function() {
	                    return this.children.length
	                },
	                configurable: !0
	            },
	            firstChild: {
	                get: function() {
	                    var t = tt(this);
	                    return void 0 !== (t = t && t.firstChild) ? t : le.firstChild(this)
	                },
	                configurable: !0
	            },
	            lastChild: {
	                get: function() {
	                    var t = tt(this);
	                    return void 0 !== (t = t && t.lastChild) ? t : le.lastChild(this)
	                },
	                configurable: !0
	            },
	            textContent: {
	                get: function() {
	                    if (it(this)) {
	                        for (var t, e = [], n = 0, o = this.childNodes; t = o[n]; n++) t.nodeType !== Node.COMMENT_NODE && e.push(t.textContent);
	                        return e.join("")
	                    }
	                    return le.textContent(this)
	                },
	                set: function(t) {
	                    switch (null == t && (t = ""), this.nodeType) {
	                        case Node.ELEMENT_NODE:
	                        case Node.DOCUMENT_FRAGMENT_NODE:
	                            if (!it(this) && ue) {
	                                var e = this.firstChild;
	                                (e != this.lastChild || e && e.nodeType != Node.TEXT_NODE) && ce(this), ee.Ca.textContent.set.call(this, t);
	                            } else ce(this), (0 < t.length || this.nodeType === Node.ELEMENT_NODE) && this.appendChild(document.createTextNode(t));
	                            break;
	                        default:
	                            this.nodeValue = t;
	                    }
	                },
	                configurable: !0
	            },
	            firstElementChild: {
	                get: function() {
	                    var t = tt(this);
	                    if (t && void 0 !== t.firstChild) {
	                        for (t = this.firstChild; t && t.nodeType !== Node.ELEMENT_NODE;) t = t.nextSibling;
	                        return t
	                    }
	                    return le.firstElementChild(this)
	                },
	                configurable: !0
	            },
	            lastElementChild: {
	                get: function() {
	                    var t = tt(this);
	                    if (t && void 0 !== t.lastChild) {
	                        for (t = this.lastChild; t && t.nodeType !== Node.ELEMENT_NODE;) t = t.previousSibling;
	                        return t
	                    }
	                    return le.lastElementChild(this)
	                },
	                configurable: !0
	            },
	            children: {
	                get: function() {
	                    var t;
	                    return (t = it(this) ? Array.prototype.filter.call(this.childNodes, function(t) {
	                        return t.nodeType === Node.ELEMENT_NODE
	                    }) : le.children(this)).item = function(e) {
	                        return t[e]
	                    }, t
	                },
	                configurable: !0
	            },
	            innerHTML: {
	                get: function() {
	                    return it(this) ? Yt("template" === this.localName ? this.content : this) : le.innerHTML(this)
	                },
	                set: function(t) {
	                    var e = "template" === this.localName ? this.content : this;
	                    ce(e);
	                    var n = this.localName;
	                    for (n && "template" !== n || (n = "div"), n = he.createElement(n), ue ? ee.Ca.innerHTML.set.call(n, t) : n.innerHTML = t; n.firstChild;) e.appendChild(n.firstChild);
	                },
	                configurable: !0
	            }
	        },
	        ye = {
	            shadowRoot: {
	                get: function() {
	                    var t = tt(this);
	                    return t && t.Da || null
	                },
	                configurable: !0
	            }
	        },
	        be = {
	            activeElement: {
	                get: function() {
	                    var t = pe && pe.get ? pe.get.call(document) : et.I ? void 0 : document.activeElement;
	                    if (t && t.nodeType) {
	                        var e = !!at(this);
	                        if (this === document || e && this.host !== t && Ct.contains.call(this.host, t)) {
	                            for (e = st(t); e && e !== this;) e = st(t = e.host);
	                            t = this === document ? e ? null : t : e === this ? t : null;
	                        } else t = null;
	                    } else t = null;
	                    return t
	                },
	                set: function() {},
	                configurable: !0
	            }
	        };

	    function we(t, e, n) {
	        for (var o in e) {
	            var r = Object.getOwnPropertyDescriptor(t, o);
	            r && r.configurable || !r && n ? Object.defineProperty(t, o, e[o]) : n && console.warn("Could not define", o, "on", t);
	        }
	    }

	    function Ee(t) {
	        we(t, me), we(t, ve), we(t, ge), we(t, be);
	    }

	    var Ne = et.I ? function() {} : function(t) {
	            var e = Q(t);
	            e.va || (e.va = !0, we(t, me, !0), we(t, ve, !0));
	        },
	        Ce = et.I ? function() {} : function(t) {
	            Q(t).Ia || (we(t, ge, !0), we(t, ye, !0));
	        },
	        Se = le.childNodes;

	    function _e(t, e, n) {
	        Ne(t), n = n || null;
	        var o = Q(t),
	            r = Q(e),
	            i = n ? Q(n) : null;
	        o.previousSibling = n ? i.previousSibling : e.lastChild, (i = tt(o.previousSibling)) && (i.nextSibling = t), (i = tt(o.nextSibling = n)) && (i.previousSibling = t), o.parentNode = e, n ? n === r.firstChild && (r.firstChild = t) : (r.lastChild = t, r.firstChild || (r.firstChild = t)), r.childNodes = null;
	    }

	    function Te(t, e) {
	        var n = Q(t);
	        if (void 0 === n.firstChild)
	            for (e = e || Se(t), n.firstChild = e[0] || null, n.lastChild = e[e.length - 1] || null, Ce(t), n = 0; n < e.length; n++) {
	                var o = e[n],
	                    r = Q(o);
	                r.parentNode = t, r.nextSibling = e[n + 1] || null, r.previousSibling = e[n - 1] || null, Ne(o);
	            }
	    }
	    var Oe = le.parentNode;

	    function De(t, e, n) {
	        if (e === t) throw Error("Failed to execute 'appendChild' on 'Node': The new child element contains the parent.");
	        if (n) {
	            var o = tt(n);
	            if (void 0 !== (o = o && o.parentNode) && o !== t || void 0 === o && Oe(n) !== t) throw Error("Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.")
	        }
	        if (n === e) return e;
	        var r, i;
	        if (e.parentNode && xe(e.parentNode, e), !e.__noInsertionPoint) {
	            var l;
	            if (i = r = st(t)) "slot" === e.localName ? l = [e] : e.querySelectorAll && (l = e.querySelectorAll("slot")), i = l && l.length ? l : void 0;
	            i && (o = i, (l = r).a = l.a || [], l.m = l.m || [], l.w = l.w || {}, l.a.push.apply(l.a, [].concat(o instanceof Array ? o : function(t) {
	                for (var e, n = []; !(e = t.next()).done;) n.push(e.value);
	                return n
	            }(function(t) {
	                a();
	                var e = t[Symbol.iterator];
	                return e ? e.call(t) : s(t)
	            }(o)))));
	        }
	        if (("slot" === t.localName || i) && (r = r || st(t)) && ln(r), it(t)) {
	            if (r = n, Ce(t), void 0 !== (i = Q(t)).firstChild && (i.childNodes = null), e.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
	                for (i = e.childNodes, l = 0; l < i.length; l++) _e(i[l], t, r);
	                i = void 0 !== (r = Q(e)).firstChild ? null : void 0, r.firstChild = r.lastChild = i, r.childNodes = i;
	            } else _e(e, t, r);
	            if (r = tt(t), Me(t)) {
	                ln(r.root);
	                var c = !0;
	            } else r.root && (c = !0);
	        }
	        return c || (c = at(t) ? t.host : t, n ? (n = function t(e) {
	            var n = e;
	            e && "slot" === e.localName && (n = (n = (n = tt(e)) && n.L) && n.length ? n[0] : t(e.nextSibling));
	            return n
	        }(n), Ct.insertBefore.call(c, e, n)) : Ct.appendChild.call(c, e)), Le(t, e), e
	    }

	    function xe(t, e) {
	        if (e.parentNode !== t) throw Error("The node to be removed is not a child of this node: " + e);
	        var n = st(e),
	            o = tt(t);
	        if (it(t)) {
	            var r = Q(e),
	                i = Q(t);
	            e === i.firstChild && (i.firstChild = r.nextSibling), e === i.lastChild && (i.lastChild = r.previousSibling);
	            var a = r.previousSibling,
	                s = r.nextSibling;
	            if (a && (Q(a).nextSibling = s), s && (Q(s).previousSibling = a), r.parentNode = r.previousSibling = r.nextSibling = void 0, void 0 !== i.childNodes && (i.childNodes = null), Me(t)) {
	                ln(o.root);
	                var l = !0;
	            }
	        }
	        if (function t(e) {
	                var n = tt(e);
	                if (n && void 0 !== n.V) {
	                    n = e.childNodes;
	                    for (var o, r = 0, i = n.length; r < i && (o = n[r]); r++) t(o);
	                }(e = tt(e)) && (e.V = void 0);
	            }(e), n) {
	            if ((r = t && "slot" === t.localName) && (l = !0), n.m) {
	                for (p in fn(n), i = n.w)
	                    for (a = i[p], s = 0; s < a.length; s++) {
	                        var c = a[s];
	                        if (gt(e, c)) {
	                            a.splice(s, 1);
	                            var u = n.m.indexOf(c);
	                            if (0 <= u && n.m.splice(u, 1), s--, c = (u = tt(c)).L)
	                                for (var h = 0; h < c.length; h++) {
	                                    var d = c[h],
	                                        f = nn(d);
	                                    f && Ct.removeChild.call(f, d);
	                                }
	                            u.L = [], u.assignedNodes = [], u = !0;
	                        }
	                    }
	                var p = u;
	            } else p = void 0;
	            (p || r) && ln(n);
	        }
	        return l || (l = at(t) ? t.host : t, (!o.root && "slot" !== e.localName || l === Oe(e)) && Ct.removeChild.call(l, e)), Le(t, null, e), e
	    }

	    function Me(t) {
	        return (t = (t = tt(t)) && t.root) && vn(t)
	    }

	    function Ae(t, e) {
	        if ("slot" === e) Me(t = t.parentNode) && ln(tt(t).root);
	        else if ("slot" === t.localName && "name" === e && (e = st(t))) {
	            if (e.m) {
	                var n = t.Ja,
	                    o = pn(t);
	                if (o !== n) {
	                    var r = (n = e.w[n]).indexOf(t);
	                    0 <= r && n.splice(r, 1), (n = e.w[o] || (e.w[o] = [])).push(t), 1 < n.length && (e.w[o] = mn(n));
	                }
	            }
	            ln(e);
	        }
	    }

	    function Le(t, e, n) {
	        (t = (t = tt(t)) && t.S) && (e && t.addedNodes.push(e), n && t.removedNodes.push(n), function(t) {
	            t.a || (t.a = !0, mt(function() {
	                ! function(t) {
	                    if (t.a) {
	                        t.a = !1;
	                        var e = t.takeRecords();
	                        e.length && t.ca.forEach(function(t) {
	                            t(e);
	                        });
	                    }
	                }(t);
	            }));
	        }(t));
	    }

	    function ke(t, e, n) {
	        var o = [];
	        return function t(e, n, o, r) {
	            for (var i, a = 0, s = e.length; a < s && (i = e[a]); a++) {
	                var l;
	                if (l = i.nodeType === Node.ELEMENT_NODE) {
	                    var c = n,
	                        u = o,
	                        h = r,
	                        d = c(l = i);
	                    d && h.push(l), u && u(d) ? l = d : (t(l.childNodes, c, u, h), l = void 0);
	                }
	                if (l) break
	            }
	        }(t.childNodes, e, n, o), o
	    }
	    var je = null;

	    function Re(t, e, n) {
	        je || (je = window.ShadyCSS && window.ShadyCSS.ScopingShim), je && "class" === e ? je.setElementClass(t, n) : (Ct.setAttribute.call(t, e, n), Ae(t, e));
	    }
	    var Pe = "__eventWrappers" + Date.now(),
	        Fe = {
	            blur: !0,
	            focus: !0,
	            focusin: !0,
	            focusout: !0,
	            click: !0,
	            dblclick: !0,
	            mousedown: !0,
	            mouseenter: !0,
	            mouseleave: !0,
	            mousemove: !0,
	            mouseout: !0,
	            mouseover: !0,
	            mouseup: !0,
	            wheel: !0,
	            beforeinput: !0,
	            input: !0,
	            keydown: !0,
	            keyup: !0,
	            compositionstart: !0,
	            compositionupdate: !0,
	            compositionend: !0,
	            touchstart: !0,
	            touchend: !0,
	            touchmove: !0,
	            touchcancel: !0,
	            pointerover: !0,
	            pointerenter: !0,
	            pointerdown: !0,
	            pointermove: !0,
	            pointerup: !0,
	            pointercancel: !0,
	            pointerout: !0,
	            pointerleave: !0,
	            gotpointercapture: !0,
	            lostpointercapture: !0,
	            dragstart: !0,
	            drag: !0,
	            dragenter: !0,
	            dragleave: !0,
	            dragover: !0,
	            drop: !0,
	            dragend: !0,
	            DOMActivate: !0,
	            DOMFocusIn: !0,
	            DOMFocusOut: !0,
	            keypress: !0
	        };

	    function He(t, e) {
	        var n = [],
	            o = t;
	        for (t = t === window ? window : t.getRootNode(); o;) n.push(o), o = o.assignedSlot ? o.assignedSlot : o.nodeType === Node.DOCUMENT_FRAGMENT_NODE && o.host && (e || o !== t) ? o.host : o.parentNode;
	        return n[n.length - 1] === document && n.push(window), n
	    }

	    function Ie(t, e) {
	        if (!at) return t;
	        t = He(t, !0);
	        for (var n, o, r, i, a = 0; a < e.length; a++)
	            if ((r = (n = e[a]) === window ? window : n.getRootNode()) !== o && (i = t.indexOf(r), o = r), !at(r) || -1 < i) return n
	    }
	    var Ue = {
	        get composed() {
	            return !1 !== this.isTrusted && void 0 === this.ha && (this.ha = Fe[this.type]), this.ha || !1
	        },
	        composedPath: function() {
	            return this.ta || (this.ta = He(this.__target, this.composed)), this.ta
	        },
	        get target() {
	            return Ie(this.currentTarget, this.composedPath())
	        },
	        get relatedTarget() {
	            return this.ja ? (this.wa || (this.wa = He(this.ja, !0)), Ie(this.currentTarget, this.wa)) : null
	        },
	        stopPropagation: function() {
	            Event.prototype.stopPropagation.call(this), this.ia = !0;
	        },
	        stopImmediatePropagation: function() {
	            Event.prototype.stopImmediatePropagation.call(this), this.ia = this.Ha = !0;
	        }
	    };

	    function qe(t) {
	        function e(e, n) {
	            return (e = new t(e, n)).ha = n && !!n.composed, e
	        }
	        return function(t, e) {
	            for (var n in e) t[n] = e[n];
	        }(e, t), e.prototype = t.prototype, e
	    }
	    var Be = {
	        focus: !0,
	        blur: !0
	    };

	    function Ve(t) {
	        return t.__target !== t.target || t.ja !== t.relatedTarget
	    }

	    function We(t, e, n) {
	        if (n = e.__handlers && e.__handlers[t.type] && e.__handlers[t.type][n])
	            for (var o, r = 0;
	                (o = n[r]) && (!Ve(t) || t.target !== t.relatedTarget) && (o.call(e, t), !t.Ha); r++);
	    }

	    function Ge(t) {
	        var e, n = t.composedPath();
	        Object.defineProperty(t, "currentTarget", {
	            get: function() {
	                return r
	            },
	            configurable: !0
	        });
	        for (var o = n.length - 1; 0 <= o; o--) {
	            var r = n[o];
	            if (We(t, r, "capture"), t.ia) return
	        }
	        for (Object.defineProperty(t, "eventPhase", {
	                get: function() {
	                    return Event.AT_TARGET
	                }
	            }), o = 0; o < n.length; o++) {
	            var i = tt(r = n[o]);
	            if (i = i && i.root, (0 === o || i && i === e) && (We(t, r, "bubble"), r !== window && (e = r.getRootNode()), t.ia)) break
	        }
	    }

	    function Ke(t, e, n, o, r, i) {
	        for (var a = 0; a < t.length; a++) {
	            var s = t[a],
	                l = s.type,
	                c = s.capture,
	                u = s.once,
	                h = s.passive;
	            if (e === s.node && n === l && o === c && r === u && i === h) return a
	        }
	        return -1
	    }

	    function $e(t, e, n) {
	        if (e) {
	            var o = typeof e;
	            if (("function" === o || "object" === o) && ("object" !== o || e.handleEvent && "function" == typeof e.handleEvent)) {
	                if (n && "object" == typeof n) var r = !!n.capture,
	                    i = !!n.once,
	                    a = !!n.passive;
	                else r = !!n, a = i = !1;
	                var s = n && n.la || this,
	                    l = e[Pe];
	                if (l) {
	                    if (-1 < Ke(l, s, t, r, i, a)) return
	                } else e[Pe] = [];
	                l = function(r) {
	                    if (i && this.removeEventListener(t, e, n), r.__target || Je(r), s !== this) {
	                        var a = Object.getOwnPropertyDescriptor(r, "currentTarget");
	                        Object.defineProperty(r, "currentTarget", {
	                            get: function() {
	                                return s
	                            },
	                            configurable: !0
	                        });
	                    }
	                    if (r.composed || -1 < r.composedPath().indexOf(s))
	                        if (Ve(r) && r.target === r.relatedTarget) r.eventPhase === Event.BUBBLING_PHASE && r.stopImmediatePropagation();
	                        else if (r.eventPhase === Event.CAPTURING_PHASE || r.bubbles || r.target === s || s instanceof Window) {
	                        var l = "function" === o ? e.call(s, r) : e.handleEvent && e.handleEvent(r);
	                        return s !== this && (a ? (Object.defineProperty(r, "currentTarget", a), a = null) : delete r.currentTarget), l
	                    }
	                }, e[Pe].push({
	                    node: s,
	                    type: t,
	                    capture: r,
	                    once: i,
	                    passive: a,
	                    gb: l
	                }), Be[t] ? (this.__handlers = this.__handlers || {}, this.__handlers[t] = this.__handlers[t] || {
	                    capture: [],
	                    bubble: []
	                }, this.__handlers[t][r ? "capture" : "bubble"].push(l)) : (this instanceof Window ? Ct.eb : Ct.addEventListener).call(this, t, l, n);
	            }
	        }
	    }

	    function Xe(t, e, n) {
	        if (e) {
	            if (n && "object" == typeof n) var o = !!n.capture,
	                r = !!n.once,
	                i = !!n.passive;
	            else o = !!n, i = r = !1;
	            var a = n && n.la || this,
	                s = void 0,
	                l = null;
	            try {
	                l = e[Pe];
	            } catch (t) {}
	            l && (-1 < (r = Ke(l, a, t, o, r, i)) && (s = l.splice(r, 1)[0].gb, l.length || (e[Pe] = void 0))), (this instanceof Window ? Ct.fb : Ct.removeEventListener).call(this, t, s || e, n), s && Be[t] && this.__handlers && this.__handlers[t] && (-1 < (s = (t = this.__handlers[t][o ? "capture" : "bubble"]).indexOf(s)) && t.splice(s, 1));
	        }
	    }

	    function Je(t) {
	        if (t.__target = t.target, t.ja = t.relatedTarget, et.I) {
	            var e = Object.getPrototypeOf(t);
	            if (!e.hasOwnProperty("__patchProto")) {
	                var n = Object.create(e);
	                n.ib = e, ut(n, Ue), e.__patchProto = n;
	            }
	            t.__proto__ = e.__patchProto;
	        } else ut(t, Ue);
	    }
	    var Ye = qe(window.Event),
	        ze = qe(window.CustomEvent),
	        Ze = qe(window.MouseEvent);

	    function Qe(t, e) {
	        return {
	            index: t,
	            W: [],
	            ba: e
	        }
	    }

	    function tn(t, e, n, o) {
	        var r = 0,
	            i = 0,
	            a = 0,
	            s = 0,
	            l = Math.min(e - r, o - i);
	        if (0 == r && 0 == i) t: {
	            for (a = 0; a < l; a++)
	                if (t[a] !== n[a]) break t;a = l;
	        }
	        if (e == t.length && o == n.length) {
	            s = t.length;
	            for (var c = n.length, u = 0; u < l - a && en(t[--s], n[--c]);) u++;
	            s = u;
	        }
	        if (i += a, o -= s, 0 == (e -= s) - (r += a) && 0 == o - i) return [];
	        if (r == e) {
	            for (e = Qe(r, 0); i < o;) e.W.push(n[i++]);
	            return [e]
	        }
	        if (i == o) return [Qe(r, e - r)];
	        for (o = o - (a = i) + 1, s = e - (l = r) + 1, e = Array(o), c = 0; c < o; c++) e[c] = Array(s), e[c][0] = c;
	        for (c = 0; c < s; c++) e[0][c] = c;
	        for (c = 1; c < o; c++)
	            for (u = 1; u < s; u++)
	                if (t[l + u - 1] === n[a + c - 1]) e[c][u] = e[c - 1][u - 1];
	                else {
	                    var h = e[c - 1][u] + 1,
	                        d = e[c][u - 1] + 1;
	                    e[c][u] = h < d ? h : d;
	                } for (l = e.length - 1, a = e[0].length - 1, o = e[l][a], t = []; 0 < l || 0 < a;) 0 == l ? (t.push(2), a--) : 0 == a ? (t.push(3), l--) : (s = e[l - 1][a - 1], (h = (c = e[l - 1][a]) < (u = e[l][a - 1]) ? c < s ? c : s : u < s ? u : s) == s ? (s == o ? t.push(0) : (t.push(1), o = s), l--, a--) : h == c ? (t.push(3), l--, o = c) : (t.push(2), a--, o = u));
	        for (t.reverse(), e = void 0, l = [], a = 0; a < t.length; a++) switch (t[a]) {
	            case 0:
	                e && (l.push(e), e = void 0), r++, i++;
	                break;
	            case 1:
	                e || (e = Qe(r, 0)), e.ba++, r++, e.W.push(n[i]), i++;
	                break;
	            case 2:
	                e || (e = Qe(r, 0)), e.ba++, r++;
	                break;
	            case 3:
	                e || (e = Qe(r, 0)), e.W.push(n[i]), i++;
	        }
	        return e && l.push(e), l
	    }

	    function en(t, e) {
	        return t === e
	    }
	    var nn = le.parentNode,
	        on = le.childNodes,
	        rn = {};

	    function an(t) {
	        var e = [];
	        do {
	            e.unshift(t);
	        } while (t = t.parentNode);
	        return e
	    }

	    function sn(t, e, n) {
	        if (t !== rn) throw new TypeError("Illegal constructor");
	        this.Oa = "ShadyRoot", t = on(e), t = Array.prototype.slice.call(t), this.host = e, this.b = n && n.mode, Te(e, t), (n = tt(e)).root = this, n.Da = "closed" !== this.b ? this : null, (n = Q(this)).firstChild = n.lastChild = n.parentNode = n.nextSibling = n.previousSibling = null, n.childNodes = [], this.aa = !1, this.a = this.w = this.m = null, n = 0;
	        for (var o = t.length; n < o; n++) Ct.removeChild.call(e, t[n]);
	    }

	    function ln(t) {
	        t.aa || (t.aa = !0, wt(function() {
	            return cn(t)
	        }));
	    }

	    function cn(t) {
	        for (var e; t;) {
	            t.aa && (e = t);
	            t: {
	                var n = t;
	                if (at(t = n.host.getRootNode()))
	                    for (var o = n.host.childNodes, r = 0; r < o.length; r++)
	                        if ("slot" == (n = o[r]).localName) break t;t = void 0;
	            }
	        }
	        e && e._renderRoot();
	    }

	    function un(t, e, n) {
	        var o = Q(e),
	            r = o.Z;
	        o.Z = null, n || (n = (t = t.w[e.slot || "__catchall"]) && t[0]), n ? (Q(n).assignedNodes.push(e), o.assignedSlot = n) : o.assignedSlot = void 0, r !== o.assignedSlot && o.assignedSlot && (Q(o.assignedSlot).da = !0);
	    }

	    function hn(t, e, n) {
	        for (var o, r = 0; r < n.length && (o = n[r]); r++)
	            if ("slot" == o.localName) {
	                var i = tt(o).assignedNodes;
	                i && i.length && hn(t, e, i);
	            } else e.push(n[r]);
	    }

	    function dn(t, e) {
	        Ct.dispatchEvent.call(e, new Event("slotchange")), (e = tt(e)).assignedSlot && dn(t, e.assignedSlot);
	    }

	    function fn(t) {
	        if (t.a && t.a.length) {
	            for (var e, n = t.a, o = 0; o < n.length; o++) {
	                var r = n[o];
	                Te(r), Te(r.parentNode);
	                var i = pn(r);
	                t.w[i] ? ((e = e || {})[i] = !0, t.w[i].push(r)) : t.w[i] = [r], t.m.push(r);
	            }
	            if (e)
	                for (var a in e) t.w[a] = mn(t.w[a]);
	            t.a = [];
	        }
	    }

	    function pn(t) {
	        var e = t.name || t.getAttribute("name") || "__catchall";
	        return t.Ja = e
	    }

	    function mn(t) {
	        return t.sort(function(t, e) {
	            t = an(t);
	            for (var n = an(e), o = 0; o < t.length; o++) {
	                e = t[o];
	                var r = n[o];
	                if (e !== r) return (t = Array.from(e.parentNode.childNodes)).indexOf(e) - t.indexOf(r)
	            }
	        })
	    }

	    function vn(t) {
	        return fn(t), !(!t.m || !t.m.length)
	    }

	    function gn(t) {
	        var e = t.getRootNode();
	        return at(e) && cn(e), (t = tt(t)) && t.assignedSlot || null
	    }
	    sn.prototype._renderRoot = function() {
	        if (this.aa = !1, this.m) {
	            fn(this);
	            for (var t, e = 0; e < this.m.length; e++) {
	                var n = tt(t = this.m[e]),
	                    o = n.assignedNodes;
	                if (n.assignedNodes = [], n.L = [], n.pa = o)
	                    for (n = 0; n < o.length; n++) {
	                        var r = tt(o[n]);
	                        r.Z = r.assignedSlot, r.assignedSlot === t && (r.assignedSlot = null);
	                    }
	            }
	            for (t = this.host.firstChild; t; t = t.nextSibling) un(this, t);
	            for (e = 0; e < this.m.length; e++) {
	                if (!(o = tt(t = this.m[e])).assignedNodes.length)
	                    for (n = t.firstChild; n; n = n.nextSibling) un(this, n, t);
	                if ((n = (n = tt(t.parentNode)) && n.root) && vn(n) && n._renderRoot(), hn(this, o.L, o.assignedNodes), n = o.pa) {
	                    for (r = 0; r < n.length; r++) tt(n[r]).Z = null;
	                    o.pa = null, n.length > o.assignedNodes.length && (o.da = !0);
	                }
	                o.da && (o.da = !1, dn(this, t));
	            }
	            for (e = this.m, t = [], o = 0; o < e.length; o++)(r = tt(n = e[o].parentNode)) && r.root || !(0 > t.indexOf(n)) || t.push(n);
	            for (e = 0; e < t.length; e++) {
	                n = (o = t[e]) === this ? this.host : o, r = [], o = o.childNodes;
	                for (var i = 0; i < o.length; i++) {
	                    var a = o[i];
	                    if ("slot" == a.localName) {
	                        a = tt(a).L;
	                        for (var s = 0; s < a.length; s++) r.push(a[s]);
	                    } else r.push(a);
	                }
	                o = void 0, i = on(n), i = Array.prototype.slice.call(i), a = tn(r, r.length, i, i.length);
	                for (var l = s = 0; s < a.length && (o = a[s]); s++) {
	                    for (var c, u = 0; u < o.W.length && (c = o.W[u]); u++) nn(c) === n && Ct.removeChild.call(n, c), i.splice(o.index + l, 1);
	                    l -= o.ba;
	                }
	                for (l = 0; l < a.length && (o = a[l]); l++)
	                    for (s = i[o.index], u = o.index; u < o.index + o.ba; u++) c = r[u], Ct.insertBefore.call(n, c, s), i.splice(u, 0, c);
	            }
	        }
	    };
	    var yn = {
	            addEventListener: $e.bind(window),
	            removeEventListener: Xe.bind(window)
	        },
	        bn = {
	            addEventListener: $e,
	            removeEventListener: Xe,
	            appendChild: function(t) {
	                return De(this, t)
	            },
	            insertBefore: function(t, e) {
	                return De(this, t, e)
	            },
	            removeChild: function(t) {
	                return xe(this, t)
	            },
	            replaceChild: function(t, e) {
	                return De(this, t, e), xe(this, e), t
	            },
	            cloneNode: function(t) {
	                if ("template" == this.localName) var e = Ct.cloneNode.call(this, t);
	                else if (e = Ct.cloneNode.call(this, !1), t) {
	                    t = this.childNodes;
	                    for (var n, o = 0; o < t.length; o++) n = t[o].cloneNode(!0), e.appendChild(n);
	                }
	                return e
	            },
	            getRootNode: function() {
	                return function t(e) {
	                    if (e && e.nodeType) {
	                        var n = Q(e),
	                            o = n.V;
	                        return void 0 === o && (at(e) ? (o = e, n.V = o) : (o = (o = e.parentNode) ? t(o) : e, Ct.contains.call(document.documentElement, e) && (n.V = o))), o
	                    }
	                }(this)
	            },
	            contains: function(t) {
	                return gt(this, t)
	            },
	            dispatchEvent: function(t) {
	                return Et(), Ct.dispatchEvent.call(this, t)
	            }
	        };
	    Object.defineProperties(bn, {
	        isConnected: {
	            get: function() {
	                if (fe && fe.call(this)) return !0;
	                if (this.nodeType == Node.DOCUMENT_FRAGMENT_NODE) return !1;
	                var t = this.ownerDocument;
	                if (vt) {
	                    if (Ct.contains.call(t, this)) return !0
	                } else if (t.documentElement && Ct.contains.call(t.documentElement, this)) return !0;
	                for (t = this; t && !(t instanceof Document);) t = t.parentNode || (at(t) ? t.host : void 0);
	                return !!(t && t instanceof Document)
	            },
	            configurable: !0
	        }
	    });
	    var wn = {
	            get assignedSlot() {
	                return gn(this)
	            }
	        },
	        En = {
	            querySelector: function(t) {
	                return ke(this, function(e) {
	                    return ct.call(e, t)
	                }, function(t) {
	                    return !!t
	                })[0] || null
	            },
	            querySelectorAll: function(t, e) {
	                if (e) {
	                    e = Array.prototype.slice.call(Ct.querySelectorAll(this, t));
	                    var n = this.getRootNode();
	                    return e.filter(function(t) {
	                        return t.getRootNode() == n
	                    })
	                }
	                return ke(this, function(e) {
	                    return ct.call(e, t)
	                })
	            }
	        },
	        Nn = {
	            assignedNodes: function(t) {
	                if ("slot" === this.localName) {
	                    var e = this.getRootNode();
	                    return at(e) && cn(e), (e = tt(this)) && (t && t.flatten ? e.L : e.assignedNodes) || []
	                }
	            }
	        },
	        Cn = ht({
	            setAttribute: function(t, e) {
	                Re(this, t, e);
	            },
	            removeAttribute: function(t) {
	                Ct.removeAttribute.call(this, t), Ae(this, t);
	            },
	            attachShadow: function(t) {
	                if (!this) throw "Must provide a host.";
	                if (!t) throw "Not enough arguments.";
	                return new sn(rn, this, t)
	            },
	            get slot() {
	                return this.getAttribute("slot")
	            },
	            set slot(t) {
	                Re(this, "slot", t);
	            },
	            get assignedSlot() {
	                return gn(this)
	            }
	        }, En, Nn);
	    Object.defineProperties(Cn, ye);
	    var Sn = ht({
	        importNode: function(t, e) {
	            return function t(e, n) {
	                if (e.ownerDocument !== document) return Ct.importNode.call(document, e, n);
	                var o = Ct.importNode.call(document, e, !1);
	                if (n) {
	                    e = e.childNodes, n = 0;
	                    for (var r; n < e.length; n++) r = t(e[n], !0), o.appendChild(r);
	                }
	                return o
	            }(t, e)
	        },
	        getElementById: function(t) {
	            return ke(this, function(e) {
	                return e.id == t
	            }, function(t) {
	                return !!t
	            })[0] || null
	        }
	    }, En);
	    Object.defineProperties(Sn, {
	        _activeElement: be.activeElement
	    });
	    var _n = HTMLElement.prototype.blur,
	        Tn = ht({
	            blur: function() {
	                var t = tt(this);
	                (t = (t = t && t.root) && t.activeElement) ? t.blur(): _n.call(this);
	            }
	        }),
	        On = {
	            addEventListener: function(t, e, n) {
	                "object" != typeof n && (n = {
	                    capture: !!n
	                }), n.la = this, this.host.addEventListener(t, e, n);
	            },
	            removeEventListener: function(t, e, n) {
	                "object" != typeof n && (n = {
	                    capture: !!n
	                }), n.la = this, this.host.removeEventListener(t, e, n);
	            },
	            getElementById: function(t) {
	                return ke(this, function(e) {
	                    return e.id == t
	                }, function(t) {
	                    return !!t
	                })[0] || null
	            }
	        };

	    function Dn(t, e) {
	        for (var n = Object.getOwnPropertyNames(e), o = 0; o < n.length; o++) {
	            var r = n[o],
	                i = Object.getOwnPropertyDescriptor(e, r);
	            i.value ? t[r] = i.value : Object.defineProperty(t, r, i);
	        }
	    }
	    if (et.Ba) {
	        var xn = {
	            inUse: et.Ba,
	            patch: function(t) {
	                return Ce(t), Ne(t), t
	            },
	            isShadyRoot: at,
	            enqueue: wt,
	            flush: Et,
	            settings: et,
	            filterMutations: function(t, e) {
	                var n = e.getRootNode();
	                return t.map(function(t) {
	                    var e = n === t.target.getRootNode();
	                    if (e && t.addedNodes) {
	                        if ((e = Array.from(t.addedNodes).filter(function(t) {
	                                return n === t.getRootNode()
	                            })).length) return t = Object.create(t), Object.defineProperty(t, "addedNodes", {
	                            value: e,
	                            configurable: !0
	                        }), t
	                    } else if (e) return t
	                }).filter(function(t) {
	                    return t
	                })
	            },
	            observeChildren: function(t, e) {
	                var n = Q(t);
	                n.S || (n.S = new Nt), n.S.ca.add(e);
	                var o = n.S;
	                return {
	                    La: e,
	                    P: o,
	                    Pa: t,
	                    takeRecords: function() {
	                        return o.takeRecords()
	                    }
	                }
	            },
	            unobserveChildren: function(t) {
	                var e = t && t.P;
	                e && (e.ca.delete(t.La), e.ca.size || (Q(t.Pa).S = null));
	            },
	            nativeMethods: Ct,
	            nativeTree: le
	        };
	        window.ShadyDOM = xn, window.Event = Ye, window.CustomEvent = ze, window.MouseEvent = Ze,
	            function() {
	                for (var t in Be) window.addEventListener(t, function(t) {
	                    t.__target || (Je(t), Ge(t));
	                }, !0);
	            }();
	        var Mn = window.customElements && window.customElements.nativeHTMLElement || HTMLElement;
	        Dn(sn.prototype, On), Dn(window.Node.prototype, bn), Dn(window.Window.prototype, yn), Dn(window.Text.prototype, wn), Dn(window.DocumentFragment.prototype, En), Dn(window.Element.prototype, Cn), Dn(window.Document.prototype, Sn), window.HTMLSlotElement && Dn(window.HTMLSlotElement.prototype, Nn), Dn(Mn.prototype, Tn), et.I && (Ee(window.Node.prototype), Ee(window.Text.prototype), Ee(window.DocumentFragment.prototype), Ee(window.Element.prototype), Ee(Mn.prototype), Ee(window.Document.prototype), window.HTMLSlotElement && Ee(window.HTMLSlotElement.prototype)),
	            function() {
	                var t = sn.prototype;
	                t.__proto__ = DocumentFragment.prototype, we(t, me, !0), we(t, ge, !0), we(t, be, !0), Object.defineProperties(t, {
	                    nodeType: {
	                        value: Node.DOCUMENT_FRAGMENT_NODE,
	                        configurable: !0
	                    },
	                    nodeName: {
	                        value: "#document-fragment",
	                        configurable: !0
	                    },
	                    nodeValue: {
	                        value: null,
	                        configurable: !0
	                    }
	                }), ["localName", "namespaceURI", "prefix"].forEach(function(e) {
	                    Object.defineProperty(t, e, {
	                        value: void 0,
	                        configurable: !0
	                    });
	                }), ["ownerDocument", "baseURI", "isConnected"].forEach(function(e) {
	                    Object.defineProperty(t, e, {
	                        get: function() {
	                            return this.host[e]
	                        },
	                        configurable: !0
	                    });
	                });
	            }(), window.ShadowRoot = sn;
	    }
	    var An = new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));

	    function Ln(t) {
	        var e = An.has(t);
	        return t = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(t), !e && t
	    }

	    function kn(t) {
	        var e = t.isConnected;
	        if (void 0 !== e) return e;
	        for (; t && !(t.__CE_isImportDocument || t instanceof Document);) t = t.parentNode || (window.ShadowRoot && t instanceof ShadowRoot ? t.host : void 0);
	        return !(!t || !(t.__CE_isImportDocument || t instanceof Document))
	    }

	    function jn(t, e) {
	        for (; e && e !== t && !e.nextSibling;) e = e.parentNode;
	        return e && e !== t ? e.nextSibling : null
	    }

	    function Rn(t, e, n) {
	        n = void 0 === n ? new Set : n;
	        for (var o = t; o;) {
	            if (o.nodeType === Node.ELEMENT_NODE) {
	                var r = o;
	                e(r);
	                var i = r.localName;
	                if ("link" === i && "import" === r.getAttribute("rel")) {
	                    if ((o = r.import) instanceof Node && !n.has(o))
	                        for (n.add(o), o = o.firstChild; o; o = o.nextSibling) Rn(o, e, n);
	                    o = jn(t, r);
	                    continue
	                }
	                if ("template" === i) {
	                    o = jn(t, r);
	                    continue
	                }
	                if (r = r.__CE_shadowRoot)
	                    for (r = r.firstChild; r; r = r.nextSibling) Rn(r, e, n);
	            }
	            o = o.firstChild ? o.firstChild : jn(t, o);
	        }
	    }

	    function Pn(t, e, n) {
	        t[e] = n;
	    }

	    function Fn() {
	        this.a = new Map, this.M = new Map, this.F = [], this.c = !1;
	    }

	    function Hn(t, e) {
	        t.c = !0, t.F.push(e);
	    }

	    function In(t, e) {
	        t.c && Rn(e, function(e) {
	            return t.b(e)
	        });
	    }

	    function Un(t, e) {
	        var n = [];
	        for (Rn(e, function(t) {
	                return n.push(t)
	            }), e = 0; e < n.length; e++) {
	            var o = n[e];
	            1 === o.__CE_state ? t.connectedCallback(o) : Vn(t, o);
	        }
	    }

	    function qn(t, e) {
	        var n = [];
	        for (Rn(e, function(t) {
	                return n.push(t)
	            }), e = 0; e < n.length; e++) {
	            var o = n[e];
	            1 === o.__CE_state && t.disconnectedCallback(o);
	        }
	    }

	    function Bn(t, e, n) {
	        var o = (n = void 0 === n ? {} : n).bb || new Set,
	            r = n.ga || function(e) {
	                return Vn(t, e)
	            },
	            i = [];
	        if (Rn(e, function(e) {
	                if ("link" === e.localName && "import" === e.getAttribute("rel")) {
	                    var n = e.import;
	                    n instanceof Node && (n.__CE_isImportDocument = !0, n.__CE_hasRegistry = !0), n && "complete" === n.readyState ? n.__CE_documentLoadHandled = !0 : e.addEventListener("load", function() {
	                        var n = e.import;
	                        if (!n.__CE_documentLoadHandled) {
	                            n.__CE_documentLoadHandled = !0;
	                            var i = new Set(o);
	                            i.delete(n), Bn(t, n, {
	                                bb: i,
	                                ga: r
	                            });
	                        }
	                    });
	                } else i.push(e);
	            }, o), t.c)
	            for (e = 0; e < i.length; e++) t.b(i[e]);
	        for (e = 0; e < i.length; e++) r(i[e]);
	    }

	    function Vn(t, e) {
	        if (void 0 === e.__CE_state) {
	            var n = e.ownerDocument;
	            if ((n.defaultView || n.__CE_isImportDocument && n.__CE_hasRegistry) && (n = t.a.get(e.localName))) {
	                n.constructionStack.push(e);
	                var o = n.constructor;
	                try {
	                    try {
	                        if (new o !== e) throw Error("The custom element constructor did not produce the element being upgraded.")
	                    } finally {
	                        n.constructionStack.pop();
	                    }
	                } catch (t) {
	                    throw e.__CE_state = 2, t
	                }
	                if (e.__CE_state = 1, e.__CE_definition = n, n.attributeChangedCallback)
	                    for (n = n.observedAttributes, o = 0; o < n.length; o++) {
	                        var r = n[o],
	                            i = e.getAttribute(r);
	                        null !== i && t.attributeChangedCallback(e, r, null, i, null);
	                    }
	                kn(e) && t.connectedCallback(e);
	            }
	        }
	    }

	    function Wn(t) {
	        var e = document;
	        this.A = t, this.a = e, this.P = void 0, Bn(this.A, this.a), "loading" === this.a.readyState && (this.P = new MutationObserver(this.b.bind(this)), this.P.observe(this.a, {
	            childList: !0,
	            subtree: !0
	        }));
	    }

	    function Gn(t) {
	        t.P && t.P.disconnect();
	    }

	    function Kn() {
	        var t = this;
	        this.b = this.a = void 0, this.c = new Promise(function(e) {
	            t.b = e, t.a && e(t.a);
	        });
	    }

	    function $n(t) {
	        this.ma = !1, this.A = t, this.ra = new Map, this.na = function(t) {
	            return t()
	        }, this.Y = !1, this.oa = [], this.Ma = new Wn(t);
	    }
	    Fn.prototype.b = function(t) {
	        if (this.c && !t.__CE_patched) {
	            t.__CE_patched = !0;
	            for (var e = 0; e < this.F.length; e++) this.F[e](t);
	        }
	    }, Fn.prototype.connectedCallback = function(t) {
	        var e = t.__CE_definition;
	        e.connectedCallback && e.connectedCallback.call(t);
	    }, Fn.prototype.disconnectedCallback = function(t) {
	        var e = t.__CE_definition;
	        e.disconnectedCallback && e.disconnectedCallback.call(t);
	    }, Fn.prototype.attributeChangedCallback = function(t, e, n, o, r) {
	        var i = t.__CE_definition;
	        i.attributeChangedCallback && -1 < i.observedAttributes.indexOf(e) && i.attributeChangedCallback.call(t, e, n, o, r);
	    }, Wn.prototype.b = function(t) {
	        var e = this.a.readyState;
	        for ("interactive" !== e && "complete" !== e || Gn(this), e = 0; e < t.length; e++)
	            for (var n = t[e].addedNodes, o = 0; o < n.length; o++) Bn(this.A, n[o]);
	    }, Kn.prototype.resolve = function(t) {
	        if (this.a) throw Error("Already resolved.");
	        this.a = t, this.b && this.b(t);
	    }, (t = $n.prototype).define = function(t, e) {
	        var n = this;
	        if (!(e instanceof Function)) throw new TypeError("Custom element constructors must be functions.");
	        if (!Ln(t)) throw new SyntaxError("The element name '" + t + "' is not valid.");
	        if (this.A.a.get(t)) throw Error("A custom element with name '" + t + "' has already been defined.");
	        if (this.ma) throw Error("A custom element is already being defined.");
	        this.ma = !0;
	        try {
	            var o = function(t) {
	                    var e = r[t];
	                    if (void 0 !== e && !(e instanceof Function)) throw Error("The '" + t + "' callback must be a function.");
	                    return e
	                },
	                r = e.prototype;
	            if (!(r instanceof Object)) throw new TypeError("The custom element constructor's prototype is not an object.");
	            var i = o("connectedCallback"),
	                a = o("disconnectedCallback"),
	                s = o("adoptedCallback"),
	                l = o("attributeChangedCallback"),
	                c = e.observedAttributes || [];
	        } catch (t) {
	            return
	        } finally {
	            this.ma = !1;
	        }
	        e = {
	                localName: t,
	                constructor: e,
	                connectedCallback: i,
	                disconnectedCallback: a,
	                adoptedCallback: s,
	                attributeChangedCallback: l,
	                observedAttributes: c,
	                constructionStack: []
	            },
	            function(t, e, n) {
	                t.a.set(e, n), t.M.set(n.constructor, n);
	            }(this.A, t, e), this.oa.push(e), this.Y || (this.Y = !0, this.na(function() {
	                return function(t) {
	                    if (!1 !== t.Y) {
	                        t.Y = !1;
	                        for (var e = t.oa, n = [], o = new Map, r = 0; r < e.length; r++) o.set(e[r].localName, []);
	                        for (Bn(t.A, document, {
	                                ga: function(e) {
	                                    if (void 0 === e.__CE_state) {
	                                        var r = e.localName,
	                                            i = o.get(r);
	                                        i ? i.push(e) : t.A.a.get(r) && n.push(e);
	                                    }
	                                }
	                            }), r = 0; r < n.length; r++) Vn(t.A, n[r]);
	                        for (; 0 < e.length;) {
	                            var i = e.shift();
	                            r = i.localName, i = o.get(i.localName);
	                            for (var a = 0; a < i.length; a++) Vn(t.A, i[a]);
	                            (r = t.ra.get(r)) && r.resolve(void 0);
	                        }
	                    }
	                }(n)
	            }));
	    }, t.ga = function(t) {
	        Bn(this.A, t);
	    }, t.get = function(t) {
	        if (t = this.A.a.get(t)) return t.constructor
	    }, t.whenDefined = function(t) {
	        if (!Ln(t)) return Promise.reject(new SyntaxError("'" + t + "' is not a valid custom element name."));
	        var e = this.ra.get(t);
	        return e ? e.c : (e = new Kn, this.ra.set(t, e), this.A.a.get(t) && !this.oa.some(function(e) {
	            return e.localName === t
	        }) && e.resolve(void 0), e.c)
	    }, t.Xa = function(t) {
	        Gn(this.Ma);
	        var e = this.na;
	        this.na = function(n) {
	            return t(function() {
	                return e(n)
	            })
	        };
	    }, window.CustomElementRegistry = $n, $n.prototype.define = $n.prototype.define, $n.prototype.upgrade = $n.prototype.ga, $n.prototype.get = $n.prototype.get, $n.prototype.whenDefined = $n.prototype.whenDefined, $n.prototype.polyfillWrapFlushCallback = $n.prototype.Xa;
	    var Xn = window.Document.prototype.createElement,
	        Jn = window.Document.prototype.createElementNS,
	        Yn = window.Document.prototype.importNode,
	        zn = window.Document.prototype.prepend,
	        Zn = window.Document.prototype.append,
	        Qn = window.DocumentFragment.prototype.prepend,
	        to = window.DocumentFragment.prototype.append,
	        eo = window.Node.prototype.cloneNode,
	        no = window.Node.prototype.appendChild,
	        oo = window.Node.prototype.insertBefore,
	        ro = window.Node.prototype.removeChild,
	        io = window.Node.prototype.replaceChild,
	        ao = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
	        so = window.Element.prototype.attachShadow,
	        lo = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
	        co = window.Element.prototype.getAttribute,
	        uo = window.Element.prototype.setAttribute,
	        ho = window.Element.prototype.removeAttribute,
	        fo = window.Element.prototype.getAttributeNS,
	        po = window.Element.prototype.setAttributeNS,
	        mo = window.Element.prototype.removeAttributeNS,
	        vo = window.Element.prototype.insertAdjacentElement,
	        go = window.Element.prototype.insertAdjacentHTML,
	        yo = window.Element.prototype.prepend,
	        bo = window.Element.prototype.append,
	        wo = window.Element.prototype.before,
	        Eo = window.Element.prototype.after,
	        No = window.Element.prototype.replaceWith,
	        Co = window.Element.prototype.remove,
	        So = window.HTMLElement,
	        _o = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, "innerHTML"),
	        To = window.HTMLElement.prototype.insertAdjacentElement,
	        Oo = window.HTMLElement.prototype.insertAdjacentHTML,
	        Do = new function() {};

	    function xo(t, e, n) {
	        function o(e) {
	            return function(n) {
	                for (var o = [], r = 0; r < arguments.length; ++r) o[r - 0] = arguments[r];
	                r = [];
	                for (var i = [], a = 0; a < o.length; a++) {
	                    var s = o[a];
	                    if (s instanceof Element && kn(s) && i.push(s), s instanceof DocumentFragment)
	                        for (s = s.firstChild; s; s = s.nextSibling) r.push(s);
	                    else r.push(s);
	                }
	                for (e.apply(this, o), o = 0; o < i.length; o++) qn(t, i[o]);
	                if (kn(this))
	                    for (o = 0; o < r.length; o++)(i = r[o]) instanceof Element && Un(t, i);
	            }
	        }
	        void 0 !== n.fa && (e.prepend = o(n.fa)), void 0 !== n.append && (e.append = o(n.append));
	    }
	    var Mo = window.customElements;
	    if (!Mo || Mo.forcePolyfill || "function" != typeof Mo.define || "function" != typeof Mo.get) {
	        var Ao = new Fn;
	        ! function() {
	            var t = Ao;
	            window.HTMLElement = function() {
	                function e() {
	                    var e = this.constructor,
	                        n = t.M.get(e);
	                    if (!n) throw Error("The custom element being constructed was not registered with `customElements`.");
	                    var o = n.constructionStack;
	                    if (0 === o.length) return o = Xn.call(document, n.localName), Object.setPrototypeOf(o, e.prototype), o.__CE_state = 1, o.__CE_definition = n, t.b(o), o;
	                    var r = o[n = o.length - 1];
	                    if (r === Do) throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
	                    return o[n] = Do, Object.setPrototypeOf(r, e.prototype), t.b(r), r
	                }
	                return e.prototype = So.prototype, e
	            }();
	        }(),
	        function() {
	            var t = Ao;
	            Pn(Document.prototype, "createElement", function(e) {
	                if (this.__CE_hasRegistry) {
	                    var n = t.a.get(e);
	                    if (n) return new n.constructor
	                }
	                return e = Xn.call(this, e), t.b(e), e
	            }), Pn(Document.prototype, "importNode", function(e, n) {
	                return e = Yn.call(this, e, n), this.__CE_hasRegistry ? Bn(t, e) : In(t, e), e
	            }), Pn(Document.prototype, "createElementNS", function(e, n) {
	                if (this.__CE_hasRegistry && (null === e || "http://www.w3.org/1999/xhtml" === e)) {
	                    var o = t.a.get(n);
	                    if (o) return new o.constructor
	                }
	                return e = Jn.call(this, e, n), t.b(e), e
	            }), xo(t, Document.prototype, {
	                fa: zn,
	                append: Zn
	            });
	        }(), xo(Ao, DocumentFragment.prototype, {
	                fa: Qn,
	                append: to
	            }),
	            function() {
	                var t = Ao;

	                function e(e, n) {
	                    Object.defineProperty(e, "textContent", {
	                        enumerable: n.enumerable,
	                        configurable: !0,
	                        get: n.get,
	                        set: function(e) {
	                            if (this.nodeType === Node.TEXT_NODE) n.set.call(this, e);
	                            else {
	                                var o = void 0;
	                                if (this.firstChild) {
	                                    var r = this.childNodes,
	                                        i = r.length;
	                                    if (0 < i && kn(this)) {
	                                        o = Array(i);
	                                        for (var a = 0; a < i; a++) o[a] = r[a];
	                                    }
	                                }
	                                if (n.set.call(this, e), o)
	                                    for (e = 0; e < o.length; e++) qn(t, o[e]);
	                            }
	                        }
	                    });
	                }
	                Pn(Node.prototype, "insertBefore", function(e, n) {
	                    if (e instanceof DocumentFragment) {
	                        var o = Array.prototype.slice.apply(e.childNodes);
	                        if (e = oo.call(this, e, n), kn(this))
	                            for (n = 0; n < o.length; n++) Un(t, o[n]);
	                        return e
	                    }
	                    return o = kn(e), n = oo.call(this, e, n), o && qn(t, e), kn(this) && Un(t, e), n
	                }), Pn(Node.prototype, "appendChild", function(e) {
	                    if (e instanceof DocumentFragment) {
	                        var n = Array.prototype.slice.apply(e.childNodes);
	                        if (e = no.call(this, e), kn(this))
	                            for (var o = 0; o < n.length; o++) Un(t, n[o]);
	                        return e
	                    }
	                    return n = kn(e), o = no.call(this, e), n && qn(t, e), kn(this) && Un(t, e), o
	                }), Pn(Node.prototype, "cloneNode", function(e) {
	                    return e = eo.call(this, e), this.ownerDocument.__CE_hasRegistry ? Bn(t, e) : In(t, e), e
	                }), Pn(Node.prototype, "removeChild", function(e) {
	                    var n = kn(e),
	                        o = ro.call(this, e);
	                    return n && qn(t, e), o
	                }), Pn(Node.prototype, "replaceChild", function(e, n) {
	                    if (e instanceof DocumentFragment) {
	                        var o = Array.prototype.slice.apply(e.childNodes);
	                        if (e = io.call(this, e, n), kn(this))
	                            for (qn(t, n), n = 0; n < o.length; n++) Un(t, o[n]);
	                        return e
	                    }
	                    o = kn(e);
	                    var r = io.call(this, e, n),
	                        i = kn(this);
	                    return i && qn(t, n), o && qn(t, e), i && Un(t, e), r
	                }), ao && ao.get ? e(Node.prototype, ao) : Hn(t, function(t) {
	                    e(t, {
	                        enumerable: !0,
	                        configurable: !0,
	                        get: function() {
	                            for (var t = [], e = 0; e < this.childNodes.length; e++) t.push(this.childNodes[e].textContent);
	                            return t.join("")
	                        },
	                        set: function(t) {
	                            for (; this.firstChild;) ro.call(this, this.firstChild);
	                            no.call(this, document.createTextNode(t));
	                        }
	                    });
	                });
	            }(),
	            function() {
	                var t = Ao;

	                function e(e, n) {
	                    Object.defineProperty(e, "innerHTML", {
	                        enumerable: n.enumerable,
	                        configurable: !0,
	                        get: n.get,
	                        set: function(e) {
	                            var o = this,
	                                r = void 0;
	                            if (kn(this) && (r = [], Rn(this, function(t) {
	                                    t !== o && r.push(t);
	                                })), n.set.call(this, e), r)
	                                for (var i = 0; i < r.length; i++) {
	                                    var a = r[i];
	                                    1 === a.__CE_state && t.disconnectedCallback(a);
	                                }
	                            return this.ownerDocument.__CE_hasRegistry ? Bn(t, this) : In(t, this), e
	                        }
	                    });
	                }

	                function n(e, n) {
	                    Pn(e, "insertAdjacentElement", function(e, o) {
	                        var r = kn(o);
	                        return e = n.call(this, e, o), r && qn(t, o), kn(e) && Un(t, o), e
	                    });
	                }

	                function o(e, n) {
	                    function o(e, n) {
	                        for (var o = []; e !== n; e = e.nextSibling) o.push(e);
	                        for (n = 0; n < o.length; n++) Bn(t, o[n]);
	                    }
	                    Pn(e, "insertAdjacentHTML", function(t, e) {
	                        if ("beforebegin" === (t = t.toLowerCase())) {
	                            var r = this.previousSibling;
	                            n.call(this, t, e), o(r || this.parentNode.firstChild, this);
	                        } else if ("afterbegin" === t) r = this.firstChild, n.call(this, t, e), o(this.firstChild, r);
	                        else if ("beforeend" === t) r = this.lastChild, n.call(this, t, e), o(r || this.firstChild, null);
	                        else {
	                            if ("afterend" !== t) throw new SyntaxError("The value provided (" + String(t) + ") is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'.");
	                            r = this.nextSibling, n.call(this, t, e), o(this.nextSibling, r);
	                        }
	                    });
	                }
	                so && Pn(Element.prototype, "attachShadow", function(t) {
	                        return this.__CE_shadowRoot = so.call(this, t)
	                    }), lo && lo.get ? e(Element.prototype, lo) : _o && _o.get ? e(HTMLElement.prototype, _o) : Hn(t, function(t) {
	                        e(t, {
	                            enumerable: !0,
	                            configurable: !0,
	                            get: function() {
	                                return eo.call(this, !0).innerHTML
	                            },
	                            set: function(t) {
	                                var e = "template" === this.localName,
	                                    n = e ? this.content : this,
	                                    o = Xn.call(document, this.localName);
	                                for (o.innerHTML = t; 0 < n.childNodes.length;) ro.call(n, n.childNodes[0]);
	                                for (t = e ? o.content : o; 0 < t.childNodes.length;) no.call(n, t.childNodes[0]);
	                            }
	                        });
	                    }), Pn(Element.prototype, "setAttribute", function(e, n) {
	                        if (1 !== this.__CE_state) return uo.call(this, e, n);
	                        var o = co.call(this, e);
	                        uo.call(this, e, n), n = co.call(this, e), t.attributeChangedCallback(this, e, o, n, null);
	                    }), Pn(Element.prototype, "setAttributeNS", function(e, n, o) {
	                        if (1 !== this.__CE_state) return po.call(this, e, n, o);
	                        var r = fo.call(this, e, n);
	                        po.call(this, e, n, o), o = fo.call(this, e, n), t.attributeChangedCallback(this, n, r, o, e);
	                    }), Pn(Element.prototype, "removeAttribute", function(e) {
	                        if (1 !== this.__CE_state) return ho.call(this, e);
	                        var n = co.call(this, e);
	                        ho.call(this, e), null !== n && t.attributeChangedCallback(this, e, n, null, null);
	                    }), Pn(Element.prototype, "removeAttributeNS", function(e, n) {
	                        if (1 !== this.__CE_state) return mo.call(this, e, n);
	                        var o = fo.call(this, e, n);
	                        mo.call(this, e, n);
	                        var r = fo.call(this, e, n);
	                        o !== r && t.attributeChangedCallback(this, n, o, r, e);
	                    }), To ? n(HTMLElement.prototype, To) : vo ? n(Element.prototype, vo) : console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched."), Oo ? o(HTMLElement.prototype, Oo) : go ? o(Element.prototype, go) : console.warn("Custom Elements: `Element#insertAdjacentHTML` was not patched."), xo(t, Element.prototype, {
	                        fa: yo,
	                        append: bo
	                    }),
	                    function(t) {
	                        var e = Element.prototype;

	                        function n(e) {
	                            return function(n) {
	                                for (var o = [], r = 0; r < arguments.length; ++r) o[r - 0] = arguments[r];
	                                r = [];
	                                for (var i = [], a = 0; a < o.length; a++) {
	                                    var s = o[a];
	                                    if (s instanceof Element && kn(s) && i.push(s), s instanceof DocumentFragment)
	                                        for (s = s.firstChild; s; s = s.nextSibling) r.push(s);
	                                    else r.push(s);
	                                }
	                                for (e.apply(this, o), o = 0; o < i.length; o++) qn(t, i[o]);
	                                if (kn(this))
	                                    for (o = 0; o < r.length; o++)(i = r[o]) instanceof Element && Un(t, i);
	                            }
	                        }
	                        void 0 !== wo && (e.before = n(wo)), void 0 !== wo && (e.after = n(Eo)), void 0 !== No && Pn(e, "replaceWith", function(e) {
	                            for (var n = [], o = 0; o < arguments.length; ++o) n[o - 0] = arguments[o];
	                            o = [];
	                            for (var r = [], i = 0; i < n.length; i++) {
	                                var a = n[i];
	                                if (a instanceof Element && kn(a) && r.push(a), a instanceof DocumentFragment)
	                                    for (a = a.firstChild; a; a = a.nextSibling) o.push(a);
	                                else o.push(a);
	                            }
	                            for (i = kn(this), No.apply(this, n), n = 0; n < r.length; n++) qn(t, r[n]);
	                            if (i)
	                                for (qn(t, this), n = 0; n < o.length; n++)(r = o[n]) instanceof Element && Un(t, r);
	                        }), void 0 !== Co && Pn(e, "remove", function() {
	                            var e = kn(this);
	                            Co.call(this), e && qn(t, this);
	                        });
	                    }(t);
	            }(), document.__CE_hasRegistry = !0;
	        var Lo = new $n(Ao);
	        Object.defineProperty(window, "customElements", {
	            configurable: !0,
	            enumerable: !0,
	            value: Lo
	        });
	    }

	    function ko() {
	        this.end = this.start = 0, this.rules = this.parent = this.previous = null, this.cssText = this.parsedCssText = "", this.atRule = !1, this.type = 0, this.parsedSelector = this.selector = this.keyframesName = "";
	    }

	    function jo(t) {
	        var e = Ro,
	            n = t = t.replace(qo, "").replace(Bo, ""),
	            o = new ko;
	        o.start = 0, o.end = n.length;
	        for (var r = o, i = 0, a = n.length; i < a; i++)
	            if ("{" === n[i]) {
	                r.rules || (r.rules = []);
	                var s = r,
	                    l = s.rules[s.rules.length - 1] || null;
	                (r = new ko).start = i + 1, r.parent = s, r.previous = l, s.rules.push(r);
	            } else "}" === n[i] && (r.end = i + 1, r = r.parent || o);
	        return e(o, t)
	    }

	    function Ro(t, e) {
	        var n = e.substring(t.start, t.end - 1);
	        if (t.parsedCssText = t.cssText = n.trim(), t.parent && (n = (n = (n = function(t) {
	                return t.replace(/\\([0-9a-f]{1,6})\s/gi, function(t, e) {
	                    for (e = 6 - (t = e).length; e--;) t = "0" + t;
	                    return "\\" + t
	                })
	            }(n = e.substring(t.previous ? t.previous.end : t.parent.start, t.start - 1))).replace(Xo, " ")).substring(n.lastIndexOf(";") + 1), n = t.parsedSelector = t.selector = n.trim(), t.atRule = 0 === n.indexOf("@"), t.atRule ? 0 === n.indexOf("@media") ? t.type = Io : n.match($o) && (t.type = Ho, t.keyframesName = t.selector.split(Xo).pop()) : t.type = 0 === n.indexOf("--") ? Uo : Fo), n = t.rules)
	            for (var o, r = 0, i = n.length; r < i && (o = n[r]); r++) Ro(o, e);
	        return t
	    }
	    var Po, Fo = 1,
	        Ho = 7,
	        Io = 4,
	        Uo = 1e3,
	        qo = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
	        Bo = /@import[^;]*;/gim,
	        Vo = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
	        Wo = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
	        Go = /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
	        Ko = /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
	        $o = /^@[^\s]*keyframes/,
	        Xo = /\s+/g,
	        Jo = !(window.ShadyDOM && window.ShadyDOM.inUse);

	    function Yo(t) {
	        Po = (!t || !t.shimcssproperties) && (Jo || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)")));
	    }
	    window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? Po = window.ShadyCSS.nativeCss : window.ShadyCSS ? (Yo(window.ShadyCSS), window.ShadyCSS = void 0) : Yo(window.WebComponents && window.WebComponents.flags);
	    var zo = Po,
	        Zo = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,
	        Qo = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
	        tr = /(--[\w-]+)\s*([:,;)]|$)/gi,
	        er = /(animation\s*:)|(animation-name\s*:)/,
	        nr = /@media\s(.*)/,
	        or = /\{[^}]*\}/g,
	        rr = new Set;

	    function ir(t, e) {
	        return t ? ("string" == typeof t && (t = jo(t)), e && lr(t, e), function t(e, n, o) {
	            o = void 0 === o ? "" : o;
	            var r = "";
	            if (e.cssText || e.rules) {
	                var i, a = e.rules;
	                if ((i = a) && (i = !((i = a[0]) && i.selector && 0 === i.selector.indexOf("--"))), i) {
	                    i = 0;
	                    for (var s, l = a.length; i < l && (s = a[i]); i++) r = t(s, n, r);
	                } else n = n ? e.cssText : (n = (n = e.cssText).replace(Vo, "").replace(Wo, "")).replace(Go, "").replace(Ko, ""), (r = n.trim()) && (r = "  " + r + "\n");
	            }
	            return r && (e.selector && (o += e.selector + " {\n"), o += r, e.selector && (o += "}\n\n")), o
	        }(t, zo)) : ""
	    }

	    function ar(t) {
	        return !t.__cssRules && t.textContent && (t.__cssRules = jo(t.textContent)), t.__cssRules || null
	    }

	    function sr(t) {
	        return !!t.parent && t.parent.type === Ho
	    }

	    function lr(t, e, n, o) {
	        if (t) {
	            var r = !1,
	                i = t.type;
	            if (o && i === Io) {
	                var a = t.selector.match(nr);
	                a && (window.matchMedia(a[1]).matches || (r = !0));
	            }
	            if (i === Fo ? e(t) : n && i === Ho ? n(t) : i === Uo && (r = !0), (t = t.rules) && !r) {
	                r = 0, i = t.length;
	                for (var s; r < i && (s = t[r]); r++) lr(s, e, n, o);
	            }
	        }
	    }

	    function cr(t, e, n, o) {
	        var r = document.createElement("style");
	        return e && r.setAttribute("scope", e), r.textContent = t, hr(r, n, o), r
	    }
	    var ur = null;

	    function hr(t, e, n) {
	        (e = e || document.head).insertBefore(t, n && n.nextSibling || e.firstChild), ur ? t.compareDocumentPosition(ur) === Node.DOCUMENT_POSITION_PRECEDING && (ur = t) : ur = t;
	    }

	    function dr(t, e) {
	        Jo ? t.setAttribute("class", e) : window.ShadyDOM.nativeMethods.setAttribute.call(t, "class", e);
	    }

	    function fr(t) {
	        var e = t.localName,
	            n = "";
	        return e ? -1 < e.indexOf("-") || (n = e, e = t.getAttribute && t.getAttribute("is") || "") : (e = t.is, n = t.extends), {
	            is: e,
	            X: n
	        }
	    }

	    function pr() {}

	    function mr(t, e, n) {
	        var o = Ir;
	        t.__styleScoped ? t.__styleScoped = null : function t(e, n, o, r) {
	            n.nodeType === Node.ELEMENT_NODE && vr(n, o, r);
	            if (n = "template" === n.localName ? (n.content || n.jb).childNodes : n.children || n.childNodes)
	                for (var i = 0; i < n.length; i++) t(e, n[i], o, r);
	        }(o, t, e || "", n);
	    }

	    function vr(t, e, n) {
	        if (e)
	            if (t.classList) n ? (t.classList.remove("style-scope"), t.classList.remove(e)) : (t.classList.add("style-scope"), t.classList.add(e));
	            else if (t.getAttribute) {
	            var o = t.getAttribute(Fr);
	            n ? o && dr(t, e = o.replace("style-scope", "").replace(e, "")) : dr(t, (o ? o + " " : "") + "style-scope " + e);
	        }
	    }

	    function gr(t, e, n) {
	        var o = Ir,
	            r = t.__cssBuild;
	        return Jo || "shady" === r ? e = ir(e, n) : e = function(t, e, n, o, r) {
	            var i = yr(n, o);
	            return n = n ? Rr + n : "", ir(e, function(e) {
	                e.c || (e.selector = e.G = br(t, e, t.b, n, i), e.c = !0), r && r(e, n, i);
	            })
	        }(o, e, (t = fr(t)).is, t.X, n) + "\n\n", e.trim()
	    }

	    function yr(t, e) {
	        return e ? "[is=" + t + "]" : t
	    }

	    function br(t, e, n, o, r) {
	        var i = e.selector.split(_r);
	        if (!sr(e)) {
	            e = 0;
	            for (var a, s = i.length; e < s && (a = i[e]); e++) i[e] = n.call(t, a, o, r);
	        }
	        return i.join(_r)
	    }

	    function wr(t) {
	        return t.replace(Cr, function(t, e, n) {
	            return -1 < n.indexOf("+") ? n = n.replace(/\+/g, "___") : -1 < n.indexOf("___") && (n = n.replace(/___/g, "+")), ":" + e + "(" + n + ")"
	        })
	    }

	    function Er(t, e) {
	        return (t = t.split(Pr))[0] += e, t.join(Pr)
	    }

	    function Nr(t) {
	        t.selector === xr && (t.selector = "html");
	    }
	    pr.prototype.b = function(t, e, n) {
	        var o = !1;
	        t = t.trim();
	        var r = Cr.test(t);
	        return r && (t = wr(t = t.replace(Cr, function(t, e, n) {
	            return ":" + e + "(" + n.replace(/\s/g, "") + ")"
	        }))), t = (t = t.replace(Ar, Dr + " $1")).replace(Tr, function(t, r, i) {
	            return o || (t = function(t, e, n, o) {
	                var r = t.indexOf(Mr);
	                if (0 <= t.indexOf(Dr) ? t = function(t, e) {
	                        var n = t.match(Lr);
	                        return (n = n && n[2].trim() || "") ? n[0].match(Or) ? t.replace(Lr, function(t, n, o) {
	                            return e + o
	                        }) : n.split(Or)[0] === e ? n : Hr : t.replace(Dr, e)
	                    }(t, o) : 0 !== r && (t = n ? Er(t, n) : t), n = !1, 0 <= r && (e = "", n = !0), n) {
	                    var i = !0;
	                    n && (t = t.replace(kr, function(t, e) {
	                        return " > " + e
	                    }));
	                }
	                return {
	                    value: t = t.replace(jr, function(t, e, n) {
	                        return '[dir="' + n + '"] ' + e + ", " + e + '[dir="' + n + '"]'
	                    }),
	                    Sa: e,
	                    stop: i
	                }
	            }(i, r, e, n), o = o || t.stop, r = t.Sa, i = t.value), r + i
	        }), r && (t = wr(t)), t
	    }, pr.prototype.c = function(t) {
	        return t.match(Mr) ? this.b(t, Sr) : Er(t.trim(), Sr)
	    }, e.Object.defineProperties(pr.prototype, {
	        a: {
	            configurable: !0,
	            enumerable: !0,
	            get: function() {
	                return "style-scope"
	            }
	        }
	    });
	    var Cr = /:(nth[-\w]+)\(([^)]+)\)/,
	        Sr = ":not(.style-scope)",
	        _r = ",",
	        Tr = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=[])+)/g,
	        Or = /[[.:#*]/,
	        Dr = ":host",
	        xr = ":root",
	        Mr = "::slotted",
	        Ar = new RegExp("^(" + Mr + ")"),
	        Lr = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,
	        kr = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,
	        jr = /(.*):dir\((?:(ltr|rtl))\)/,
	        Rr = ".",
	        Pr = ":",
	        Fr = "class",
	        Hr = "should_not_match",
	        Ir = new pr;

	    function Ur(t, e, n, o) {
	        this.K = t || null, this.b = e || null, this.sa = n || [], this.T = null, this.X = o || "", this.a = this.H = this.O = null;
	    }

	    function qr(t) {
	        return t ? t.__styleInfo : null
	    }

	    function Br(t, e) {
	        return t.__styleInfo = e
	    }

	    function Vr(t) {
	        var e = this.matches || this.matchesSelector || this.mozMatchesSelector || this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector;
	        return e && e.call(this, t)
	    }
	    Ur.prototype.c = function() {
	        return this.K
	    }, Ur.prototype._getStyleRules = Ur.prototype.c;
	    var Wr = navigator.userAgent.match("Trident");

	    function Gr() {}

	    function Kr(t) {
	        if (!t.B) {
	            var e = {},
	                n = {};
	            $r(t, n) && (e.J = n, t.rules = null), e.cssText = t.parsedCssText.replace(or, "").replace(Zo, ""), t.B = e;
	        }
	    }

	    function $r(t, e) {
	        var n = t.B;
	        if (!n) {
	            n = t.parsedCssText;
	            for (var o; t = Zo.exec(n);) "inherit" === (o = (t[2] || t[3]).trim()) && "unset" === o || (e[t[1].trim()] = o), o = !0;
	            return o
	        }
	        if (n.J) return Object.assign(e, n.J), !0
	    }

	    function Xr(t, e, n) {
	        return e && (e = 0 <= e.indexOf(";") ? Jr(t, e, n) : function t(e, n) {
	            var o = e.indexOf("var(");
	            if (-1 === o) return n(e, "", "", "");
	            t: {
	                for (var r = 0, i = o + 3, a = e.length; i < a; i++)
	                    if ("(" === e[i]) r++;
	                    else if (")" === e[i] && 0 == --r) break t;i = -1;
	            }
	            return r = e.substring(o + 4, i), o = e.substring(0, o), e = t(e.substring(i + 1), n), -1 === (i = r.indexOf(",")) ? n(o, r.trim(), "", e) : n(o, r.substring(0, i).trim(), r.substring(i + 1).trim(), e)
	        }(e, function(e, o, r, i) {
	            return o ? ((o = Xr(t, n[o], n)) && "initial" !== o ? "apply-shim-inherit" === o && (o = "inherit") : o = Xr(t, n[r] || r, n) || r, e + (o || "") + i) : e + i
	        })), e && e.trim() || ""
	    }

	    function Jr(t, e, n) {
	        e = e.split(";");
	        for (var o, r, i = 0; i < e.length; i++)
	            if (o = e[i]) {
	                if (Qo.lastIndex = 0, r = Qo.exec(o)) o = Xr(t, n[r[1]], n);
	                else if (-1 !== (r = o.indexOf(":"))) {
	                    var a = o.substring(r);
	                    a = Xr(t, a = a.trim(), n) || a, o = o.substring(0, r) + a;
	                }
	                e[i] = o && o.lastIndexOf(";") === o.length - 1 ? o.slice(0, -1) : o || "";
	            } return e.join(";")
	    }

	    function Yr(t, e) {
	        var n = {},
	            o = {},
	            r = e && e.__cssBuild;
	        return lr(e, function(e) {
	            ! function(t, e, n, o) {
	                if (e.B || Kr(e), e.B.J) {
	                    var r = fr(t);
	                    t = r.is, r = r.X, r = t ? yr(t, r) : "html";
	                    var i = e.parsedSelector,
	                        a = ":host > *" === i || "html" === i,
	                        s = 0 === i.indexOf(":host") && !a;
	                    "shady" === n && (s = !(a = i === r + " > *." + r || -1 !== i.indexOf("html")) && 0 === i.indexOf(r)), "shadow" === n && (a = ":host > *" === i || "html" === i, s = s && !a), (a || s) && (n = r, s && (e.G || (e.G = br(Ir, e, Ir.b, t ? Rr + t : "", r)), n = e.G || r), o({
	                        Za: n,
	                        Wa: s,
	                        wb: a
	                    }));
	                }
	            }(t, e, r, function(r) {
	                Vr.call(t.kb || t, r.Za) && (r.Wa ? $r(e, n) : $r(e, o));
	            });
	        }, null, !0), {
	            Ya: o,
	            Va: n
	        }
	    }

	    function zr(t, e, n, o) {
	        var r = fr(e),
	            i = yr(r.is, r.X),
	            a = new RegExp("(?:^|[^.#[:])" + (e.extends ? "\\" + i.slice(0, -1) + "\\]" : i) + "($|[.:[\\s>+~])"),
	            s = function(t, e) {
	                t = t.b;
	                var n = {};
	                if (!Jo && t)
	                    for (var o = 0, r = t[o]; o < t.length; r = t[++o]) {
	                        var i = r,
	                            a = e;
	                        i.F = new RegExp("\\b" + i.keyframesName + "(?!\\B|-)", "g"), i.a = i.keyframesName + "-" + a, i.G = i.G || i.selector, i.selector = i.G.replace(i.keyframesName, i.a), n[r.keyframesName] = Zr(r);
	                    }
	                return n
	            }(r = qr(e).K, o);
	        return gr(e, r, function(e) {
	            var r = "";
	            if (e.B || Kr(e), e.B.cssText && (r = Jr(t, e.B.cssText, n)), e.cssText = r, !Jo && !sr(e) && e.cssText) {
	                var l = r = e.cssText;
	                if (null == e.za && (e.za = er.test(r)), e.za)
	                    if (null == e.ea)
	                        for (var c in e.ea = [], s) r !== (l = (l = s[c])(r)) && (r = l, e.ea.push(c));
	                    else {
	                        for (c = 0; c < e.ea.length; ++c) r = (l = s[e.ea[c]])(r);
	                        l = r;
	                    } e.cssText = l, e.G = e.G || e.selector, r = "." + o, l = 0;
	                for (var u, h = (c = e.G.split(",")).length; l < h && (u = c[l]); l++) c[l] = u.match(a) ? u.replace(i, r) : r + " " + u;
	                e.selector = c.join(",");
	            }
	        })
	    }

	    function Zr(t) {
	        return function(e) {
	            return e.replace(t.F, t.a)
	        }
	    }

	    function Qr(t, e) {
	        var n = ti,
	            o = ar(t);
	        t.textContent = ir(o, function(t) {
	            var o = t.cssText = t.parsedCssText;
	            t.B && t.B.cssText && (o = o.replace(Vo, "").replace(Wo, ""), t.cssText = Jr(n, o, e));
	        });
	    }
	    e.Object.defineProperties(Gr.prototype, {
	        a: {
	            configurable: !0,
	            enumerable: !0,
	            get: function() {
	                return "x-scope"
	            }
	        }
	    });
	    var ti = new Gr,
	        ei = {},
	        ni = window.customElements;
	    if (ni && !Jo) {
	        var oi = ni.define;
	        ni.define = function(t, e, n) {
	            var o = document.createComment(" Shady DOM styles for " + t + " "),
	                r = document.head;
	            r.insertBefore(o, (ur ? ur.nextSibling : null) || r.firstChild), ur = o, ei[t] = o, oi.call(ni, t, e, n);
	        };
	    }

	    function ri() {
	        this.cache = {};
	    }

	    function ii() {}

	    function ai(t) {
	        for (var e = 0; e < t.length; e++) {
	            var n = t[e];
	            if (n.target !== document.documentElement && n.target !== document.head)
	                for (var o = 0; o < n.addedNodes.length; o++) {
	                    var r = n.addedNodes[o];
	                    if (r.nodeType === Node.ELEMENT_NODE) {
	                        var i = r.getRootNode(),
	                            a = r,
	                            s = [];
	                        if (a.classList ? s = Array.from(a.classList) : a instanceof window.SVGElement && a.hasAttribute("class") && (s = a.getAttribute("class").split(/\s+/)), (a = -1 < (s = (a = s).indexOf(Ir.a)) ? a[s + 1] : "") && i === r.ownerDocument) mr(r, a, !0);
	                        else if (i.nodeType === Node.DOCUMENT_FRAGMENT_NODE && (i = i.host))
	                            if (a === (i = fr(i).is))
	                                for (r = window.ShadyDOM.nativeMethods.querySelectorAll.call(r, ":not(." + Ir.a + ")"), i = 0; i < r.length; i++) vr(r[i], a);
	                            else a && mr(r, a, !0), mr(r, i);
	                    }
	                }
	        }
	    }
	    if (ri.prototype.store = function(t, e, n, o) {
	            var r = this.cache[t] || [];
	            r.push({
	                J: e,
	                styleElement: n,
	                H: o
	            }), 100 < r.length && r.shift(), this.cache[t] = r;
	        }, ri.prototype.fetch = function(t, e, n) {
	            if (t = this.cache[t])
	                for (var o = t.length - 1; 0 <= o; o--) {
	                    var r, i = t[o];
	                    t: {
	                        for (r = 0; r < n.length; r++) {
	                            var a = n[r];
	                            if (i.J[a] !== e[a]) {
	                                r = !1;
	                                break t
	                            }
	                        }
	                        r = !0;
	                    }
	                    if (r) return i
	                }
	        }, !Jo) {
	        var si = new MutationObserver(ai),
	            li = function(t) {
	                si.observe(t, {
	                    childList: !0,
	                    subtree: !0
	                });
	            };
	        if (window.customElements && !window.customElements.polyfillWrapFlushCallback) li(document);
	        else {
	            var ci = function() {
	                li(document.body);
	            };
	            window.HTMLImports ? window.HTMLImports.whenReady(ci) : requestAnimationFrame(function() {
	                if ("loading" === document.readyState) {
	                    var t = function() {
	                        ci(), document.removeEventListener("readystatechange", t);
	                    };
	                    document.addEventListener("readystatechange", t);
	                } else ci();
	            });
	        }
	        ii = function() {
	            ai(si.takeRecords());
	        };
	    }
	    var ui = ii,
	        hi = {},
	        di = Promise.resolve();

	    function fi(t) {
	        (t = hi[t]) && (t._applyShimCurrentVersion = t._applyShimCurrentVersion || 0, t._applyShimValidatingVersion = t._applyShimValidatingVersion || 0, t._applyShimNextVersion = (t._applyShimNextVersion || 0) + 1);
	    }

	    function pi(t) {
	        return t._applyShimCurrentVersion === t._applyShimNextVersion
	    }
	    var mi = new ri;

	    function vi() {
	        this.Aa = {}, this.c = document.documentElement;
	        var t = new ko;
	        t.rules = [], this.F = Br(this.c, new Ur(t)), this.M = !1, this.b = this.a = null;
	    }

	    function gi(t) {
	        !t.a && window.ShadyCSS && window.ShadyCSS.ApplyShim && (t.a = window.ShadyCSS.ApplyShim, t.a.invalidCallback = fi),
	            function(t) {
	                !t.b && window.ShadyCSS && window.ShadyCSS.CustomStyleInterface && (t.b = window.ShadyCSS.CustomStyleInterface, t.b.transformCallback = function(e) {
	                    t.Ea(e);
	                }, t.b.validateCallback = function() {
	                    requestAnimationFrame(function() {
	                        (t.b.enqueued || t.M) && t.flushCustomStyles();
	                    });
	                });
	            }(t);
	    }

	    function yi(t, e) {
	        return (e = e.getRootNode().host) ? qr(e) ? e : yi(t, e) : t.c
	    }

	    function bi(t, e, n) {
	        var o = qr(t = yi(t, e));
	        t = Object.create(o.O || null);
	        var r = Yr(e, n.K);
	        for (var i in e = function(t, e) {
	                var n = {},
	                    o = [];
	                return lr(t, function(t) {
	                    t.B || Kr(t);
	                    var r = t.G || t.parsedSelector;
	                    e && t.B.J && r && Vr.call(e, r) && ($r(t, n), t = t.index, r = parseInt(t / 32, 10), o[r] = (o[r] || 0) | 1 << t % 32);
	                }, null, !0), {
	                    J: n,
	                    key: o
	                }
	            }(o.K, e).J, Object.assign(t, r.Va, e, r.Ya), e = n.T)((r = e[i]) || 0 === r) && (t[i] = r);
	        for (i = ti, e = Object.getOwnPropertyNames(t), r = 0; r < e.length; r++) t[o = e[r]] = Xr(i, t[o], t);
	        n.O = t;
	    }(t = vi.prototype).Ga = function() {
	        ui();
	    }, t.Ta = function(t) {
	        return ar(t)
	    }, t.ab = function(t) {
	        return ir(t)
	    }, t.prepareTemplate = function(t, e, n) {
	        if (!t.F) {
	            t.F = !0, t.name = e, t.extends = n, hi[e] = t;
	            for (var o = (o = t.content.querySelector("style")) && o.getAttribute("css-build") || "", r = [], i = t.content.querySelectorAll("style"), a = 0; a < i.length; a++) {
	                var s = i[a];
	                if (s.hasAttribute("shady-unscoped")) {
	                    if (!Jo) {
	                        var l = s.textContent;
	                        rr.has(l) || (rr.add(l), l = s.cloneNode(!0), document.head.appendChild(l)), s.parentNode.removeChild(s);
	                    }
	                } else r.push(s.textContent), s.parentNode.removeChild(s);
	            }
	            r = r.join("").trim(), n = {
	                is: e,
	                extends: n,
	                hb: o
	            }, Jo || mr(t.content, e), gi(this), i = Qo.test(r) || Zo.test(r), Qo.lastIndex = 0, Zo.lastIndex = 0, r = jo(r), i && zo && this.a && this.a.transformRules(r, e), t._styleAst = r, t.M = o, o = [], zo || (o = function(t) {
	                var e = {},
	                    n = [],
	                    o = 0;
	                for (var r in lr(t, function(t) {
	                        Kr(t), t.index = o++, t = t.B.cssText;
	                        for (var n; n = tr.exec(t);) {
	                            var r = n[1];
	                            ":" !== n[2] && (e[r] = !0);
	                        }
	                    }, function(t) {
	                        n.push(t);
	                    }), t.b = n, t = [], e) t.push(r);
	                return t
	            }(t._styleAst)), o.length && !zo || (r = Jo ? t.content : null, e = ei[e], e = (i = gr(n, t._styleAst)).length ? cr(i, n.is, r, e) : void 0, t.a = e), t.c = o;
	        }
	    }, t.flushCustomStyles = function() {
	        if (gi(this), this.b) {
	            var t = this.b.processStyles();
	            if (this.b.enqueued) {
	                if (zo)
	                    for (var e = 0; e < t.length; e++) {
	                        var n = this.b.getStyleForCustomStyle(t[e]);
	                        if (n && zo && this.a) {
	                            var o = ar(n);
	                            gi(this), this.a.transformRules(o), n.textContent = ir(o);
	                        }
	                    } else
	                        for (bi(this, this.c, this.F), e = 0; e < t.length; e++)(n = this.b.getStyleForCustomStyle(t[e])) && Qr(n, this.F.O);
	                this.b.enqueued = !1, this.M && !zo && this.styleDocument();
	            }
	        }
	    }, t.styleElement = function(t, e) {
	        var n = fr(t).is,
	            o = qr(t);
	        if (!o) {
	            var r = fr(t);
	            o = r.is, r = r.X;
	            var i = ei[o];
	            if (o = hi[o]) var a = o._styleAst,
	                s = o.c;
	            o = Br(t, new Ur(a, i, s, r));
	        }
	        if (t !== this.c && (this.M = !0), e && (o.T = o.T || {}, Object.assign(o.T, e)), zo) {
	            if (o.T)
	                for (var l in e = o.T) null === l ? t.style.removeProperty(l) : t.style.setProperty(l, e[l]);
	            ((l = hi[n]) || t === this.c) && l && l.a && !pi(l) && ((pi(l) || l._applyShimValidatingVersion !== l._applyShimNextVersion) && (gi(this), this.a && this.a.transformRules(l._styleAst, n), l.a.textContent = gr(t, o.K), function(t) {
	                t._applyShimValidatingVersion = t._applyShimNextVersion, t.b || (t.b = !0, di.then(function() {
	                    t._applyShimCurrentVersion = t._applyShimNextVersion, t.b = !1;
	                }));
	            }(l)), Jo && (n = t.shadowRoot) && (n.querySelector("style").textContent = gr(t, o.K)), o.K = l._styleAst);
	        } else if (bi(this, t, o), o.sa && o.sa.length) {
	            n = o, l = fr(t).is, o = (e = mi.fetch(l, n.O, n.sa)) ? e.styleElement : null, a = n.H, (s = e && e.H) || (s = l + "-" + (s = this.Aa[l] = (this.Aa[l] || 0) + 1)), n.H = s, s = n.H, r = ti, r = o ? o.textContent || "" : zr(r, t, n.O, s);
	            var c = (i = qr(t)).a;
	            c && !Jo && c !== o && (c._useCount--, 0 >= c._useCount && c.parentNode && c.parentNode.removeChild(c)), Jo ? i.a ? (i.a.textContent = r, o = i.a) : r && (o = cr(r, s, t.shadowRoot, i.b)) : o ? o.parentNode || (Wr && -1 < r.indexOf("@media") && (o.textContent = r), hr(o, null, i.b)) : r && (o = cr(r, s, null, i.b)), o && (o._useCount = o._useCount || 0, i.a != o && o._useCount++, i.a = o), s = o, Jo || (o = n.H, i = r = t.getAttribute("class") || "", a && (i = r.replace(new RegExp("\\s*x-scope\\s*" + a + "\\s*", "g"), " ")), r !== (i += (i ? " " : "") + "x-scope " + o) && dr(t, i)), e || mi.store(l, n.O, s, n.H);
	        }
	    }, t.styleDocument = function(t) {
	        this.styleSubtree(this.c, t);
	    }, t.styleSubtree = function(t, e) {
	        var n = t.shadowRoot;
	        if ((n || t === this.c) && this.styleElement(t, e), e = n && (n.children || n.childNodes))
	            for (t = 0; t < e.length; t++) this.styleSubtree(e[t]);
	        else if (t = t.children || t.childNodes)
	            for (e = 0; e < t.length; e++) this.styleSubtree(t[e]);
	    }, t.Ea = function(t) {
	        var e = this,
	            n = ar(t);
	        lr(n, function(t) {
	            if (Jo) Nr(t);
	            else {
	                var n = Ir;
	                t.selector = t.parsedSelector, Nr(t), t.selector = t.G = br(n, t, n.c, void 0, void 0);
	            }
	            zo && (gi(e), e.a && e.a.transformRule(t));
	        }), zo ? t.textContent = ir(n) : this.F.K.rules.push(n);
	    }, t.getComputedStyleValue = function(t, e) {
	        var n;
	        return zo || (n = (qr(t) || qr(yi(this, t))).O[e]), (n = n || window.getComputedStyle(t).getPropertyValue(e)) ? n.trim() : ""
	    }, t.$a = function(t, e) {
	        var n = t.getRootNode();
	        if (e = e ? e.split(/\s/) : [], !(n = n.host && n.host.localName)) {
	            var o = t.getAttribute("class");
	            if (o) {
	                o = o.split(/\s/);
	                for (var r = 0; r < o.length; r++)
	                    if (o[r] === Ir.a) {
	                        n = o[r + 1];
	                        break
	                    }
	            }
	        }
	        n && e.push(Ir.a, n), zo || (n = qr(t)) && n.H && e.push(ti.a, n.H), dr(t, e.join(" "));
	    }, t.Qa = function(t) {
	        return qr(t)
	    }, vi.prototype.flush = vi.prototype.Ga, vi.prototype.prepareTemplate = vi.prototype.prepareTemplate, vi.prototype.styleElement = vi.prototype.styleElement, vi.prototype.styleDocument = vi.prototype.styleDocument, vi.prototype.styleSubtree = vi.prototype.styleSubtree, vi.prototype.getComputedStyleValue = vi.prototype.getComputedStyleValue, vi.prototype.setElementClass = vi.prototype.$a, vi.prototype._styleInfoForNode = vi.prototype.Qa, vi.prototype.transformCustomStyleForDocument = vi.prototype.Ea, vi.prototype.getStyleAst = vi.prototype.Ta, vi.prototype.styleAstToString = vi.prototype.ab, vi.prototype.flushCustomStyles = vi.prototype.flushCustomStyles, Object.defineProperties(vi.prototype, {
	        nativeShadow: {
	            get: function() {
	                return Jo
	            }
	        },
	        nativeCss: {
	            get: function() {
	                return zo
	            }
	        }
	    });
	    var wi, Ei, Ni = new vi;
	    window.ShadyCSS && (wi = window.ShadyCSS.ApplyShim, Ei = window.ShadyCSS.CustomStyleInterface), window.ShadyCSS = {
	            ScopingShim: Ni,
	            prepareTemplate: function(t, e, n) {
	                Ni.flushCustomStyles(), Ni.prepareTemplate(t, e, n);
	            },
	            styleSubtree: function(t, e) {
	                Ni.flushCustomStyles(), Ni.styleSubtree(t, e);
	            },
	            styleElement: function(t) {
	                Ni.flushCustomStyles(), Ni.styleElement(t);
	            },
	            styleDocument: function(t) {
	                Ni.flushCustomStyles(), Ni.styleDocument(t);
	            },
	            flushCustomStyles: function() {
	                Ni.flushCustomStyles();
	            },
	            getComputedStyleValue: function(t, e) {
	                return Ni.getComputedStyleValue(t, e)
	            },
	            nativeCss: zo,
	            nativeShadow: Jo
	        }, wi && (window.ShadyCSS.ApplyShim = wi), Ei && (window.ShadyCSS.CustomStyleInterface = Ei),
	        function(t) {
	            function e(t) {
	                return "" == t && (i.call(this), this.h = !0), t.toLowerCase()
	            }

	            function n(t) {
	                var e = t.charCodeAt(0);
	                return 32 < e && 127 > e && -1 == [34, 35, 60, 62, 63, 96].indexOf(e) ? t : encodeURIComponent(t)
	            }

	            function o(t) {
	                var e = t.charCodeAt(0);
	                return 32 < e && 127 > e && -1 == [34, 35, 60, 62, 96].indexOf(e) ? t : encodeURIComponent(t)
	            }

	            function r(t, r, a) {
	                function s(t) {
	                }
	                var l = r || "scheme start",
	                    f = 0,
	                    p = "",
	                    m = !1,
	                    v = !1;
	                t: for (;
	                    (null != t[f - 1] || 0 == f) && !this.h;) {
	                    var y = t[f];
	                    switch (l) {
	                        case "scheme start":
	                            if (!y || !h.test(y)) {
	                                if (r) {
	                                    break t
	                                }
	                                p = "", l = "no scheme";
	                                continue
	                            }
	                            p += y.toLowerCase(), l = "scheme";
	                            break;
	                        case "scheme":
	                            if (y && d.test(y)) p += y.toLowerCase();
	                            else {
	                                if (":" != y) {
	                                    if (r) {
	                                        break t
	                                    }
	                                    p = "", f = 0, l = "no scheme";
	                                    continue
	                                }
	                                if (this.g = p, p = "", r) break t;
	                                void 0 !== c[this.g] && (this.D = !0), l = "file" == this.g ? "relative" : this.D && a && a.g == this.g ? "relative or authority" : this.D ? "authority first slash" : "scheme data";
	                            }
	                            break;
	                        case "scheme data":
	                            "?" == y ? (this.u = "?", l = "query") : "#" == y ? (this.C = "#", l = "fragment") : null != y && "\t" != y && "\n" != y && "\r" != y && (this.qa += n(y));
	                            break;
	                        case "no scheme":
	                            if (a && void 0 !== c[a.g]) {
	                                l = "relative";
	                                continue
	                            }
	                            i.call(this), this.h = !0;
	                            break;
	                        case "relative or authority":
	                            if ("/" != y || "/" != t[f + 1]) {
	                                l = "relative";
	                                continue
	                            }
	                            l = "authority ignore slashes";
	                            break;
	                        case "relative":
	                            if (this.D = !0, "file" != this.g && (this.g = a.g), null == y) {
	                                this.i = a.i, this.s = a.s, this.j = a.j.slice(), this.u = a.u, this.v = a.v, this.f = a.f;
	                                break t
	                            }
	                            if ("/" == y || "\\" == y) l = "relative slash";
	                            else if ("?" == y) this.i = a.i, this.s = a.s, this.j = a.j.slice(), this.u = "?", this.v = a.v, this.f = a.f, l = "query";
	                            else {
	                                if ("#" != y) {
	                                    l = t[f + 1];
	                                    var b = t[f + 2];
	                                    ("file" != this.g || !h.test(y) || ":" != l && "|" != l || null != b && "/" != b && "\\" != b && "?" != b && "#" != b) && (this.i = a.i, this.s = a.s, this.v = a.v, this.f = a.f, this.j = a.j.slice(), this.j.pop()), l = "relative path";
	                                    continue
	                                }
	                                this.i = a.i, this.s = a.s, this.j = a.j.slice(), this.u = a.u, this.C = "#", this.v = a.v, this.f = a.f, l = "fragment";
	                            }
	                            break;
	                        case "relative slash":
	                            if ("/" != y && "\\" != y) {
	                                "file" != this.g && (this.i = a.i, this.s = a.s, this.v = a.v, this.f = a.f), l = "relative path";
	                                continue
	                            }
	                            l = "file" == this.g ? "file host" : "authority ignore slashes";
	                            break;
	                        case "authority first slash":
	                            if ("/" != y) {
	                                l = "authority ignore slashes";
	                                continue
	                            }
	                            l = "authority second slash";
	                            break;
	                        case "authority second slash":
	                            if (l = "authority ignore slashes", "/" != y) {
	                                continue
	                            }
	                            break;
	                        case "authority ignore slashes":
	                            if ("/" != y && "\\" != y) {
	                                l = "authority";
	                                continue
	                            }
	                            break;
	                        case "authority":
	                            if ("@" == y) {
	                                for (m && (p += "%40"), m = !0, y = 0; y < p.length; y++) "\t" == (b = p[y]) || "\n" == b || "\r" == b ? s("Invalid whitespace in authority.") : ":" == b && null === this.f ? this.f = "" : (b = n(b), null !== this.f ? this.f += b : this.v += b);
	                                p = "";
	                            } else {
	                                if (null == y || "/" == y || "\\" == y || "?" == y || "#" == y) {
	                                    f -= p.length, p = "", l = "host";
	                                    continue
	                                }
	                                p += y;
	                            }
	                            break;
	                        case "file host":
	                            if (null == y || "/" == y || "\\" == y || "?" == y || "#" == y) {
	                                2 != p.length || !h.test(p[0]) || ":" != p[1] && "|" != p[1] ? (0 != p.length && (this.i = e.call(this, p), p = ""), l = "relative path start") : l = "relative path";
	                                continue
	                            }
	                            "\t" == y || "\n" == y || "\r" == y ? s("Invalid whitespace in file host.") : p += y;
	                            break;
	                        case "host":
	                        case "hostname":
	                            if (":" != y || v) {
	                                if (null == y || "/" == y || "\\" == y || "?" == y || "#" == y) {
	                                    if (this.i = e.call(this, p), p = "", l = "relative path start", r) break t;
	                                    continue
	                                }
	                                "\t" != y && "\n" != y && "\r" != y ? ("[" == y ? v = !0 : "]" == y && (v = !1), p += y) : s("Invalid code point in host/hostname: " + y);
	                            } else if (this.i = e.call(this, p), p = "", l = "port", "hostname" == r) break t;
	                            break;
	                        case "port":
	                            if (/[0-9]/.test(y)) p += y;
	                            else {
	                                if (null == y || "/" == y || "\\" == y || "?" == y || "#" == y || r) {
	                                    if ("" != p && ((p = parseInt(p, 10)) != c[this.g] && (this.s = p + ""), p = ""), r) break t;
	                                    l = "relative path start";
	                                    continue
	                                }
	                                "\t" == y || "\n" == y || "\r" == y ? s("Invalid code point in port: " + y) : (i.call(this), this.h = !0);
	                            }
	                            break;
	                        case "relative path start":
	                            if (l = "relative path", "/" != y && "\\" != y) continue;
	                            break;
	                        case "relative path":
	                            null != y && "/" != y && "\\" != y && (r || "?" != y && "#" != y) ? "\t" != y && "\n" != y && "\r" != y && (p += n(y)) : ((b = u[p.toLowerCase()]) && (p = b), ".." == p ? (this.j.pop(), "/" != y && "\\" != y && this.j.push("")) : "." == p && "/" != y && "\\" != y ? this.j.push("") : "." != p && ("file" == this.g && 0 == this.j.length && 2 == p.length && h.test(p[0]) && "|" == p[1] && (p = p[0] + ":"), this.j.push(p)), p = "", "?" == y ? (this.u = "?", l = "query") : "#" == y && (this.C = "#", l = "fragment"));
	                            break;
	                        case "query":
	                            r || "#" != y ? null != y && "\t" != y && "\n" != y && "\r" != y && (this.u += o(y)) : (this.C = "#", l = "fragment");
	                            break;
	                        case "fragment":
	                            null != y && "\t" != y && "\n" != y && "\r" != y && (this.C += y);
	                    }
	                    f++;
	                }
	            }

	            function i() {
	                this.v = this.qa = this.g = "", this.f = null, this.s = this.i = "", this.j = [], this.C = this.u = "", this.D = this.h = !1;
	            }

	            function a(t, e) {
	                void 0 === e || e instanceof a || (e = new a(String(e))), this.Ra = t, i.call(this), t = t.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, ""), r.call(this, t, null, e);
	            }
	            var s = !1;
	            if (!t.qb) try {
	                var l = new URL("b", "http://a");
	                l.pathname = "c%20d", s = "http://a/c%20d" === l.href;
	            } catch (t) {}
	            if (!s) {
	                var c = Object.create(null);
	                c.ftp = 21, c.file = 0, c.gopher = 70, c.http = 80, c.https = 443, c.ws = 80, c.wss = 443;
	                var u = Object.create(null);
	                u["%2e"] = ".", u[".%2e"] = "..", u["%2e."] = "..", u["%2e%2e"] = "..";
	                var h = /[a-zA-Z]/,
	                    d = /[a-zA-Z0-9\+\-\.]/;
	                a.prototype = {
	                    toString: function() {
	                        return this.href
	                    },
	                    get href() {
	                        if (this.h) return this.Ra;
	                        var t = "";
	                        return "" == this.v && null == this.f || (t = this.v + (null != this.f ? ":" + this.f : "") + "@"), this.protocol + (this.D ? "//" + t + this.host : "") + this.pathname + this.u + this.C
	                    },
	                    set href(t) {
	                        i.call(this), r.call(this, t);
	                    },
	                    get protocol() {
	                        return this.g + ":"
	                    },
	                    set protocol(t) {
	                        this.h || r.call(this, t + ":", "scheme start");
	                    },
	                    get host() {
	                        return this.h ? "" : this.s ? this.i + ":" + this.s : this.i
	                    },
	                    set host(t) {
	                        !this.h && this.D && r.call(this, t, "host");
	                    },
	                    get hostname() {
	                        return this.i
	                    },
	                    set hostname(t) {
	                        !this.h && this.D && r.call(this, t, "hostname");
	                    },
	                    get port() {
	                        return this.s
	                    },
	                    set port(t) {
	                        !this.h && this.D && r.call(this, t, "port");
	                    },
	                    get pathname() {
	                        return this.h ? "" : this.D ? "/" + this.j.join("/") : this.qa
	                    },
	                    set pathname(t) {
	                        !this.h && this.D && (this.j = [], r.call(this, t, "relative path start"));
	                    },
	                    get search() {
	                        return this.h || !this.u || "?" == this.u ? "" : this.u
	                    },
	                    set search(t) {
	                        !this.h && this.D && (this.u = "?", "?" == t[0] && (t = t.slice(1)), r.call(this, t, "query"));
	                    },
	                    get hash() {
	                        return this.h || !this.C || "#" == this.C ? "" : this.C
	                    },
	                    set hash(t) {
	                        this.h || (this.C = "#", "#" == t[0] && (t = t.slice(1)), r.call(this, t, "fragment"));
	                    },
	                    get origin() {
	                        var t;
	                        if (this.h || !this.g) return "";
	                        switch (this.g) {
	                            case "data":
	                            case "file":
	                            case "javascript":
	                            case "mailto":
	                                return "null"
	                        }
	                        return (t = this.host) ? this.g + "://" + t : ""
	                    }
	                };
	                var f = t.URL;
	                f && (a.createObjectURL = function(t) {
	                    return f.createObjectURL.apply(f, arguments)
	                }, a.revokeObjectURL = function(t) {
	                    f.revokeObjectURL(t);
	                }), t.URL = a;
	            }
	        }(window);
	    var Ci = {},
	        Si = Object.create,
	        _i = Object.defineProperties,
	        Ti = Object.defineProperty;

	    function Oi(t, e) {
	        return {
	            value: t,
	            configurable: !!(e = void 0 === e ? {} : e).ya,
	            writable: !!e.cb,
	            enumerable: !!e.e
	        }
	    }
	    var Di = void 0;
	    try {
	        Di = 1 === Ti({}, "y", {
	            get: function() {
	                return 1
	            }
	        }).y;
	    } catch (r) {
	        Di = !1;
	    }
	    var xi = {};
	    var Mi = Si(null);

	    function Ai(t) {
	        if (this instanceof Ai) throw new TypeError("Symbol is not a constructor");
	        var e = function(t) {
	            t = String(t);
	            for (var e = "", n = 0; xi[t + e];) e = n += 1;
	            xi[t + e] = 1;
	            var o = "Symbol(" + t + e + ")";
	            return Di && Ti(Object.prototype, o, {
	                get: void 0,
	                set: function(t) {
	                    Ti(this, o, Oi(t, {
	                        ya: !0,
	                        cb: !0
	                    }));
	                },
	                configurable: !0,
	                enumerable: !1
	            }), o
	        }(t = void 0 === t ? "" : String(t));
	        return Di ? Si(Mi, {
	            ua: Oi(t),
	            Ka: Oi(e)
	        }) : e
	    }
	    _i(Ai, {
	        for: Oi(function(t) {
	            if (t = String(t), Ci[t]) return Ci[t];
	            var e = Ai(t);
	            return Ci[t] = e
	        }),
	        keyFor: Oi(function(t) {
	            if (Di && (!t || "Symbol" !== t[Ai.toStringTag])) throw new TypeError(t + " is not a symbol");
	            for (var e in Ci)
	                if (Ci[e] === t) return Di ? Ci[e].ua : Ci[e].substr(7, Ci[e].length - 8)
	        })
	    }), _i(Ai, {
	        ub: Oi(Ai("hasInstance")),
	        vb: Oi(Ai("isConcatSpreadable")),
	        iterator: Oi(Ai("iterator")),
	        match: Oi(Ai("match")),
	        replace: Oi(Ai("replace")),
	        search: Oi(Ai("search")),
	        Ab: Oi(Ai("species")),
	        split: Oi(Ai("split")),
	        Bb: Oi(Ai("toPrimitive")),
	        toStringTag: Oi(Ai("toStringTag")),
	        unscopables: Oi(Ai("unscopables"))
	    }), _i(Mi, {
	        constructor: Oi(Ai),
	        toString: Oi(function() {
	            return this.Ka
	        }),
	        valueOf: Oi(function() {
	            return "Symbol(" + this.ua + ")"
	        })
	    }), Di && Ti(Mi, Ai.toStringTag, Oi("Symbol", {
	        ya: !0
	    }));
	    var Li = "function" == typeof Symbol ? Symbol : Ai;
	    window.Symbol || (window.Symbol = Li, Array.prototype[Li.iterator] = function() {
	        function t(t, r, i) {
	            for (;;) switch (n) {
	                case 0:
	                    e = 0;
	                case 1:
	                    if (!(e < o.length)) {
	                        n = 3;
	                        break
	                    }
	                    return n = 4, {
	                        value: o[e],
	                        done: !1
	                    };
	                case 4:
	                    if (1 != t) {
	                        n = 5;
	                        break
	                    }
	                    throw n = -1, i;
	                case 5:
	                case 2:
	                    e++, n = 1;
	                    break;
	                case 3:
	                    n = -1;
	                default:
	                    return {
	                        value: void 0,
	                        done: !0
	                    }
	            }
	        }
	        var e, n = 0,
	            o = this,
	            r = {
	                next: function(e) {
	                    return t(0, 0, void 0)
	                },
	                throw: function(e) {
	                    return t(1, 0, e)
	                },
	                return: function() {
	                    throw Error("Not yet implemented")
	                }
	            };
	        return a(), r[Symbol.iterator] = function() {
	            return this
	        }, r
	    }, Set.prototype[Li.iterator] = function() {
	        function t(t, i, a) {
	            for (;;) switch (o) {
	                case 0:
	                    n = [], r.forEach(function(t) {
	                        n.push(t);
	                    }), e = 0;
	                case 1:
	                    if (!(e < n.length)) {
	                        o = 3;
	                        break
	                    }
	                    return o = 4, {
	                        value: n[e],
	                        done: !1
	                    };
	                case 4:
	                    if (1 != t) {
	                        o = 5;
	                        break
	                    }
	                    throw o = -1, a;
	                case 5:
	                case 2:
	                    e++, o = 1;
	                    break;
	                case 3:
	                    o = -1;
	                default:
	                    return {
	                        value: void 0,
	                        done: !0
	                    }
	            }
	        }
	        var e, n, o = 0,
	            r = this,
	            i = {
	                next: function(e) {
	                    return t(0, 0, void 0)
	                },
	                throw: function(e) {
	                    return t(1, 0, e)
	                },
	                return: function() {
	                    throw Error("Not yet implemented")
	                }
	            };
	        return a(), i[Symbol.iterator] = function() {
	            return this
	        }, i
	    }, Map.prototype[Li.iterator] = function() {
	        function t(t, i, a) {
	            for (;;) switch (o) {
	                case 0:
	                    n = [], r.forEach(function(t, e) {
	                        n.push([e, t]);
	                    }), e = 0;
	                case 1:
	                    if (!(e < n.length)) {
	                        o = 3;
	                        break
	                    }
	                    return o = 4, {
	                        value: n[e],
	                        done: !1
	                    };
	                case 4:
	                    if (1 != t) {
	                        o = 5;
	                        break
	                    }
	                    throw o = -1, a;
	                case 5:
	                case 2:
	                    e++, o = 1;
	                    break;
	                case 3:
	                    o = -1;
	                default:
	                    return {
	                        value: void 0,
	                        done: !0
	                    }
	            }
	        }
	        var e, n, o = 0,
	            r = this,
	            i = {
	                next: function(e) {
	                    return t(0, 0, void 0)
	                },
	                throw: function(e) {
	                    return t(1, 0, e)
	                },
	                return: function() {
	                    throw Error("Not yet implemented")
	                }
	            };
	        return a(), i[Symbol.iterator] = function() {
	            return this
	        }, i
	    }, String.prototype[Li.iterator] = function() {
	        function t(t, r, i) {
	            for (;;) switch (n) {
	                case 0:
	                    e = 0;
	                case 1:
	                    if (!(e < o.length)) {
	                        n = 3;
	                        break
	                    }
	                    return n = 4, {
	                        value: o[e],
	                        done: !1
	                    };
	                case 4:
	                    if (1 != t) {
	                        n = 5;
	                        break
	                    }
	                    throw n = -1, i;
	                case 5:
	                case 2:
	                    e++, n = 1;
	                    break;
	                case 3:
	                    n = -1;
	                default:
	                    return {
	                        value: void 0,
	                        done: !0
	                    }
	            }
	        }
	        var e, n = 0,
	            o = this,
	            r = {
	                next: function(e) {
	                    return t(0, 0, void 0)
	                },
	                throw: function(e) {
	                    return t(1, 0, e)
	                },
	                return: function() {
	                    throw Error("Not yet implemented")
	                }
	            };
	        return a(), r[Symbol.iterator] = function() {
	            return this
	        }, r
	    });
	    var ki = document.createElement("style");
	    ki.textContent = "body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";
	    var ji = document.querySelector("head");
	    ji.insertBefore(ki, ji.firstChild);
	    var Ri = window.customElements,
	        Pi = !1,
	        Fi = null;

	    function Hi() {
	        window.HTMLTemplateElement.bootstrap && window.HTMLTemplateElement.bootstrap(window.document), Fi && Fi(), Pi = !0, window.WebComponents.ready = !0, document.dispatchEvent(new CustomEvent("WebComponentsReady", {
	            bubbles: !0
	        }));
	    }
	    Ri.polyfillWrapFlushCallback && Ri.polyfillWrapFlushCallback(function(t) {
	        Fi = t, Pi && t();
	    }), "complete" !== document.readyState ? (window.addEventListener("load", Hi), window.addEventListener("DOMContentLoaded", function() {
	        window.removeEventListener("load", Hi), Hi();
	    })) : Hi();
	}).call(commonjsGlobal);

	(function () {

	  // requestAnimationFrame
	  window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

	  if (!window.requestAnimationFrame) {
	    window.requestAnimationFrame = function (e) {
	      "function" == typeof e && setTimeout(function () {
	        e();
	      }, 17);
	    };
	  }

	  (function ($glob$) {
	    var TMAWEBVIEW = function (exports) {

	      $glob$.__JSSDK_VERSION__ = {
	        SDKVersion: '',
	        SDKUpdateVersion: '',
	        CommitHash: ''
	      };

	      var _global = new Function('return this;')();
	      var __proto = Function.prototype;
	      var g = {};

	      function _overideFunction() {
	        if (arguments.length > 0 && /^\s*return this\s*;?\s*$/.test(arguments[arguments.length - 1])) {
	          return function () {
	            return g;
	          };
	        }
	        return function () {};
	      }

	      if (typeof _global.webkit === 'undefined') {
	        var _eval = undefined;
	        _global.eval = _eval;
	        _overideFunction.prototype = __proto;
	        _overideFunction.prototype.constructor = _overideFunction;
	        // eslint-disable-next-line no-global-assign
	        Function = _overideFunction;
	      }

	      var ttJSCore = _global.ttJSCore;
	      var webkit = _global.webkit;

	      if (_global.ttJSCore) {
	        _global.ttJSCore = {
	          onDocumentReady: function onDocumentReady() {
	            return ttJSCore.onDocumentReady();
	          }
	        };
	      }

	      if (_global.webkit) {
	        _global.webkit = {
	          messageHandlers: {
	            onDocumentReady: {
	              postMessage: function postMessage() {
	                return webkit.messageHandlers.onDocumentReady.postMessage('');
	              }
	            }
	          }
	        };
	      }

	      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	        return typeof obj;
	      } : function (obj) {
	        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	      };

	      var classCallCheck = function (instance, Constructor) {
	        if (!(instance instanceof Constructor)) {
	          throw new TypeError("Cannot call a class as a function");
	        }
	      };

	      var inherits = function (subClass, superClass) {
	        if (typeof superClass !== "function" && superClass !== null) {
	          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	        }

	        subClass.prototype = Object.create(superClass && superClass.prototype, {
	          constructor: {
	            value: subClass,
	            enumerable: false,
	            writable: true,
	            configurable: true
	          }
	        });
	        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	      };

	      var possibleConstructorReturn = function (self, call) {
	        if (!self) {
	          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	        }

	        return call && (typeof call === "object" || typeof call === "function") ? call : self;
	      };

	      var readyQueue = [];
	      if (_typeof(_global.TMAConfig) === 'object' && _global.TMAConfig !== null) {
	        _global.TMAConfig.onReady = function (cb) {
	          cb(_global.TMAConfig);
	        };

	        _global.TMAConfig.onRealReady = function (cb) {
	          if (typeof cb === 'function') {
	            readyQueue.push(cb);
	          }
	        };

	        _global.TMAConfig.ready = function () {
	          readyQueue.forEach(function (cb) {
	            cb(_global.TMAConfig);
	          });
	        };
	      }

	      /**
	       * Helpers.
	       */

	      var s = 1000;
	      var m = s * 60;
	      var h = m * 60;
	      var d = h * 24;
	      var y = d * 365.25;

	      /**
	       * Parse or format the given `val`.
	       *
	       * Options:
	       *
	       *  - `long` verbose formatting [false]
	       *
	       * @param {String|Number} val
	       * @param {Object} [options]
	       * @throws {Error} throw an error if val is not a non-empty string or a number
	       * @return {String|Number}
	       * @api public
	       */

	      var ms = function ms(val, options) {
	        options = options || {};
	        var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	        if (type === 'string' && val.length > 0) {
	          return parse(val);
	        } else if (type === 'number' && isNaN(val) === false) {
	          return options.long ? fmtLong(val) : fmtShort(val);
	        }
	        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	      };

	      /**
	       * Parse the given `str` and return milliseconds.
	       *
	       * @param {String} str
	       * @return {Number}
	       * @api private
	       */

	      function parse(str) {
	        str = String(str);
	        if (str.length > 100) {
	          return;
	        }
	        var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	        if (!match) {
	          return;
	        }
	        var n = parseFloat(match[1]);
	        var type = (match[2] || 'ms').toLowerCase();
	        switch (type) {
	          case 'years':
	          case 'year':
	          case 'yrs':
	          case 'yr':
	          case 'y':
	            return n * y;
	          case 'days':
	          case 'day':
	          case 'd':
	            return n * d;
	          case 'hours':
	          case 'hour':
	          case 'hrs':
	          case 'hr':
	          case 'h':
	            return n * h;
	          case 'minutes':
	          case 'minute':
	          case 'mins':
	          case 'min':
	          case 'm':
	            return n * m;
	          case 'seconds':
	          case 'second':
	          case 'secs':
	          case 'sec':
	          case 's':
	            return n * s;
	          case 'milliseconds':
	          case 'millisecond':
	          case 'msecs':
	          case 'msec':
	          case 'ms':
	            return n;
	          default:
	            return undefined;
	        }
	      }

	      /**
	       * Short format for `ms`.
	       *
	       * @param {Number} ms
	       * @return {String}
	       * @api private
	       */

	      function fmtShort(ms) {
	        if (ms >= d) {
	          return Math.round(ms / d) + 'd';
	        }
	        if (ms >= h) {
	          return Math.round(ms / h) + 'h';
	        }
	        if (ms >= m) {
	          return Math.round(ms / m) + 'm';
	        }
	        if (ms >= s) {
	          return Math.round(ms / s) + 's';
	        }
	        return ms + 'ms';
	      }

	      /**
	       * Long format for `ms`.
	       *
	       * @param {Number} ms
	       * @return {String}
	       * @api private
	       */

	      function fmtLong(ms) {
	        return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	      }

	      /**
	       * Pluralization helper.
	       */

	      function plural(ms, n, name) {
	        if (ms < n) {
	          return;
	        }
	        if (ms < n * 1.5) {
	          return Math.floor(ms / n) + ' ' + name;
	        }
	        return Math.ceil(ms / n) + ' ' + name + 's';
	      }

	      createDebug.debug = createDebug;
	      createDebug.coerce = coerce;
	      createDebug.disable = disable;
	      createDebug.enable = enable;
	      createDebug.enabled = enabled;
	      createDebug.humanize = ms;

	      /**
	       * Active `debug` instances.
	       */
	      createDebug.instances = [];

	      /**
	       * The currently active debug mode names, and names to skip.
	       */

	      createDebug.names = [];
	      createDebug.skips = [];

	      /**
	       * Map of special "%n" handling functions, for the debug "format" argument.
	       *
	       * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	       */

	      createDebug.formatters = {};

	      /**
	       * Select a color.
	       * @param {String} namespace
	       * @return {Number}
	       * @api private
	       */

	      function selectColor(namespace) {
	        var hash = 0,
	            i;

	        for (i in namespace) {
	          hash = (hash << 5) - hash + namespace.charCodeAt(i);
	          hash |= 0; // Convert to 32bit integer
	        }

	        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	      }

	      /**
	       * Create a debugger with the given `namespace`.
	       *
	       * @param {String} namespace
	       * @return {Function}
	       * @api public
	       */

	      function createDebug(namespace) {

	        var prevTime;

	        function debug() {
	          // disabled?
	          if (!_global.__FORCE_LOG__ && !debug.enabled) {
	            return;
	          }

	          var self = debug;

	          // set `diff` timestamp
	          var curr = +new Date();
	          var ms$$1 = curr - (prevTime || curr);
	          self.diff = ms$$1;
	          self.prev = prevTime;
	          self.curr = curr;
	          prevTime = curr;

	          // turn the `arguments` into a proper Array
	          var args = new Array(arguments.length);
	          for (var i = 0; i < args.length; i++) {
	            args[i] = arguments[i];
	          }

	          args[0] = createDebug.coerce(args[0]);

	          if ('string' !== typeof args[0]) {
	            // anything else let's inspect with %O
	            args.unshift('%O');
	          }

	          // apply any `formatters` transformations
	          var index = 0;
	          args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	            // if we encounter an escaped % then don't increase the array index
	            if (match === '%%') {
	              return match;
	            }
	            index++;
	            var formatter = createDebug.formatters[format];
	            if ('function' === typeof formatter) {
	              var val = args[index];
	              match = formatter.call(self, val);

	              // now we need to remove `args[index]` since it's inlined in the `format`
	              args.splice(index, 1);
	              index--;
	            }
	            return match;
	          });

	          // apply env-specific formatting (colors, etc.)
	          createDebug.formatArgs.call(self, args);

	          var logFn = debug.log || createDebug.log || console.log.bind(console);
	          logFn.apply(self, args);
	        }

	        debug.namespace = namespace;
	        debug.enabled = createDebug.enabled(namespace);
	        debug.useColors = createDebug.useColors();
	        debug.color = selectColor(namespace);
	        debug.destroy = destroy;

	        // env-specific initialization logic for debug instances
	        if ('function' === typeof createDebug.init) {
	          createDebug.init(debug);
	        }

	        createDebug.instances.push(debug);

	        return debug;
	      }

	      function destroy() {
	        var index = createDebug.instances.indexOf(this);
	        if (index !== -1) {
	          createDebug.instances.splice(index, 1);
	          return true;
	        } else {
	          return false;
	        }
	      }

	      /**
	       * Enables a debug mode by namespaces. This can include modes
	       * separated by a colon and wildcards.
	       *
	       * @param {String} namespaces
	       * @api public
	       */

	      function enable(namespaces) {
	        createDebug.save(namespaces);

	        createDebug.names = [];
	        createDebug.skips = [];

	        var i;
	        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	        var len = split.length;

	        for (i = 0; i < len; i++) {
	          if (!split[i]) {
	            continue;
	          } // ignore empty strings
	          namespaces = split[i].replace(/\*/g, '.*?');
	          if (namespaces[0] === '-') {
	            createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	          } else {
	            createDebug.names.push(new RegExp('^' + namespaces + '$'));
	          }
	        }

	        for (i = 0; i < createDebug.instances.length; i++) {
	          var instance = createDebug.instances[i];
	          instance.enabled = createDebug.enabled(instance.namespace);
	        }
	      }

	      /**
	       * Disable debug output.
	       *
	       * @api public
	       */

	      function disable() {
	        createDebug.enable('');
	      }

	      /**
	       * Returns true if the given mode name is enabled, false otherwise.
	       *
	       * @param {String} name
	       * @return {Boolean}
	       * @api public
	       */

	      function enabled(name) {
	        if (name[name.length - 1] === '*') {
	          return true;
	        }
	        var i, len;
	        for (i = 0, len = createDebug.skips.length; i < len; i++) {
	          if (createDebug.skips[i].test(name)) {
	            return false;
	          }
	        }
	        for (i = 0, len = createDebug.names.length; i < len; i++) {
	          if (createDebug.names[i].test(name)) {
	            return true;
	          }
	        }
	        return false;
	      }

	      /**
	       * Coerce `val`.
	       *
	       * @param {Mixed} val
	       * @return {Mixed}
	       * @api private
	       */

	      function coerce(val) {
	        if (val instanceof Error) {
	          return val.stack || val.message;
	        }
	        return val;
	      }

	      /**
	       * This is the web browser implementation of `debug()`.
	       *
	       * Expose `debug()` as the module.
	       */

	      createDebug.log = log;
	      createDebug.formatArgs = formatArgs;
	      createDebug.save = save;
	      createDebug.load = load;
	      createDebug.useColors = useColors;
	      createDebug.storage = localstorage();

	      /**
	       * Colors.
	       */

	      createDebug.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

	      /**
	       * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	       * and the Firebug extension (any Firefox version) are known
	       * to support "%c" CSS customizations.
	       *
	       * TODO: add a `localStorage` variable to explicitly enable/disable colors
	       */

	      function useColors() {
	        // NB: In an Electron preload script, document will be defined but not fully
	        // initialized. Since we know we're in Chrome, we'll just detect this case
	        // explicitly
	        if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	          return true;
	        }

	        // Internet Explorer and Edge do not support colors.
	        if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	          return false;
	        }

	        // is webkit? http://stackoverflow.com/a/16459606/376773
	        // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	        return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
	        // is firebug? http://stackoverflow.com/a/398120/376773
	        typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table)
	        // is firefox >= v31?
	        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	        || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31
	        // double check webkit in userAgent just in case we are in a worker
	        || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	      }

	      /**
	       * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	       */

	      createDebug.formatters.j = function (v) {
	        try {
	          return JSON.stringify(v);
	        } catch (err) {
	          return '[UnexpectedJSONParseError]: ' + err.message;
	        }
	      };

	      /**
	       * Colorize log arguments if enabled.
	       *
	       * @api public
	       */

	      function formatArgs(args) {
	        var useColors = this.useColors;

	        args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + createDebug.humanize(this.diff);

	        if (!useColors) {
	          return;
	        }

	        var c = 'color: ' + this.color;
	        args.splice(1, 0, c, 'color: inherit');

	        // the final "%c" is somewhat tricky, because there could be other
	        // arguments passed either before or after the %c, so we need to
	        // figure out the correct index to insert the CSS into
	        var index = 0;
	        var lastC = 0;
	        args[0].replace(/%[a-zA-Z%]/g, function (match) {
	          if ('%%' === match) {
	            return;
	          }
	          index++;
	          if ('%c' === match) {
	            // we only are interested in the *last* %c
	            // (the user may have provided their own)
	            lastC = index;
	          }
	        });

	        args.splice(lastC, 0, c);
	      }

	      /**
	       * Invokes `console.log()` when available.
	       * No-op when `console.log` is not a "function".
	       *
	       * @api public
	       */

	      function log() {
	        // this hackery is required for IE8/9, where
	        // the `console.log` function doesn't have 'apply'
	        return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	      }

	      /**
	       * Save `namespaces`.
	       *
	       * @param {String} namespaces
	       * @api private
	       */

	      function save(namespaces) {
	        try {
	          if (null == namespaces) {
	            createDebug.storage.debug = '';
	          } else {
	            createDebug.storage.debug = namespaces;
	          }
	        } catch (e) {}
	      }

	      /**
	       * Load `namespaces`.
	       *
	       * @return {String} returns the previously persisted debug modes
	       * @api private
	       */

	      function load() {
	        return '*TMA*';
	      }

	      /**
	       * Enable namespaces listed in `localStorage.debug` initially.
	       */

	      createDebug.enable(load());

	      /**
	       * Localstorage attempts to return the localstorage.
	       *
	       * This is necessary because safari throws
	       * when a user disables cookies/localstorage
	       * and you attempt to access it.
	       *
	       * @return {LocalStorage}
	       * @api private
	       */

	      function localstorage() {
	        var g = typeof window === 'undefined' ? _global : window;
	        try {
	          /* eslint-disable no-return-assign */
	          return g.__DEBUG_NAMESPACE ? g.__DEBUG_NAMESPACE : g.__DEBUG_NAMESPACE = {};
	        } catch (e) {}
	      }

	      var TYPE = 'RUNTIME';
	      var app = 'TMA';

	      // let debug = debug(`[${app}][DEBUG][${TYPE}]`);
	      // let trace = debug(`[${app}][TRACE][${TYPE}]`);
	      // let log = debug(`[${app}][LOG][${TYPE}]`);
	      // let info = debug(`[${app}][INFO][${TYPE}]`);
	      // let warn = debug(`[${app}][WARN][${TYPE}]`);
	      // let error = debug(`[${app}][ERROR][${TYPE}]`);

	      // const logMethod = ['debug', 'group', 'groupEnd', 'trace', 'log', 'info', 'warn', 'error', 'time', 'timeEnd'];
	      var allMethod = [];
	      for (var i in console) {
	        allMethod.push(i);
	      }

	      /* eslint-disable no-console */
	      var logMethod = allMethod.filter(function (method) {
	        return typeof console[method] === 'function';
	      });

	      var logger$1 = {};

	      logMethod.forEach(function (method) {
	        logger$1[method] = createDebug('[' + app + '][' + method.toUpperCase() + '][' + TYPE + ']');
	        /* eslint-disable no-console */
	        logger$1[method].log = console[method].bind(console);
	      });

	      var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	      var btoa = btoa || function (e) {
	        for (var t, n, r = String(e), o = '', i = 0, a = alphabet; r.charAt(0 | i) || (a = '=', i % 1); o += a.charAt(63 & t >> 8 - i % 1 * 8)) {
	          if ((n = r.charCodeAt(i += 0.75)) > 255) {
	            throw new Error('"btoa" failed');
	          }
	          t = t << 8 | n;
	        }
	        return o;
	      };

	      var atob = atob || function (e) {
	        var t = String(e).replace(/=+$/, ''),
	            n = '';
	        if (t.length % 4 == 1) {
	          throw new Error('"atob" failed');
	        }
	        for (var r, o, i = 0, a = 0; o = t.charAt(a++), o; ~o && (r = i % 4 ? 64 * r + o : o, i++ % 4) ? n += String.fromCharCode(255 & r >> (-2 * i & 6)) : 0) {
	          o = alphabet.indexOf(o);
	        }
	        return n;
	      };

	      function encodeToUi8Base64(ab) {
	        var string = '';
	        var ui8aReader = new Uint8Array(ab),
	            len = ui8aReader.byteLength;
	        for (var i = 0; i < len; i++) {
	          string += String.fromCharCode(ui8aReader[i]);
	        }
	        return btoa(string);
	      }

	      function decodeFromUi8Base64(string) {
	        var base64String = atob(string),
	            len = base64String.length,
	            ui8aReader = new Uint8Array(len);
	        for (var i = 0; i < len; i++) {
	          ui8aReader[i] = base64String.charCodeAt(i);
	        }
	        return ui8aReader.buffer;
	      }

	      function _new(data) {
	        return {
	          base64: encodeToUi8Base64(data)
	        };
	      }

	      function _get(data) {
	        if (data != null) {
	          if (data.base64) {
	            return decodeFromUi8Base64(data.base64);
	          } else {
	            return undefined;
	          }
	        }
	      }

	      function isType(type) {
	        return function (arg) {
	          return Object.prototype.toString.call(arg).toLowerCase() === ('[object ' + type + ']').toLowerCase();
	        };
	      }

	      function _pack(data) {
	        if (isType('Object')(data) === false) {
	          return data;
	        }

	        // 收集并转换需要编码的字段
	        var needTransAttrs = [];
	        for (var key in data) {
	          var item = data[key];
	          if (item !== undefined && item instanceof ArrayBuffer && item.byteLength !== undefined) {
	            var obj = _new(item);
	            obj.key = key;
	            needTransAttrs.push(obj);
	          }
	        }

	        if (needTransAttrs.length > 0) {
	          // 从原始数据上删除需要转换的字段
	          for (var i = 0; i < needTransAttrs.length; i++) {
	            var tmp = needTransAttrs[i];
	            delete data[tmp.key];
	          }

	          data.__nativeBuffers__ = needTransAttrs;
	        }

	        return data;
	      }

	      function _unpack(data) {
	        if (isType('Object')(data) === false || null == data.__nativeBuffers__) {
	          return data;
	        }

	        var nbs = data.__nativeBuffers__;
	        delete data.__nativeBuffers__;

	        for (var i = 0; i < nbs.length; i++) {
	          var item = nbs[i];
	          if (null != item) {
	            var tmp = _get(item);
	            if (tmp !== undefined && tmp instanceof ArrayBuffer) {
	              data[item.key] = tmp;
	            }
	          }
	        }

	        return data;
	      }

	      var NativeBuffer = {
	        new: _new,
	        get: _get,
	        pack: _pack,
	        unpack: _unpack
	      };

	      /**
	       * 本地修改点：
	       *  1. WeixinJSBridge => ttJSBridge
	       *  2. WeixinJSCore => ttJSCore
	       *  3. invokeCallbackHandler => invokeHandler
	       *  4. invokeHandler 和 subscribeHandler 里加了一层 JSONDecode
	       *  5. 删除了对 webkit 和 ttJSCore 删除的部分
	       */

	      var invokeCallbackMap = {};
	      var invokeCallbackIdCounter = 0;
	      var eventMap = {};
	      var customEventMap = {};
	      var invokeTaskCache = [];
	      var onAppEnterBackground = false;
	      var reserveInvokeCallbackIds = [];

	      var ACTIONS = {
	        onAppEnterBackground: 'onAppEnterBackground',
	        onAppEnterForeground: 'onAppEnterForeground'
	      };

	      var backgroundEventManager = {
	        needCache: ['showModal', 'showToast', 'showActionSheet', 'hideToast'],
	        needDisabled: ['onAccelerometerChange', 'onCompassChange']
	      };

	      // var webkit = global.webkit;
	      // var ttJSCore = global.ttJSCore;

	      var logSwitchOn = false;

	      function _checkSyncInvokeResult(res, callbackId) {
	        if (res !== undefined && typeof invokeCallbackMap[callbackId] == 'function' && res !== '' && res !== null) {
	          try {
	            res = JSON.parse(res);
	            res = NativeBuffer.unpack(res);
	          } catch (t) {
	            res = {};
	          }

	          invokeCallbackMap[callbackId](res);
	          delete invokeCallbackMap[callbackId];
	        }
	      }

	      function _invoke(ev, param, callbackId) {
	        if (logSwitchOn) {
	          logger.log('invoke客户端方法', ev, param, callbackId);
	        }

	        // 进入后台时，缓存调端的 task
	        if (onAppEnterBackground && backgroundEventManager.needCache.find(function (e) {
	          return e === ev;
	        })) {
	          invokeTaskCache.push([ev, param, callbackId]);
	          return;
	        }

	        if (ttJSCore) {
	          var res = ttJSCore.invoke(ev, param, callbackId);
	          _checkSyncInvokeResult(res, callbackId);
	        } else {
	          var wkInvokeParam = {
	            event: ev,
	            paramsString: param,
	            callbackId: callbackId
	          };

	          webkit.messageHandlers.invoke.postMessage(wkInvokeParam);
	        }
	      }

	      function _publish(ev, paramString, webviewIdsString) {
	        if (logSwitchOn) {
	          logger.log('publish到对岸', ev, paramString, webviewIdsString);
	        }
	        if (ttJSCore) {
	          ttJSCore.publish(ev, paramString, webviewIdsString);
	        } else {
	          webkit.messageHandlers.publish.postMessage({
	            event: ev,
	            paramsString: paramString,
	            webviewIds: webviewIdsString
	          });
	        }
	      }

	      function _beforeInvoke(ev, data, cb) {
	        data = NativeBuffer.pack(data);
	        var datastring = JSON.stringify(data || {}),
	            _id = ++invokeCallbackIdCounter;
	        invokeCallbackMap[_id] = cb;
	        // trick for openSchema
	        if (ev === 'openSchema') {
	          reserveInvokeCallbackIds.push(_id);
	        }
	        _invoke(ev, datastring, _id);
	      }

	      function _invokeHandler(callbackId, data) {
	        if (logSwitchOn) {
	          logger.log('invokeHandler客户端执行回调', callbackId, data);
	        }
	        // NOTE 这里修改了原有的实现，加了一层 JSON 转码
	        if (typeof data === 'string') {
	          data = JSON.parse(data);
	        }
	        data = NativeBuffer.unpack(data);
	        var _cb = invokeCallbackMap[callbackId];
	        typeof _cb == 'function' && _cb(data);

	        if (reserveInvokeCallbackIds.indexOf(callbackId) === -1) {
	          delete invokeCallbackMap[callbackId];
	        }
	      }

	      function _on(ev, cb) {
	        eventMap[ev] = cb;
	      }

	      function _beforePublish(ev, data, webviewIds) {
	        webviewIds = webviewIds || [];
	        webviewIds = JSON.stringify(webviewIds);
	        var custom_ev = 'custom_event_' + ev;
	        var datastring = JSON.stringify(data);

	        _publish(custom_ev, datastring, webviewIds);
	      }

	      function _subscribe(ev, cb) {
	        customEventMap['custom_event_' + ev] = cb;
	      }

	      function _subscribeHandler(ev, data, webviewId, r) {
	        if (logSwitchOn) {
	          logger.log('subscribeHandler事件触发', ev, data, webviewId, r);
	        }

	        if (ev === ACTIONS.onAppEnterBackground) {
	          onAppEnterBackground = true;
	        } else if (ev === ACTIONS.onAppEnterForeground) {
	          // 回到前台时，取出缓存的 task
	          onAppEnterBackground = false;
	          while (invokeTaskCache.length) {
	            _invoke.apply(null, invokeTaskCache.shift());
	          }
	        }
	        // 处于后台期间需要屏蔽的回调处理
	        if (onAppEnterBackground && backgroundEventManager.needDisabled.find(function (e) {
	          return e === ev;
	        })) {
	          return;
	        }

	        // NOTE 这里修改了原有的实现，加了一层 JSON 转码
	        if (typeof data === 'string') {
	          data = JSON.parse(data);
	        }
	        data = NativeBuffer.unpack(data);
	        var _cb = ev.indexOf('custom_event_') > -1 ? customEventMap[ev] : eventMap[ev];
	        typeof _cb == 'function' && _cb(data, webviewId, r);
	      }

	      var ttJSBridge$1 = {
	        on: _on,
	        publish: _beforePublish,
	        invoke: _beforeInvoke,
	        subscribe: _subscribe
	      };

	      // 暴露给端上的
	      _global.ttJSBridge = {
	        get invokeHandler() {
	          return _invokeHandler;
	        },
	        get subscribeHandler() {
	          return _subscribeHandler;
	        }
	      };

	      /* !
	      * EventEmitter2
	      * https://github.com/hij1nx/EventEmitter2
	      *
	      * Copyright (c) 2013 hij1nx
	      * Licensed under the MIT license.
	      */
	      var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
	        return Object.prototype.toString.call(obj) === '[object Array]';
	      };
	      var defaultMaxListeners = 100;

	      function init() {
	        this._events = {};
	        if (this._conf) {
	          configure.call(this, this._conf);
	        }
	      }

	      function configure(conf) {
	        if (conf) {
	          this._conf = conf;

	          conf.delimiter && (this.delimiter = conf.delimiter);
	          this._maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;

	          conf.wildcard && (this.wildcard = conf.wildcard);
	          conf.newListener && (this._newListener = conf.newListener);
	          conf.removeListener && (this._removeListener = conf.removeListener);
	          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);

	          if (this.wildcard) {
	            this.listenerTree = {};
	          }
	        } else {
	          this._maxListeners = defaultMaxListeners;
	        }
	      }

	      function logPossibleMemoryLeak(count, eventName) {
	        var errorMsg = '(node) warning: possible EventEmitter memory ' + 'leak detected. ' + count + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.';

	        if (this.verboseMemoryLeak) {
	          errorMsg += ' Event name: ' + eventName + '.';
	        }

	        if (typeof process !== 'undefined' && process.emitWarning) {
	          var e = new Error(errorMsg);
	          e.name = 'MaxListenersExceededWarning';
	          e.emitter = this;
	          e.count = count;
	          process.emitWarning(e);
	        } else {
	          logger.error(errorMsg);

	          if (logger.trace) {
	            logger.trace();
	          }
	        }
	      }

	      function EventEmitter(conf) {
	        this._events = {};
	        this._newListener = false;
	        this._removeListener = false;
	        this.verboseMemoryLeak = false;
	        configure.call(this, conf);
	      }
	      EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

	      //
	      // Attention, function return type now is array, always !
	      // It has zero elements if no any matches found and one or more
	      // elements (leafs) if there are matches
	      //
	      function searchListenerTree(handlers, type, tree, i) {
	        if (!tree) {
	          return [];
	        }
	        var listeners = [],
	            leaf,
	            len,
	            branch,
	            xTree,
	            xxTree,
	            isolatedBranch,
	            endReached,
	            typeLength = type.length,
	            currentType = type[i],
	            nextType = type[i + 1];
	        if (i === typeLength && tree._listeners) {
	          //
	          // If at the end of the event(s) list and the tree has listeners
	          // invoke those listeners.
	          //
	          if (typeof tree._listeners === 'function') {
	            handlers && handlers.push(tree._listeners);
	            return [tree];
	          } else {
	            for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
	              handlers && handlers.push(tree._listeners[leaf]);
	            }
	            return [tree];
	          }
	        }

	        if (currentType === '*' || currentType === '**' || tree[currentType]) {
	          //
	          // If the event emitted is '*' at this part
	          // or there is a concrete match at this patch
	          //
	          if (currentType === '*') {
	            for (branch in tree) {
	              if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
	                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 1));
	              }
	            }
	            return listeners;
	          } else if (currentType === '**') {
	            endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === '*';
	            if (endReached && tree._listeners) {
	              // The next element has a _listeners, add it to the handlers.
	              listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
	            }

	            for (branch in tree) {
	              if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
	                if (branch === '*' || branch === '**') {
	                  if (tree[branch]._listeners && !endReached) {
	                    listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
	                  }
	                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
	                } else if (branch === nextType) {
	                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 2));
	                } else {
	                  // No match on this one, shift into the tree but not in the type array.
	                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
	                }
	              }
	            }
	            return listeners;
	          }

	          listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i + 1));
	        }

	        xTree = tree['*'];
	        if (xTree) {
	          //
	          // If the listener tree will allow any match for this part,
	          // then recursively explore all branches of the tree
	          //
	          searchListenerTree(handlers, type, xTree, i + 1);
	        }

	        xxTree = tree['**'];
	        if (xxTree) {
	          if (i < typeLength) {
	            if (xxTree._listeners) {
	              // If we have a listener on a '**', it will catch all, so add its handler.
	              searchListenerTree(handlers, type, xxTree, typeLength);
	            }

	            // Build arrays of matching next branches and others.
	            for (branch in xxTree) {
	              if (branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
	                if (branch === nextType) {
	                  // We know the next element will match, so jump twice.
	                  searchListenerTree(handlers, type, xxTree[branch], i + 2);
	                } else if (branch === currentType) {
	                  // Current node matches, move into the tree.
	                  searchListenerTree(handlers, type, xxTree[branch], i + 1);
	                } else {
	                  isolatedBranch = {};
	                  isolatedBranch[branch] = xxTree[branch];
	                  searchListenerTree(handlers, type, { '**': isolatedBranch }, i + 1);
	                }
	              }
	            }
	          } else if (xxTree._listeners) {
	            // We have reached the end and still on a '**'
	            searchListenerTree(handlers, type, xxTree, typeLength);
	          } else if (xxTree['*'] && xxTree['*']._listeners) {
	            searchListenerTree(handlers, type, xxTree['*'], typeLength);
	          }
	        }

	        return listeners;
	      }

	      function growListenerTree(type, listener) {

	        type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

	        //
	        // Looks for two consecutive '**', if so, don't add the event at all.
	        //
	        for (var i = 0, len = type.length; i + 1 < len; i++) {
	          if (type[i] === '**' && type[i + 1] === '**') {
	            return;
	          }
	        }

	        var tree = this.listenerTree;
	        var name = type.shift();

	        while (name !== undefined) {

	          if (!tree[name]) {
	            tree[name] = {};
	          }

	          tree = tree[name];

	          if (type.length === 0) {

	            if (!tree._listeners) {
	              tree._listeners = listener;
	            } else {
	              if (typeof tree._listeners === 'function') {
	                tree._listeners = [tree._listeners];
	              }

	              tree._listeners.push(listener);

	              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
	                tree._listeners.warned = true;
	                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
	              }
	            }
	            return true;
	          }
	          name = type.shift();
	        }
	        return true;
	      }

	      // By default EventEmitters will print a warning if more than
	      // 10 listeners are added to it. This is a useful default which
	      // helps finding memory leaks.
	      //
	      // Obviously not all Emitters should be limited to 10. This function allows
	      // that to be increased. Set to zero for unlimited.

	      EventEmitter.prototype.delimiter = '.';

	      EventEmitter.prototype.setMaxListeners = function (n) {
	        if (n !== undefined) {
	          this._maxListeners = n;
	          if (!this._conf) {
	            this._conf = {};
	          }
	          this._conf.maxListeners = n;
	        }
	      };

	      EventEmitter.prototype.event = '';

	      EventEmitter.prototype.once = function (event, fn) {
	        return this._once(event, fn, false);
	      };

	      EventEmitter.prototype.prependOnceListener = function (event, fn) {
	        return this._once(event, fn, true);
	      };

	      EventEmitter.prototype._once = function (event, fn, prepend) {
	        this._many(event, 1, fn, prepend);
	        return this;
	      };

	      EventEmitter.prototype.many = function (event, ttl, fn) {
	        return this._many(event, ttl, fn, false);
	      };

	      EventEmitter.prototype.prependMany = function (event, ttl, fn) {
	        return this._many(event, ttl, fn, true);
	      };

	      EventEmitter.prototype._many = function (event, ttl, fn, prepend) {
	        var self = this;

	        if (typeof fn !== 'function') {
	          throw new Error('many only accepts instances of Function');
	        }

	        function listener() {
	          if (--ttl === 0) {
	            self.off(event, listener);
	          }
	          return fn.apply(this, arguments);
	        }

	        listener._origin = fn;

	        this._on(event, listener, prepend);

	        return self;
	      };

	      EventEmitter.prototype.emit = function () {

	        this._events || init.call(this);

	        var type = arguments[0];

	        if (type === 'newListener' && !this._newListener) {
	          if (!this._events.newListener) {
	            return false;
	          }
	        }

	        var al = arguments.length;
	        var args, l, i, j;
	        var handler;

	        if (this._all && this._all.length) {
	          handler = this._all.slice();
	          if (al > 3) {
	            args = new Array(al);
	            for (j = 0; j < al; j++) {
	              args[j] = arguments[j];
	            }
	          }

	          for (i = 0, l = handler.length; i < l; i++) {
	            this.event = type;
	            switch (al) {
	              case 1:
	                handler[i].call(this, type);
	                break;
	              case 2:
	                handler[i].call(this, type, arguments[1]);
	                break;
	              case 3:
	                handler[i].call(this, type, arguments[1], arguments[2]);
	                break;
	              default:
	                handler[i].apply(this, args);
	            }
	          }
	        }

	        if (this.wildcard) {
	          handler = [];
	          var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
	        } else {
	          handler = this._events[type];
	          if (typeof handler === 'function') {
	            this.event = type;
	            switch (al) {
	              case 1:
	                handler.call(this);
	                break;
	              case 2:
	                handler.call(this, arguments[1]);
	                break;
	              case 3:
	                handler.call(this, arguments[1], arguments[2]);
	                break;
	              default:
	                args = new Array(al - 1);
	                for (j = 1; j < al; j++) {
	                  args[j - 1] = arguments[j];
	                }
	                handler.apply(this, args);
	            }
	            return true;
	          } else if (handler) {
	            // need to make copy of handlers because list can change in the middle
	            // of emit call
	            handler = handler.slice();
	          }
	        }

	        if (handler && handler.length) {
	          if (al > 3) {
	            args = new Array(al - 1);
	            for (j = 1; j < al; j++) {
	              args[j - 1] = arguments[j];
	            }
	          }
	          for (i = 0, l = handler.length; i < l; i++) {
	            this.event = type;
	            switch (al) {
	              case 1:
	                handler[i].call(this);
	                break;
	              case 2:
	                handler[i].call(this, arguments[1]);
	                break;
	              case 3:
	                handler[i].call(this, arguments[1], arguments[2]);
	                break;
	              default:
	                handler[i].apply(this, args);
	            }
	          }
	          return true;
	        } else if (!this._all && type === 'error') {
	          if (arguments[1] instanceof Error) {
	            throw arguments[1]; // Unhandled 'error' event
	          } else {
	            throw new Error('Uncaught, unspecified \'error\' event.');
	          }
	        }

	        return !!this._all;
	      };

	      EventEmitter.prototype.emitAsync = function () {

	        this._events || init.call(this);

	        var type = arguments[0];

	        if (type === 'newListener' && !this._newListener) {
	          if (!this._events.newListener) {
	            return Promise.resolve([false]);
	          }
	        }

	        var promises = [];

	        var al = arguments.length;
	        var args, l, i, j;
	        var handler;

	        if (this._all) {
	          if (al > 3) {
	            args = new Array(al);
	            for (j = 1; j < al; j++) {
	              args[j] = arguments[j];
	            }
	          }
	          for (i = 0, l = this._all.length; i < l; i++) {
	            this.event = type;
	            switch (al) {
	              case 1:
	                promises.push(this._all[i].call(this, type));
	                break;
	              case 2:
	                promises.push(this._all[i].call(this, type, arguments[1]));
	                break;
	              case 3:
	                promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
	                break;
	              default:
	                promises.push(this._all[i].apply(this, args));
	            }
	          }
	        }

	        if (this.wildcard) {
	          handler = [];
	          var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
	        } else {
	          handler = this._events[type];
	        }

	        if (typeof handler === 'function') {
	          this.event = type;
	          switch (al) {
	            case 1:
	              promises.push(handler.call(this));
	              break;
	            case 2:
	              promises.push(handler.call(this, arguments[1]));
	              break;
	            case 3:
	              promises.push(handler.call(this, arguments[1], arguments[2]));
	              break;
	            default:
	              args = new Array(al - 1);
	              for (j = 1; j < al; j++) {
	                args[j - 1] = arguments[j];
	              }
	              promises.push(handler.apply(this, args));
	          }
	        } else if (handler && handler.length) {
	          handler = handler.slice();
	          if (al > 3) {
	            args = new Array(al - 1);
	            for (j = 1; j < al; j++) {
	              args[j - 1] = arguments[j];
	            }
	          }
	          for (i = 0, l = handler.length; i < l; i++) {
	            this.event = type;
	            switch (al) {
	              case 1:
	                promises.push(handler[i].call(this));
	                break;
	              case 2:
	                promises.push(handler[i].call(this, arguments[1]));
	                break;
	              case 3:
	                promises.push(handler[i].call(this, arguments[1], arguments[2]));
	                break;
	              default:
	                promises.push(handler[i].apply(this, args));
	            }
	          }
	        } else if (!this._all && type === 'error') {
	          if (arguments[1] instanceof Error) {
	            return Promise.reject(arguments[1]); // Unhandled 'error' event
	          } else {
	            return Promise.reject('Uncaught, unspecified \'error\' event.');
	          }
	        }

	        return Promise.all(promises);
	      };

	      EventEmitter.prototype.on = function (type, listener) {
	        return this._on(type, listener, false);
	      };

	      EventEmitter.prototype.prependListener = function (type, listener) {
	        return this._on(type, listener, true);
	      };

	      EventEmitter.prototype.onAny = function (fn) {
	        return this._onAny(fn, false);
	      };

	      EventEmitter.prototype.prependAny = function (fn) {
	        return this._onAny(fn, true);
	      };

	      EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	      EventEmitter.prototype._onAny = function (fn, prepend) {
	        if (typeof fn !== 'function') {
	          throw new Error('onAny only accepts instances of Function');
	        }

	        if (!this._all) {
	          this._all = [];
	        }

	        // Add the function to the event listener collection.
	        if (prepend) {
	          this._all.unshift(fn);
	        } else {
	          this._all.push(fn);
	        }

	        return this;
	      };

	      EventEmitter.prototype._on = function (type, listener, prepend) {
	        if (typeof type === 'function') {
	          this._onAny(type, listener);
	          return this;
	        }

	        if (typeof listener !== 'function') {
	          throw new Error('on only accepts instances of Function');
	        }
	        this._events || init.call(this);

	        // To avoid recursion in the case that type == "newListeners"! Before
	        // adding it to the listeners, first emit "newListeners".
	        if (this._newListener) {
	          this.emit('newListener', type, listener);
	        }

	        if (this.wildcard) {
	          growListenerTree.call(this, type, listener);
	          return this;
	        }

	        if (!this._events[type]) {
	          // Optimize the case of one listener. Don't need the extra array object.
	          this._events[type] = listener;
	        } else {
	          if (typeof this._events[type] === 'function') {
	            // Change to array.
	            this._events[type] = [this._events[type]];
	          }

	          // If we've already got an array, just add
	          if (prepend) {
	            this._events[type].unshift(listener);
	          } else {
	            this._events[type].push(listener);
	          }

	          // Check for listener leak
	          if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
	            this._events[type].warned = true;
	            logPossibleMemoryLeak.call(this, this._events[type].length, type);
	          }
	        }

	        return this;
	      };

	      EventEmitter.prototype.off = function (type, listener) {
	        if (typeof listener !== 'function') {
	          throw new Error('removeListener only takes instances of Function');
	        }

	        var handlers,
	            leafs = [];

	        if (this.wildcard) {
	          var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
	        } else {
	          // does not use listeners(), so no side effect of creating _events[type]
	          if (!this._events[type]) {
	            return this;
	          }
	          handlers = this._events[type];
	          leafs.push({ _listeners: handlers });
	        }

	        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
	          var leaf = leafs[iLeaf];
	          handlers = leaf._listeners;
	          if (isArray(handlers)) {

	            var position = -1;

	            for (var i = 0, length = handlers.length; i < length; i++) {
	              if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
	                position = i;
	                break;
	              }
	            }

	            if (position < 0) {
	              continue;
	            }

	            if (this.wildcard) {
	              leaf._listeners.splice(position, 1);
	            } else {
	              this._events[type].splice(position, 1);
	            }

	            if (handlers.length === 0) {
	              if (this.wildcard) {
	                delete leaf._listeners;
	              } else {
	                delete this._events[type];
	              }
	            }
	            if (this._removeListener) {
	              this.emit('removeListener', type, listener);
	            }

	            return this;
	          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
	            if (this.wildcard) {
	              delete leaf._listeners;
	            } else {
	              delete this._events[type];
	            }
	            if (this._removeListener) {
	              this.emit('removeListener', type, listener);
	            }
	          }
	        }

	        function recursivelyGarbageCollect(root) {
	          if (root === undefined) {
	            return;
	          }
	          var keys = Object.keys(root);
	          for (var i in keys) {
	            var key = keys[i];
	            var obj = root[key];
	            if (obj instanceof Function || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
	              continue;
	            }
	            if (Object.keys(obj).length > 0) {
	              recursivelyGarbageCollect(root[key]);
	            }
	            if (Object.keys(obj).length === 0) {
	              delete root[key];
	            }
	          }
	        }
	        recursivelyGarbageCollect(this.listenerTree);

	        return this;
	      };

	      EventEmitter.prototype.offAny = function (fn) {
	        var i = 0,
	            l = 0,
	            fns;
	        if (fn && this._all && this._all.length > 0) {
	          fns = this._all;
	          for (i = 0, l = fns.length; i < l; i++) {
	            if (fn === fns[i]) {
	              fns.splice(i, 1);
	              if (this._removeListener) {
	                this.emit('removeListenerAny', fn);
	              }
	              return this;
	            }
	          }
	        } else {
	          fns = this._all;
	          if (this._removeListener) {
	            for (i = 0, l = fns.length; i < l; i++) {
	              this.emit('removeListenerAny', fns[i]);
	            }
	          }
	          this._all = [];
	        }
	        return this;
	      };

	      EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

	      EventEmitter.prototype.removeAllListeners = function (type) {
	        if (type === undefined) {
	          !this._events || init.call(this);
	          return this;
	        }

	        if (this.wildcard) {
	          var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	          var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

	          for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
	            var leaf = leafs[iLeaf];
	            leaf._listeners = null;
	          }
	        } else if (this._events) {
	          this._events[type] = null;
	        }
	        return this;
	      };

	      EventEmitter.prototype.listeners = function (type) {
	        if (this.wildcard) {
	          var handlers = [];
	          var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
	          return handlers;
	        }

	        this._events || init.call(this);

	        if (!this._events[type]) {
	          this._events[type] = [];
	        }
	        if (!isArray(this._events[type])) {
	          this._events[type] = [this._events[type]];
	        }
	        return this._events[type];
	      };

	      EventEmitter.prototype.eventNames = function () {
	        return Object.keys(this._events);
	      };

	      EventEmitter.prototype.listenerCount = function (type) {
	        return this.listeners(type).length;
	      };

	      EventEmitter.prototype.listenersAny = function () {

	        if (this._all) {
	          return this._all;
	        } else {
	          return [];
	        }
	      };

	      function ext(obj, key, val) {
	        if (key in obj) {
	          Object.defineProperty(obj, key, {
	            value: val,
	            enumerable: true,
	            configurable: true,
	            writable: true
	          });
	        } else {
	          obj[key] = val;
	        }

	        return obj;
	      }

	      var RunType = {
	        APP: 'micro_app',
	        GAME: 'micro_game',
	        DEVTOOLS: 'ide'
	      };

	      var ThirdScriptErrorKey = {};
	      ext(ThirdScriptErrorKey, RunType.APP, 'thirdScriptError');
	      ext(ThirdScriptErrorKey, RunType.GAME, 'gameThirdScriptError');

	      var APIKeyId = {
	        createRequestTask: 1,
	        operateRequestTask: 2,
	        createUploadTask: 3,
	        operateUploadTask: 4,
	        createDownloadTask: 5,
	        operateDownloadTask: 6,
	        setAudioState: 7,
	        getAudioState: 8,
	        operateAudio: 9,
	        createAudioInstance: 10,
	        destroyAudioInstance: 11,
	        operateRecorder: 12,
	        chooseVideo: 13,
	        saveVideoToPhotosAlbum: 14,
	        saveFile: 15,
	        getStorage: 16,
	        setStorage: 17,
	        removeStorage: 18,
	        removeStorageSync: 19,
	        clearStorage: 20,
	        getStorageInfo: 21,
	        getStorageInfoSync: 22,
	        openLocation: 23,
	        getSystemInfo: 24,
	        getSystemInfoSync: 25,
	        getNetworkType: 26,
	        getConnectedWifi: 27,
	        getClipboardData: 28,
	        setClipboardData: 29,
	        setKeepScreenOn: 30,
	        enableAccelerometer: 31,
	        vibrateShort: 32,
	        vibrateLong: 33,
	        showModal: 34,
	        showToast: 35,
	        hideToast: 36,
	        showActionSheet: 37,
	        redirectTo: 38,
	        reLaunch: 39,
	        navigateTo: 40,
	        switchTab: 41,
	        navigateBack: 42,
	        protocolPathToAbsPath: 43,
	        base64ToTempFilePath: 44,
	        makePhoneCall: 45,
	        login: 46,
	        checkSession: 47,
	        getUserInfo: 48,
	        getUseDuration: 49,
	        dealUserRelation: 50,
	        requestPayment: 51,
	        chooseAddress: 52,
	        setKeyboardValue: 53,
	        hideKeyboard: 54,
	        getCurrentRoute: 55,
	        getPhoneNumber: 56,
	        initReady: 57,
	        showKeyboard: 58,
	        showDatePickerView: 59,
	        insertVideoPlayer: 60,
	        removeVideoPlayer: 61,
	        webViewReadyToTerminate: 62,
	        getFileInfo: 63,
	        getSavedFileList: 64,
	        removeSavedFile: 65,
	        saveFileSync: 66,
	        readFile: 67,
	        readFileSync: 68,
	        writeFileSync: 69,
	        mkdirSync: 70,
	        readdirSync: 71,
	        rmdirSync: 72,
	        accessSync: 73,
	        unlinkSync: 74,
	        statSync: 75,
	        renameSync: 76,
	        copyFile: 77,
	        copyFileSync: 78,
	        unzip: 79,
	        getMenuButtonBoundingClientRect: 80,
	        updateKeyboard: 81,
	        exitMiniProgram: 82,
	        getLaunchOptionsSync: 83,
	        showShareMenu: 84,
	        hideShareMenu: 85,
	        getShareInfo: 86,
	        shareAppMessageDirectly: 87,
	        updateShareMenu: 88,
	        shareVideo: 89,
	        startCompass: 90,
	        stopCompass: 91,
	        startGameRecord: 92,
	        stopGameRecord: 93,
	        chooseImage: 94,
	        previewImage: 95,
	        getImageInfo: 96,
	        saveImageToPhotosAlbum: 97,
	        authorize: 98,
	        insertContainer: 99,
	        updateContainer: 100,
	        removeContainer: 101,
	        updateInput: 102,
	        showPickerView: 104,
	        showMultiPickerView: 105,
	        updateMultiPickerView: 106,
	        disableScrollBounce: 107,
	        removeTextArea: 108,
	        insertTextArea: 109,
	        updateTextArea: 110,
	        insertHTMLWebView: 111,
	        removeHTMLWebView: 112,
	        updateHTMLWebView: 113,
	        createSocketTask: 114,
	        operateSocketTask: 115,
	        getLocation: 116,
	        scanCode: 117,
	        startPullDownRefresh: 118,
	        stopPullDownRefresh: 119,
	        getSetting: 120,
	        openSetting: 121,
	        resumeGameRecord: 122,
	        getCloudStorageByRelation: 123,
	        getUserCloudStorage: 124,
	        removeUserCloudStorage: 125,
	        setUserCloudStorage: 126,
	        openUserProfile: 127,
	        pauseGameRecord: 128,
	        operateVideoAd: 129,
	        createVideoAd: 130,
	        getGeneralInfo: 131,
	        tma_login: 132,
	        openSchema: 133,
	        getVideoManager: 134,
	        createFaceDetector: 135,
	        requestCamera: 136,
	        createOffscreenVideo: 137,
	        reportAnalytics: 138,
	        requestGamePayment: 139,
	        operateScreenRecorder: 140
	      };

	      // 宿主实现的私有方法
	      var HostMethodId = {
	        // 头条
	        tt_checkIsFollowUser: 5000,
	        tt_requestFollowUser: 5001,
	        // 抖音
	        aweme_addFriend: 6000
	      };

	      var SpeedValueType = {
	        webview2AppService: 1,
	        appService2Webview: 2,
	        funcReady: 3,
	        firstGetData: 4,
	        firstRenderTime: 5,
	        reRenderTime: 6,
	        forceUpdateRenderTime: 7,
	        appRoute2newPage: 8,
	        newPage2pageReady: 9,
	        thirdScriptRunTime: 10,
	        pageframe: 11,
	        WAWebview: 12,
	        WAWidget: 13,
	        widgetCanvasReady: 14,
	        widgetFirstDataPush: 15
	      };

	      var ErrorType = {
	        appServiceSDKScriptError: 1,
	        webviewSDKScriptError: 2,
	        jsEngineScriptError: 3,
	        thirdScriptError: 4,
	        webviewScriptError: 5,
	        parserScriptError: 6
	      };

	      // 什么类型的错误需要交给 sentry 处理
	      var SENTRY_ERROR = [1, 2, 3, 5, 6];

	      function safeBridgeInvoke(callback) {
	        ttJSBridge$1 !== undefined ? callback() : document.addEventListener('ttJSBridgeReady', callback, false);
	      }

	      function _invoke$1() {
	        var args = arguments;
	        safeBridgeInvoke(function () {
	          ttJSBridge$1.invoke.apply(ttJSBridge$1, args);
	        });
	      }

	      var systemInfo = {};

	      function _checkObjectKeys(obj) {
	        var keysArr = [];
	        for (var key in obj) {
	          keysArr.push(key);
	        }
	        return keysArr.length;
	      }

	      function getSystemInfoSync() {
	        if (!_checkObjectKeys(systemInfo)) {
	          _invoke$1('getSystemInfoSync', {}, function (res) {
	            var isOk = res.errMsg.indexOf('getSystemInfoSync:ok') === 0;
	            if (isOk) {
	              systemInfo = res;
	            }
	          });
	        }

	        return systemInfo;
	      }

	      function safeBridgeInvoke$1(callback) {
	        ttJSBridge$1 !== undefined ? callback() : document.addEventListener('ttJSBridgeReady', callback, false);
	      }

	      function _invoke$2() {
	        var args = arguments;
	        safeBridgeInvoke$1(function () {
	          ttJSBridge$1.invoke.apply(ttJSBridge$1, args);
	        });
	      }

	      function _publish$1() {
	        var args = arguments;
	        safeBridgeInvoke$1(function () {
	          ttJSBridge$1.publish.apply(ttJSBridge$1, args);
	        });
	      }

	      // 上报错误信息至 sentry
	      // 错误信息指除第三方开发者的错误信息
	      function invokeSentryReport(_ref) {
	        var url = _ref.url,
	            method = _ref.method,
	            header = _ref.header,
	            data = _ref.data;

	        _invoke$2('sentryReport', {
	          url: url,
	          method: method,
	          header: header,
	          data: data
	        });
	      }

	      // 将数据发给客户端，然后使用 APP Log3.0 发送至数据平台
	      // 数据上报均基于此接口
	      function invokeReportCustom(data) {
	        var _systemInfo = getSystemInfoSync();
	        var logData = {
	          tag: data.tag || '',
	          data: {
	            mp_id: (typeof TMAConfig === 'undefined' ? 'undefined' : _typeof(TMAConfig)) === 'object' && TMAConfig !== null && TMAConfig.appId || '',
	            lib_version: _systemInfo.SDKUpdateVersion || '1.0.0.0',
	            _param_for_special: Reporter$1.getRunType()
	          }
	        };
	        Object.assign(logData.data, data.data);
	        _invoke$2('systemLog', logData, function () {
	          typeof data.cb === 'function' && data.cb();
	        });
	      }

	      function surroundTryCatch(func) {
	        return function () {
	          try {
	            return func.apply(func, arguments);
	          } catch (err) {
	            logger.error('reporter error: ' + (err && err.message));
	          }
	        };
	      }

	      var lastSpeedReportTime = 0;
	      var lastWebviewErrorMsg = '';
	      var globalRoute = '';
	      var globalMethod = '';
	      var sentry = null;
	      var exeWebviewErrorMsg = function exeWebviewErrorMsg() {};
	      var RunType$1 = RunType.APP;

	      var Constructor = {
	        // 包装第三方回调
	        surroundThirdByTryCatch: function surroundThirdByTryCatch(func, errTip) {
	          var msg = '';
	          if (globalRoute) {
	            msg = 'at ' + globalRoute + ' ' + globalMethod + ' function;';
	          }

	          return function () {
	            var res;
	            try {
	              var startTime = Date.now();
	              res = func.apply(func, arguments);
	              var cost = Date.now() - startTime;
	              if (cost > 1e3) {
	                // 执行过慢
	                Constructor.slowReport({
	                  key: 'apiCallBack',
	                  cost: cost,
	                  extend: msg + errTip
	                });
	              }
	            } catch (err) {
	              // 第三方错误
	              Constructor.thirdErrorReport({
	                error: err,
	                extend: msg + errTip
	              });
	            }
	            return res;
	          };
	        },
	        // 运行过慢统计上报
	        slowReport: function slowReport(param) {
	          // 第三方执行过慢，缺少可视化工具，暂时不作处理
	          return;
	        },
	        // 速度、性能统计上报
	        speedReport: function speedReport(param) {
	          var key = param.key,
	              data = param.data,
	              timeMark = param.timeMark,
	              force = param.force,
	              eventName = param.eventName;
	          var startTime = timeMark.startTime,
	              endTime = timeMark.endTime;

	          var speedValueType = SpeedValueType && SpeedValueType[key];
	          var now = Date.now();
	          var strLength = 0;

	          if (speedValueType && startTime && endTime && (force || now - lastSpeedReportTime >= 500)) {
	            data && (strLength = JSON.stringify(data).length);
	            lastSpeedReportTime = now;
	            var tag = 'mp_speed_analysis';
	            // 上传至数据平台
	            // 如果是 subscribe/publish, 会有 event_name(绑定的消息)/total_duration(publish => native => subscribe)
	            invokeReportCustom({
	              tag: tag,
	              data: {
	                speed_value_type: key,
	                total_duration: endTime - startTime,
	                param_length: strLength || 0,
	                event_name: eventName || ''
	              }
	            });
	          }
	        },
	        // 第三方错误上报
	        thirdErrorReport: function thirdErrorReport(param) {
	          var error = param.error,
	              extend = param.extend;

	          Constructor.errorReport({
	            key: 'thirdScriptError',
	            error: error,
	            extend: extend
	          });
	        },
	        // 通用上报错误接口
	        errorReport: function errorReport(param) {
	          var key = param.key,
	              error = param.error,
	              extend = param.extend;

	          var errorType = ErrorType && ErrorType[key];
	          if (errorType) {
	            var errorString = extend ? error.message + ';' + extend : error.message;
	            var msg = key + '\n' + errorString + '\n' + error.stack;
	            logger.error(msg);
	            if (typeof window != 'undefined' && window.__webviewId__) {
	              // webview 的 error 发送至 jsCore
	              _publish$1('WEBVIEW_ERROR_MSG', {
	                data: {
	                  msg: msg
	                },
	                options: {
	                  timestamp: Date.now()
	                }
	              });
	            } else {
	              Constructor.triggerErrorMessage(msg);
	            }

	            if (SENTRY_ERROR.indexOf(errorType) > -1) {
	              if (_global.Sentry) {
	                if (!sentry) {
	                  sentry = new Sentry({
	                    key: 'ed6716196f0742d2bdee626bc665a2fe',
	                    project: '325',
	                    transportCallback: invokeSentryReport
	                  });
	                }
	                var _systemInfo = getSystemInfoSync();
	                sentry.report(error, {
	                  error_type: key,
	                  mp_id: (typeof TMAConfig === 'undefined' ? 'undefined' : _typeof(TMAConfig)) === 'object' && TMAConfig !== null && TMAConfig.appId || '',
	                  lib_version: _systemInfo.SDKUpdateVersion || '1.0.0.0',
	                  version_code: _systemInfo.version,
	                  run_type: Constructor.getRunType()
	                });
	              } else {
	                logger.error(msg);
	              }
	            } else {
	              return;
	              // 第三方错误暂时不处理
	              // var __id = `${errorType},${error.name},${encodeURIComponent(errorString)},${encodeURIComponent(error.stack)}`;

	              // // TODO 增加反馈错误的条件
	              // Constructor.reportKeyValue({
	              //     key: 'Error',
	              //     value: __id,
	              //     force: true
	              // });
	            }
	          }
	        },
	        registerErrorListener: function registerErrorListener(cb) {
	          if (typeof cb === 'function') {
	            exeWebviewErrorMsg = cb;
	          }
	        },
	        triggerErrorMessage: function triggerErrorMessage(msg) {
	          if (lastWebviewErrorMsg != msg) {
	            lastWebviewErrorMsg = msg;
	            setTimeout(function () {
	              try {
	                exeWebviewErrorMsg(msg);
	              } catch (e) {
	                logger.error(e.message + ' at onError callback function');
	              }
	            }, 0);
	          }
	        },

	        unRegisterErrorListener: function unRegisterErrorListener() {
	          exeWebviewErrorMsg = function exeWebviewErrorMsg() {};
	        },
	        // 个性化上传数据
	        customReport: function customReport() {
	          var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	              _ref2$tag = _ref2.tag,
	              tag = _ref2$tag === undefined ? '' : _ref2$tag,
	              _ref2$data = _ref2.data,
	              data = _ref2$data === undefined ? {} : _ref2$data,
	              cb = _ref2.cb;

	          invokeReportCustom({ tag: tag, data: data, cb: cb });
	        },
	        setAsGame: function setAsGame() {
	          RunType$1 = RunType.GAME;
	        },
	        saveAsDevtools: function saveAsDevtools() {
	          RunType$1 = RunType.DEVTOOLS;
	        },
	        getRunType: function getRunType() {
	          return RunType$1;
	        }
	      };

	      var Reporter$1 = {};

	      for (var funcName in Constructor) {
	        !function (fn) {
	          Reporter$1.__defineGetter__(fn, function () {
	            return surroundTryCatch(Constructor[fn]);
	          });
	        }(funcName);
	      }

	      Reporter$1.__defineSetter__('__route__', function (val) {
	        globalRoute = val;
	      });

	      Reporter$1.__defineSetter__('__method__', function (val) {
	        globalMethod = val;
	      });

	      typeof window != 'undefined' && (window.Reporter = Reporter$1);

	      typeof window != 'undefined' && (window.onbeforeunload = function () {
	        //    Constructor.submit();
	      });

	      /**
	       * 主要统计各个 API 的调用成功/失败情况，根据 API、错误信息和调用情况分别进行统计
	       */

	      // 上报队列
	      var okMap = {};
	      var failMap = {};
	      var cancelMap = {};
	      var lastReportTimestamp = 0;

	      function _trans(result, maps) {
	        var res = Object.keys(maps).filter(function (func) {
	          return APIKeyId[func] || HostMethodId[func];
	        }).map(function (func) {
	          return Object.keys(maps[func]).map(function (errMsg) {
	            // 压缩一下
	            var duration = maps[func][errMsg];
	            var count = duration.length;
	            var durationAmount = duration.reduce(function (total, current) {
	              return total + current;
	            }, 0);
	            var averageDuration = durationAmount / count;
	            return (APIKeyId[func] || HostMethodId[func]) + '|' + result + '|' + count + '|' + averageDuration + '|' + errMsg.replace(func, '');
	          });
	        });

	        return [].concat.apply([], res);
	      }

	      function clear() {
	        okMap = {};
	        failMap = {};
	        cancelMap = {};
	      }

	      function reportRealtimeAction() {
	        var okarray = _trans(1, okMap);
	        var failarray = _trans(2, failMap);
	        var cancelarray = _trans(3, cancelMap);
	        var dataArray = [].concat(okarray, failarray, cancelarray);

	        if (dataArray.length > 0) {
	          Reporter$1.customReport({
	            tag: 'mp_api_analysis',
	            data: {
	              api_data_array: dataArray
	            },
	            cb: clear
	          });
	        }
	      }

	      function reportJSAPI(func, isOk, isFail, isCancel, errMsg, duration) {
	        var evMap = isOk ? okMap : isFail ? failMap : cancelMap;

	        evMap[func] = evMap[func] || {};
	        evMap[func][errMsg] = (evMap[func][errMsg] || []).concat(duration);

	        if (Date.now() - lastReportTimestamp >= 3e4) {
	          lastReportTimestamp = Date.now();
	          setTimeout(reportRealtimeAction, 3e4);
	        }
	      }

	      // page-frame需要的全局ttJSBridge
	      Object.assign(window.ttJSBridge, ttJSBridge$1);

	      function safeUse(cb) {
	        cb();
	      }

	      function invoke() {
	        var e = arguments;
	        safeUse(function () {
	          ttJSBridge.invoke.apply(ttJSBridge, e);
	        });
	      }

	      function on() {
	        var e = arguments;
	        safeUse(function () {
	          ttJSBridge.on.apply(ttJSBridge, e);
	        });
	      }

	      function publish() {
	        var args = Array.prototype.slice.call(arguments);
	        args[1] = {
	          data: args[1],
	          options: {
	            timestamp: Date.now()
	          }
	        };
	        safeUse(function () {
	          ttJSBridge.publish.apply(ttJSBridge, args);
	        });
	      }

	      function subscribe() {
	        var args = Array.prototype.slice.call(arguments),
	            originCallback = args[1];
	        args[1] = function (res, wvid) {

	          if (typeof res == 'string') {
	            res = JSON.parse(res);
	          }
	          var data = res.data,
	              options = res.options;
	          // var startTime = options && options.timestamp || 0;
	          // var endTime = Date.now();
	          // var option = arguments[2] || {};

	          if (typeof originCallback == 'function') {
	            originCallback(data, wvid);
	            // appService2Webview time
	            // Reporter.speedReport({
	            //   key: 'appService2Webview',
	            //   data: data || {},
	            //   timeMark: {
	            //     startTime,
	            //     endTime,
	            //     nativeTime: option.nativeTime || 0,
	            //   },
	            //   eventName: args[0],
	            // });
	          }
	        };
	        safeUse(function () {
	          ttJSBridge.subscribe.apply(ttJSBridge, args);
	        });
	      }

	      function invokeMethod(api) {
	        var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	        var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	        var invokeStartTime = Date.now();
	        var customs = {};
	        for (var key in param) {
	          'function' == typeof param[key] && (customs[key] = param[key], delete param[key]);
	        }

	        invoke(api, param, function (res) {
	          var invokeEndTime = Date.now();

	          res.errMsg = res.errMsg || api + ':ok';
	          var isOk = 0 === res.errMsg.indexOf(api + ':ok'),
	              isCancel = 0 === res.errMsg.indexOf(api + ':cancel'),
	              isFail = 0 === res.errMsg.indexOf(api + ':fail');
	          'function' == typeof option.beforeAll && option.beforeAll(res);
	          isOk ? ('function' == typeof option.beforeSuccess && option.beforeSuccess(res), 'function' == typeof customs.success && customs.success(res), 'function' == typeof option.afterSuccess && option.afterSuccess(res)) : isCancel ? ('function' == typeof customs.cancel && customs.cancel(res), 'function' == typeof option.cancel && option.cancel(res)) : isFail && ('function' == typeof option.beforeFail && option.beforeFail(res), 'function' == typeof customs.fail && customs.fail(res), 'function' == typeof option.afterFail && option.afterFail(res));
	          'function' == typeof customs.complete && customs.complete(res);
	          'function' == typeof option.afterAll && option.afterAll(res);

	          // 统计使用情况
	          reportJSAPI(api, isOk, isFail, isCancel, res.errMsg, invokeEndTime - invokeStartTime);
	        });
	      }

	      function onMethod(e, t) {
	        on(e, t);
	      }

	      var emitter = new EventEmitter();

	      function getRealRoute() {
	        var relative = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

	        if (0 === path.indexOf('/')) {
	          return path.substr(1);
	        }
	        if (0 === path.indexOf('./')) {
	          return getRealRoute(relative, path.substr(2));
	        }
	        var n,
	            i,
	            r = path.split('/');
	        for (n = 0, i = r.length; n < i && '..' === r[n]; n++) {}
	        r.splice(0, n);
	        path = r.join('/');
	        var o = relative.length > 0 ? relative.split('/') : [];
	        return o.splice(o.length - n - 1, n + 1), o.concat(r).join('/');
	      }

	      function getPlatform() {
	        var ua = window.navigator.userAgent.toLowerCase();
	        return (/(iphone|ipad)/.test(ua) ? 'ios' : /android/.test(ua) ? 'android' : undefined
	        );
	      }

	      var WebviewSdkKnownError = function (_Error) {
	        inherits(WebviewSdkKnownError, _Error);

	        function WebviewSdkKnownError(msg) {
	          classCallCheck(this, WebviewSdkKnownError);

	          var _this = possibleConstructorReturn(this, _Error.call(this, 'Webview-SDK:' + msg));

	          _this.type = 'WebviewSdkKnownError';
	          return _this;
	        }

	        return WebviewSdkKnownError;
	      }(Error);

	      function surroundByTryCatch(func, msg) {
	        return function () {
	          try {
	            return func.apply(func, arguments);
	          } catch (err) {
	            if (Object.prototype.toString.apply(err) === '[object Error]') {
	              if ('WebviewSdkKnownError' == err.type) {
	                throw err;
	              }
	              Reporter.errorReport({
	                key: 'webviewSDKScriptError',
	                error: err,
	                extend: msg
	              });
	            }
	          }
	        };
	      }

	      var cbid = 0;
	      var customMethods = [];
	      var privateMethods = [];
	      var noop$1 = function noop() {};

	      function invokeAppServiceMethod(option) {
	        var name = option.name;
	        var type = option.type === undefined ? "sdk" : option.type; // type有custom bridge 不传
	        var args = option.args === undefined ? {} : option.args;
	        var ext = option.ext === undefined ? {} : option.ext;
	        customMethods[cbid] = {
	          success: args.success || noop$1,
	          fail: args.fail || noop$1,
	          complete: args.complete || noop$1
	        };
	        privateMethods[cbid] = {
	          beforeAll: ext.beforeAll || noop$1,
	          beforeSuccess: ext.beforeSuccess || noop$1,
	          afterSuccess: ext.afterSuccess || noop$1,
	          beforeFail: ext.beforeFail || noop$1,
	          afterFail: ext.afterFail || noop$1,
	          afterAll: ext.afterAll || noop$1
	        };

	        publish("invokeAppServiceMethod", {
	          name: name,
	          type: type,
	          args: args,
	          callbackId: cbid
	        });
	        cbid += 1;
	      }
	      subscribe("callbackAppServiceMethod", function (e) {
	        var t = e.res,
	            isOk = e.isSuccess,
	            i = e.callbackId,
	            customs = customMethods[i],
	            privates = privateMethods[i];
	        privates.beforeAll(t);
	        isOk ? (privates.beforeSuccess(t), customs.success(t), privates.afterSuccess(t)) : (privates.beforeFail(t), customs.fail(t), privates.afterFail(t));
	        customs.complete(t);
	        privates.afterAll(t);
	      });

	      function transformRpx(str) {
	        if (typeof str !== 'string') {
	          return str;
	        }
	        var state = 0;
	        var res = '',
	            number = '';
	        for (var i = 0, l = str.length; i < l; i++) {
	          var char = str[i];
	          if (state === 1) {
	            if (char === '\n' || char === '\r' || char === ' ' && res.slice(-1) === ' ') {
	              continue;
	            }
	            if (char === '(' && res.slice(-4, -1) === 'url') {
	              state = 2;
	            }
	            if (char === ';') {
	              state = 0;
	            }
	            if (/[\d.]/.test(char) && i < l - 1) {
	              state = 3;
	              number += char;
	              continue;
	            }
	            res += char;
	          } else if (state === 2) {
	            if (char === ')') {
	              state = 1;
	            }
	            res += char;
	          } else if (state === 3) {
	            if (!/[\d.]/.test(char)) {
	              var safeNum = Number(number);
	              if (str.slice(i, i + 4).match(/rpx([\s;),}]|$)/) && !isNaN(safeNum)) {
	                res += window.rpx2px(safeNum) + 'px';
	                i += 2;
	              } else {
	                res += number;
	                res += char;
	              }
	              state = 1;
	              number = '';
	              continue;
	            }
	            number += char;
	            if (i === l - 1) {
	              // 结束了，number还没处理
	              res += number;
	            }
	          } else {
	            if (char === ':') {
	              state = 1;
	            }
	            res += char;
	          }
	        }

	        return res;
	      }

	      emitter.setMaxListeners(0);

	      // 注册监听 service 发来的调用
	      subscribe('invokeWebviewMethod', function (ev) {
	        emitter.emit(ev.name, ev.args, function (res) {
	          publish('callbackWebviewMethod', {
	            res: res,
	            callbackId: ev.callbackId
	          });
	        });
	      });

	      /** * console ** */
	      // 新页面初始化时，会接受core已经打过的log，做到任意页面都能看到全部core log的效果
	      // 加flag是为了防止重复收到广播
	      var vconsole_inited = false;
	      subscribe('vconsole_synchronize_logs', function (res) {
	        new VConsole({
	          defaultPlugins: ['log', 'system']
	        });
	        var logs = res.logs;
	        if (!vconsole_inited) {
	          vconsole_inited = true;
	          logs.forEach(function (_ref) {
	            var _console;

	            var method = _ref.method,
	                args = _ref.args;

	            /* eslint-disable no-console */
	            (_console = console)[method].apply(_console, args);
	          });
	        }
	      });

	      // 接收core传过来的log消息
	      var log_methods = ['log', 'warn', 'error', 'info', 'debug'];
	      log_methods.forEach(function (method) {
	        subscribe('vconsole_' + method, function (res) {
	          var _console2;

	          /* eslint-disable no-console */
	          (_console2 = console)[method].apply(_console2, res.log);
	        });
	      });

	      // 关键方法
	      document.addEventListener('generateFuncReady', function () {
	        setTimeout(function () {
	          publish('GenerateFuncReady', {});
	        }, 20);
	      });
	      function getCurrentRoute(e) {
	        invokeMethod('getCurrentRoute', e, {
	          beforeSuccess: function beforeSuccess(e) {
	            e.route = e.route.split('?')[0];
	          }
	        });
	      }

	      var tt = {
	        invoke: invoke,
	        on: on,
	        publish: publish,
	        subscribe: subscribe,

	        transformRpx: transformRpx,

	        getPlatform: getPlatform,
	        getRealRoute: getRealRoute,

	        getPhoneNumber: function getPhoneNumber() {
	          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	          invokeMethod('getPhoneNumber', e);
	        },

	        showKeyboard: function showKeyboard(e) {
	          invokeMethod('showKeyboard', e);
	        },
	        showDatePickerView: function showDatePickerView(e) {
	          invokeMethod('showDatePickerView', e);
	        },
	        hideKeyboard: function hideKeyboard(e) {
	          invokeMethod('hideKeyboard', e);
	        },
	        insertVideoPlayer: function insertVideoPlayer(e) {
	          invokeMethod('insertVideoPlayer', e);
	        },
	        removeVideoPlayer: function removeVideoPlayer(e) {
	          invokeMethod('removeVideoPlayer', e);
	        },
	        webViewReadyToTerminate: function webViewReadyToTerminate(e) {
	          invokeMethod('webViewReadyToTerminate', e);
	        },
	        redirectTo: function redirectTo(e) {

	          invokeAppServiceMethod({
	            name: 'redirectTo',
	            args: e
	          });
	        },
	        navigateTo: function navigateTo(e) {

	          invokeAppServiceMethod({
	            name: 'navigateTo',
	            args: e
	          });
	        },
	        switchTab: function switchTab(e) {
	          invokeAppServiceMethod({
	            name: 'switchTab',
	            args: e
	          });
	        },
	        reLaunch: function reLaunch(e) {
	          invokeAppServiceMethod({
	            name: 'reLaunch',
	            args: e
	          });
	        },
	        navigateBack: function navigateBack(e) {
	          invokeAppServiceMethod({
	            name: 'navigateBack',
	            args: e
	          });
	        },
	        clearStorage: function clearStorage(e) {
	          invokeAppServiceMethod({
	            name: 'clearStorage',
	            args: e
	          });
	        },
	        getSystemInfo: function getSystemInfo(e) {
	          invokeAppServiceMethod({
	            name: 'getSystemInfo',
	            args: e
	          });
	        },
	        getHTMLLength: function getHTMLLength() {
	          return document.body.innerHTML.length;
	        },
	        getCurrentRoute: getCurrentRoute,
	        onRequestComponentInfo: function onRequestComponentInfo(e) {
	          subscribe('requestComponentInfo', e);
	        },
	        sendComponentInfo: function sendComponentInfo(e) {
	          publish('responseComponentInfo', e);
	        },
	        onRequestComponentObserver: function onRequestComponentObserver(e) {
	          subscribe('requestComponentObserver', e);
	        },
	        sendComponentObserver: function sendComponentObserver(e) {
	          publish('responseComponentObserver', e);
	        },
	        onWebViewWillManuallyTerminate: function onWebViewWillManuallyTerminate(e) {
	          onMethod('onWebViewWillManuallyTerminate', e);
	        },
	        onAppDataChange: function onAppDataChange(e) {
	          emitter.on('appDataChange', function (t, n) {
	            e(t, n);
	          });
	        },
	        onComponentDataChange: function onComponentDataChange(e) {
	          emitter.on('componentDataChange', function (t, n) {
	            e(t, n);
	          });
	        },
	        onTriggerComponentEvent: function onTriggerComponentEvent(e) {
	          emitter.on('triggerComponentEvent', function (t, n) {
	            e(t, n);
	          });
	        },
	        onSelectComponent: function onSelectComponent(e) {
	          emitter.on('selectComponent', function (t, n) {
	            e(t, n);
	          });
	        },
	        onSelectComponentInPage: function onSelectComponentInPage(e) {
	          emitter.on('selectComponentInPage', function (t, n) {
	            e(t, n);
	          });
	        },
	        onGetRelationNodes: function onGetRelationNodes(e) {
	          emitter.on('getRelationNodes', function (t, n) {
	            e(t, n);
	          });
	        },
	        onPageScrollTo: function onPageScrollTo(e) {
	          subscribe('pageScrollTo', function (t) {
	            e(t);
	          });
	        },
	        clearLog: function clearLog() {
	          publish('webviewClearLog');
	        },
	        // 重要方法
	        publishPageEvent: function publishPageEvent(e, t, n) {
	          publish('PAGE_EVENT', {
	            eventName: e,
	            data: t,
	            nodeId: n
	          });
	        },
	        publishComentEvent: function publishComentEvent(eventName, data, nodeId, islifetime, route) {
	          publish('COMPONENT_EVENT', {
	            eventName: eventName,
	            data: data,
	            nodeId: nodeId,
	            islifetime: islifetime,
	            route: route
	          });
	        },
	        publishComponentDataChange: function publishComponentDataChange(datatype, data, nodeId) {
	          publish('COMPONENT_DATA_CHANGE', {
	            datatype: datatype,
	            data: data,
	            nodeId: nodeId
	          });
	        },
	        publishComponentRelationChange: function publishComponentRelationChange(data) {
	          publish('COMPONENT_RELATION_CHANGE', {
	            data: data
	          });
	        },
	        dosomething: function dosomething() {},
	        getProtocolXPath: function getProtocolXPath(protocolPath, cb) {
	          invokeMethod('protocolPathToAbsPath', {
	            protocolPath: protocolPath
	          }, {
	            beforeAll: function beforeAll(res) {
	              cb(res.absPath);
	            }
	          });
	        },
	        addTimingDots: function addTimingDots(dots) {
	          publish('addTimingDots', {
	            timingMap: dots
	          });
	        },
	        setPerformance: function setPerformance() {
	          publish('setPerformance');
	        }
	      };

	      for (var fnc in tt) {
	        if (typeof tt[fnc] === 'function') {
	          tt[fnc] = surroundByTryCatch(tt[fnc], 'at tt.' + fnc);
	        }
	      }

	      // all es6 shim

	      exports.logger = logger$1;
	      exports.tt = tt;

	      return exports;
	    }({});
	    $glob$.tt = $glob$.wx = TMAWEBVIEW.tt; /* 提供对wxAPI支持 */
	    $glob$.logger = TMAWEBVIEW.logger;
	  })(window);

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  window.JSCompiler_renameProperty = function (prop) {
	    return prop;
	  };

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  var CSS_URL_RX = /(url\()([^)]*)(\))/g;
	  var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
	  var workingURL = void 0;
	  var resolveDoc = void 0;
	  /**
	   * Resolves the given URL against the provided `baseUri'.
	   *
	   * Note that this function performs no resolution for URLs that start
	   * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
	   * URL resolution, use `window.URL`.
	   *
	   * @param {string} url Input URL to resolve
	   * @param {?string=} baseURI Base URI to resolve the URL against
	   * @return {string} resolved URL
	   */
	  function resolveUrl(url, baseURI) {
	    if (url && ABS_URL.test(url)) {
	      return url;
	    }
	    // Lazy feature detection.
	    if (workingURL === undefined) {
	      workingURL = false;
	      try {
	        var u = new URL('b', 'http://a');
	        u.pathname = 'c%20d';
	        workingURL = u.href === 'http://a/c%20d';
	      } catch (e) {
	        // silently fail
	      }
	    }
	    if (!baseURI) {
	      baseURI = document.baseURI || window.location.href;
	    }
	    if (workingURL) {
	      return new URL(url, baseURI).href;
	    }
	    // Fallback to creating an anchor into a disconnected document.
	    if (!resolveDoc) {
	      resolveDoc = document.implementation.createHTMLDocument('temp');
	      resolveDoc.base = resolveDoc.createElement('base');
	      resolveDoc.head.appendChild(resolveDoc.base);
	      resolveDoc.anchor = resolveDoc.createElement('a');
	      resolveDoc.body.appendChild(resolveDoc.anchor);
	    }
	    resolveDoc.base.href = baseURI;
	    resolveDoc.anchor.href = url;
	    return resolveDoc.anchor.href || url;
	  }

	  /**
	   * Resolves any relative URL's in the given CSS text against the provided
	   * `ownerDocument`'s `baseURI`.
	   *
	   * @param {string} cssText CSS text to process
	   * @param {string} baseURI Base URI to resolve the URL against
	   * @return {string} Processed CSS text with resolved URL's
	   */
	  function resolveCss(cssText, baseURI) {
	    return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
	      return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
	    });
	  }

	  /**
	   * Returns a path from a given `url`. The path includes the trailing
	   * `/` from the url.
	   *
	   * @param {string} url Input URL to transform
	   * @return {string} resolved path
	   */
	  function pathFromUrl(url) {
	    return url.substring(0, url.lastIndexOf('/') + 1);
	  }

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */
	  var useShadow = !window.ShadyDOM;
	  var useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
	  var useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;

	  /**
	   * Globally settable property that is automatically assigned to
	   * `ElementMixin` instances, useful for binding in templates to
	   * make URL's relative to an application's root.  Defaults to the main
	   * document URL, but can be overridden by users.  It may be useful to set
	   * `rootPath` to provide a stable application mount path when
	   * using client side routing.
	   */
	  var rootPath = undefined || pathFromUrl(document.baseURI || window.location.href);

	  /**
	   * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:
	   *
	   *     Polymer = {
	   *       sanitizeDOMValue: function(value, name, type, node) { ... }
	   *     }
	   *
	   * Where:
	   *
	   * `value` is the value to sanitize.
	   * `name` is the name of an attribute or property (for example, href).
	   * `type` indicates where the value is being inserted: one of property, attribute, or text.
	   * `node` is the node where the value is being inserted.
	   *
	   * @type {(function(*,string,string,Node):*)|undefined}
	   */
	  var sanitizeDOMValue = undefined;

	  /**
	   * Globally settable property to make Polymer Gestures use passive TouchEvent listeners when recognizing gestures.
	   * When set to `true`, gestures made from touch will not be able to prevent scrolling, allowing for smoother
	   * scrolling performance.
	   * Defaults to `false` for backwards compatibility.
	   */
	  var passiveTouchGestures = false;

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  // unique global id for deduping mixins.
	  var dedupeId = 0;

	  /* eslint-disable valid-jsdoc */
	  /**
	   * Wraps an ES6 class expression mixin such that the mixin is only applied
	   * if it has not already been applied its base argument. Also memoizes mixin
	   * applications.
	   *
	   * @template T
	   * @param {T} mixin ES6 class expression mixin to wrap
	   * @return {T}
	   * @suppress {invalidCasts}
	   */
	  var dedupingMixin = function (mixin) {
	    var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;
	    if (!mixinApplications) {
	      mixinApplications = new WeakMap();
	      /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;
	    }
	    // maintain a unique id for each mixin
	    var mixinDedupeId = dedupeId++;
	    function dedupingMixin(base) {
	      var baseSet = /** @type {!MixinFunction} */base.__mixinSet;
	      if (baseSet && baseSet[mixinDedupeId]) {
	        return base;
	      }
	      var map = mixinApplications;
	      var extended = map.get(base);
	      if (!extended) {
	        extended = /** @type {!Function} */mixin(base);
	        map.set(base, extended);
	      }
	      // copy inherited mixin set from the extended class, or the base class
	      // NOTE: we avoid use of Set here because some browser (IE11)
	      // cannot extend a base Set via the constructor.
	      var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);
	      mixinSet[mixinDedupeId] = true;
	      /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;
	      return extended;
	    }

	    return (/** @type {T} */dedupingMixin
	    );
	  };
	  /* eslint-enable valid-jsdoc */

	  var classCallCheck = function (instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  };

	  var createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  var get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  var inherits = function (subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  };

	  var possibleConstructorReturn = function (self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  };

	  var taggedTemplateLiteral = function (strings, raw) {
	    return Object.freeze(Object.defineProperties(strings, {
	      raw: {
	        value: Object.freeze(raw)
	      }
	    }));
	  };

	  var toConsumableArray = function (arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  };

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  var MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
	  var INCLUDE_ATTR = 'include';
	  var SHADY_UNSCOPED_ATTR = 'shady-unscoped';

	  function importModule(moduleId) {
	    var /** DomModule */PolymerDomModule = customElements.get('dom-module');
	    if (!PolymerDomModule) {
	      return null;
	    }
	    return PolymerDomModule.import(moduleId);
	  }

	  function styleForImport(importDoc) {
	    // NOTE: polyfill affordance.
	    // under the HTMLImports polyfill, there will be no 'body',
	    // but the import pseudo-doc can be used directly.
	    var container = importDoc.body ? importDoc.body : importDoc;
	    var importCss = resolveCss(container.textContent, importDoc.baseURI);
	    var style = document.createElement('style');
	    style.textContent = importCss;
	    return style;
	  }

	  /**
	   * Returns a list of <style> elements in a space-separated list of `dom-module`s.
	   *
	   * @function
	   * @param {string} moduleIds List of dom-module id's within which to
	   * search for css.
	   * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements
	   * @this {StyleGather}
	   */
	  function stylesFromModules(moduleIds) {
	    var modules = moduleIds.trim().split(/\s+/);
	    var styles = [];
	    for (var i = 0; i < modules.length; i++) {
	      styles.push.apply(styles, toConsumableArray(stylesFromModule(modules[i])));
	    }
	    return styles;
	  }

	  /**
	   * Returns a list of <style> elements in a given `dom-module`.
	   * Styles in a `dom-module` can come either from `<style>`s within the
	   * first `<template>`, or else from one or more
	   * `<link rel="import" type="css">` links outside the template.
	   *
	   * @param {string} moduleId dom-module id to gather styles from
	   * @return {!Array<!HTMLStyleElement>} Array of contained styles.
	   * @this {StyleGather}
	   */
	  function stylesFromModule(moduleId) {
	    var m = importModule(moduleId);

	    if (!m) {
	      console.warn('Could not find style data in module named', moduleId);
	      return [];
	    }

	    if (m._styles === undefined) {
	      var styles = [];
	      // module imports: <link rel="import" type="css">
	      styles.push.apply(styles, toConsumableArray(_stylesFromModuleImports(m)));
	      // include css from the first template in the module
	      var template = m.querySelector('template');
	      if (template) {
	        styles.push.apply(styles, toConsumableArray(stylesFromTemplate(template,
	        /** @type {templateWithAssetPath} */m.assetpath)));
	      }

	      m._styles = styles;
	    }

	    return m._styles;
	  }

	  /**
	   * Returns the `<style>` elements within a given template.
	   *
	   * @param {!HTMLTemplateElement} template Template to gather styles from
	   * @param {string} baseURI baseURI for style content
	   * @return {!Array<!HTMLStyleElement>} Array of styles
	   * @this {StyleGather}
	   */
	  function stylesFromTemplate(template, baseURI) {
	    if (!template._styles) {
	      var styles = [];
	      // if element is a template, get content from its .content
	      var e$ = template.content.querySelectorAll('style');
	      for (var i = 0; i < e$.length; i++) {
	        var e = e$[i];
	        // support style sharing by allowing styles to "include"
	        // other dom-modules that contain styling
	        var include = e.getAttribute(INCLUDE_ATTR);
	        if (include) {
	          styles.push.apply(styles, toConsumableArray(stylesFromModules(include).filter(function (item, index, self) {
	            return self.indexOf(item) === index;
	          })));
	        }
	        if (baseURI) {
	          e.textContent = resolveCss(e.textContent, baseURI);
	        }
	        styles.push(e);
	      }
	      template._styles = styles;
	    }
	    return template._styles;
	  }

	  /**
	   * Returns a list of <style> elements  from stylesheets loaded via `<link rel="import" type="css">` links within the specified `dom-module`.
	   *
	   * @param {string} moduleId Id of `dom-module` to gather CSS from
	   * @return {!Array<!HTMLStyleElement>} Array of contained styles.
	   * @this {StyleGather}
	   */
	  function stylesFromModuleImports(moduleId) {
	    var m = importModule(moduleId);
	    return m ? _stylesFromModuleImports(m) : [];
	  }

	  /**
	   * @this {StyleGather}
	   * @param {!HTMLElement} module dom-module element that could contain `<link rel="import" type="css">` styles
	   * @return {!Array<!HTMLStyleElement>} Array of contained styles
	   */
	  function _stylesFromModuleImports(module) {
	    var styles = [];
	    var p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
	    for (var i = 0; i < p$.length; i++) {
	      var p = p$[i];
	      if (p.import) {
	        var importDoc = p.import;
	        var unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);
	        if (unscoped && !importDoc._unscopedStyle) {
	          var style = styleForImport(importDoc);
	          style.setAttribute(SHADY_UNSCOPED_ATTR, '');
	          importDoc._unscopedStyle = style;
	        } else if (!importDoc._style) {
	          importDoc._style = styleForImport(importDoc);
	        }
	        styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
	      }
	    }
	    return styles;
	  }

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  var modules = {};
	  var lcModules = {};
	  function findModule(id) {
	    return modules[id] || lcModules[id.toLowerCase()];
	  }

	  function styleOutsideTemplateCheck(inst) {
	    if (inst.querySelector('style')) {
	      console.warn('dom-module %s has style outside template', inst.id);
	    }
	  }

	  /**
	   * The `dom-module` element registers the dom it contains to the name given
	   * by the module's id attribute. It provides a unified database of dom
	   * accessible via its static `import` API.
	   *
	   * A key use case of `dom-module` is for providing custom element `<template>`s
	   * via HTML imports that are parsed by the native HTML parser, that can be
	   * relocated during a bundling pass and still looked up by `id`.
	   *
	   * Example:
	   *
	   *     <dom-module id="foo">
	   *       <img src="stuff.png">
	   *     </dom-module>
	   *
	   * Then in code in some other location that cannot access the dom-module above
	   *
	   *     let img = customElements.get('dom-module').import('foo', 'img');
	   *
	   * @customElement
	   * @extends HTMLElement
	   * @summary Custom element that provides a registry of relocatable DOM content
	   *   by `id` that is agnostic to bundling.
	   * @unrestricted
	   */
	  var DomModule = function (_HTMLElement) {
	    inherits(DomModule, _HTMLElement);

	    function DomModule() {
	      classCallCheck(this, DomModule);
	      return possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));
	    }

	    createClass(DomModule, [{
	      key: 'attributeChangedCallback',


	      /* eslint-disable no-unused-vars */
	      /**
	       * @param {string} name Name of attribute.
	       * @param {?string} old Old value of attribute.
	       * @param {?string} value Current value of attribute.
	       * @param {?string} namespace Attribute namespace.
	       * @return {void}
	       */
	      value: function attributeChangedCallback(name, old, value, namespace) {
	        if (old !== value) {
	          this.register();
	        }
	      }
	      /* eslint-enable no-unused-args */

	      /**
	       * The absolute URL of the original location of this `dom-module`.
	       *
	       * This value will differ from this element's `ownerDocument` in the
	       * following ways:
	       * - Takes into account any `assetpath` attribute added during bundling
	       *   to indicate the original location relative to the bundled location
	       * - Uses the HTMLImports polyfill's `importForElement` API to ensure
	       *   the path is relative to the import document's location since
	       *   `ownerDocument` is not currently polyfilled
	       */

	    }, {
	      key: 'register',


	      /**
	       * Registers the dom-module at a given id. This method should only be called
	       * when a dom-module is imperatively created. For
	       * example, `document.createElement('dom-module').register('foo')`.
	       * @param {string=} id The id at which to register the dom-module.
	       * @return {void}
	       */
	      value: function register(id) {
	        id = id || this.id;
	        if (id) {
	          this.id = id;
	          // store id separate from lowercased id so that
	          // in all cases mixedCase id will stored distinctly
	          // and lowercase version is a fallback
	          modules[id] = this;
	          lcModules[id.toLowerCase()] = this;
	          styleOutsideTemplateCheck(this);
	        }
	      }
	    }, {
	      key: 'assetpath',
	      get: function () {
	        // Don't override existing assetpath.
	        if (!this.__assetpath) {
	          // note: assetpath set via an attribute must be relative to this
	          // element's location; accomodate polyfilled HTMLImports
	          var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
	          var url = resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);
	          this.__assetpath = pathFromUrl(url);
	        }
	        return this.__assetpath;
	      }
	    }], [{
	      key: 'import',


	      /**
	       * Retrieves the element specified by the css `selector` in the module
	       * registered by `id`. For example, this.import('foo', 'img');
	       * @param {string} id The id of the dom-module in which to search.
	       * @param {string=} selector The css selector by which to find the element.
	       * @return {Element} Returns the element which matches `selector` in the
	       * module registered at the specified `id`.
	       */
	      value: function _import(id, selector) {
	        if (id) {
	          var m = findModule(id);
	          if (m && selector) {
	            return m.querySelector(selector);
	          }
	          return m;
	        }
	        return null;
	      }
	    }, {
	      key: 'observedAttributes',
	      get: function () {
	        return ['id'];
	      }
	    }]);
	    return DomModule;
	  }(HTMLElement);

	  DomModule.prototype['modules'] = modules;

	  customElements.define('dom-module', DomModule);

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  /**
	   * Returns true if the given string is a structured data path (has dots).
	   *
	   * Example:
	   *
	   * ```
	   * isPath('foo.bar.baz') // true
	   * isPath('foo')         // false
	   * ```
	   *
	   * @param {string} path Path string
	   * @return {boolean} True if the string contained one or more dots
	   */
	  function isPath(path) {
	    return path.indexOf('.') >= 0;
	  }

	  /**
	   * Returns the root property name for the given path.
	   *
	   * Example:
	   *
	   * ```
	   * root('foo.bar.baz') // 'foo'
	   * root('foo')         // 'foo'
	   * ```
	   *
	   * @param {string} path Path string
	   * @return {string} Root property name
	   */
	  function root(path) {
	    var dotIndex = path.indexOf('.');
	    if (dotIndex === -1) {
	      return path;
	    }
	    return path.slice(0, dotIndex);
	  }

	  /**
	   * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
	   * Returns true if the given path is an ancestor of the base path.
	   *
	   * Example:
	   *
	   * ```
	   * isAncestor('foo.bar', 'foo')         // true
	   * isAncestor('foo.bar', 'foo.bar')     // false
	   * isAncestor('foo.bar', 'foo.bar.baz') // false
	   * ```
	   *
	   * @param {string} base Path string to test against.
	   * @param {string} path Path string to test.
	   * @return {boolean} True if `path` is an ancestor of `base`.
	   */
	  function isAncestor(base, path) {
	    //     base.startsWith(path + '.');
	    return base.indexOf(path + '.') === 0;
	  }

	  /**
	   * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
	   *
	   * Example:
	   *
	   * ```
	   * isDescendant('foo.bar', 'foo.bar.baz') // true
	   * isDescendant('foo.bar', 'foo.bar')     // false
	   * isDescendant('foo.bar', 'foo')         // false
	   * ```
	   *
	   * @param {string} base Path string to test against.
	   * @param {string} path Path string to test.
	   * @return {boolean} True if `path` is a descendant of `base`.
	   */
	  function isDescendant(base, path) {
	    //     path.startsWith(base + '.');
	    return path.indexOf(base + '.') === 0;
	  }

	  /**
	   * Replaces a previous base path with a new base path, preserving the
	   * remainder of the path.
	   *
	   * User must ensure `path` has a prefix of `base`.
	   *
	   * Example:
	   *
	   * ```
	   * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'
	   * ```
	   *
	   * @param {string} base Current base string to remove
	   * @param {string} newBase New base string to replace with
	   * @param {string} path Path to translate
	   * @return {string} Translated string
	   */
	  function translate(base, newBase, path) {
	    return newBase + path.slice(base.length);
	  }

	  /**
	   * Converts array-based paths to flattened path.  String-based paths
	   * are returned as-is.
	   *
	   * Example:
	   *
	   * ```
	   * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
	   * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
	   * ```
	   *
	   * @param {string | !Array<string|number>} path Input path
	   * @return {string} Flattened path
	   */
	  function normalize(path) {
	    if (Array.isArray(path)) {
	      var parts = [];
	      for (var i = 0; i < path.length; i++) {
	        var args = path[i].toString().split('.');
	        for (var j = 0; j < args.length; j++) {
	          parts.push(args[j]);
	        }
	      }
	      return parts.join('.');
	    } else {
	      return path;
	    }
	  }

	  /**
	   * Splits a path into an array of property names. Accepts either arrays
	   * of path parts or strings.
	   *
	   * Example:
	   *
	   * ```
	   * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
	   * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
	   * ```
	   *
	   * @param {string | !Array<string|number>} path Input path
	   * @return {!Array<string>} Array of path parts
	   * @this {Path}
	   * @suppress {checkTypes}
	   */
	  function split(path) {
	    if (Array.isArray(path)) {
	      return normalize(path).split('.');
	    }
	    return path.toString().split('.');
	  }

	  /**
	   * Reads a value from a path.  If any sub-property in the path is `undefined`,
	   * this method returns `undefined` (will never throw.
	   *
	   * @param {Object} root Object from which to dereference path from
	   * @param {string | !Array<string|number>} path Path to read
	   * @param {Object=} info If an object is provided to `info`, the normalized
	   *  (flattened) path will be set to `info.path`.
	   * @return {*} Value at path, or `undefined` if the path could not be
	   *  fully dereferenced.
	   * @this {Path}
	   */
	  function get$1(root, path, info) {
	    var prop = root;
	    var parts = split(path);
	    // Loop over path parts[0..n-1] and dereference
	    for (var i = 0; i < parts.length; i++) {
	      if (!prop) {
	        return;
	      }
	      var part = parts[i];
	      prop = prop[part];
	    }
	    if (info) {
	      info.path = parts.join('.');
	    }
	    return prop;
	  }

	  /**
	   * Sets a value to a path.  If any sub-property in the path is `undefined`,
	   * this method will no-op.
	   *
	   * @param {Object} root Object from which to dereference path from
	   * @param {string | !Array<string|number>} path Path to set
	   * @param {*} value Value to set to path
	   * @return {string | undefined} The normalized version of the input path
	   * @this {Path}
	   */
	  function set$1(root, path, value) {
	    var prop = root;
	    var parts = split(path);
	    var last = parts[parts.length - 1];
	    if (parts.length > 1) {
	      // Loop over path parts[0..n-2] and dereference
	      for (var i = 0; i < parts.length - 1; i++) {
	        var part = parts[i];
	        prop = prop[part];
	        if (!prop) {
	          return;
	        }
	      }
	      // Set value to object at end of path
	      prop[last] = value;
	    } else {
	      // Simple property set
	      prop[path] = value;
	    }
	    return parts.join('.');
	  }

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  var caseMap = {};
	  var DASH_TO_CAMEL = /-[a-z]/g;
	  var CAMEL_TO_DASH = /([A-Z])/g;

	  /**
	   * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
	   * (e.g. `fooBarBaz`).
	   *
	   * @param {string} dash Dash-case identifier
	   * @return {string} Camel-case representation of the identifier
	   */
	  function dashToCamelCase(dash) {
	    return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {
	      return m[1].toUpperCase();
	    }));
	  }

	  /**
	   * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
	   * (e.g. `foo-bar-baz`).
	   *
	   * @param {string} camel Camel-case identifier
	   * @return {string} Dash-case representation of the identifier
	   */
	  function camelToDashCase(camel) {
	    return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
	  }

	  var caseMap$0 = /*#__PURE__*/Object.freeze({
	    dashToCamelCase: dashToCamelCase,
	    camelToDashCase: camelToDashCase
	  });

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  // Microtask implemented using Mutation Observer
	  var microtaskCurrHandle = 0;
	  var microtaskLastHandle = 0;
	  var microtaskCallbacks = [];
	  var microtaskNodeContent = 0;
	  var microtaskNode = document.createTextNode('');
	  new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

	  function microtaskFlush() {
	    var len = microtaskCallbacks.length;
	    for (var i = 0; i < len; i++) {
	      var cb = microtaskCallbacks[i];
	      if (cb) {
	        try {
	          cb();
	        } catch (e) {
	          setTimeout(function () {
	            throw e;
	          });
	        }
	      }
	    }
	    microtaskCallbacks.splice(0, len);
	    microtaskLastHandle += len;
	  }

	  /**
	   * Async interface wrapper around `setTimeout`.
	   *
	   * @namespace
	   * @summary Async interface wrapper around `setTimeout`.
	   */
	  var timeOut = {
	    /**
	     * Returns a sub-module with the async interface providing the provided
	     * delay.
	     *
	     * @memberof timeOut
	     * @param {number=} delay Time to wait before calling callbacks in ms
	     * @return {!AsyncInterface} An async timeout interface
	     */
	    after: function (delay) {
	      return {
	        run: function (fn) {
	          return window.setTimeout(fn, delay);
	        },
	        cancel: function (handle) {
	          window.clearTimeout(handle);
	        }
	      };
	    },

	    /**
	     * Enqueues a function called in the next task.
	     *
	     * @memberof timeOut
	     * @param {!Function} fn Callback to run
	     * @param {number=} delay Delay in milliseconds
	     * @return {number} Handle used for canceling task
	     */
	    run: function (fn, delay) {
	      return window.setTimeout(fn, delay);
	    },

	    /**
	     * Cancels a previously enqueued `timeOut` callback.
	     *
	     * @memberof timeOut
	     * @param {number} handle Handle returned from `run` of callback to cancel
	     * @return {void}
	     */
	    cancel: function (handle) {
	      window.clearTimeout(handle);
	    }
	  };

	  /**
	   * Async interface for enqueuing callbacks that run at microtask timing.
	   *
	   * Note that microtask timing is achieved via a single `MutationObserver`,
	   * and thus callbacks enqueued with this API will all run in a single
	   * batch, and not interleaved with other microtasks such as promises.
	   * Promises are avoided as an implementation choice for the time being
	   * due to Safari bugs that cause Promises to lack microtask guarantees.
	   *
	   * @namespace
	   * @summary Async interface for enqueuing callbacks that run at microtask
	   *   timing.
	   */
	  var microTask = {

	    /**
	     * Enqueues a function called at microtask timing.
	     *
	     * @memberof microTask
	     * @param {!Function=} callback Callback to run
	     * @return {number} Handle used for canceling task
	     */
	    run: function (callback) {
	      microtaskNode.textContent = microtaskNodeContent++;
	      microtaskCallbacks.push(callback);
	      return microtaskCurrHandle++;
	    },


	    /**
	     * Cancels a previously enqueued `microTask` callback.
	     *
	     * @memberof microTask
	     * @param {number} handle Handle returned from `run` of callback to cancel
	     * @return {void}
	     */
	    cancel: function (handle) {
	      var idx = handle - microtaskLastHandle;
	      if (idx >= 0) {
	        if (!microtaskCallbacks[idx]) {
	          throw new Error('invalid async handle: ' + handle);
	        }
	        microtaskCallbacks[idx] = null;
	      }
	    }
	  };

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  /** @const {!AsyncInterface} */
	  var microtask = microTask;

	  /**
	   * Element class mixin that provides basic meta-programming for creating one
	   * or more property accessors (getter/setter pair) that enqueue an async
	   * (batched) `_propertiesChanged` callback.
	   *
	   * For basic usage of this mixin, call `MyClass.createProperties(props)`
	   * once at class definition time to create property accessors for properties
	   * named in props, implement `_propertiesChanged` to react as desired to
	   * property changes, and implement `static get observedAttributes()` and
	   * include lowercase versions of any property names that should be set from
	   * attributes. Last, call `this._enableProperties()` in the element's
	   * `connectedCallback` to enable the accessors.
	   *
	   * @mixinFunction
	   * @polymer
	   * @summary Element class mixin for reacting to property changes from
	   *   generated property accessors.
	   */
	  var PropertiesChanged = dedupingMixin(function (superClass) {

	    /**
	     * @polymer
	     * @mixinClass
	     * @extends {superClass}
	     * @implements {Polymer_PropertiesChanged}
	     * @unrestricted
	     */
	    var PropertiesChanged = function (_superClass) {
	      inherits(PropertiesChanged, _superClass);
	      createClass(PropertiesChanged, [{
	        key: '_createPropertyAccessor',
	        //eslint-disable-line no-unused-vars

	        /**
	         * Creates a setter/getter pair for the named property with its own
	         * local storage.  The getter returns the value in the local storage,
	         * and the setter calls `_setProperty`, which updates the local storage
	         * for the property and enqueues a `_propertiesChanged` callback.
	         *
	         * This method may be called on a prototype or an instance.  Calling
	         * this method may overwrite a property value that already exists on
	         * the prototype/instance by creating the accessor.
	         *
	         * @param {string} property Name of the property
	         * @param {boolean=} readOnly When true, no setter is created; the
	         *   protected `_setProperty` function must be used to set the property
	         * @return {void}
	         * @protected
	         */
	        value: function _createPropertyAccessor(property, readOnly) {
	          this._addPropertyToAttributeMap(property);
	          if (!this.hasOwnProperty('__dataHasAccessor')) {
	            this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
	          }
	          if (!this.__dataHasAccessor[property]) {
	            this.__dataHasAccessor[property] = true;
	            this._definePropertyAccessor(property, readOnly);
	          }
	        }

	        /**
	         * Adds the given `property` to a map matching attribute names
	         * to property names, using `attributeNameForProperty`. This map is
	         * used when deserializing attribute values to properties.
	         *
	         * @param {string} property Name of the property
	         */

	      }, {
	        key: '_addPropertyToAttributeMap',
	        value: function _addPropertyToAttributeMap(property) {
	          if (!this.hasOwnProperty('__dataAttributes')) {
	            this.__dataAttributes = Object.assign({}, this.__dataAttributes);
	          }
	          if (!this.__dataAttributes[property]) {
	            var attr = this.constructor.attributeNameForProperty(property);
	            this.__dataAttributes[attr] = property;
	          }
	        }

	        /**
	         * Defines a property accessor for the given property.
	         * @param {string} property Name of the property
	         * @param {boolean=} readOnly When true, no setter is created
	         * @return {void}
	         */

	      }, {
	        key: '_definePropertyAccessor',
	        value: function _definePropertyAccessor(property, readOnly) {
	          Object.defineProperty(this, property, {
	            /* eslint-disable valid-jsdoc */
	            /** @this {PropertiesChanged} */
	            get: function () {
	              return this._getProperty(property);
	            },

	            /** @this {PropertiesChanged} */
	            set: readOnly ? function () {} : function (value) {
	              this._setProperty(property, value);
	            }
	            /* eslint-enable */
	          });
	        }
	      }], [{
	        key: 'createProperties',


	        /**
	         * Creates property accessors for the given property names.
	         * @param {!Object} props Object whose keys are names of accessors.
	         * @return {void}
	         * @protected
	         */
	        value: function createProperties(props) {
	          var proto = this.prototype;
	          for (var prop in props) {
	            // don't stomp an existing accessor
	            if (!(prop in proto)) {
	              proto._createPropertyAccessor(prop);
	            }
	          }
	        }

	        /**
	         * Returns an attribute name that corresponds to the given property.
	         * The attribute name is the lowercased property name. Override to
	         * customize this mapping.
	         * @param {string} property Property to convert
	         * @return {string} Attribute name corresponding to the given property.
	         *
	         * @protected
	         */

	      }, {
	        key: 'attributeNameForProperty',
	        value: function attributeNameForProperty(property) {
	          return property.toLowerCase();
	        }

	        /**
	         * Override point to provide a type to which to deserialize a value to
	         * a given property.
	         * @param {string} name Name of property
	         *
	         * @protected
	         */

	      }, {
	        key: 'typeForProperty',
	        value: function typeForProperty(name) {}
	      }]);

	      function PropertiesChanged() {
	        classCallCheck(this, PropertiesChanged);

	        var _this = possibleConstructorReturn(this, (PropertiesChanged.__proto__ || Object.getPrototypeOf(PropertiesChanged)).call(this));

	        _this.__dataEnabled = false;
	        _this.__dataReady = false;
	        _this.__dataInvalid = false;
	        _this.__data = {};
	        _this.__dataPending = null;
	        _this.__dataOld = null;
	        _this.__dataInstanceProps = null;
	        _this.__serializing = false;
	        _this._initializeProperties();
	        return _this;
	      }

	      /**
	       * Lifecycle callback called when properties are enabled via
	       * `_enableProperties`.
	       *
	       * Users may override this function to implement behavior that is
	       * dependent on the element having its property data initialized, e.g.
	       * from defaults (initialized from `constructor`, `_initializeProperties`),
	       * `attributeChangedCallback`, or values propagated from host e.g. via
	       * bindings.  `super.ready()` must be called to ensure the data system
	       * becomes enabled.
	       *
	       * @return {void}
	       * @public
	       */


	      createClass(PropertiesChanged, [{
	        key: 'ready',
	        value: function ready() {
	          this.__dataReady = true;
	          this._flushProperties();
	        }

	        /**
	         * Initializes the local storage for property accessors.
	         *
	         * Provided as an override point for performing any setup work prior
	         * to initializing the property accessor system.
	         *
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_initializeProperties',
	        value: function _initializeProperties() {
	          // Capture instance properties; these will be set into accessors
	          // during first flush. Don't set them here, since we want
	          // these to overwrite defaults/constructor assignments
	          for (var p in this.__dataHasAccessor) {
	            if (this.hasOwnProperty(p)) {
	              this.__dataInstanceProps = this.__dataInstanceProps || {};
	              this.__dataInstanceProps[p] = this[p];
	              delete this[p];
	            }
	          }
	        }

	        /**
	         * Called at ready time with bag of instance properties that overwrote
	         * accessors when the element upgraded.
	         *
	         * The default implementation sets these properties back into the
	         * setter at ready time.  This method is provided as an override
	         * point for customizing or providing more efficient initialization.
	         *
	         * @param {Object} props Bag of property values that were overwritten
	         *   when creating property accessors.
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_initializeInstanceProperties',
	        value: function _initializeInstanceProperties(props) {
	          Object.assign(this, props);
	        }

	        /**
	         * Updates the local storage for a property (via `_setPendingProperty`)
	         * and enqueues a `_proeprtiesChanged` callback.
	         *
	         * @param {string} property Name of the property
	         * @param {*} value Value to set
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_setProperty',
	        value: function _setProperty(property, value) {
	          if (this._setPendingProperty(property, value)) {
	            this._invalidateProperties();
	          }
	        }

	        /**
	         * Returns the value for the given property.
	         * @param {string} property Name of property
	         * @return {*} Value for the given property
	         * @protected
	         */

	      }, {
	        key: '_getProperty',
	        value: function _getProperty(property) {
	          return this.__data[property];
	        }

	        /* eslint-disable no-unused-vars */
	        /**
	         * Updates the local storage for a property, records the previous value,
	         * and adds it to the set of "pending changes" that will be passed to the
	         * `_propertiesChanged` callback.  This method does not enqueue the
	         * `_propertiesChanged` callback.
	         *
	         * @param {string} property Name of the property
	         * @param {*} value Value to set
	         * @param {boolean=} ext Not used here; affordance for closure
	         * @return {boolean} Returns true if the property changed
	         * @protected
	         */

	      }, {
	        key: '_setPendingProperty',
	        value: function _setPendingProperty(property, value, ext) {
	          var old = this.__data[property];
	          var changed = this._shouldPropertyChange(property, value, old);
	          if (changed) {
	            if (!this.__dataPending) {
	              this.__dataPending = {};
	              this.__dataOld = {};
	            }
	            // Ensure old is captured from the last turn
	            if (this.__dataOld && !(property in this.__dataOld)) {
	              this.__dataOld[property] = old;
	            }
	            this.__data[property] = value;
	            this.__dataPending[property] = value;
	          }
	          return changed;
	        }
	        /* eslint-enable */

	        /**
	         * Marks the properties as invalid, and enqueues an async
	         * `_propertiesChanged` callback.
	         *
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_invalidateProperties',
	        value: function _invalidateProperties() {
	          var _this2 = this;

	          if (!this.__dataInvalid && this.__dataReady) {
	            this.__dataInvalid = true;
	            microtask.run(function () {
	              if (_this2.__dataInvalid) {
	                _this2.__dataInvalid = false;
	                _this2._flushProperties();
	              }
	            });
	          }
	        }

	        /**
	         * Call to enable property accessor processing. Before this method is
	         * called accessor values will be set but side effects are
	         * queued. When called, any pending side effects occur immediately.
	         * For elements, generally `connectedCallback` is a normal spot to do so.
	         * It is safe to call this method multiple times as it only turns on
	         * property accessors once.
	         *
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_enableProperties',
	        value: function _enableProperties() {
	          if (!this.__dataEnabled) {
	            this.__dataEnabled = true;
	            if (this.__dataInstanceProps) {
	              this._initializeInstanceProperties(this.__dataInstanceProps);
	              this.__dataInstanceProps = null;
	            }
	            this.ready();
	          }
	        }

	        /**
	         * Calls the `_propertiesChanged` callback with the current set of
	         * pending changes (and old values recorded when pending changes were
	         * set), and resets the pending set of changes. Generally, this method
	         * should not be called in user code.
	         *
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_flushProperties',
	        value: function _flushProperties() {
	          var props = this.__data;
	          var changedProps = this.__dataPending;
	          var old = this.__dataOld;
	          if (this._shouldPropertiesChange(props, changedProps, old)) {
	            this.__dataPending = null;
	            this.__dataOld = null;
	            this._propertiesChanged(props, changedProps, old);
	          }
	        }

	        /**
	         * Called in `_flushProperties` to determine if `_propertiesChanged`
	         * should be called. The default implementation returns true if
	         * properties are pending. Override to customize when
	         * `_propertiesChanged` is called.
	         * @param {!Object} currentProps Bag of all current accessor values
	         * @param {!Object} changedProps Bag of properties changed since the last
	         *   call to `_propertiesChanged`
	         * @param {!Object} oldProps Bag of previous values for each property
	         *   in `changedProps`
	         * @return {boolean} true if changedProps is truthy
	         */

	      }, {
	        key: '_shouldPropertiesChange',
	        value: function _shouldPropertiesChange(currentProps, changedProps, oldProps) {
	          // eslint-disable-line no-unused-vars
	          return Boolean(changedProps);
	        }

	        /**
	         * Callback called when any properties with accessors created via
	         * `_createPropertyAccessor` have been set.
	         *
	         * @param {!Object} currentProps Bag of all current accessor values
	         * @param {!Object} changedProps Bag of properties changed since the last
	         *   call to `_propertiesChanged`
	         * @param {!Object} oldProps Bag of previous values for each property
	         *   in `changedProps`
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_propertiesChanged',
	        value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars


	        /**
	         * Method called to determine whether a property value should be
	         * considered as a change and cause the `_propertiesChanged` callback
	         * to be enqueued.
	         *
	         * The default implementation returns `true` if a strict equality
	         * check fails. The method always returns false for `NaN`.
	         *
	         * Override this method to e.g. provide stricter checking for
	         * Objects/Arrays when using immutable patterns.
	         *
	         * @param {string} property Property name
	         * @param {*} value New property value
	         * @param {*} old Previous property value
	         * @return {boolean} Whether the property should be considered a change
	         *   and enqueue a `_proeprtiesChanged` callback
	         * @protected
	         */

	      }, {
	        key: '_shouldPropertyChange',
	        value: function _shouldPropertyChange(property, value, old) {
	          return (
	            // Strict equality check
	            old !== value && (
	            // This ensures (old==NaN, value==NaN) always returns false
	            old === old || value === value)
	          );
	        }

	        /**
	         * Implements native Custom Elements `attributeChangedCallback` to
	         * set an attribute value to a property via `_attributeToProperty`.
	         *
	         * @param {string} name Name of attribute that changed
	         * @param {?string} old Old attribute value
	         * @param {?string} value New attribute value
	         * @param {?string} namespace Attribute namespace.
	         * @return {void}
	         * @suppress {missingProperties} Super may or may not implement the callback
	         */

	      }, {
	        key: 'attributeChangedCallback',
	        value: function attributeChangedCallback(name, old, value, namespace) {
	          if (old !== value) {
	            this._attributeToProperty(name, value);
	          }
	          if (get(PropertiesChanged.prototype.__proto__ || Object.getPrototypeOf(PropertiesChanged.prototype), 'attributeChangedCallback', this)) {
	            get(PropertiesChanged.prototype.__proto__ || Object.getPrototypeOf(PropertiesChanged.prototype), 'attributeChangedCallback', this).call(this, name, old, value, namespace);
	          }
	        }

	        /**
	         * Deserializes an attribute to its associated property.
	         *
	         * This method calls the `_deserializeValue` method to convert the string to
	         * a typed value.
	         *
	         * @param {string} attribute Name of attribute to deserialize.
	         * @param {?string} value of the attribute.
	         * @param {*=} type type to deserialize to, defaults to the value
	         * returned from `typeForProperty`
	         * @return {void}
	         */

	      }, {
	        key: '_attributeToProperty',
	        value: function _attributeToProperty(attribute, value, type) {
	          if (!this.__serializing) {
	            var map = this.__dataAttributes;
	            var property = map && map[attribute] || attribute;
	            this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));
	          }
	        }

	        /**
	         * Serializes a property to its associated attribute.
	         *
	         * @suppress {invalidCasts} Closure can't figure out `this` is an element.
	         *
	         * @param {string} property Property name to reflect.
	         * @param {string=} attribute Attribute name to reflect to.
	         * @param {*=} value Property value to refect.
	         * @return {void}
	         */

	      }, {
	        key: '_propertyToAttribute',
	        value: function _propertyToAttribute(property, attribute, value) {
	          this.__serializing = true;
	          value = arguments.length < 3 ? this[property] : value;
	          this._valueToNodeAttribute( /** @type {!HTMLElement} */this, value, attribute || this.constructor.attributeNameForProperty(property));
	          this.__serializing = false;
	        }

	        /**
	         * Sets a typed value to an HTML attribute on a node.
	         *
	         * This method calls the `_serializeValue` method to convert the typed
	         * value to a string.  If the `_serializeValue` method returns `undefined`,
	         * the attribute will be removed (this is the default for boolean
	         * type `false`).
	         *
	         * @param {Element} node Element to set attribute to.
	         * @param {*} value Value to serialize.
	         * @param {string} attribute Attribute name to serialize to.
	         * @return {void}
	         */

	      }, {
	        key: '_valueToNodeAttribute',
	        value: function _valueToNodeAttribute(node, value, attribute) {
	          var str = this._serializeValue(value);
	          if (str === undefined) {
	            node.removeAttribute(attribute);
	          } else {
	            node.setAttribute(attribute, str);
	          }
	        }

	        /**
	         * Converts a typed JavaScript value to a string.
	         *
	         * This method is called when setting JS property values to
	         * HTML attributes.  Users may override this method to provide
	         * serialization for custom types.
	         *
	         * @param {*} value Property value to serialize.
	         * @return {string | undefined} String serialized from the provided
	         * property  value.
	         */

	      }, {
	        key: '_serializeValue',
	        value: function _serializeValue(value) {
	          switch (typeof value) {
	            case 'boolean':
	              return value ? '' : undefined;
	            default:
	              return value != null ? value.toString() : undefined;
	          }
	        }

	        /**
	         * Converts a string to a typed JavaScript value.
	         *
	         * This method is called when reading HTML attribute values to
	         * JS properties.  Users may override this method to provide
	         * deserialization for custom `type`s. Types for `Boolean`, `String`,
	         * and `Number` convert attributes to the expected types.
	         *
	         * @param {?string} value Value to deserialize.
	         * @param {*=} type Type to deserialize the string to.
	         * @return {*} Typed value deserialized from the provided string.
	         */

	      }, {
	        key: '_deserializeValue',
	        value: function _deserializeValue(value, type) {
	          switch (type) {
	            case Boolean:
	              return value !== null;
	            case Number:
	              return Number(value);
	            default:
	              return value;
	          }
	        }
	      }]);
	      return PropertiesChanged;
	    }(superClass);

	    return PropertiesChanged;
	  });

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  var caseMap$1 = caseMap$0;

	  // Save map of native properties; this forms a blacklist or properties
	  // that won't have their values "saved" by `saveAccessorValue`, since
	  // reading from an HTMLElement accessor from the context of a prototype throws
	  var nativeProperties = {};
	  var proto = HTMLElement.prototype;
	  while (proto) {
	    var props = Object.getOwnPropertyNames(proto);
	    for (var i = 0; i < props.length; i++) {
	      nativeProperties[props[i]] = true;
	    }
	    proto = Object.getPrototypeOf(proto);
	  }

	  /**
	   * Used to save the value of a property that will be overridden with
	   * an accessor. If the `model` is a prototype, the values will be saved
	   * in `__dataProto`, and it's up to the user (or downstream mixin) to
	   * decide how/when to set these values back into the accessors.
	   * If `model` is already an instance (it has a `__data` property), then
	   * the value will be set as a pending property, meaning the user should
	   * call `_invalidateProperties` or `_flushProperties` to take effect
	   *
	   * @param {Object} model Prototype or instance
	   * @param {string} property Name of property
	   * @return {void}
	   * @private
	   */
	  function saveAccessorValue(model, property) {
	    // Don't read/store value for any native properties since they could throw
	    if (!nativeProperties[property]) {
	      var value = model[property];
	      if (value !== undefined) {
	        if (model.__data) {
	          // Adding accessor to instance; update the property
	          // It is the user's responsibility to call _flushProperties
	          model._setPendingProperty(property, value);
	        } else {
	          // Adding accessor to proto; save proto's value for instance-time use
	          if (!model.__dataProto) {
	            model.__dataProto = {};
	          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
	            model.__dataProto = Object.create(model.__dataProto);
	          }
	          model.__dataProto[property] = value;
	        }
	      }
	    }
	  }

	  /**
	   * Element class mixin that provides basic meta-programming for creating one
	   * or more property accessors (getter/setter pair) that enqueue an async
	   * (batched) `_propertiesChanged` callback.
	   *
	   * For basic usage of this mixin:
	   *
	   * -   Declare attributes to observe via the standard `static get observedAttributes()`. Use
	   *     `dash-case` attribute names to represent `camelCase` property names.
	   * -   Implement the `_propertiesChanged` callback on the class.
	   * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to generate
	   *     property accessors for each observed attribute. This must be called before the first
	   *     instance is created, for example, by calling it before calling `customElements.define`.
	   *     It can also be called lazily from the element's `constructor`, as long as it's guarded so
	   *     that the call is only made once, when the first instance is created.
	   * -   Call `this._enableProperties()` in the element's `connectedCallback` to enable
	   *     the accessors.
	   *
	   * Any `observedAttributes` will automatically be
	   * deserialized via `attributeChangedCallback` and set to the associated
	   * property using `dash-case`-to-`camelCase` convention.
	   *
	   * @mixinFunction
	   * @polymer
	   * @appliesMixin PropertiesChanged
	   * @summary Element class mixin for reacting to property changes from
	   *   generated property accessors.
	   */
	  var PropertyAccessors = dedupingMixin(function (superClass) {

	    /**
	     * @constructor
	     * @extends {superClass}
	     * @implements {Polymer_PropertiesChanged}
	     * @unrestricted
	     */
	    var base = PropertiesChanged(superClass);

	    /**
	     * @polymer
	     * @mixinClass
	     * @implements {Polymer_PropertyAccessors}
	     * @extends {base}
	     * @unrestricted
	     */

	    var PropertyAccessors = function (_base) {
	      inherits(PropertyAccessors, _base);

	      function PropertyAccessors() {
	        classCallCheck(this, PropertyAccessors);
	        return possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).apply(this, arguments));
	      }

	      createClass(PropertyAccessors, [{
	        key: '_initializeProperties',


	        /**
	         * Overrides PropertiesChanged implementation to initialize values for
	         * accessors created for values that already existed on the element
	         * prototype.
	         *
	         * @return {void}
	         * @protected
	         */
	        value: function _initializeProperties() {
	          if (this.__dataProto) {
	            this._initializeProtoProperties(this.__dataProto);
	            this.__dataProto = null;
	          }
	          get(PropertyAccessors.prototype.__proto__ || Object.getPrototypeOf(PropertyAccessors.prototype), '_initializeProperties', this).call(this);
	        }

	        /**
	         * Called at instance time with bag of properties that were overwritten
	         * by accessors on the prototype when accessors were created.
	         *
	         * The default implementation sets these properties back into the
	         * setter at instance time.  This method is provided as an override
	         * point for customizing or providing more efficient initialization.
	         *
	         * @param {Object} props Bag of property values that were overwritten
	         *   when creating property accessors.
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_initializeProtoProperties',
	        value: function _initializeProtoProperties(props) {
	          for (var p in props) {
	            this._setProperty(p, props[p]);
	          }
	        }

	        /**
	         * Ensures the element has the given attribute. If it does not,
	         * assigns the given value to the attribute.
	         *
	         * @suppress {invalidCasts} Closure can't figure out `this` is infact an element
	         *
	         * @param {string} attribute Name of attribute to ensure is set.
	         * @param {string} value of the attribute.
	         * @return {void}
	         */

	      }, {
	        key: '_ensureAttribute',
	        value: function _ensureAttribute(attribute, value) {
	          var el = /** @type {!HTMLElement} */this;
	          if (!el.hasAttribute(attribute)) {
	            this._valueToNodeAttribute(el, value, attribute);
	          }
	        }

	        /**
	         * Overrides PropertiesChanged implemention to serialize objects as JSON.
	         *
	         * @param {*} value Property value to serialize.
	         * @return {string | undefined} String serialized from the provided property value.
	         */

	      }, {
	        key: '_serializeValue',
	        value: function _serializeValue(value) {
	          /* eslint-disable no-fallthrough */
	          switch (typeof value) {
	            case 'object':
	              if (value instanceof Date) {
	                return value.toString();
	              } else if (value) {
	                try {
	                  return JSON.stringify(value);
	                } catch (x) {
	                  return '';
	                }
	              }

	            default:
	              return get(PropertyAccessors.prototype.__proto__ || Object.getPrototypeOf(PropertyAccessors.prototype), '_serializeValue', this).call(this, value);
	          }
	        }

	        /**
	         * Converts a string to a typed JavaScript value.
	         *
	         * This method is called by Polymer when reading HTML attribute values to
	         * JS properties.  Users may override this method on Polymer element
	         * prototypes to provide deserialization for custom `type`s.  Note,
	         * the `type` argument is the value of the `type` field provided in the
	         * `properties` configuration object for a given property, and is
	         * by convention the constructor for the type to deserialize.
	         *
	         *
	         * @param {?string} value Attribute value to deserialize.
	         * @param {*=} type Type to deserialize the string to.
	         * @return {*} Typed value deserialized from the provided string.
	         */

	      }, {
	        key: '_deserializeValue',
	        value: function _deserializeValue(value, type) {
	          /**
	           * @type {*}
	           */
	          var outValue = void 0;
	          switch (type) {
	            case Object:
	              try {
	                outValue = JSON.parse( /** @type {string} */value);
	              } catch (x) {
	                // allow non-JSON literals like Strings and Numbers
	                outValue = value;
	              }
	              break;
	            case Array:
	              try {
	                outValue = JSON.parse( /** @type {string} */value);
	              } catch (x) {
	                outValue = null;
	                console.warn('Polymer::Attributes: couldn\'t decode Array as JSON: ' + value);
	              }
	              break;
	            case Date:
	              outValue = isNaN(value) ? String(value) : Number(value);
	              outValue = new Date(outValue);
	              break;
	            default:
	              outValue = get(PropertyAccessors.prototype.__proto__ || Object.getPrototypeOf(PropertyAccessors.prototype), '_deserializeValue', this).call(this, value, type);
	              break;
	          }
	          return outValue;
	        }
	        /* eslint-enable no-fallthrough */

	        /**
	         * Overrides PropertiesChanged implementation to save existing prototype
	         * property value so that it can be reset.
	         * @param {string} property Name of the property
	         * @param {boolean=} readOnly When true, no setter is created
	         *
	         * When calling on a prototype, any overwritten values are saved in
	         * `__dataProto`, and it is up to the subclasser to decide how/when
	         * to set those properties back into the accessor.  When calling on an
	         * instance, the overwritten value is set via `_setPendingProperty`,
	         * and the user should call `_invalidateProperties` or `_flushProperties`
	         * for the values to take effect.
	         * @protected
	         * @return {void}
	         */

	      }, {
	        key: '_definePropertyAccessor',
	        value: function _definePropertyAccessor(property, readOnly) {
	          saveAccessorValue(this, property);
	          get(PropertyAccessors.prototype.__proto__ || Object.getPrototypeOf(PropertyAccessors.prototype), '_definePropertyAccessor', this).call(this, property, readOnly);
	        }

	        /**
	         * Returns true if this library created an accessor for the given property.
	         *
	         * @param {string} property Property name
	         * @return {boolean} True if an accessor was created
	         */

	      }, {
	        key: '_hasAccessor',
	        value: function _hasAccessor(property) {
	          return this.__dataHasAccessor && this.__dataHasAccessor[property];
	        }

	        /**
	         * Returns true if the specified property has a pending change.
	         *
	         * @param {string} prop Property name
	         * @return {boolean} True if property has a pending change
	         * @protected
	         */

	      }, {
	        key: '_isPropertyPending',
	        value: function _isPropertyPending(prop) {
	          return Boolean(this.__dataPending && prop in this.__dataPending);
	        }
	      }], [{
	        key: 'createPropertiesForAttributes',


	        /**
	         * Generates property accessors for all attributes in the standard
	         * static `observedAttributes` array.
	         *
	         * Attribute names are mapped to property names using the `dash-case` to
	         * `camelCase` convention
	         *
	         * @return {void}
	         */
	        value: function createPropertiesForAttributes() {
	          var a$ = this.observedAttributes;
	          for (var _i = 0; _i < a$.length; _i++) {
	            this.prototype._createPropertyAccessor(caseMap$1.dashToCamelCase(a$[_i]));
	          }
	        }

	        /**
	         * Returns an attribute name that corresponds to the given property.
	         * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
	         * @param {string} property Property to convert
	         * @return {string} Attribute name corresponding to the given property.
	         *
	         * @protected
	         */

	      }, {
	        key: 'attributeNameForProperty',
	        value: function attributeNameForProperty(property) {
	          return caseMap$1.camelToDashCase(property);
	        }
	      }]);
	      return PropertyAccessors;
	    }(base);

	    return PropertyAccessors;
	  });

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  // 1.x backwards-compatible auto-wrapper for template type extensions
	  // This is a clear layering violation and gives favored-nation status to
	  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
	  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and
	  // b.) to maintain if/repeat capability in parser-constrained elements
	  //     (e.g. table, select) in lieu of native CE type extensions without
	  //     massive new invention in this space (e.g. directive system)
	  var templateExtensions = {
	    'dom-if': true,
	    'dom-repeat': true
	  };
	  function wrapTemplateExtension(node) {
	    var is = node.getAttribute('is');
	    if (is && templateExtensions[is]) {
	      var t = node;
	      t.removeAttribute('is');
	      node = t.ownerDocument.createElement(is);
	      t.parentNode.replaceChild(node, t);
	      node.appendChild(t);
	      while (t.attributes.length) {
	        node.setAttribute(t.attributes[0].name, t.attributes[0].value);
	        t.removeAttribute(t.attributes[0].name);
	      }
	    }
	    return node;
	  }

	  function findTemplateNode(root, nodeInfo) {
	    // recursively ascend tree until we hit root
	    var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
	    // unwind the stack, returning the indexed node at each level
	    if (parent) {
	      // note: marginally faster than indexing via childNodes
	      // (http://jsperf.com/childnodes-lookup)
	      for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
	        if (nodeInfo.parentIndex === i++) {
	          return n;
	        }
	      }
	    } else {
	      return root;
	    }
	  }

	  // construct `$` map (from id annotations)
	  function applyIdToMap(inst, map, node, nodeInfo) {
	    if (nodeInfo.id) {
	      map[nodeInfo.id] = node;
	    }
	  }

	  // install event listeners (from event annotations)
	  function applyEventListener(inst, node, nodeInfo) {
	    if (nodeInfo.events && nodeInfo.events.length) {
	      for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
	        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
	      }
	    }
	  }

	  // push configuration references at configure time
	  function applyTemplateContent(inst, node, nodeInfo) {
	    if (nodeInfo.templateInfo) {
	      node._templateInfo = nodeInfo.templateInfo;
	    }
	  }

	  function createNodeEventHandler(context, eventName, methodName) {
	    // Instances can optionally have a _methodHost which allows redirecting where
	    // to find methods. Currently used by `templatize`.
	    context = context._methodHost || context;
	    var handler = function (e) {
	      if (context[methodName]) {
	        context[methodName](e, e.detail);
	      } else {
	        console.warn('listener method `' + methodName + '` not defined');
	      }
	    };
	    return handler;
	  }

	  /**
	   * Element mixin that provides basic template parsing and stamping, including
	   * the following template-related features for stamped templates:
	   *
	   * - Declarative event listeners (`on-eventname="listener"`)
	   * - Map of node id's to stamped node instances (`this.$.id`)
	   * - Nested template content caching/removal and re-installation (performance
	   *   optimization)
	   *
	   * @mixinFunction
	   * @polymer
	   * @summary Element class mixin that provides basic template parsing and stamping
	   */
	  var TemplateStamp = dedupingMixin(function (superClass) {

	    /**
	     * @polymer
	     * @mixinClass
	     * @implements {Polymer_TemplateStamp}
	     */
	    var TemplateStamp = function (_superClass) {
	      inherits(TemplateStamp, _superClass);

	      function TemplateStamp() {
	        classCallCheck(this, TemplateStamp);
	        return possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));
	      }

	      createClass(TemplateStamp, [{
	        key: '_stampTemplate',


	        /**
	         * Clones the provided template content and returns a document fragment
	         * containing the cloned dom.
	         *
	         * The template is parsed (once and memoized) using this library's
	         * template parsing features, and provides the following value-added
	         * features:
	         * * Adds declarative event listeners for `on-event="handler"` attributes
	         * * Generates an "id map" for all nodes with id's under `$` on returned
	         *   document fragment
	         * * Passes template info including `content` back to templates as
	         *   `_templateInfo` (a performance optimization to avoid deep template
	         *   cloning)
	         *
	         * Note that the memoized template parsing process is destructive to the
	         * template: attributes for bindings and declarative event listeners are
	         * removed after being noted in notes, and any nested `<template>.content`
	         * is removed and stored in notes as well.
	         *
	         * @param {!HTMLTemplateElement} template Template to stamp
	         * @return {!StampedTemplate} Cloned template content
	         */
	        value: function _stampTemplate(template) {
	          // Polyfill support: bootstrap the template if it has not already been
	          if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
	            HTMLTemplateElement.decorate(template);
	          }
	          var templateInfo = this.constructor._parseTemplate(template);
	          var nodeInfo = templateInfo.nodeInfoList;
	          var content = templateInfo.content || template.content;
	          var dom = /** @type {DocumentFragment} */document.importNode(content, true);
	          // NOTE: ShadyDom optimization indicating there is an insertion point
	          dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
	          var nodes = dom.nodeList = new Array(nodeInfo.length);
	          dom.$ = {};
	          for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
	            var node = nodes[i] = findTemplateNode(dom, info);
	            applyIdToMap(this, dom.$, node, info);
	            applyTemplateContent(this, node, info);
	            applyEventListener(this, node, info);
	          }
	          dom = /** @type {!StampedTemplate} */dom; // eslint-disable-line no-self-assign
	          return dom;
	        }

	        /**
	         * Adds an event listener by method name for the event provided.
	         *
	         * This method generates a handler function that looks up the method
	         * name at handling time.
	         *
	         * @param {!Node} node Node to add listener on
	         * @param {string} eventName Name of event
	         * @param {string} methodName Name of method
	         * @param {*=} context Context the method will be called on (defaults
	         *   to `node`)
	         * @return {Function} Generated handler function
	         */

	      }, {
	        key: '_addMethodEventListenerToNode',
	        value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {
	          context = context || node;
	          var handler = createNodeEventHandler(context, eventName, methodName);
	          this._addEventListenerToNode(node, eventName, handler);
	          return handler;
	        }

	        /**
	         * Override point for adding custom or simulated event handling.
	         *
	         * @param {!Node} node Node to add event listener to
	         * @param {string} eventName Name of event
	         * @param {function(!Event):void} handler Listener function to add
	         * @return {void}
	         */

	      }, {
	        key: '_addEventListenerToNode',
	        value: function _addEventListenerToNode(node, eventName, handler) {
	          node.addEventListener(eventName, handler);
	        }

	        /**
	         * Override point for adding custom or simulated event handling.
	         *
	         * @param {Node} node Node to remove event listener from
	         * @param {string} eventName Name of event
	         * @param {function(!Event):void} handler Listener function to remove
	         * @return {void}
	         */

	      }, {
	        key: '_removeEventListenerFromNode',
	        value: function _removeEventListenerFromNode(node, eventName, handler) {
	          node.removeEventListener(eventName, handler);
	        }
	      }], [{
	        key: '_parseTemplate',


	        /**
	         * Scans a template to produce template metadata.
	         *
	         * Template-specific metadata are stored in the object returned, and node-
	         * specific metadata are stored in objects in its flattened `nodeInfoList`
	         * array.  Only nodes in the template that were parsed as nodes of
	         * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
	         * contains an `index` (`childNodes` index in parent) and optionally
	         * `parent`, which points to node info of its parent (including its index).
	         *
	         * The template metadata object returned from this method has the following
	         * structure (many fields optional):
	         *
	         * ```js
	         *   {
	         *     // Flattened list of node metadata (for nodes that generated metadata)
	         *     nodeInfoList: [
	         *       {
	         *         // `id` attribute for any nodes with id's for generating `$` map
	         *         id: {string},
	         *         // `on-event="handler"` metadata
	         *         events: [
	         *           {
	         *             name: {string},   // event name
	         *             value: {string},  // handler method name
	         *           }, ...
	         *         ],
	         *         // Notes when the template contained a `<slot>` for shady DOM
	         *         // optimization purposes
	         *         hasInsertionPoint: {boolean},
	         *         // For nested `<template>`` nodes, nested template metadata
	         *         templateInfo: {object}, // nested template metadata
	         *         // Metadata to allow efficient retrieval of instanced node
	         *         // corresponding to this metadata
	         *         parentInfo: {number},   // reference to parent nodeInfo>
	         *         parentIndex: {number},  // index in parent's `childNodes` collection
	         *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
	         *       },
	         *       ...
	         *     ],
	         *     // When true, the template had the `strip-whitespace` attribute
	         *     // or was nested in a template with that setting
	         *     stripWhitespace: {boolean},
	         *     // For nested templates, nested template content is moved into
	         *     // a document fragment stored here; this is an optimization to
	         *     // avoid the cost of nested template cloning
	         *     content: {DocumentFragment}
	         *   }
	         * ```
	         *
	         * This method kicks off a recursive treewalk as follows:
	         *
	         * ```
	         *    _parseTemplate <---------------------+
	         *      _parseTemplateContent              |
	         *        _parseTemplateNode  <------------|--+
	         *          _parseTemplateNestedTemplate --+  |
	         *          _parseTemplateChildNodes ---------+
	         *          _parseTemplateNodeAttributes
	         *            _parseTemplateNodeAttribute
	         *
	         * ```
	         *
	         * These methods may be overridden to add custom metadata about templates
	         * to either `templateInfo` or `nodeInfo`.
	         *
	         * Note that this method may be destructive to the template, in that
	         * e.g. event annotations may be removed after being noted in the
	         * template metadata.
	         *
	         * @param {!HTMLTemplateElement} template Template to parse
	         * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
	         *   template, for parsing nested templates
	         * @return {!TemplateInfo} Parsed template metadata
	         */
	        value: function _parseTemplate(template, outerTemplateInfo) {
	          // since a template may be re-used, memo-ize metadata
	          if (!template._templateInfo) {
	            var templateInfo = template._templateInfo = {};
	            templateInfo.nodeInfoList = [];
	            templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');
	            this._parseTemplateContent(template, templateInfo, { parent: null });
	          }
	          return template._templateInfo;
	        }
	      }, {
	        key: '_parseTemplateContent',
	        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
	          return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
	        }

	        /**
	         * Parses template node and adds template and node metadata based on
	         * the current node, and its `childNodes` and `attributes`.
	         *
	         * This method may be overridden to add custom node or template specific
	         * metadata based on this node.
	         *
	         * @param {Node} node Node to parse
	         * @param {!TemplateInfo} templateInfo Template metadata for current template
	         * @param {!NodeInfo} nodeInfo Node metadata for current template.
	         * @return {boolean} `true` if the visited node added node-specific
	         *   metadata to `nodeInfo`
	         */

	      }, {
	        key: '_parseTemplateNode',
	        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
	          var noted = void 0;
	          var element = /** @type {Element} */node;
	          if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
	            noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
	          } else if (element.localName === 'slot') {
	            // For ShadyDom optimization, indicating there is an insertion point
	            templateInfo.hasInsertionPoint = true;
	          }
	          if (element.firstChild) {
	            noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
	          }
	          if (element.hasAttributes && element.hasAttributes()) {
	            noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
	          }
	          return noted;
	        }

	        /**
	         * Parses template child nodes for the given root node.
	         *
	         * This method also wraps whitelisted legacy template extensions
	         * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
	         * wrappers, collapses text nodes, and strips whitespace from the template
	         * if the `templateInfo.stripWhitespace` setting was provided.
	         *
	         * @param {Node} root Root node whose `childNodes` will be parsed
	         * @param {!TemplateInfo} templateInfo Template metadata for current template
	         * @param {!NodeInfo} nodeInfo Node metadata for current template.
	         * @return {void}
	         */

	      }, {
	        key: '_parseTemplateChildNodes',
	        value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
	          if (root.localName === 'script' || root.localName === 'style') {
	            return;
	          }
	          for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {
	            // Wrap templates
	            if (node.localName == 'template') {
	              node = wrapTemplateExtension(node);
	            }
	            // collapse adjacent textNodes: fixes an IE issue that can cause
	            // text nodes to be inexplicably split =(
	            // note that root.normalize() should work but does not so we do this
	            // manually.
	            next = node.nextSibling;
	            if (node.nodeType === Node.TEXT_NODE) {
	              var /** Node */n = next;
	              while (n && n.nodeType === Node.TEXT_NODE) {
	                node.textContent += n.textContent;
	                next = n.nextSibling;
	                root.removeChild(n);
	                n = next;
	              }
	              // optionally strip whitespace
	              if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
	                root.removeChild(node);
	                continue;
	              }
	            }
	            var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };
	            if (this._parseTemplateNode(node, templateInfo, childInfo)) {
	              childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;
	            }
	            // Increment if not removed
	            if (node.parentNode) {
	              parentIndex++;
	            }
	          }
	        }

	        /**
	         * Parses template content for the given nested `<template>`.
	         *
	         * Nested template info is stored as `templateInfo` in the current node's
	         * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
	         * It will then be the responsibility of the host to set it back to the
	         * template and for users stamping nested templates to use the
	         * `_contentForTemplate` method to retrieve the content for this template
	         * (an optimization to avoid the cost of cloning nested template content).
	         *
	         * @param {HTMLTemplateElement} node Node to parse (a <template>)
	         * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
	         *   that includes the template `node`
	         * @param {!NodeInfo} nodeInfo Node metadata for current template.
	         * @return {boolean} `true` if the visited node added node-specific
	         *   metadata to `nodeInfo`
	         */

	      }, {
	        key: '_parseTemplateNestedTemplate',
	        value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
	          var templateInfo = this._parseTemplate(node, outerTemplateInfo);
	          var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
	          content.appendChild(node.content);
	          nodeInfo.templateInfo = templateInfo;
	          return true;
	        }

	        /**
	         * Parses template node attributes and adds node metadata to `nodeInfo`
	         * for nodes of interest.
	         *
	         * @param {Element} node Node to parse
	         * @param {TemplateInfo} templateInfo Template metadata for current template
	         * @param {NodeInfo} nodeInfo Node metadata for current template.
	         * @return {boolean} `true` if the visited node added node-specific
	         *   metadata to `nodeInfo`
	         */

	      }, {
	        key: '_parseTemplateNodeAttributes',
	        value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
	          // Make copy of original attribute list, since the order may change
	          // as attributes are added and removed
	          var noted = false;
	          var attrs = Array.from(node.attributes);
	          for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
	            noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
	          }
	          return noted;
	        }

	        /**
	         * Parses a single template node attribute and adds node metadata to
	         * `nodeInfo` for attributes of interest.
	         *
	         * This implementation adds metadata for `on-event="handler"` attributes
	         * and `id` attributes.
	         *
	         * @param {Element} node Node to parse
	         * @param {!TemplateInfo} templateInfo Template metadata for current template
	         * @param {!NodeInfo} nodeInfo Node metadata for current template.
	         * @param {string} name Attribute name
	         * @param {string} value Attribute value
	         * @return {boolean} `true` if the visited node added node-specific
	         *   metadata to `nodeInfo`
	         */

	      }, {
	        key: '_parseTemplateNodeAttribute',
	        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
	          // events (on-*)
	          if (name.slice(0, 3) === 'on-') {
	            node.removeAttribute(name);
	            nodeInfo.events = nodeInfo.events || [];
	            nodeInfo.events.push({
	              name: name.slice(3),
	              value: value
	            });
	            return true;
	          }
	          // static id
	          else if (name === 'id') {
	              nodeInfo.id = value;
	              return true;
	            }
	          return false;
	        }

	        /**
	         * Returns the `content` document fragment for a given template.
	         *
	         * For nested templates, Polymer performs an optimization to cache nested
	         * template content to avoid the cost of cloning deeply nested templates.
	         * This method retrieves the cached content for a given template.
	         *
	         * @param {HTMLTemplateElement} template Template to retrieve `content` for
	         * @return {DocumentFragment} Content fragment
	         */

	      }, {
	        key: '_contentForTemplate',
	        value: function _contentForTemplate(template) {
	          var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;
	          return templateInfo && templateInfo.content || template.content;
	        }
	      }]);
	      return TemplateStamp;
	    }(superClass);

	    return TemplateStamp;
	  });

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  /** @const {Object} */
	  var CaseMap = caseMap$0;

	  // Monotonically increasing unique ID used for de-duping effects triggered
	  // from multiple properties in the same turn
	  var dedupeId$1 = 0;

	  /**
	   * Property effect types; effects are stored on the prototype using these keys
	   * @enum {string}
	   */
	  var TYPES = {
	    COMPUTE: '__computeEffects',
	    REFLECT: '__reflectEffects',
	    NOTIFY: '__notifyEffects',
	    PROPAGATE: '__propagateEffects',
	    OBSERVE: '__observeEffects',
	    READ_ONLY: '__readOnly'
	  };

	  /** @const {RegExp} */
	  var capitalAttributeRegex = /[A-Z]/;

	  /**
	   * Ensures that the model has an own-property map of effects for the given type.
	   * The model may be a prototype or an instance.
	   *
	   * Property effects are stored as arrays of effects by property in a map,
	   * by named type on the model. e.g.
	   *
	   *   __computeEffects: {
	   *     foo: [ ... ],
	   *     bar: [ ... ]
	   *   }
	   *
	   * If the model does not yet have an effect map for the type, one is created
	   * and returned.  If it does, but it is not an own property (i.e. the
	   * prototype had effects), the the map is deeply cloned and the copy is
	   * set on the model and returned, ready for new effects to be added.
	   *
	   * @param {Object} model Prototype or instance
	   * @param {string} type Property effect type
	   * @return {Object} The own-property map of effects for the given type
	   * @private
	   */
	  function ensureOwnEffectMap(model, type) {
	    var effects = model[type];
	    if (!effects) {
	      effects = model[type] = {};
	    } else if (!model.hasOwnProperty(type)) {
	      effects = model[type] = Object.create(model[type]);
	      for (var p in effects) {
	        var protoFx = effects[p];
	        var instFx = effects[p] = Array(protoFx.length);
	        for (var i = 0; i < protoFx.length; i++) {
	          instFx[i] = protoFx[i];
	        }
	      }
	    }
	    return effects;
	  }

	  // -- effects ----------------------------------------------

	  /**
	   * Runs all effects of a given type for the given set of property changes
	   * on an instance.
	   *
	   * @param {!PropertyEffectsType} inst The instance with effects to run
	   * @param {Object} effects Object map of property-to-Array of effects
	   * @param {Object} props Bag of current property changes
	   * @param {Object=} oldProps Bag of previous values for changed properties
	   * @param {boolean=} hasPaths True with `props` contains one or more paths
	   * @param {*=} extraArgs Additional metadata to pass to effect function
	   * @return {boolean} True if an effect ran for this property
	   * @private
	   */
	  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
	    if (effects) {
	      var ran = false;
	      var id = dedupeId$1++;
	      for (var prop in props) {
	        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
	          ran = true;
	        }
	      }
	      return ran;
	    }
	    return false;
	  }

	  /**
	   * Runs a list of effects for a given property.
	   *
	   * @param {!PropertyEffectsType} inst The instance with effects to run
	   * @param {Object} effects Object map of property-to-Array of effects
	   * @param {number} dedupeId Counter used for de-duping effects
	   * @param {string} prop Name of changed property
	   * @param {*} props Changed properties
	   * @param {*} oldProps Old properties
	   * @param {boolean=} hasPaths True with `props` contains one or more paths
	   * @param {*=} extraArgs Additional metadata to pass to effect function
	   * @return {boolean} True if an effect ran for this property
	   * @private
	   */
	  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
	    var ran = false;
	    var rootProperty = hasPaths ? root(prop) : prop;
	    var fxs = effects[rootProperty];
	    if (fxs) {
	      for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
	        if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
	          if (fx.info) {
	            fx.info.lastRun = dedupeId;
	          }
	          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
	          ran = true;
	        }
	      }
	    }
	    return ran;
	  }

	  /**
	   * Determines whether a property/path that has changed matches the trigger
	   * criteria for an effect.  A trigger is a descriptor with the following
	   * structure, which matches the descriptors returned from `parseArg`.
	   * e.g. for `foo.bar.*`:
	   * ```
	   * trigger: {
	   *   name: 'a.b',
	   *   structured: true,
	   *   wildcard: true
	   * }
	   * ```
	   * If no trigger is given, the path is deemed to match.
	   *
	   * @param {string} path Path or property that changed
	   * @param {DataTrigger} trigger Descriptor
	   * @return {boolean} Whether the path matched the trigger
	   */
	  function pathMatchesTrigger(path, trigger) {
	    if (trigger) {
	      var triggerPath = trigger.name;
	      return triggerPath == path || trigger.structured && isAncestor(triggerPath, path) || trigger.wildcard && isDescendant(triggerPath, path);
	    } else {
	      return true;
	    }
	  }

	  /**
	   * Implements the "observer" effect.
	   *
	   * Calls the method with `info.methodName` on the instance, passing the
	   * new and old values.
	   *
	   * @param {!PropertyEffectsType} inst The instance the effect will be run on
	   * @param {string} property Name of property
	   * @param {Object} props Bag of current property changes
	   * @param {Object} oldProps Bag of previous values for changed properties
	   * @param {?} info Effect metadata
	   * @return {void}
	   * @private
	   */
	  function runObserverEffect(inst, property, props, oldProps, info) {
	    var fn = typeof info.method === "string" ? inst[info.method] : info.method;
	    var changedProp = info.property;
	    if (fn) {
	      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
	    } else if (!info.dynamicFn) {
	      console.warn('observer method `' + info.method + '` not defined');
	    }
	  }

	  /**
	   * Runs "notify" effects for a set of changed properties.
	   *
	   * This method differs from the generic `runEffects` method in that it
	   * will dispatch path notification events in the case that the property
	   * changed was a path and the root property for that path didn't have a
	   * "notify" effect.  This is to maintain 1.0 behavior that did not require
	   * `notify: true` to ensure object sub-property notifications were
	   * sent.
	   *
	   * @param {!PropertyEffectsType} inst The instance with effects to run
	   * @param {Object} notifyProps Bag of properties to notify
	   * @param {Object} props Bag of current property changes
	   * @param {Object} oldProps Bag of previous values for changed properties
	   * @param {boolean} hasPaths True with `props` contains one or more paths
	   * @return {void}
	   * @private
	   */
	  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
	    // Notify
	    var fxs = inst[TYPES.NOTIFY];
	    var notified = void 0;
	    var id = dedupeId$1++;
	    // Try normal notify effects; if none, fall back to try path notification
	    for (var prop in notifyProps) {
	      if (notifyProps[prop]) {
	        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
	          notified = true;
	        } else if (hasPaths && notifyPath(inst, prop, props)) {
	          notified = true;
	        }
	      }
	    }
	    // Flush host if we actually notified and host was batching
	    // And the host has already initialized clients; this prevents
	    // an issue with a host observing data changes before clients are ready.
	    var host = void 0;
	    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
	      host._invalidateProperties();
	    }
	  }

	  /**
	   * Dispatches {property}-changed events with path information in the detail
	   * object to indicate a sub-path of the property was changed.
	   *
	   * @param {!PropertyEffectsType} inst The element from which to fire the event
	   * @param {string} path The path that was changed
	   * @param {Object} props Bag of current property changes
	   * @return {boolean} Returns true if the path was notified
	   * @private
	   */
	  function notifyPath(inst, path, props) {
	    var rootProperty = root(path);
	    if (rootProperty !== path) {
	      var eventName = camelToDashCase(rootProperty) + '-changed';
	      dispatchNotifyEvent(inst, eventName, props[path], path);
	      return true;
	    }
	    return false;
	  }

	  /**
	   * Dispatches {property}-changed events to indicate a property (or path)
	   * changed.
	   *
	   * @param {!PropertyEffectsType} inst The element from which to fire the event
	   * @param {string} eventName The name of the event to send ('{property}-changed')
	   * @param {*} value The value of the changed property
	   * @param {string | null | undefined} path If a sub-path of this property changed, the path
	   *   that changed (optional).
	   * @return {void}
	   * @private
	   * @suppress {invalidCasts}
	   */
	  function dispatchNotifyEvent(inst, eventName, value, path) {
	    var detail = {
	      value: value,
	      queueProperty: true
	    };
	    if (path) {
	      detail.path = path;
	    }
	    /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));
	  }

	  /**
	   * Implements the "notify" effect.
	   *
	   * Dispatches a non-bubbling event named `info.eventName` on the instance
	   * with a detail object containing the new `value`.
	   *
	   * @param {!PropertyEffectsType} inst The instance the effect will be run on
	   * @param {string} property Name of property
	   * @param {Object} props Bag of current property changes
	   * @param {Object} oldProps Bag of previous values for changed properties
	   * @param {?} info Effect metadata
	   * @param {boolean} hasPaths True with `props` contains one or more paths
	   * @return {void}
	   * @private
	   */
	  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
	    var rootProperty = hasPaths ? root(property) : property;
	    var path = rootProperty != property ? property : null;
	    var value = path ? get$1(inst, path) : inst.__data[property];
	    if (path && value === undefined) {
	      value = props[property]; // specifically for .splices
	    }
	    dispatchNotifyEvent(inst, info.eventName, value, path);
	  }

	  /**
	   * Handler function for 2-way notification events. Receives context
	   * information captured in the `addNotifyListener` closure from the
	   * `__notifyListeners` metadata.
	   *
	   * Sets the value of the notified property to the host property or path.  If
	   * the event contained path information, translate that path to the host
	   * scope's name for that path first.
	   *
	   * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
	   * @param {!PropertyEffectsType} inst Host element instance handling the notification event
	   * @param {string} fromProp Child element property that was bound
	   * @param {string} toPath Host property/path that was bound
	   * @param {boolean} negate Whether the binding was negated
	   * @return {void}
	   * @private
	   */
	  function handleNotification(event, inst, fromProp, toPath, negate) {
	    var value = void 0;
	    var detail = /** @type {Object} */event.detail;
	    var fromPath = detail && detail.path;
	    if (fromPath) {
	      toPath = translate(fromProp, toPath, fromPath);
	      value = detail && detail.value;
	    } else {
	      value = event.target[fromProp];
	    }
	    value = negate ? !value : value;
	    if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
	      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
	        inst._invalidateProperties();
	      }
	    }
	  }

	  /**
	   * Implements the "reflect" effect.
	   *
	   * Sets the attribute named `info.attrName` to the given property value.
	   *
	   * @param {!PropertyEffectsType} inst The instance the effect will be run on
	   * @param {string} property Name of property
	   * @param {Object} props Bag of current property changes
	   * @param {Object} oldProps Bag of previous values for changed properties
	   * @param {?} info Effect metadata
	   * @return {void}
	   * @private
	   */
	  function runReflectEffect(inst, property, props, oldProps, info) {
	    var value = inst.__data[property];
	    if (sanitizeDOMValue) {
	      value = sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */inst);
	    }
	    inst._propertyToAttribute(property, info.attrName, value);
	  }

	  /**
	   * Runs "computed" effects for a set of changed properties.
	   *
	   * This method differs from the generic `runEffects` method in that it
	   * continues to run computed effects based on the output of each pass until
	   * there are no more newly computed properties.  This ensures that all
	   * properties that will be computed by the initial set of changes are
	   * computed before other effects (binding propagation, observers, and notify)
	   * run.
	   *
	   * @param {!PropertyEffectsType} inst The instance the effect will be run on
	   * @param {!Object} changedProps Bag of changed properties
	   * @param {!Object} oldProps Bag of previous values for changed properties
	   * @param {boolean} hasPaths True with `props` contains one or more paths
	   * @return {void}
	   * @private
	   */
	  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
	    var computeEffects = inst[TYPES.COMPUTE];
	    if (computeEffects) {
	      var inputProps = changedProps;
	      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
	        Object.assign(oldProps, inst.__dataOld);
	        Object.assign(changedProps, inst.__dataPending);
	        inputProps = inst.__dataPending;
	        inst.__dataPending = null;
	      }
	    }
	  }

	  /**
	   * Implements the "computed property" effect by running the method with the
	   * values of the arguments specified in the `info` object and setting the
	   * return value to the computed property specified.
	   *
	   * @param {!PropertyEffectsType} inst The instance the effect will be run on
	   * @param {string} property Name of property
	   * @param {Object} props Bag of current property changes
	   * @param {Object} oldProps Bag of previous values for changed properties
	   * @param {?} info Effect metadata
	   * @return {void}
	   * @private
	   */
	  function runComputedEffect(inst, property, props, oldProps, info) {
	    var result = runMethodEffect(inst, property, props, oldProps, info);
	    var computedProp = info.methodInfo;
	    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
	      inst._setPendingProperty(computedProp, result, true);
	    } else {
	      inst[computedProp] = result;
	    }
	  }

	  /**
	   * Computes path changes based on path links set up using the `linkPaths`
	   * API.
	   *
	   * @param {!PropertyEffectsType} inst The instance whose props are changing
	   * @param {string | !Array<(string|number)>} path Path that has changed
	   * @param {*} value Value of changed path
	   * @return {void}
	   * @private
	   */
	  function computeLinkedPaths(inst, path, value) {
	    var links = inst.__dataLinkedPaths;
	    if (links) {
	      var link = void 0;
	      for (var a in links) {
	        var b = links[a];
	        if (isDescendant(a, path)) {
	          link = translate(a, b, path);
	          inst._setPendingPropertyOrPath(link, value, true, true);
	        } else if (isDescendant(b, path)) {
	          link = translate(b, a, path);
	          inst._setPendingPropertyOrPath(link, value, true, true);
	        }
	      }
	    }
	  }

	  // -- bindings ----------------------------------------------

	  /**
	   * Adds binding metadata to the current `nodeInfo`, and binding effects
	   * for all part dependencies to `templateInfo`.
	   *
	   * @param {Function} constructor Class that `_parseTemplate` is currently
	   *   running on
	   * @param {TemplateInfo} templateInfo Template metadata for current template
	   * @param {NodeInfo} nodeInfo Node metadata for current template node
	   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
	   * @param {string} target Target property name
	   * @param {!Array<!BindingPart>} parts Array of binding part metadata
	   * @param {string=} literal Literal text surrounding binding parts (specified
	   *   only for 'property' bindings, since these must be initialized as part
	   *   of boot-up)
	   * @return {void}
	   * @private
	   */
	  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
	    // Create binding metadata and add to nodeInfo
	    nodeInfo.bindings = nodeInfo.bindings || [];
	    var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };
	    nodeInfo.bindings.push(binding);
	    // Add listener info to binding metadata
	    if (shouldAddListener(binding)) {
	      var _binding$parts$ = binding.parts[0],
	          event = _binding$parts$.event,
	          negate = _binding$parts$.negate;

	      binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
	      binding.listenerNegate = negate;
	    }
	    // Add "propagate" property effects to templateInfo
	    var index = templateInfo.nodeInfoList.length;
	    for (var i = 0; i < binding.parts.length; i++) {
	      var part = binding.parts[i];
	      part.compoundIndex = i;
	      addEffectForBindingPart(constructor, templateInfo, binding, part, index);
	    }
	  }

	  /**
	   * Adds property effects to the given `templateInfo` for the given binding
	   * part.
	   *
	   * @param {Function} constructor Class that `_parseTemplate` is currently
	   *   running on
	   * @param {TemplateInfo} templateInfo Template metadata for current template
	   * @param {!Binding} binding Binding metadata
	   * @param {!BindingPart} part Binding part metadata
	   * @param {number} index Index into `nodeInfoList` for this node
	   * @return {void}
	   */
	  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
	    if (!part.literal) {
	      if (binding.kind === 'attribute' && binding.target[0] === '-') {
	        console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
	      } else {
	        var dependencies = part.dependencies;
	        var info = { index: index, binding: binding, part: part, evaluator: constructor };
	        for (var j = 0; j < dependencies.length; j++) {
	          var trigger = dependencies[j];
	          if (typeof trigger == 'string') {
	            trigger = parseArg(trigger);
	            trigger.wildcard = true;
	          }
	          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
	            fn: runBindingEffect,
	            info: info, trigger: trigger
	          });
	        }
	      }
	    }
	  }

	  /**
	   * Implements the "binding" (property/path binding) effect.
	   *
	   * Note that binding syntax is overridable via `_parseBindings` and
	   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
	   * non-literal parts returned from `_parseBindings`.  However,
	   * there is no support for _path_ bindings via custom binding parts,
	   * as this is specific to Polymer's path binding syntax.
	   *
	   * @param {!PropertyEffectsType} inst The instance the effect will be run on
	   * @param {string} path Name of property
	   * @param {Object} props Bag of current property changes
	   * @param {Object} oldProps Bag of previous values for changed properties
	   * @param {?} info Effect metadata
	   * @param {boolean} hasPaths True with `props` contains one or more paths
	   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
	   *   metadata
	   * @return {void}
	   * @private
	   */
	  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
	    var node = nodeList[info.index];
	    var binding = info.binding;
	    var part = info.part;
	    // Subpath notification: transform path and set to client
	    // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
	    if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
	      var value = props[path];
	      path = translate(part.source, binding.target, path);
	      if (node._setPendingPropertyOrPath(path, value, false, true)) {
	        inst._enqueueClient(node);
	      }
	    } else {
	      var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
	      // Propagate value to child
	      applyBindingValue(inst, node, binding, part, _value);
	    }
	  }

	  /**
	   * Sets the value for an "binding" (binding) effect to a node,
	   * either as a property or attribute.
	   *
	   * @param {!PropertyEffectsType} inst The instance owning the binding effect
	   * @param {Node} node Target node for binding
	   * @param {!Binding} binding Binding metadata
	   * @param {!BindingPart} part Binding part metadata
	   * @param {*} value Value to set
	   * @return {void}
	   * @private
	   */
	  function applyBindingValue(inst, node, binding, part, value) {
	    value = computeBindingValue(node, value, binding, part);
	    if (sanitizeDOMValue) {
	      value = sanitizeDOMValue(value, binding.target, binding.kind, node);
	    }
	    if (binding.kind == 'attribute') {
	      // Attribute binding
	      inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);
	    } else {
	      // Property binding
	      var prop = binding.target;
	      if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
	        if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
	          if (node._setPendingProperty(prop, value)) {
	            inst._enqueueClient(node);
	          }
	        }
	      } else {
	        inst._setUnmanagedPropertyToNode(node, prop, value);
	      }
	    }
	  }

	  /**
	   * Transforms an "binding" effect value based on compound & negation
	   * effect metadata, as well as handling for special-case properties
	   *
	   * @param {Node} node Node the value will be set to
	   * @param {*} value Value to set
	   * @param {!Binding} binding Binding metadata
	   * @param {!BindingPart} part Binding part metadata
	   * @return {*} Transformed value to set
	   * @private
	   */
	  function computeBindingValue(node, value, binding, part) {
	    if (binding.isCompound) {
	      var storage = node.__dataCompoundStorage[binding.target];
	      storage[part.compoundIndex] = value;
	      value = storage.join('');
	    }
	    if (binding.kind !== 'attribute') {
	      // Some browsers serialize `undefined` to `"undefined"`
	      if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {
	        value = value == undefined ? '' : value;
	      }
	    }
	    return value;
	  }

	  /**
	   * Returns true if a binding's metadata meets all the requirements to allow
	   * 2-way binding, and therefore a `<property>-changed` event listener should be
	   * added:
	   * - used curly braces
	   * - is a property (not attribute) binding
	   * - is not a textContent binding
	   * - is not compound
	   *
	   * @param {!Binding} binding Binding metadata
	   * @return {boolean} True if 2-way listener should be added
	   * @private
	   */
	  function shouldAddListener(binding) {
	    return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
	  }

	  /**
	   * Setup compound binding storage structures, notify listeners, and dataHost
	   * references onto the bound nodeList.
	   *
	   * @param {!PropertyEffectsType} inst Instance that bas been previously bound
	   * @param {TemplateInfo} templateInfo Template metadata
	   * @return {void}
	   * @private
	   */
	  function setupBindings(inst, templateInfo) {
	    // Setup compound storage, dataHost, and notify listeners
	    var nodeList = templateInfo.nodeList,
	        nodeInfoList = templateInfo.nodeInfoList;

	    if (nodeInfoList.length) {
	      for (var i = 0; i < nodeInfoList.length; i++) {
	        var info = nodeInfoList[i];
	        var node = nodeList[i];
	        var bindings = info.bindings;
	        if (bindings) {
	          for (var _i = 0; _i < bindings.length; _i++) {
	            var binding = bindings[_i];
	            setupCompoundStorage(node, binding);
	            addNotifyListener(node, inst, binding);
	          }
	        }
	        node.__dataHost = inst;
	      }
	    }
	  }

	  /**
	   * Initializes `__dataCompoundStorage` local storage on a bound node with
	   * initial literal data for compound bindings, and sets the joined
	   * literal parts to the bound property.
	   *
	   * When changes to compound parts occur, they are first set into the compound
	   * storage array for that property, and then the array is joined to result in
	   * the final value set to the property/attribute.
	   *
	   * @param {Node} node Bound node to initialize
	   * @param {Binding} binding Binding metadata
	   * @return {void}
	   * @private
	   */
	  function setupCompoundStorage(node, binding) {
	    if (binding.isCompound) {
	      // Create compound storage map
	      var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
	      var parts = binding.parts;
	      // Copy literals from parts into storage for this binding
	      var literals = new Array(parts.length);
	      for (var j = 0; j < parts.length; j++) {
	        literals[j] = parts[j].literal;
	      }
	      var target = binding.target;
	      storage[target] = literals;
	      // Configure properties with their literal parts
	      if (binding.literal && binding.kind == 'property') {
	        node[target] = binding.literal;
	      }
	    }
	  }

	  /**
	   * Adds a 2-way binding notification event listener to the node specified
	   *
	   * @param {Object} node Child element to add listener to
	   * @param {!PropertyEffectsType} inst Host element instance to handle notification event
	   * @param {Binding} binding Binding metadata
	   * @return {void}
	   * @private
	   */
	  function addNotifyListener(node, inst, binding) {
	    if (binding.listenerEvent) {
	      var part = binding.parts[0];
	      node.addEventListener(binding.listenerEvent, function (e) {
	        handleNotification(e, inst, binding.target, part.source, part.negate);
	      });
	    }
	  }

	  // -- for method-based effects (complexObserver & computed) --------------

	  /**
	   * Adds property effects for each argument in the method signature (and
	   * optionally, for the method name if `dynamic` is true) that calls the
	   * provided effect function.
	   *
	   * @param {Element | Object} model Prototype or instance
	   * @param {!MethodSignature} sig Method signature metadata
	   * @param {string} type Type of property effect to add
	   * @param {Function} effectFn Function to run when arguments change
	   * @param {*=} methodInfo Effect-specific information to be included in
	   *   method effect metadata
	   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
	   *   method names should be included as a dependency to the effect. Note,
	   *   defaults to true if the signature is static (sig.static is true).
	   * @return {void}
	   * @private
	   */
	  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
	    dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);
	    var info = {
	      methodName: sig.methodName,
	      args: sig.args,
	      methodInfo: methodInfo,
	      dynamicFn: dynamicFn
	    };
	    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
	      if (!arg.literal) {
	        model._addPropertyEffect(arg.rootProperty, type, {
	          fn: effectFn, info: info, trigger: arg
	        });
	      }
	    }
	    if (dynamicFn) {
	      model._addPropertyEffect(sig.methodName, type, {
	        fn: effectFn, info: info
	      });
	    }
	  }

	  /**
	   * Calls a method with arguments marshaled from properties on the instance
	   * based on the method signature contained in the effect metadata.
	   *
	   * Multi-property observers, computed properties, and inline computing
	   * functions call this function to invoke the method, then use the return
	   * value accordingly.
	   *
	   * @param {!PropertyEffectsType} inst The instance the effect will be run on
	   * @param {string} property Name of property
	   * @param {Object} props Bag of current property changes
	   * @param {Object} oldProps Bag of previous values for changed properties
	   * @param {?} info Effect metadata
	   * @return {*} Returns the return value from the method invocation
	   * @private
	   */
	  function runMethodEffect(inst, property, props, oldProps, info) {
	    // Instances can optionally have a _methodHost which allows redirecting where
	    // to find methods. Currently used by `templatize`.
	    var context = inst._methodHost || inst;
	    var fn = context[info.methodName];
	    if (fn) {
	      var args = marshalArgs(inst.__data, info.args, property, props);
	      return fn.apply(context, args);
	    } else if (!info.dynamicFn) {
	      console.warn('method `' + info.methodName + '` not defined');
	    }
	  }

	  var emptyArray = [];

	  // Regular expressions used for binding
	  var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
	  var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
	  var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
	  var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
	  var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
	  var ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
	  var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
	  var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
	  var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
	  var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
	  var CLOSE_BRACKET = '(?:]]|}})';
	  var NEGATE = '(?:(!)\\s*)?'; // Group 2
	  var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
	  var bindingRegex = new RegExp(EXPRESSION, "g");

	  /**
	   * Create a string from binding parts of all the literal parts
	   *
	   * @param {!Array<BindingPart>} parts All parts to stringify
	   * @return {string} String made from the literal parts
	   */
	  function literalFromParts(parts) {
	    var s = '';
	    for (var i = 0; i < parts.length; i++) {
	      var literal = parts[i].literal;
	      s += literal || '';
	    }
	    return s;
	  }

	  /**
	   * Parses an expression string for a method signature, and returns a metadata
	   * describing the method in terms of `methodName`, `static` (whether all the
	   * arguments are literals), and an array of `args`
	   *
	   * @param {string} expression The expression to parse
	   * @return {?MethodSignature} The method metadata object if a method expression was
	   *   found, otherwise `undefined`
	   * @private
	   */
	  function parseMethod(expression) {
	    // tries to match valid javascript property names
	    var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
	    if (m) {
	      var methodName = m[1];
	      var sig = { methodName: methodName, static: true, args: emptyArray };
	      if (m[2].trim()) {
	        // replace escaped commas with comma entity, split on un-escaped commas
	        var args = m[2].replace(/\\,/g, '&comma;').split(',');
	        return parseArgs(args, sig);
	      } else {
	        return sig;
	      }
	    }
	    return null;
	  }

	  /**
	   * Parses an array of arguments and sets the `args` property of the supplied
	   * signature metadata object. Sets the `static` property to false if any
	   * argument is a non-literal.
	   *
	   * @param {!Array<string>} argList Array of argument names
	   * @param {!MethodSignature} sig Method signature metadata object
	   * @return {!MethodSignature} The updated signature metadata object
	   * @private
	   */
	  function parseArgs(argList, sig) {
	    sig.args = argList.map(function (rawArg) {
	      var arg = parseArg(rawArg);
	      if (!arg.literal) {
	        sig.static = false;
	      }
	      return arg;
	    }, this);
	    return sig;
	  }

	  /**
	   * Parses an individual argument, and returns an argument metadata object
	   * with the following fields:
	   *
	   *   {
	   *     value: 'prop',        // property/path or literal value
	   *     literal: false,       // whether argument is a literal
	   *     structured: false,    // whether the property is a path
	   *     rootProperty: 'prop', // the root property of the path
	   *     wildcard: false       // whether the argument was a wildcard '.*' path
	   *   }
	   *
	   * @param {string} rawArg The string value of the argument
	   * @return {!MethodArg} Argument metadata object
	   * @private
	   */
	  function parseArg(rawArg) {
	    // clean up whitespace
	    var arg = rawArg.trim()
	    // replace comma entity with comma
	    .replace(/&comma;/g, ',')
	    // repair extra escape sequences; note only commas strictly need
	    // escaping, but we allow any other char to be escaped since its
	    // likely users will do this
	    .replace(/\\(.)/g, '\$1');
	    // basic argument descriptor
	    var a = {
	      name: arg,
	      value: '',
	      literal: false
	    };
	    // detect literal value (must be String or Number)
	    var fc = arg[0];
	    if (fc === '-') {
	      fc = arg[1];
	    }
	    if (fc >= '0' && fc <= '9') {
	      fc = '#';
	    }
	    switch (fc) {
	      case "'":
	      case '"':
	        a.value = arg.slice(1, -1);
	        a.literal = true;
	        break;
	      case '#':
	        a.value = Number(arg);
	        a.literal = true;
	        break;
	    }
	    // if not literal, look for structured path
	    if (!a.literal) {
	      a.rootProperty = root(arg);
	      // detect structured path (has dots)
	      a.structured = isPath(arg);
	      if (a.structured) {
	        a.wildcard = arg.slice(-2) == '.*';
	        if (a.wildcard) {
	          a.name = arg.slice(0, -2);
	        }
	      }
	    }
	    return a;
	  }

	  /**
	   * Gather the argument values for a method specified in the provided array
	   * of argument metadata.
	   *
	   * The `path` and `value` arguments are used to fill in wildcard descriptor
	   * when the method is being called as a result of a path notification.
	   *
	   * @param {Object} data Instance data storage object to read properties from
	   * @param {!Array<!MethodArg>} args Array of argument metadata
	   * @param {string} path Property/path name that triggered the method effect
	   * @param {Object} props Bag of current property changes
	   * @return {Array<*>} Array of argument values
	   * @private
	   */
	  function marshalArgs(data, args, path, props) {
	    var values = [];
	    for (var i = 0, l = args.length; i < l; i++) {
	      var arg = args[i];
	      var name = arg.name;
	      var v = void 0;
	      if (arg.literal) {
	        v = arg.value;
	      } else {
	        if (arg.structured) {
	          v = get$1(data, name);
	          // when data is not stored e.g. `splices`
	          if (v === undefined) {
	            v = props[name];
	          }
	        } else {
	          v = data[name];
	        }
	      }
	      if (arg.wildcard) {
	        // Only send the actual path changed info if the change that
	        // caused the observer to run matched the wildcard
	        var baseChanged = name.indexOf(path + '.') === 0;
	        var matches$$1 = path.indexOf(name) === 0 && !baseChanged;
	        values[i] = {
	          path: matches$$1 ? path : name,
	          value: matches$$1 ? props[path] : v,
	          base: v
	        };
	      } else {
	        values[i] = v;
	      }
	    }
	    return values;
	  }

	  // data api

	  /**
	   * Sends array splice notifications (`.splices` and `.length`)
	   *
	   * Note: this implementation only accepts normalized paths
	   *
	   * @param {!PropertyEffectsType} inst Instance to send notifications to
	   * @param {Array} array The array the mutations occurred on
	   * @param {string} path The path to the array that was mutated
	   * @param {Array} splices Array of splice records
	   * @return {void}
	   * @private
	   */
	  function _notifySplices(inst, array, path, splices) {
	    var splicesPath = path + '.splices';
	    inst.notifyPath(splicesPath, { indexSplices: splices });
	    inst.notifyPath(path + '.length', array.length);
	    // Null here to allow potentially large splice records to be GC'ed.
	    inst.__data[splicesPath] = { indexSplices: null };
	  }

	  /**
	   * Creates a splice record and sends an array splice notification for
	   * the described mutation
	   *
	   * Note: this implementation only accepts normalized paths
	   *
	   * @param {!PropertyEffectsType} inst Instance to send notifications to
	   * @param {Array} array The array the mutations occurred on
	   * @param {string} path The path to the array that was mutated
	   * @param {number} index Index at which the array mutation occurred
	   * @param {number} addedCount Number of added items
	   * @param {Array} removed Array of removed items
	   * @return {void}
	   * @private
	   */
	  function notifySplice(inst, array, path, index, addedCount, removed) {
	    _notifySplices(inst, array, path, [{
	      index: index,
	      addedCount: addedCount,
	      removed: removed,
	      object: array,
	      type: 'splice'
	    }]);
	  }

	  /**
	   * Returns an upper-cased version of the string.
	   *
	   * @param {string} name String to uppercase
	   * @return {string} Uppercased string
	   * @private
	   */
	  function upper(name) {
	    return name[0].toUpperCase() + name.substring(1);
	  }

	  /**
	   * Element class mixin that provides meta-programming for Polymer's template
	   * binding and data observation (collectively, "property effects") system.
	   *
	   * This mixin uses provides the following key static methods for adding
	   * property effects to an element class:
	   * - `addPropertyEffect`
	   * - `createPropertyObserver`
	   * - `createMethodObserver`
	   * - `createNotifyingProperty`
	   * - `createReadOnlyProperty`
	   * - `createReflectedProperty`
	   * - `createComputedProperty`
	   * - `bindTemplate`
	   *
	   * Each method creates one or more property accessors, along with metadata
	   * used by this mixin's implementation of `_propertiesChanged` to perform
	   * the property effects.
	   *
	   * Underscored versions of the above methods also exist on the element
	   * prototype for adding property effects on instances at runtime.
	   *
	   * Note that this mixin overrides several `PropertyAccessors` methods, in
	   * many cases to maintain guarantees provided by the Polymer 1.x features;
	   * notably it changes property accessors to be synchronous by default
	   * whereas the default when using `PropertyAccessors` standalone is to be
	   * async by default.
	   *
	   * @mixinFunction
	   * @polymer
	   * @appliesMixin TemplateStamp
	   * @appliesMixin PropertyAccessors
	   * @summary Element class mixin that provides meta-programming for Polymer's
	   * template binding and data observation system.
	   */
	  var PropertyEffects = dedupingMixin(function (superClass) {

	    /**
	     * @constructor
	     * @extends {superClass}
	     * @implements {Polymer_PropertyAccessors}
	     * @implements {Polymer_TemplateStamp}
	     * @unrestricted
	     */
	    var propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));

	    /**
	     * @polymer
	     * @mixinClass
	     * @implements {Polymer_PropertyEffects}
	     * @extends {propertyEffectsBase}
	     * @unrestricted
	     */

	    var PropertyEffects = function (_propertyEffectsBase) {
	      inherits(PropertyEffects, _propertyEffectsBase);

	      function PropertyEffects() {
	        classCallCheck(this, PropertyEffects);

	        /** @type {boolean} */
	        // Used to identify users of this mixin, ala instanceof
	        var _this = possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));

	        _this.__isPropertyEffectsClient = true;
	        /** @type {number} */
	        // NOTE: used to track re-entrant calls to `_flushProperties`
	        // path changes dirty check against `__dataTemp` only during one "turn"
	        // and are cleared when `__dataCounter` returns to 0.
	        _this.__dataCounter = 0;
	        /** @type {boolean} */
	        _this.__dataClientsReady;
	        /** @type {Array} */
	        _this.__dataPendingClients;
	        /** @type {Object} */
	        _this.__dataToNotify;
	        /** @type {Object} */
	        _this.__dataLinkedPaths;
	        /** @type {boolean} */
	        _this.__dataHasPaths;
	        /** @type {Object} */
	        _this.__dataCompoundStorage;
	        /** @type {Polymer_PropertyEffects} */
	        _this.__dataHost;
	        /** @type {!Object} */
	        _this.__dataTemp;
	        /** @type {boolean} */
	        _this.__dataClientsInitialized;
	        /** @type {!Object} */
	        _this.__data;
	        /** @type {!Object} */
	        _this.__dataPending;
	        /** @type {!Object} */
	        _this.__dataOld;
	        /** @type {Object} */
	        _this.__computeEffects;
	        /** @type {Object} */
	        _this.__reflectEffects;
	        /** @type {Object} */
	        _this.__notifyEffects;
	        /** @type {Object} */
	        _this.__propagateEffects;
	        /** @type {Object} */
	        _this.__observeEffects;
	        /** @type {Object} */
	        _this.__readOnly;
	        /** @type {!TemplateInfo} */
	        _this.__templateInfo;
	        return _this;
	      }

	      createClass(PropertyEffects, [{
	        key: '_initializeProperties',


	        /**
	         * @return {void}
	         */
	        value: function _initializeProperties() {
	          get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);
	          hostStack.registerHost(this);
	          this.__dataClientsReady = false;
	          this.__dataPendingClients = null;
	          this.__dataToNotify = null;
	          this.__dataLinkedPaths = null;
	          this.__dataHasPaths = false;
	          // May be set on instance prior to upgrade
	          this.__dataCompoundStorage = this.__dataCompoundStorage || null;
	          this.__dataHost = this.__dataHost || null;
	          this.__dataTemp = {};
	          this.__dataClientsInitialized = false;
	        }

	        /**
	         * Overrides `PropertyAccessors` implementation to provide a
	         * more efficient implementation of initializing properties from
	         * the prototype on the instance.
	         *
	         * @override
	         * @param {Object} props Properties to initialize on the prototype
	         * @return {void}
	         */

	      }, {
	        key: '_initializeProtoProperties',
	        value: function _initializeProtoProperties(props) {
	          this.__data = Object.create(props);
	          this.__dataPending = Object.create(props);
	          this.__dataOld = {};
	        }

	        /**
	         * Overrides `PropertyAccessors` implementation to avoid setting
	         * `_setProperty`'s `shouldNotify: true`.
	         *
	         * @override
	         * @param {Object} props Properties to initialize on the instance
	         * @return {void}
	         */

	      }, {
	        key: '_initializeInstanceProperties',
	        value: function _initializeInstanceProperties(props) {
	          var readOnly = this[TYPES.READ_ONLY];
	          for (var prop in props) {
	            if (!readOnly || !readOnly[prop]) {
	              this.__dataPending = this.__dataPending || {};
	              this.__dataOld = this.__dataOld || {};
	              this.__data[prop] = this.__dataPending[prop] = props[prop];
	            }
	          }
	        }

	        // Prototype setup ----------------------------------------

	        /**
	         * Equivalent to static `addPropertyEffect` API but can be called on
	         * an instance to add effects at runtime.  See that method for
	         * full API docs.
	         *
	         * @param {string} property Property that should trigger the effect
	         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
	         * @param {Object=} effect Effect metadata object
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_addPropertyEffect',
	        value: function _addPropertyEffect(property, type, effect) {
	          this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
	          // effects are accumulated into arrays per property based on type
	          var effects = ensureOwnEffectMap(this, type)[property];
	          if (!effects) {
	            effects = this[type][property] = [];
	          }
	          effects.push(effect);
	        }

	        /**
	         * Removes the given property effect.
	         *
	         * @param {string} property Property the effect was associated with
	         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
	         * @param {Object=} effect Effect metadata object to remove
	         * @return {void}
	         */

	      }, {
	        key: '_removePropertyEffect',
	        value: function _removePropertyEffect(property, type, effect) {
	          var effects = ensureOwnEffectMap(this, type)[property];
	          var idx = effects.indexOf(effect);
	          if (idx >= 0) {
	            effects.splice(idx, 1);
	          }
	        }

	        /**
	         * Returns whether the current prototype/instance has a property effect
	         * of a certain type.
	         *
	         * @param {string} property Property name
	         * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
	         * @return {boolean} True if the prototype/instance has an effect of this type
	         * @protected
	         */

	      }, {
	        key: '_hasPropertyEffect',
	        value: function _hasPropertyEffect(property, type) {
	          var effects = this[type];
	          return Boolean(effects && effects[property]);
	        }

	        /**
	         * Returns whether the current prototype/instance has a "read only"
	         * accessor for the given property.
	         *
	         * @param {string} property Property name
	         * @return {boolean} True if the prototype/instance has an effect of this type
	         * @protected
	         */

	      }, {
	        key: '_hasReadOnlyEffect',
	        value: function _hasReadOnlyEffect(property) {
	          return this._hasPropertyEffect(property, TYPES.READ_ONLY);
	        }

	        /**
	         * Returns whether the current prototype/instance has a "notify"
	         * property effect for the given property.
	         *
	         * @param {string} property Property name
	         * @return {boolean} True if the prototype/instance has an effect of this type
	         * @protected
	         */

	      }, {
	        key: '_hasNotifyEffect',
	        value: function _hasNotifyEffect(property) {
	          return this._hasPropertyEffect(property, TYPES.NOTIFY);
	        }

	        /**
	         * Returns whether the current prototype/instance has a "reflect to attribute"
	         * property effect for the given property.
	         *
	         * @param {string} property Property name
	         * @return {boolean} True if the prototype/instance has an effect of this type
	         * @protected
	         */

	      }, {
	        key: '_hasReflectEffect',
	        value: function _hasReflectEffect(property) {
	          return this._hasPropertyEffect(property, TYPES.REFLECT);
	        }

	        /**
	         * Returns whether the current prototype/instance has a "computed"
	         * property effect for the given property.
	         *
	         * @param {string} property Property name
	         * @return {boolean} True if the prototype/instance has an effect of this type
	         * @protected
	         */

	      }, {
	        key: '_hasComputedEffect',
	        value: function _hasComputedEffect(property) {
	          return this._hasPropertyEffect(property, TYPES.COMPUTE);
	        }

	        // Runtime ----------------------------------------

	        /**
	         * Sets a pending property or path.  If the root property of the path in
	         * question had no accessor, the path is set, otherwise it is enqueued
	         * via `_setPendingProperty`.
	         *
	         * This function isolates relatively expensive functionality necessary
	         * for the public API (`set`, `setProperties`, `notifyPath`, and property
	         * change listeners via {{...}} bindings), such that it is only done
	         * when paths enter the system, and not at every propagation step.  It
	         * also sets a `__dataHasPaths` flag on the instance which is used to
	         * fast-path slower path-matching code in the property effects host paths.
	         *
	         * `path` can be a path string or array of path parts as accepted by the
	         * public API.
	         *
	         * @param {string | !Array<number|string>} path Path to set
	         * @param {*} value Value to set
	         * @param {boolean=} shouldNotify Set to true if this change should
	         *  cause a property notification event dispatch
	         * @param {boolean=} isPathNotification If the path being set is a path
	         *   notification of an already changed value, as opposed to a request
	         *   to set and notify the change.  In the latter `false` case, a dirty
	         *   check is performed and then the value is set to the path before
	         *   enqueuing the pending property change.
	         * @return {boolean} Returns true if the property/path was enqueued in
	         *   the pending changes bag.
	         * @protected
	         */

	      }, {
	        key: '_setPendingPropertyOrPath',
	        value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
	          if (isPathNotification || root(Array.isArray(path) ? path[0] : path) !== path) {
	            // Dirty check changes being set to a path against the actual object,
	            // since this is the entry point for paths into the system; from here
	            // the only dirty checks are against the `__dataTemp` cache to prevent
	            // duplicate work in the same turn only. Note, if this was a notification
	            // of a change already set to a path (isPathNotification: true),
	            // we always let the change through and skip the `set` since it was
	            // already dirty checked at the point of entry and the underlying
	            // object has already been updated
	            if (!isPathNotification) {
	              var old = get$1(this, path);
	              path = /** @type {string} */set$1(this, path, value);
	              // Use property-accessor's simpler dirty check
	              if (!path || !get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {
	                return false;
	              }
	            }
	            this.__dataHasPaths = true;
	            if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {
	              computeLinkedPaths(this, path, value);
	              return true;
	            }
	          } else {
	            if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
	              return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);
	            } else {
	              this[path] = value;
	            }
	          }
	          return false;
	        }

	        /**
	         * Applies a value to a non-Polymer element/node's property.
	         *
	         * The implementation makes a best-effort at binding interop:
	         * Some native element properties have side-effects when
	         * re-setting the same value (e.g. setting `<input>.value` resets the
	         * cursor position), so we do a dirty-check before setting the value.
	         * However, for better interop with non-Polymer custom elements that
	         * accept objects, we explicitly re-set object changes coming from the
	         * Polymer world (which may include deep object changes without the
	         * top reference changing), erring on the side of providing more
	         * information.
	         *
	         * Users may override this method to provide alternate approaches.
	         *
	         * @param {!Node} node The node to set a property on
	         * @param {string} prop The property to set
	         * @param {*} value The value to set
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_setUnmanagedPropertyToNode',
	        value: function _setUnmanagedPropertyToNode(node, prop, value) {
	          // It is a judgment call that resetting primitives is
	          // "bad" and resettings objects is also "good"; alternatively we could
	          // implement a whitelist of tag & property values that should never
	          // be reset (e.g. <input>.value && <select>.value)
	          if (value !== node[prop] || typeof value == 'object') {
	            node[prop] = value;
	          }
	        }

	        /**
	         * Overrides the `PropertiesChanged` implementation to introduce special
	         * dirty check logic depending on the property & value being set:
	         *
	         * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
	         *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
	         * 2. Object set to simple property (e.g. 'prop': {...})
	         *    Stored in `__dataTemp` and `__data`, dirty checked against
	         *    `__dataTemp` by default implementation of `_shouldPropertyChange`
	         * 3. Primitive value set to simple property (e.g. 'prop': 42)
	         *    Stored in `__data`, dirty checked against `__data`
	         *
	         * The dirty-check is important to prevent cycles due to two-way
	         * notification, but paths and objects are only dirty checked against any
	         * previous value set during this turn via a "temporary cache" that is
	         * cleared when the last `_propertiesChanged` exits. This is so:
	         * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
	         *    due to array mutations like shift/unshift/splice; this is fine
	         *    since path changes are dirty-checked at user entry points like `set`
	         * b. dirty-checking for objects only lasts one turn to allow the user
	         *    to mutate the object in-place and re-set it with the same identity
	         *    and have all sub-properties re-propagated in a subsequent turn.
	         *
	         * The temp cache is not necessarily sufficient to prevent invalid array
	         * paths, since a splice can happen during the same turn (with pathological
	         * user code); we could introduce a "fixup" for temporarily cached array
	         * paths if needed: https://github.com/Polymer/polymer/issues/4227
	         *
	         * @override
	         * @param {string} property Name of the property
	         * @param {*} value Value to set
	         * @param {boolean=} shouldNotify True if property should fire notification
	         *   event (applies only for `notify: true` properties)
	         * @return {boolean} Returns true if the property changed
	         */

	      }, {
	        key: '_setPendingProperty',
	        value: function _setPendingProperty(property, value, shouldNotify) {
	          var isPath$$1 = this.__dataHasPaths && isPath(property);
	          var prevProps = isPath$$1 ? this.__dataTemp : this.__data;
	          if (this._shouldPropertyChange(property, value, prevProps[property])) {
	            if (!this.__dataPending) {
	              this.__dataPending = {};
	              this.__dataOld = {};
	            }
	            // Ensure old is captured from the last turn
	            if (!(property in this.__dataOld)) {
	              this.__dataOld[property] = this.__data[property];
	            }
	            // Paths are stored in temporary cache (cleared at end of turn),
	            // which is used for dirty-checking, all others stored in __data
	            if (isPath$$1) {
	              this.__dataTemp[property] = value;
	            } else {
	              this.__data[property] = value;
	            }
	            // All changes go into pending property bag, passed to _propertiesChanged
	            this.__dataPending[property] = value;
	            // Track properties that should notify separately
	            if (isPath$$1 || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
	              this.__dataToNotify = this.__dataToNotify || {};
	              this.__dataToNotify[property] = shouldNotify;
	            }
	            return true;
	          }
	          return false;
	        }

	        /**
	         * Overrides base implementation to ensure all accessors set `shouldNotify`
	         * to true, for per-property notification tracking.
	         *
	         * @override
	         * @param {string} property Name of the property
	         * @param {*} value Value to set
	         * @return {void}
	         */

	      }, {
	        key: '_setProperty',
	        value: function _setProperty(property, value) {
	          if (this._setPendingProperty(property, value, true)) {
	            this._invalidateProperties();
	          }
	        }

	        /**
	         * Overrides `PropertyAccessor`'s default async queuing of
	         * `_propertiesChanged`: if `__dataReady` is false (has not yet been
	         * manually flushed), the function no-ops; otherwise flushes
	         * `_propertiesChanged` synchronously.
	         *
	         * @override
	         * @return {void}
	         */

	      }, {
	        key: '_invalidateProperties',
	        value: function _invalidateProperties() {
	          if (this.__dataReady) {
	            this._flushProperties();
	          }
	        }

	        /**
	         * Enqueues the given client on a list of pending clients, whose
	         * pending property changes can later be flushed via a call to
	         * `_flushClients`.
	         *
	         * @param {Object} client PropertyEffects client to enqueue
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_enqueueClient',
	        value: function _enqueueClient(client) {
	          this.__dataPendingClients = this.__dataPendingClients || [];
	          if (client !== this) {
	            this.__dataPendingClients.push(client);
	          }
	        }

	        /**
	         * Overrides superclass implementation.
	         *
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_flushProperties',
	        value: function _flushProperties() {
	          this.__dataCounter++;
	          get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_flushProperties', this).call(this);
	          this.__dataCounter--;
	        }

	        /**
	         * Flushes any clients previously enqueued via `_enqueueClient`, causing
	         * their `_flushProperties` method to run.
	         *
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_flushClients',
	        value: function _flushClients() {
	          if (!this.__dataClientsReady) {
	            this.__dataClientsReady = true;
	            this._readyClients();
	            // Override point where accessors are turned on; importantly,
	            // this is after clients have fully readied, providing a guarantee
	            // that any property effects occur only after all clients are ready.
	            this.__dataReady = true;
	          } else {
	            this.__enableOrFlushClients();
	          }
	        }

	        // NOTE: We ensure clients either enable or flush as appropriate. This
	        // handles two corner cases:
	        // (1) clients flush properly when connected/enabled before the host
	        // enables; e.g.
	        //   (a) Templatize stamps with no properties and does not flush and
	        //   (b) the instance is inserted into dom and
	        //   (c) then the instance flushes.
	        // (2) clients enable properly when not connected/enabled when the host
	        // flushes; e.g.
	        //   (a) a template is runtime stamped and not yet connected/enabled
	        //   (b) a host sets a property, causing stamped dom to flush
	        //   (c) the stamped dom enables.

	      }, {
	        key: '__enableOrFlushClients',
	        value: function __enableOrFlushClients() {
	          var clients = this.__dataPendingClients;
	          if (clients) {
	            this.__dataPendingClients = null;
	            for (var i = 0; i < clients.length; i++) {
	              var client = clients[i];
	              if (!client.__dataEnabled) {
	                client._enableProperties();
	              } else if (client.__dataPending) {
	                client._flushProperties();
	              }
	            }
	          }
	        }

	        /**
	         * Perform any initial setup on client dom. Called before the first
	         * `_flushProperties` call on client dom and before any element
	         * observers are called.
	         *
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_readyClients',
	        value: function _readyClients() {
	          this.__enableOrFlushClients();
	        }

	        /**
	         * Sets a bag of property changes to this instance, and
	         * synchronously processes all effects of the properties as a batch.
	         *
	         * Property names must be simple properties, not paths.  Batched
	         * path propagation is not supported.
	         *
	         * @param {Object} props Bag of one or more key-value pairs whose key is
	         *   a property and value is the new value to set for that property.
	         * @param {boolean=} setReadOnly When true, any private values set in
	         *   `props` will be set. By default, `setProperties` will not set
	         *   `readOnly: true` root properties.
	         * @return {void}
	         * @public
	         */

	      }, {
	        key: 'setProperties',
	        value: function setProperties(props, setReadOnly) {
	          for (var path in props) {
	            if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
	              //TODO(kschaaf): explicitly disallow paths in setProperty?
	              // wildcard observers currently only pass the first changed path
	              // in the `info` object, and you could do some odd things batching
	              // paths, e.g. {'foo.bar': {...}, 'foo': null}
	              this._setPendingPropertyOrPath(path, props[path], true);
	            }
	          }
	          this._invalidateProperties();
	        }

	        /**
	         * Overrides `PropertyAccessors` so that property accessor
	         * side effects are not enabled until after client dom is fully ready.
	         * Also calls `_flushClients` callback to ensure client dom is enabled
	         * that was not enabled as a result of flushing properties.
	         *
	         * @override
	         * @return {void}
	         */

	      }, {
	        key: 'ready',
	        value: function ready() {
	          // It is important that `super.ready()` is not called here as it
	          // immediately turns on accessors. Instead, we wait until `readyClients`
	          // to enable accessors to provide a guarantee that clients are ready
	          // before processing any accessors side effects.
	          this._flushProperties();
	          // If no data was pending, `_flushProperties` will not `flushClients`
	          // so ensure this is done.
	          if (!this.__dataClientsReady) {
	            this._flushClients();
	          }
	          // Before ready, client notifications do not trigger _flushProperties.
	          // Therefore a flush is necessary here if data has been set.
	          if (this.__dataPending) {
	            this._flushProperties();
	          }
	        }

	        /**
	         * Implements `PropertyAccessors`'s properties changed callback.
	         *
	         * Runs each class of effects for the batch of changed properties in
	         * a specific order (compute, propagate, reflect, observe, notify).
	         *
	         * @param {!Object} currentProps Bag of all current accessor values
	         * @param {!Object} changedProps Bag of properties changed since the last
	         *   call to `_propertiesChanged`
	         * @param {!Object} oldProps Bag of previous values for each property
	         *   in `changedProps`
	         * @return {void}
	         */

	      }, {
	        key: '_propertiesChanged',
	        value: function _propertiesChanged(currentProps, changedProps, oldProps) {
	          // ----------------------------
	          // let c = Object.getOwnPropertyNames(changedProps || {});
	          // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
	          // if (window.debug) { debugger; }
	          // ----------------------------
	          var hasPaths = this.__dataHasPaths;
	          this.__dataHasPaths = false;
	          // Compute properties
	          runComputedEffects(this, changedProps, oldProps, hasPaths);
	          // Clear notify properties prior to possible reentry (propagate, observe),
	          // but after computing effects have a chance to add to them
	          var notifyProps = this.__dataToNotify;
	          this.__dataToNotify = null;
	          // Propagate properties to clients
	          this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
	          // Flush clients
	          this._flushClients();
	          // Reflect properties
	          runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
	          // Observe properties
	          runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
	          // Notify properties to host
	          if (notifyProps) {
	            runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
	          }
	          // Clear temporary cache at end of turn
	          if (this.__dataCounter == 1) {
	            this.__dataTemp = {};
	          }
	          // ----------------------------
	          // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
	          // ----------------------------
	        }

	        /**
	         * Called to propagate any property changes to stamped template nodes
	         * managed by this element.
	         *
	         * @param {Object} changedProps Bag of changed properties
	         * @param {Object} oldProps Bag of previous values for changed properties
	         * @param {boolean} hasPaths True with `props` contains one or more paths
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_propagatePropertyChanges',
	        value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
	          if (this[TYPES.PROPAGATE]) {
	            runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
	          }
	          var templateInfo = this.__templateInfo;
	          while (templateInfo) {
	            runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
	            templateInfo = templateInfo.nextTemplateInfo;
	          }
	        }

	        /**
	         * Aliases one data path as another, such that path notifications from one
	         * are routed to the other.
	         *
	         * @param {string | !Array<string|number>} to Target path to link.
	         * @param {string | !Array<string|number>} from Source path to link.
	         * @return {void}
	         * @public
	         */

	      }, {
	        key: 'linkPaths',
	        value: function linkPaths(to, from) {
	          to = normalize(to);
	          from = normalize(from);
	          this.__dataLinkedPaths = this.__dataLinkedPaths || {};
	          this.__dataLinkedPaths[to] = from;
	        }

	        /**
	         * Removes a data path alias previously established with `_linkPaths`.
	         *
	         * Note, the path to unlink should be the target (`to`) used when
	         * linking the paths.
	         *
	         * @param {string | !Array<string|number>} path Target path to unlink.
	         * @return {void}
	         * @public
	         */

	      }, {
	        key: 'unlinkPaths',
	        value: function unlinkPaths(path) {
	          path = normalize(path);
	          if (this.__dataLinkedPaths) {
	            delete this.__dataLinkedPaths[path];
	          }
	        }

	        /**
	         * Notify that an array has changed.
	         *
	         * Example:
	         *
	         *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
	         *     ...
	         *     this.items.splice(1, 1, {name: 'Sam'});
	         *     this.items.push({name: 'Bob'});
	         *     this.notifySplices('items', [
	         *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, object: this.items, type: 'splice' },
	         *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
	         *     ]);
	         *
	         * @param {string} path Path that should be notified.
	         * @param {Array} splices Array of splice records indicating ordered
	         *   changes that occurred to the array. Each record should have the
	         *   following fields:
	         *    * index: index at which the change occurred
	         *    * removed: array of items that were removed from this index
	         *    * addedCount: number of new items added at this index
	         *    * object: a reference to the array in question
	         *    * type: the string literal 'splice'
	         *
	         *   Note that splice records _must_ be normalized such that they are
	         *   reported in index order (raw results from `Object.observe` are not
	         *   ordered and must be normalized/merged before notifying).
	         * @return {void}
	         * @public
	        */

	      }, {
	        key: 'notifySplices',
	        value: function notifySplices(path, splices) {
	          var info = { path: '' };
	          var array = /** @type {Array} */get$1(this, path, info);
	          _notifySplices(this, array, info.path, splices);
	        }

	        /**
	         * Convenience method for reading a value from a path.
	         *
	         * Note, if any part in the path is undefined, this method returns
	         * `undefined` (this method does not throw when dereferencing undefined
	         * paths).
	         *
	         * @param {(string|!Array<(string|number)>)} path Path to the value
	         *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
	         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
	         *   bracketed expressions are not supported; string-based path parts
	         *   *must* be separated by dots.  Note that when dereferencing array
	         *   indices, the index may be used as a dotted part directly
	         *   (e.g. `users.12.name` or `['users', 12, 'name']`).
	         * @param {Object=} root Root object from which the path is evaluated.
	         * @return {*} Value at the path, or `undefined` if any part of the path
	         *   is undefined.
	         * @public
	         */

	      }, {
	        key: 'get',
	        value: function get$$1(path, root$$1) {
	          return get$1(root$$1 || this, path);
	        }

	        /**
	         * Convenience method for setting a value to a path and notifying any
	         * elements bound to the same path.
	         *
	         * Note, if any part in the path except for the last is undefined,
	         * this method does nothing (this method does not throw when
	         * dereferencing undefined paths).
	         *
	         * @param {(string|!Array<(string|number)>)} path Path to the value
	         *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
	         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
	         *   bracketed expressions are not supported; string-based path parts
	         *   *must* be separated by dots.  Note that when dereferencing array
	         *   indices, the index may be used as a dotted part directly
	         *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
	         * @param {*} value Value to set at the specified path.
	         * @param {Object=} root Root object from which the path is evaluated.
	         *   When specified, no notification will occur.
	         * @return {void}
	         * @public
	        */

	      }, {
	        key: 'set',
	        value: function set$$1(path, value, root$$1) {
	          if (root$$1) {
	            set$1(root$$1, path, value);
	          } else {
	            if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {
	              if (this._setPendingPropertyOrPath(path, value, true)) {
	                this._invalidateProperties();
	              }
	            }
	          }
	        }

	        /**
	         * Adds items onto the end of the array at the path specified.
	         *
	         * The arguments after `path` and return value match that of
	         * `Array.prototype.push`.
	         *
	         * This method notifies other paths to the same array that a
	         * splice occurred to the array.
	         *
	         * @param {string | !Array<string|number>} path Path to array.
	         * @param {...*} items Items to push onto array
	         * @return {number} New length of the array.
	         * @public
	         */

	      }, {
	        key: 'push',
	        value: function push(path) {
	          var info = { path: '' };
	          var array = /** @type {Array}*/get$1(this, path, info);
	          var len = array.length;

	          for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            items[_key - 1] = arguments[_key];
	          }

	          var ret = array.push.apply(array, items);
	          if (items.length) {
	            notifySplice(this, array, info.path, len, items.length, []);
	          }
	          return ret;
	        }

	        /**
	         * Removes an item from the end of array at the path specified.
	         *
	         * The arguments after `path` and return value match that of
	         * `Array.prototype.pop`.
	         *
	         * This method notifies other paths to the same array that a
	         * splice occurred to the array.
	         *
	         * @param {string | !Array<string|number>} path Path to array.
	         * @return {*} Item that was removed.
	         * @public
	         */

	      }, {
	        key: 'pop',
	        value: function pop(path) {
	          var info = { path: '' };
	          var array = /** @type {Array} */get$1(this, path, info);
	          var hadLength = Boolean(array.length);
	          var ret = array.pop();
	          if (hadLength) {
	            notifySplice(this, array, info.path, array.length, 0, [ret]);
	          }
	          return ret;
	        }

	        /**
	         * Starting from the start index specified, removes 0 or more items
	         * from the array and inserts 0 or more new items in their place.
	         *
	         * The arguments after `path` and return value match that of
	         * `Array.prototype.splice`.
	         *
	         * This method notifies other paths to the same array that a
	         * splice occurred to the array.
	         *
	         * @param {string | !Array<string|number>} path Path to array.
	         * @param {number} start Index from which to start removing/inserting.
	         * @param {number} deleteCount Number of items to remove.
	         * @param {...*} items Items to insert into array.
	         * @return {Array} Array of removed items.
	         * @public
	         */

	      }, {
	        key: 'splice',
	        value: function splice(path, start, deleteCount) {
	          for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
	            items[_key2 - 3] = arguments[_key2];
	          }

	          var info = { path: '' };
	          var array = /** @type {Array} */get$1(this, path, info);
	          // Normalize fancy native splice handling of crazy start values
	          if (start < 0) {
	            start = array.length - Math.floor(-start);
	          } else if (start) {
	            start = Math.floor(start);
	          }
	          // array.splice does different things based on the number of arguments
	          // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)
	          // do different things. In the former, the whole array is cleared. In the
	          // latter, no items are removed.
	          // This means that we need to detect whether 1. one of the arguments
	          // is actually passed in and then 2. determine how many arguments
	          // we should pass on to the native array.splice
	          //
	          var ret = void 0;
	          // Omit any additional arguments if they were not passed in
	          if (arguments.length === 2) {
	            ret = array.splice(start);
	            // Either start was undefined and the others were defined, but in this
	            // case we can safely pass on all arguments
	            //
	            // Note: this includes the case where none of the arguments were passed in,
	            // e.g. this.splice('array'). However, if both start and deleteCount
	            // are undefined, array.splice will not modify the array (as expected)
	          } else {
	            ret = array.splice.apply(array, [start, deleteCount].concat(items));
	          }
	          // At the end, check whether any items were passed in (e.g. insertions)
	          // or if the return array contains items (e.g. deletions).
	          // Only notify if items were added or deleted.
	          if (items.length || ret.length) {
	            notifySplice(this, array, info.path, start, items.length, ret);
	          }
	          return ret;
	        }

	        /**
	         * Removes an item from the beginning of array at the path specified.
	         *
	         * The arguments after `path` and return value match that of
	         * `Array.prototype.pop`.
	         *
	         * This method notifies other paths to the same array that a
	         * splice occurred to the array.
	         *
	         * @param {string | !Array<string|number>} path Path to array.
	         * @return {*} Item that was removed.
	         * @public
	         */

	      }, {
	        key: 'shift',
	        value: function shift(path) {
	          var info = { path: '' };
	          var array = /** @type {Array} */get$1(this, path, info);
	          var hadLength = Boolean(array.length);
	          var ret = array.shift();
	          if (hadLength) {
	            notifySplice(this, array, info.path, 0, 0, [ret]);
	          }
	          return ret;
	        }

	        /**
	         * Adds items onto the beginning of the array at the path specified.
	         *
	         * The arguments after `path` and return value match that of
	         * `Array.prototype.push`.
	         *
	         * This method notifies other paths to the same array that a
	         * splice occurred to the array.
	         *
	         * @param {string | !Array<string|number>} path Path to array.
	         * @param {...*} items Items to insert info array
	         * @return {number} New length of the array.
	         * @public
	         */

	      }, {
	        key: 'unshift',
	        value: function unshift(path) {
	          var info = { path: '' };
	          var array = /** @type {Array} */get$1(this, path, info);

	          for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	            items[_key3 - 1] = arguments[_key3];
	          }

	          var ret = array.unshift.apply(array, items);
	          if (items.length) {
	            notifySplice(this, array, info.path, 0, items.length, []);
	          }
	          return ret;
	        }

	        /**
	         * Notify that a path has changed.
	         *
	         * Example:
	         *
	         *     this.item.user.name = 'Bob';
	         *     this.notifyPath('item.user.name');
	         *
	         * @param {string} path Path that should be notified.
	         * @param {*=} value Value at the path (optional).
	         * @return {void}
	         * @public
	        */

	      }, {
	        key: 'notifyPath',
	        value: function notifyPath(path, value) {
	          /** @type {string} */
	          var propPath = void 0;
	          if (arguments.length == 1) {
	            // Get value if not supplied
	            var info = { path: '' };
	            value = get$1(this, path, info);
	            propPath = info.path;
	          } else if (Array.isArray(path)) {
	            // Normalize path if needed
	            propPath = normalize(path);
	          } else {
	            propPath = /** @type{string} */path;
	          }
	          if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
	            this._invalidateProperties();
	          }
	        }

	        /**
	         * Equivalent to static `createReadOnlyProperty` API but can be called on
	         * an instance to add effects at runtime.  See that method for
	         * full API docs.
	         *
	         * @param {string} property Property name
	         * @param {boolean=} protectedSetter Creates a custom protected setter
	         *   when `true`.
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_createReadOnlyProperty',
	        value: function _createReadOnlyProperty(property, protectedSetter) {
	          this._addPropertyEffect(property, TYPES.READ_ONLY);
	          if (protectedSetter) {
	            this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {
	              this._setProperty(property, value);
	            };
	          }
	        }

	        /**
	         * Equivalent to static `createPropertyObserver` API but can be called on
	         * an instance to add effects at runtime.  See that method for
	         * full API docs.
	         *
	         * @param {string} property Property name
	         * @param {string|function(*,*)} method Function or name of observer method to call
	         * @param {boolean=} dynamicFn Whether the method name should be included as
	         *   a dependency to the effect.
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_createPropertyObserver',
	        value: function _createPropertyObserver(property, method, dynamicFn) {
	          var info = { property: property, method: method, dynamicFn: Boolean(dynamicFn) };
	          this._addPropertyEffect(property, TYPES.OBSERVE, {
	            fn: runObserverEffect, info: info, trigger: { name: property }
	          });
	          if (dynamicFn) {
	            this._addPropertyEffect( /** @type {string} */method, TYPES.OBSERVE, {
	              fn: runObserverEffect, info: info, trigger: { name: method }
	            });
	          }
	        }

	        /**
	         * Equivalent to static `createMethodObserver` API but can be called on
	         * an instance to add effects at runtime.  See that method for
	         * full API docs.
	         *
	         * @param {string} expression Method expression
	         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
	         *   whether method names should be included as a dependency to the effect.
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_createMethodObserver',
	        value: function _createMethodObserver(expression, dynamicFn) {
	          var sig = parseMethod(expression);
	          if (!sig) {
	            throw new Error("Malformed observer expression '" + expression + "'");
	          }
	          createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
	        }

	        /**
	         * Equivalent to static `createNotifyingProperty` API but can be called on
	         * an instance to add effects at runtime.  See that method for
	         * full API docs.
	         *
	         * @param {string} property Property name
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_createNotifyingProperty',
	        value: function _createNotifyingProperty(property) {
	          this._addPropertyEffect(property, TYPES.NOTIFY, {
	            fn: runNotifyEffect,
	            info: {
	              eventName: CaseMap.camelToDashCase(property) + '-changed',
	              property: property
	            }
	          });
	        }

	        /**
	         * Equivalent to static `createReflectedProperty` API but can be called on
	         * an instance to add effects at runtime.  See that method for
	         * full API docs.
	         *
	         * @param {string} property Property name
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_createReflectedProperty',
	        value: function _createReflectedProperty(property) {
	          var attr = this.constructor.attributeNameForProperty(property);
	          if (attr[0] === '-') {
	            console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');
	          } else {
	            this._addPropertyEffect(property, TYPES.REFLECT, {
	              fn: runReflectEffect,
	              info: {
	                attrName: attr
	              }
	            });
	          }
	        }

	        /**
	         * Equivalent to static `createComputedProperty` API but can be called on
	         * an instance to add effects at runtime.  See that method for
	         * full API docs.
	         *
	         * @param {string} property Name of computed property to set
	         * @param {string} expression Method expression
	         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
	         *   whether method names should be included as a dependency to the effect.
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_createComputedProperty',
	        value: function _createComputedProperty(property, expression, dynamicFn) {
	          var sig = parseMethod(expression);
	          if (!sig) {
	            throw new Error("Malformed computed expression '" + expression + "'");
	          }
	          createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
	        }

	        // -- static class methods ------------

	        /**
	         * Ensures an accessor exists for the specified property, and adds
	         * to a list of "property effects" that will run when the accessor for
	         * the specified property is set.  Effects are grouped by "type", which
	         * roughly corresponds to a phase in effect processing.  The effect
	         * metadata should be in the following form:
	         *
	         *     {
	         *       fn: effectFunction, // Reference to function to call to perform effect
	         *       info: { ... }       // Effect metadata passed to function
	         *       trigger: {          // Optional triggering metadata; if not provided
	         *         name: string      // the property is treated as a wildcard
	         *         structured: boolean
	         *         wildcard: boolean
	         *       }
	         *     }
	         *
	         * Effects are called from `_propertiesChanged` in the following order by
	         * type:
	         *
	         * 1. COMPUTE
	         * 2. PROPAGATE
	         * 3. REFLECT
	         * 4. OBSERVE
	         * 5. NOTIFY
	         *
	         * Effect functions are called with the following signature:
	         *
	         *     effectFunction(inst, path, props, oldProps, info, hasPaths)
	         *
	         * @param {string} property Property that should trigger the effect
	         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
	         * @param {Object=} effect Effect metadata object
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_bindTemplate',


	        // -- binding ----------------------------------------------

	        /**
	         * Equivalent to static `bindTemplate` API but can be called on
	         * an instance to add effects at runtime.  See that method for
	         * full API docs.
	         *
	         * This method may be called on the prototype (for prototypical template
	         * binding, to avoid creating accessors every instance) once per prototype,
	         * and will be called with `runtimeBinding: true` by `_stampTemplate` to
	         * create and link an instance of the template metadata associated with a
	         * particular stamping.
	         *
	         * @param {!HTMLTemplateElement} template Template containing binding
	         *   bindings
	         * @param {boolean=} instanceBinding When false (default), performs
	         *   "prototypical" binding of the template and overwrites any previously
	         *   bound template for the class. When true (as passed from
	         *   `_stampTemplate`), the template info is instanced and linked into
	         *   the list of bound templates.
	         * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
	         *   this is an instance of the prototypical template info
	         * @protected
	         */
	        value: function _bindTemplate(template, instanceBinding) {
	          var templateInfo = this.constructor._parseTemplate(template);
	          var wasPreBound = this.__templateInfo == templateInfo;
	          // Optimization: since this is called twice for proto-bound templates,
	          // don't attempt to recreate accessors if this template was pre-bound
	          if (!wasPreBound) {
	            for (var prop in templateInfo.propertyEffects) {
	              this._createPropertyAccessor(prop);
	            }
	          }
	          if (instanceBinding) {
	            // For instance-time binding, create instance of template metadata
	            // and link into list of templates if necessary
	            templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);
	            templateInfo.wasPreBound = wasPreBound;
	            if (!wasPreBound && this.__templateInfo) {
	              var last = this.__templateInfoLast || this.__templateInfo;
	              this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
	              templateInfo.previousTemplateInfo = last;
	              return templateInfo;
	            }
	          }
	          return this.__templateInfo = templateInfo;
	        }

	        /**
	         * Adds a property effect to the given template metadata, which is run
	         * at the "propagate" stage of `_propertiesChanged` when the template
	         * has been bound to the element via `_bindTemplate`.
	         *
	         * The `effect` object should match the format in `_addPropertyEffect`.
	         *
	         * @param {Object} templateInfo Template metadata to add effect to
	         * @param {string} prop Property that should trigger the effect
	         * @param {Object=} effect Effect metadata object
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_stampTemplate',


	        /**
	         * Stamps the provided template and performs instance-time setup for
	         * Polymer template features, including data bindings, declarative event
	         * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
	         * is returned containing the stamped DOM, ready for insertion into the
	         * DOM.
	         *
	         * This method may be called more than once; however note that due to
	         * `shadycss` polyfill limitations, only styles from templates prepared
	         * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
	         * to the shadow root and support CSS custom properties), and note that
	         * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
	         * any styles required by in runtime-stamped templates must be included
	         * in the main element template.
	         *
	         * @param {!HTMLTemplateElement} template Template to stamp
	         * @return {!StampedTemplate} Cloned template content
	         * @override
	         * @protected
	         */
	        value: function _stampTemplate(template) {
	          // Ensures that created dom is `_enqueueClient`'d to this element so
	          // that it can be flushed on next call to `_flushProperties`
	          hostStack.beginHosting(this);
	          var dom = get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);
	          hostStack.endHosting(this);
	          var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);
	          // Add template-instance-specific data to instanced templateInfo
	          templateInfo.nodeList = dom.nodeList;
	          // Capture child nodes to allow unstamping of non-prototypical templates
	          if (!templateInfo.wasPreBound) {
	            var nodes = templateInfo.childNodes = [];
	            for (var n = dom.firstChild; n; n = n.nextSibling) {
	              nodes.push(n);
	            }
	          }
	          dom.templateInfo = templateInfo;
	          // Setup compound storage, 2-way listeners, and dataHost for bindings
	          setupBindings(this, templateInfo);
	          // Flush properties into template nodes if already booted
	          if (this.__dataReady) {
	            runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
	          }
	          return dom;
	        }

	        /**
	         * Removes and unbinds the nodes previously contained in the provided
	         * DocumentFragment returned from `_stampTemplate`.
	         *
	         * @param {!StampedTemplate} dom DocumentFragment previously returned
	         *   from `_stampTemplate` associated with the nodes to be removed
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: '_removeBoundDom',
	        value: function _removeBoundDom(dom) {
	          // Unlink template info
	          var templateInfo = dom.templateInfo;
	          if (templateInfo.previousTemplateInfo) {
	            templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
	          }
	          if (templateInfo.nextTemplateInfo) {
	            templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
	          }
	          if (this.__templateInfoLast == templateInfo) {
	            this.__templateInfoLast = templateInfo.previousTemplateInfo;
	          }
	          templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
	          // Remove stamped nodes
	          var nodes = templateInfo.childNodes;
	          for (var i = 0; i < nodes.length; i++) {
	            var node = nodes[i];
	            node.parentNode.removeChild(node);
	          }
	        }

	        /**
	         * Overrides default `TemplateStamp` implementation to add support for
	         * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
	         * array is added to `nodeInfo` and populated with binding metadata
	         * with information capturing the binding target, and a `parts` array
	         * with one or more metadata objects capturing the source(s) of the
	         * binding.
	         *
	         * @override
	         * @param {Node} node Node to parse
	         * @param {TemplateInfo} templateInfo Template metadata for current template
	         * @param {NodeInfo} nodeInfo Node metadata for current template node
	         * @return {boolean} `true` if the visited node added node-specific
	         *   metadata to `nodeInfo`
	         * @protected
	         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
	         */

	      }, {
	        key: 'PROPERTY_EFFECT_TYPES',
	        get: function () {
	          return TYPES;
	        }
	      }], [{
	        key: 'addPropertyEffect',
	        value: function addPropertyEffect(property, type, effect) {
	          this.prototype._addPropertyEffect(property, type, effect);
	        }

	        /**
	         * Creates a single-property observer for the given property.
	         *
	         * @param {string} property Property name
	         * @param {string|function(*,*)} method Function or name of observer method to call
	         * @param {boolean=} dynamicFn Whether the method name should be included as
	         *   a dependency to the effect.
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: 'createPropertyObserver',
	        value: function createPropertyObserver(property, method, dynamicFn) {
	          this.prototype._createPropertyObserver(property, method, dynamicFn);
	        }

	        /**
	         * Creates a multi-property "method observer" based on the provided
	         * expression, which should be a string in the form of a normal JavaScript
	         * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
	         * should correspond to a property or path in the context of this
	         * prototype (or instance), or may be a literal string or number.
	         *
	         * @param {string} expression Method expression
	         * @param {boolean|Object=} dynamicFn Boolean or object map indicating
	         * @return {void}
	         *   whether method names should be included as a dependency to the effect.
	         * @protected
	         */

	      }, {
	        key: 'createMethodObserver',
	        value: function createMethodObserver(expression, dynamicFn) {
	          this.prototype._createMethodObserver(expression, dynamicFn);
	        }

	        /**
	         * Causes the setter for the given property to dispatch `<property>-changed`
	         * events to notify of changes to the property.
	         *
	         * @param {string} property Property name
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: 'createNotifyingProperty',
	        value: function createNotifyingProperty(property) {
	          this.prototype._createNotifyingProperty(property);
	        }

	        /**
	         * Creates a read-only accessor for the given property.
	         *
	         * To set the property, use the protected `_setProperty` API.
	         * To create a custom protected setter (e.g. `_setMyProp()` for
	         * property `myProp`), pass `true` for `protectedSetter`.
	         *
	         * Note, if the property will have other property effects, this method
	         * should be called first, before adding other effects.
	         *
	         * @param {string} property Property name
	         * @param {boolean=} protectedSetter Creates a custom protected setter
	         *   when `true`.
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: 'createReadOnlyProperty',
	        value: function createReadOnlyProperty(property, protectedSetter) {
	          this.prototype._createReadOnlyProperty(property, protectedSetter);
	        }

	        /**
	         * Causes the setter for the given property to reflect the property value
	         * to a (dash-cased) attribute of the same name.
	         *
	         * @param {string} property Property name
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: 'createReflectedProperty',
	        value: function createReflectedProperty(property) {
	          this.prototype._createReflectedProperty(property);
	        }

	        /**
	         * Creates a computed property whose value is set to the result of the
	         * method described by the given `expression` each time one or more
	         * arguments to the method changes.  The expression should be a string
	         * in the form of a normal JavaScript function signature:
	         * `'methodName(arg1, [..., argn])'`
	         *
	         * @param {string} property Name of computed property to set
	         * @param {string} expression Method expression
	         * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
	         *   method names should be included as a dependency to the effect.
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: 'createComputedProperty',
	        value: function createComputedProperty(property, expression, dynamicFn) {
	          this.prototype._createComputedProperty(property, expression, dynamicFn);
	        }

	        /**
	         * Parses the provided template to ensure binding effects are created
	         * for them, and then ensures property accessors are created for any
	         * dependent properties in the template.  Binding effects for bound
	         * templates are stored in a linked list on the instance so that
	         * templates can be efficiently stamped and unstamped.
	         *
	         * @param {!HTMLTemplateElement} template Template containing binding
	         *   bindings
	         * @return {!TemplateInfo} Template metadata object
	         * @protected
	         */

	      }, {
	        key: 'bindTemplate',
	        value: function bindTemplate(template) {
	          return this.prototype._bindTemplate(template);
	        }
	      }, {
	        key: '_addTemplatePropertyEffect',
	        value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
	          var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
	          hostProps[prop] = true;
	          var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
	          var propEffects = effects[prop] = effects[prop] || [];
	          propEffects.push(effect);
	        }
	      }, {
	        key: '_parseTemplateNode',
	        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
	          var noted = get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);
	          if (node.nodeType === Node.TEXT_NODE) {
	            var parts = this._parseBindings(node.textContent, templateInfo);
	            if (parts) {
	              // Initialize the textContent with any literal parts
	              // NOTE: default to a space here so the textNode remains; some browsers
	              // (IE) omit an empty textNode following cloneNode/importNode.
	              node.textContent = literalFromParts(parts) || ' ';
	              addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
	              noted = true;
	            }
	          }
	          return noted;
	        }

	        /**
	         * Overrides default `TemplateStamp` implementation to add support for
	         * parsing bindings from attributes.  A `bindings`
	         * array is added to `nodeInfo` and populated with binding metadata
	         * with information capturing the binding target, and a `parts` array
	         * with one or more metadata objects capturing the source(s) of the
	         * binding.
	         *
	         * @override
	         * @param {Element} node Node to parse
	         * @param {TemplateInfo} templateInfo Template metadata for current template
	         * @param {NodeInfo} nodeInfo Node metadata for current template node
	         * @param {string} name Attribute name
	         * @param {string} value Attribute value
	         * @return {boolean} `true` if the visited node added node-specific
	         *   metadata to `nodeInfo`
	         * @protected
	         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
	         */

	      }, {
	        key: '_parseTemplateNodeAttribute',
	        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
	          var parts = this._parseBindings(value, templateInfo);
	          if (parts) {
	            // Attribute or property
	            var origName = name;
	            var kind = 'property';
	            // The only way we see a capital letter here is if the attr has
	            // a capital letter in it per spec. In this case, to make sure
	            // this binding works, we go ahead and make the binding to the attribute.
	            if (capitalAttributeRegex.test(name)) {
	              kind = 'attribute';
	            } else if (name[name.length - 1] == '$') {
	              name = name.slice(0, -1);
	              kind = 'attribute';
	            }
	            // Initialize attribute bindings with any literal parts
	            var literal = literalFromParts(parts);
	            if (literal && kind == 'attribute') {
	              node.setAttribute(name, literal);
	            }
	            // Clear attribute before removing, since IE won't allow removing
	            // `value` attribute if it previously had a value (can't
	            // unconditionally set '' before removing since attributes with `$`
	            // can't be set using setAttribute)
	            if (node.localName === 'input' && origName === 'value') {
	              node.setAttribute(origName, '');
	            }
	            // Remove annotation
	            node.removeAttribute(origName);
	            // Case hackery: attributes are lower-case, but bind targets
	            // (properties) are case sensitive. Gambit is to map dash-case to
	            // camel-case: `foo-bar` becomes `fooBar`.
	            // Attribute bindings are excepted.
	            if (kind === 'property') {
	              name = dashToCamelCase(name);
	            }
	            addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
	            return true;
	          } else {
	            return get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);
	          }
	        }

	        /**
	         * Overrides default `TemplateStamp` implementation to add support for
	         * binding the properties that a nested template depends on to the template
	         * as `_host_<property>`.
	         *
	         * @override
	         * @param {Node} node Node to parse
	         * @param {TemplateInfo} templateInfo Template metadata for current template
	         * @param {NodeInfo} nodeInfo Node metadata for current template node
	         * @return {boolean} `true` if the visited node added node-specific
	         *   metadata to `nodeInfo`
	         * @protected
	         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
	         */

	      }, {
	        key: '_parseTemplateNestedTemplate',
	        value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
	          var noted = get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);
	          // Merge host props into outer template and add bindings
	          var hostProps = nodeInfo.templateInfo.hostProps;
	          var mode = '{';
	          for (var source in hostProps) {
	            var parts = [{ mode: mode, source: source, dependencies: [source] }];
	            addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
	          }
	          return noted;
	        }

	        /**
	         * Called to parse text in a template (either attribute values or
	         * textContent) into binding metadata.
	         *
	         * Any overrides of this method should return an array of binding part
	         * metadata  representing one or more bindings found in the provided text
	         * and any "literal" text in between.  Any non-literal parts will be passed
	         * to `_evaluateBinding` when any dependencies change.  The only required
	         * fields of each "part" in the returned array are as follows:
	         *
	         * - `dependencies` - Array containing trigger metadata for each property
	         *   that should trigger the binding to update
	         * - `literal` - String containing text if the part represents a literal;
	         *   in this case no `dependencies` are needed
	         *
	         * Additional metadata for use by `_evaluateBinding` may be provided in
	         * each part object as needed.
	         *
	         * The default implementation handles the following types of bindings
	         * (one or more may be intermixed with literal strings):
	         * - Property binding: `[[prop]]`
	         * - Path binding: `[[object.prop]]`
	         * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
	         * - Two-way property or path bindings (supports negation):
	         *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
	         * - Inline computed method (supports negation):
	         *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
	         *
	         * The default implementation uses a regular expression for best
	         * performance. However, the regular expression uses a white-list of
	         * allowed characters in a data-binding, which causes problems for
	         * data-bindings that do use characters not in this white-list.
	         *
	         * Instead of updating the white-list with all allowed characters,
	         * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
	         * that uses a state machine instead. This state machine is able to handle
	         * all characters. However, it is slightly less performant, therefore we
	         * extracted it into a separate optional mixin.
	         *
	         * @param {string} text Text to parse from attribute or textContent
	         * @param {Object} templateInfo Current template metadata
	         * @return {Array<!BindingPart>} Array of binding part metadata
	         * @protected
	         */

	      }, {
	        key: '_parseBindings',
	        value: function _parseBindings(text, templateInfo) {
	          var parts = [];
	          var lastIndex = 0;
	          var m = void 0;
	          // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
	          // Regex matches:
	          //        Iteration 1:  Iteration 2:
	          // m[1]: '{{'          '[['
	          // m[2]: ''            '!'
	          // m[3]: 'prop'        'compute(foo,bar)'
	          while ((m = bindingRegex.exec(text)) !== null) {
	            // Add literal part
	            if (m.index > lastIndex) {
	              parts.push({ literal: text.slice(lastIndex, m.index) });
	            }
	            // Add binding part
	            var mode = m[1][0];
	            var negate = Boolean(m[2]);
	            var source = m[3].trim();
	            var customEvent = false,
	                notifyEvent = '',
	                colon = -1;
	            if (mode == '{' && (colon = source.indexOf('::')) > 0) {
	              notifyEvent = source.substring(colon + 2);
	              source = source.substring(0, colon);
	              customEvent = true;
	            }
	            var signature = parseMethod(source);
	            var dependencies = [];
	            if (signature) {
	              // Inline computed function
	              var args = signature.args,
	                  methodName = signature.methodName;

	              for (var i = 0; i < args.length; i++) {
	                var arg = args[i];
	                if (!arg.literal) {
	                  dependencies.push(arg);
	                }
	              }
	              var dynamicFns = templateInfo.dynamicFns;
	              if (dynamicFns && dynamicFns[methodName] || signature.static) {
	                dependencies.push(methodName);
	                signature.dynamicFn = true;
	              }
	            } else {
	              // Property or path
	              dependencies.push(source);
	            }
	            parts.push({
	              source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,
	              event: notifyEvent
	            });
	            lastIndex = bindingRegex.lastIndex;
	          }
	          // Add a final literal part
	          if (lastIndex && lastIndex < text.length) {
	            var literal = text.substring(lastIndex);
	            if (literal) {
	              parts.push({
	                literal: literal
	              });
	            }
	          }
	          if (parts.length) {
	            return parts;
	          } else {
	            return null;
	          }
	        }

	        /**
	         * Called to evaluate a previously parsed binding part based on a set of
	         * one or more changed dependencies.
	         *
	         * @param {this} inst Element that should be used as scope for
	         *   binding dependencies
	         * @param {BindingPart} part Binding part metadata
	         * @param {string} path Property/path that triggered this effect
	         * @param {Object} props Bag of current property changes
	         * @param {Object} oldProps Bag of previous values for changed properties
	         * @param {boolean} hasPaths True with `props` contains one or more paths
	         * @return {*} Value the binding part evaluated to
	         * @protected
	         */

	      }, {
	        key: '_evaluateBinding',
	        value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
	          var value = void 0;
	          if (part.signature) {
	            value = runMethodEffect(inst, path, props, oldProps, part.signature);
	          } else if (path != part.source) {
	            value = get$1(inst, part.source);
	          } else {
	            if (hasPaths && isPath(path)) {
	              value = get$1(inst, path);
	            } else {
	              value = inst.__data[path];
	            }
	          }
	          if (part.negate) {
	            value = !value;
	          }
	          return value;
	        }
	      }]);
	      return PropertyEffects;
	    }(propertyEffectsBase);

	    return PropertyEffects;
	  });

	  /**
	   * Helper api for enqueuing client dom created by a host element.
	   *
	   * By default elements are flushed via `_flushProperties` when
	   * `connectedCallback` is called. Elements attach their client dom to
	   * themselves at `ready` time which results from this first flush.
	   * This provides an ordering guarantee that the client dom an element
	   * creates is flushed before the element itself (i.e. client `ready`
	   * fires before host `ready`).
	   *
	   * However, if `_flushProperties` is called *before* an element is connected,
	   * as for example `Templatize` does, this ordering guarantee cannot be
	   * satisfied because no elements are connected. (Note: Bound elements that
	   * receive data do become enqueued clients and are properly ordered but
	   * unbound elements are not.)
	   *
	   * To maintain the desired "client before host" ordering guarantee for this
	   * case we rely on the "host stack. Client nodes registers themselves with
	   * the creating host element when created. This ensures that all client dom
	   * is readied in the proper order, maintaining the desired guarantee.
	   *
	   * @private
	   */
	  var hostStack = {

	    stack: [],

	    /**
	     * @param {*} inst Instance to add to hostStack
	     * @return {void}
	     * @this {hostStack}
	     */
	    registerHost: function (inst) {
	      if (this.stack.length) {
	        var host = this.stack[this.stack.length - 1];
	        host._enqueueClient(inst);
	      }
	    },


	    /**
	     * @param {*} inst Instance to begin hosting
	     * @return {void}
	     * @this {hostStack}
	     */
	    beginHosting: function (inst) {
	      this.stack.push(inst);
	    },


	    /**
	     * @param {*} inst Instance to end hosting
	     * @return {void}
	     * @this {hostStack}
	     */
	    endHosting: function (inst) {
	      var stackLen = this.stack.length;
	      if (stackLen && this.stack[stackLen - 1] == inst) {
	        this.stack.pop();
	      }
	    }
	  };

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  /**
	   * Creates a copy of `props` with each property normalized such that
	   * upgraded it is an object with at least a type property { type: Type}.
	   *
	   * @param {Object} props Properties to normalize
	   * @return {Object} Copy of input `props` with normalized properties that
	   * are in the form {type: Type}
	   * @private
	   */
	  function normalizeProperties(props) {
	    var output = {};
	    for (var p in props) {
	      var o = props[p];
	      output[p] = typeof o === 'function' ? { type: o } : o;
	    }
	    return output;
	  }

	  /**
	   * Mixin that provides a minimal starting point to using the PropertiesChanged
	   * mixin by providing a mechanism to declare properties in a static
	   * getter (e.g. static get properties() { return { foo: String } }). Changes
	   * are reported via the `_propertiesChanged` method.
	   *
	   * This mixin provides no specific support for rendering. Users are expected
	   * to create a ShadowRoot and put content into it and update it in whatever
	   * way makes sense. This can be done in reaction to properties changing by
	   * implementing `_propertiesChanged`.
	   *
	   * @mixinFunction
	   * @polymer
	   * @appliesMixin PropertiesChanged
	   * @summary Mixin that provides a minimal starting point for using
	   * the PropertiesChanged mixin by providing a declarative `properties` object.
	   */
	  var PropertiesMixin = dedupingMixin(function (superClass) {

	    /**
	     * @constructor
	     * @extends {superClass}
	     * @implements {Polymer_PropertiesChanged}
	     */
	    var base = PropertiesChanged(superClass);

	    /**
	     * Returns the super class constructor for the given class, if it is an
	     * instance of the PropertiesMixin.
	     *
	     * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor
	     * @return {PropertiesMixinConstructor} Super class constructor
	     */
	    function superPropertiesClass(constructor) {
	      var superCtor = Object.getPrototypeOf(constructor);

	      // Note, the `PropertiesMixin` class below only refers to the class
	      // generated by this call to the mixin; the instanceof test only works
	      // because the mixin is deduped and guaranteed only to apply once, hence
	      // all constructors in a proto chain will see the same `PropertiesMixin`
	      return superCtor.prototype instanceof PropertiesMixin ?
	      /** @type {PropertiesMixinConstructor} */superCtor : null;
	    }

	    /**
	     * Returns a memoized version of the `properties` object for the
	     * given class. Properties not in object format are converted to at
	     * least {type}.
	     *
	     * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor
	     * @return {Object} Memoized properties object
	     */
	    function ownProperties(constructor) {
	      if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {
	        var props = null;

	        if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor)) && constructor.properties) {
	          props = normalizeProperties(constructor.properties);
	        }

	        constructor.__ownProperties = props;
	      }
	      return constructor.__ownProperties;
	    }

	    /**
	     * @polymer
	     * @mixinClass
	     * @extends {base}
	     * @implements {Polymer_PropertiesMixin}
	     * @unrestricted
	     */

	    var PropertiesMixin = function (_base) {
	      inherits(PropertiesMixin, _base);

	      function PropertiesMixin() {
	        classCallCheck(this, PropertiesMixin);
	        return possibleConstructorReturn(this, (PropertiesMixin.__proto__ || Object.getPrototypeOf(PropertiesMixin)).apply(this, arguments));
	      }

	      createClass(PropertiesMixin, [{
	        key: '_initializeProperties',


	        /**
	         * Overrides `PropertiesChanged` method and adds a call to
	         * `finalize` which lazily configures the element's property accessors.
	         * @override
	         * @return {void}
	         */
	        value: function _initializeProperties() {
	          this.constructor.finalize();
	          get(PropertiesMixin.prototype.__proto__ || Object.getPrototypeOf(PropertiesMixin.prototype), '_initializeProperties', this).call(this);
	        }

	        /**
	         * Called when the element is added to a document.
	         * Calls `_enableProperties` to turn on property system from
	         * `PropertiesChanged`.
	         * @suppress {missingProperties} Super may or may not implement the callback
	         * @return {void}
	         */

	      }, {
	        key: 'connectedCallback',
	        value: function connectedCallback() {
	          if (get(PropertiesMixin.prototype.__proto__ || Object.getPrototypeOf(PropertiesMixin.prototype), 'connectedCallback', this)) {
	            get(PropertiesMixin.prototype.__proto__ || Object.getPrototypeOf(PropertiesMixin.prototype), 'connectedCallback', this).call(this);
	          }
	          this._enableProperties();
	        }

	        /**
	         * Called when the element is removed from a document
	         * @suppress {missingProperties} Super may or may not implement the callback
	         * @return {void}
	         */

	      }, {
	        key: 'disconnectedCallback',
	        value: function disconnectedCallback() {
	          if (get(PropertiesMixin.prototype.__proto__ || Object.getPrototypeOf(PropertiesMixin.prototype), 'disconnectedCallback', this)) {
	            get(PropertiesMixin.prototype.__proto__ || Object.getPrototypeOf(PropertiesMixin.prototype), 'disconnectedCallback', this).call(this);
	          }
	        }
	      }], [{
	        key: 'finalize',


	        /**
	         * Finalizes an element definition, including ensuring any super classes
	         * are also finalized. This includes ensuring property
	         * accessors exist on the element prototype. This method calls
	         * `_finalizeClass` to finalize each constructor in the prototype chain.
	         * @return {void}
	         */
	        value: function finalize() {
	          if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {
	            var superCtor = superPropertiesClass( /** @type {PropertiesMixinConstructor} */this);
	            if (superCtor) {
	              superCtor.finalize();
	            }
	            this.__finalized = true;
	            this._finalizeClass();
	          }
	        }

	        /**
	         * Finalize an element class. This includes ensuring property
	         * accessors exist on the element prototype. This method is called by
	         * `finalize` and finalizes the class constructor.
	         *
	         * @protected
	         */

	      }, {
	        key: '_finalizeClass',
	        value: function _finalizeClass() {
	          var props = ownProperties( /** @type {PropertiesMixinConstructor} */this);
	          if (props) {
	            this.createProperties(props);
	          }
	        }

	        /**
	         * Returns a memoized version of all properties, including those inherited
	         * from super classes. Properties not in object format are converted to
	         * at least {type}.
	         *
	         * @return {Object} Object containing properties for this class
	         * @protected
	         */

	      }, {
	        key: 'typeForProperty',


	        /**
	         * Overrides `PropertiesChanged` method to return type specified in the
	         * static `properties` object for the given property.
	         * @param {string} name Name of property
	         * @return {*} Type to which to deserialize attribute
	         *
	         * @protected
	         */
	        value: function typeForProperty(name) {
	          var info = this._properties[name];
	          return info && info.type;
	        }
	      }, {
	        key: 'observedAttributes',


	        /**
	         * Implements standard custom elements getter to observes the attributes
	         * listed in `properties`.
	         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
	         */
	        get: function () {
	          var _this2 = this;

	          var props = this._properties;
	          return props ? Object.keys(props).map(function (p) {
	            return _this2.attributeNameForProperty(p);
	          }) : [];
	        }
	      }, {
	        key: '_properties',
	        get: function () {
	          if (!this.hasOwnProperty(JSCompiler_renameProperty('__properties', this))) {
	            var superCtor = superPropertiesClass( /** @type {PropertiesMixinConstructor} */this);
	            this.__properties = Object.assign({}, superCtor && superCtor._properties, ownProperties( /** @type {PropertiesMixinConstructor} */this));
	          }
	          return this.__properties;
	        }
	      }]);
	      return PropertiesMixin;
	    }(base);

	    return PropertiesMixin;
	  });

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  /**
	   * Element class mixin that provides the core API for Polymer's meta-programming
	   * features including template stamping, data-binding, attribute deserialization,
	   * and property change observation.
	   *
	   * Subclassers may provide the following static getters to return metadata
	   * used to configure Polymer's features for the class:
	   *
	   * - `static get is()`: When the template is provided via a `dom-module`,
	   *   users should return the `dom-module` id from a static `is` getter.  If
	   *   no template is needed or the template is provided directly via the
	   *   `template` getter, there is no need to define `is` for the element.
	   *
	   * - `static get template()`: Users may provide the template directly (as
	   *   opposed to via `dom-module`) by implementing a static `template` getter.
	   *   The getter may return an `HTMLTemplateElement` or a string, which will
	   *   automatically be parsed into a template.
	   *
	   * - `static get properties()`: Should return an object describing
	   *   property-related metadata used by Polymer features (key: property name
	   *   value: object containing property metadata). Valid keys in per-property
	   *   metadata include:
	   *   - `type` (String|Number|Object|Array|...): Used by
	   *     `attributeChangedCallback` to determine how string-based attributes
	   *     are deserialized to JavaScript property values.
	   *   - `notify` (boolean): Causes a change in the property to fire a
	   *     non-bubbling event called `<property>-changed`. Elements that have
	   *     enabled two-way binding to the property use this event to observe changes.
	   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.
	   *     To set a read-only property, use the private setter method
	   *     `_setProperty(property, value)`.
	   *   - `observer` (string): Observer method name that will be called when
	   *     the property changes. The arguments of the method are
	   *     `(value, previousValue)`.
	   *   - `computed` (string): String describing method and dependent properties
	   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
	   *     Computed properties are read-only by default and can only be changed
	   *     via the return value of the computing method.
	   *
	   * - `static get observers()`: Array of strings describing multi-property
	   *   observer methods and their dependent properties (e.g.
	   *   `'observeABC(a, b, c)'`).
	   *
	   * The base class provides default implementations for the following standard
	   * custom element lifecycle callbacks; users may override these, but should
	   * call the super method to ensure
	   * - `constructor`: Run when the element is created or upgraded
	   * - `connectedCallback`: Run each time the element is connected to the
	   *   document
	   * - `disconnectedCallback`: Run each time the element is disconnected from
	   *   the document
	   * - `attributeChangedCallback`: Run each time an attribute in
	   *   `observedAttributes` is set or removed (note: this element's default
	   *   `observedAttributes` implementation will automatically return an array
	   *   of dash-cased attributes based on `properties`)
	   *
	   * @mixinFunction
	   * @polymer
	   * @appliesMixin PropertyEffects
	   * @appliesMixin PropertiesMixin
	   * @property rootPath {string} Set to the value of `rootPath`,
	   *   which defaults to the main document path
	   * @property importPath {string} Set to the value of the class's static
	   *   `importPath` property, which defaults to the path of this element's
	   *   `dom-module` (when `is` is used), but can be overridden for other
	   *   import strategies.
	   * @summary Element class mixin that provides the core API for Polymer's
	   * meta-programming features.
	   */
	  var ElementMixin = dedupingMixin(function (base) {

	    /**
	     * @constructor
	     * @extends {base}
	     * @implements {Polymer_PropertyEffects}
	     * @implements {Polymer_PropertiesMixin}
	     */
	    var polymerElementBase = PropertiesMixin(PropertyEffects(base));

	    /**
	     * Returns a list of properties with default values.
	     * This list is created as an optimization since it is a subset of
	     * the list returned from `_properties`.
	     * This list is used in `_initializeProperties` to set property defaults.
	     *
	     * @param {PolymerElementConstructor} constructor Element class
	     * @return {PolymerElementProperties} Flattened properties for this class
	     *   that have default values
	     * @private
	     */
	    function propertyDefaults(constructor) {
	      if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {
	        constructor.__propertyDefaults = null;
	        var props = constructor._properties;
	        for (var p in props) {
	          var info = props[p];
	          if ('value' in info) {
	            constructor.__propertyDefaults = constructor.__propertyDefaults || {};
	            constructor.__propertyDefaults[p] = info;
	          }
	        }
	      }
	      return constructor.__propertyDefaults;
	    }

	    /**
	     * Returns a memoized version of the the `observers` array.
	     * @param {PolymerElementConstructor} constructor Element class
	     * @return {Array} Array containing own observers for the given class
	     * @protected
	     */
	    function ownObservers(constructor) {
	      if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {
	        constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ?
	        /** @type {PolymerElementConstructor} */constructor.observers : null;
	      }
	      return constructor.__ownObservers;
	    }

	    /**
	     * Creates effects for a property.
	     *
	     * Note, once a property has been set to
	     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
	     * these values may not be changed. For example, a subclass cannot
	     * alter these settings. However, additional `observers` may be added
	     * by subclasses.
	     *
	     * The info object should may contain property metadata as follows:
	     *
	     * * `type`: {function} type to which an attribute matching the property
	     * is deserialized. Note the property is camel-cased from a dash-cased
	     * attribute. For example, 'foo-bar' attribute is deserialized to a
	     * property named 'fooBar'.
	     *
	     * * `readOnly`: {boolean} creates a readOnly property and
	     * makes a private setter for the private of the form '_setFoo' for a
	     * property 'foo',
	     *
	     * * `computed`: {string} creates a computed property. A computed property
	     * also automatically is set to `readOnly: true`. The value is calculated
	     * by running a method and arguments parsed from the given string. For
	     * example 'compute(foo)' will compute a given property when the
	     * 'foo' property changes by executing the 'compute' method. This method
	     * must return the computed value.
	     *
	     * * `reflectToAttribute`: {boolean} If true, the property value is reflected
	     * to an attribute of the same name. Note, the attribute is dash-cased
	     * so a property named 'fooBar' is reflected as 'foo-bar'.
	     *
	     * * `notify`: {boolean} sends a non-bubbling notification event when
	     * the property changes. For example, a property named 'foo' sends an
	     * event named 'foo-changed' with `event.detail` set to the value of
	     * the property.
	     *
	     * * observer: {string} name of a method that runs when the property
	     * changes. The arguments of the method are (value, previousValue).
	     *
	     * Note: Users may want control over modifying property
	     * effects via subclassing. For example, a user might want to make a
	     * reflectToAttribute property not do so in a subclass. We've chosen to
	     * disable this because it leads to additional complication.
	     * For example, a readOnly effect generates a special setter. If a subclass
	     * disables the effect, the setter would fail unexpectedly.
	     * Based on feedback, we may want to try to make effects more malleable
	     * and/or provide an advanced api for manipulating them.
	     * Also consider adding warnings when an effect cannot be changed.
	     *
	     * @param {!PolymerElement} proto Element class prototype to add accessors
	     *   and effects to
	     * @param {string} name Name of the property.
	     * @param {Object} info Info object from which to create property effects.
	     * Supported keys:
	     * @param {Object} allProps Flattened map of all properties defined in this
	     *   element (including inherited properties)
	     * @return {void}
	     * @private
	     */
	    function createPropertyFromConfig(proto, name, info, allProps) {
	      // computed forces readOnly...
	      if (info.computed) {
	        info.readOnly = true;
	      }
	      // Note, since all computed properties are readOnly, this prevents
	      // adding additional computed property effects (which leads to a confusing
	      // setup where multiple triggers for setting a property)
	      // While we do have `hasComputedEffect` this is set on the property's
	      // dependencies rather than itself.
	      if (info.computed && !proto._hasReadOnlyEffect(name)) {
	        proto._createComputedProperty(name, info.computed, allProps);
	      }
	      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
	        proto._createReadOnlyProperty(name, !info.computed);
	      }
	      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
	        proto._createReflectedProperty(name);
	      }
	      if (info.notify && !proto._hasNotifyEffect(name)) {
	        proto._createNotifyingProperty(name);
	      }
	      // always add observer
	      if (info.observer) {
	        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
	      }
	      // always create the mapping from attribute back to property for deserialization.
	      proto._addPropertyToAttributeMap(name);
	    }

	    /**
	     * Process all style elements in the element template. Styles with the
	     * `include` attribute are processed such that any styles in
	     * the associated "style modules" are included in the element template.
	     * @param {PolymerElementConstructor} klass Element class
	     * @param {!HTMLTemplateElement} template Template to process
	     * @param {string} is Name of element
	     * @param {string} baseURI Base URI for element
	     * @private
	     */
	    function processElementStyles(klass, template, is, baseURI) {
	      var templateStyles = template.content.querySelectorAll('style');
	      var stylesWithImports = stylesFromTemplate(template);
	      // insert styles from <link rel="import" type="css"> at the top of the template
	      var linkedStyles = stylesFromModuleImports(is);
	      var firstTemplateChild = template.content.firstElementChild;
	      for (var idx = 0; idx < linkedStyles.length; idx++) {
	        var s = linkedStyles[idx];
	        s.textContent = klass._processStyleText(s.textContent, baseURI);
	        template.content.insertBefore(s, firstTemplateChild);
	      }
	      // keep track of the last "concrete" style in the template we have encountered
	      var templateStyleIndex = 0;
	      // ensure all gathered styles are actually in this template.
	      for (var i = 0; i < stylesWithImports.length; i++) {
	        var _s = stylesWithImports[i];
	        var templateStyle = templateStyles[templateStyleIndex];
	        // if the style is not in this template, it's been "included" and
	        // we put a clone of it in the template before the style that included it
	        if (templateStyle !== _s) {
	          _s = _s.cloneNode(true);
	          templateStyle.parentNode.insertBefore(_s, templateStyle);
	        } else {
	          templateStyleIndex++;
	        }
	        _s.textContent = klass._processStyleText(_s.textContent, baseURI);
	      }
	      if (window.ShadyCSS) {
	        window.ShadyCSS.prepareTemplate(template, is);
	      }
	    }

	    /**
	     * @polymer
	     * @mixinClass
	     * @unrestricted
	     * @implements {Polymer_ElementMixin}
	     */

	    var PolymerElement = function (_polymerElementBase) {
	      inherits(PolymerElement, _polymerElementBase);
	      createClass(PolymerElement, null, [{
	        key: '_finalizeClass',


	        /**
	         * Override of PropertiesMixin _finalizeClass to create observers and
	         * find the template.
	         * @return {void}
	         * @protected
	         * @override
	         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
	         */
	        value: function _finalizeClass() {
	          get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_finalizeClass', this).call(this);
	          if (this.hasOwnProperty(JSCompiler_renameProperty('is', this)) && this.is) {
	            register(this.prototype);
	          }
	          var observers = ownObservers(this);
	          if (observers) {
	            this.createObservers(observers, this._properties);
	          }
	          // note: create "working" template that is finalized at instance time
	          var template = /** @type {PolymerElementConstructor} */this.template;
	          if (template) {
	            if (typeof template === 'string') {
	              console.error('template getter must return HTMLTemplateElement');
	              template = null;
	            } else {
	              template = template.cloneNode(true);
	            }
	          }

	          this.prototype._template = template;
	        }

	        /**
	         * Override of PropertiesChanged createProperties to create accessors
	         * and property effects for all of the properties.
	         * @return {void}
	         * @protected
	         * @override
	         */

	      }, {
	        key: 'createProperties',
	        value: function createProperties(props) {
	          for (var p in props) {
	            createPropertyFromConfig(this.prototype, p, props[p], props);
	          }
	        }

	        /**
	         * Creates observers for the given `observers` array.
	         * Leverages `PropertyEffects` to create observers.
	         * @param {Object} observers Array of observer descriptors for
	         *   this class
	         * @param {Object} dynamicFns Object containing keys for any properties
	         *   that are functions and should trigger the effect when the function
	         *   reference is changed
	         * @return {void}
	         * @protected
	         */

	      }, {
	        key: 'createObservers',
	        value: function createObservers(observers, dynamicFns) {
	          var proto = this.prototype;
	          for (var i = 0; i < observers.length; i++) {
	            proto._createMethodObserver(observers[i], dynamicFns);
	          }
	        }

	        /**
	         * Returns the template that will be stamped into this element's shadow root.
	         *
	         * If a `static get is()` getter is defined, the default implementation
	         * will return the first `<template>` in a `dom-module` whose `id`
	         * matches this element's `is`.
	         *
	         * Users may override this getter to return an arbitrary template
	         * (in which case the `is` getter is unnecessary). The template returned
	         * may be either an `HTMLTemplateElement` or a string that will be
	         * automatically parsed into a template.
	         *
	         * Note that when subclassing, if the super class overrode the default
	         * implementation and the subclass would like to provide an alternate
	         * template via a `dom-module`, it should override this getter and
	         * return `DomModule.import(this.is, 'template')`.
	         *
	         * If a subclass would like to modify the super class template, it should
	         * clone it rather than modify it in place.  If the getter does expensive
	         * work such as cloning/modifying a template, it should memoize the
	         * template for maximum performance:
	         *
	         *   let memoizedTemplate;
	         *   class MySubClass extends MySuperClass {
	         *     static get template() {
	         *       if (!memoizedTemplate) {
	         *         memoizedTemplate = super.template.cloneNode(true);
	         *         let subContent = document.createElement('div');
	         *         subContent.textContent = 'This came from MySubClass';
	         *         memoizedTemplate.content.appendChild(subContent);
	         *       }
	         *       return memoizedTemplate;
	         *     }
	         *   }
	         *
	         * @return {HTMLTemplateElement|string} Template to be stamped
	         */

	      }, {
	        key: 'template',
	        get: function () {
	          if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
	            this._template = DomModule && DomModule.import(
	            /** @type {PolymerElementConstructor}*/this.is, 'template') ||
	            // note: implemented so a subclass can retrieve the super
	            // template; call the super impl this way so that `this` points
	            // to the superclass.
	            Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.template;
	          }
	          return this._template;
	        }

	        /**
	         * Path matching the url from which the element was imported.
	         *
	         * This path is used to resolve url's in template style cssText.
	         * The `importPath` property is also set on element instances and can be
	         * used to create bindings relative to the import path.
	         *
	         * For elements defined in ES modules, users should implement
	         * `static get importMeta() { return import.meta; }`, and the default
	         * implementation of `importPath` will  return `import.meta.url`'s path.
	         * For elements defined in HTML imports, this getter will return the path
	         * to the document containing a `dom-module` element matching this
	         * element's static `is` property.
	         *
	         * Note, this path should contain a trailing `/`.
	         *
	         * @return {string} The import path for this element class
	         * @suppress {missingProperties}
	         */

	      }, {
	        key: 'importPath',
	        get: function () {
	          if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
	            var meta = this.importMeta;
	            if (meta) {
	              this._importPath = pathFromUrl(meta.url);
	            } else {
	              var module = DomModule && DomModule.import( /** @type {PolymerElementConstructor} */this.is);
	              this._importPath = module && module.assetpath || Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.importPath;
	            }
	          }
	          return this._importPath;
	        }
	      }]);

	      function PolymerElement() {
	        classCallCheck(this, PolymerElement);

	        /** @type {HTMLTemplateElement} */
	        var _this = possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).call(this));

	        _this._template;
	        /** @type {string} */
	        _this._importPath;
	        /** @type {string} */
	        _this.rootPath;
	        /** @type {string} */
	        _this.importPath;
	        /** @type {StampedTemplate | HTMLElement | ShadowRoot} */
	        _this.root;
	        /** @type {!Object<string, !Element>} */
	        _this.$;
	        return _this;
	      }

	      /**
	       * Overrides the default `PropertyAccessors` to ensure class
	       * metaprogramming related to property accessors and effects has
	       * completed (calls `finalize`).
	       *
	       * It also initializes any property defaults provided via `value` in
	       * `properties` metadata.
	       *
	       * @return {void}
	       * @override
	       * @suppress {invalidCasts}
	       */


	      createClass(PolymerElement, [{
	        key: '_initializeProperties',
	        value: function _initializeProperties() {
	          this.constructor.finalize();
	          // note: finalize template when we have access to `localName` to
	          // avoid dependence on `is` for polyfilling styling.
	          this.constructor._finalizeTemplate( /** @type {!HTMLElement} */this.localName);
	          get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);
	          // set path defaults
	          this.rootPath = rootPath;
	          this.importPath = this.constructor.importPath;
	          // apply property defaults...
	          var p$ = propertyDefaults(this.constructor);
	          if (!p$) {
	            return;
	          }
	          for (var p in p$) {
	            var info = p$[p];
	            // Don't set default value if there is already an own property, which
	            // happens when a `properties` property with default but no effects had
	            // a property set (e.g. bound) by its host before upgrade
	            if (!this.hasOwnProperty(p)) {
	              var value = typeof info.value == 'function' ? info.value.call(this) : info.value;
	              // Set via `_setProperty` if there is an accessor, to enable
	              // initializing readOnly property defaults
	              if (this._hasAccessor(p)) {
	                this._setPendingProperty(p, value, true);
	              } else {
	                this[p] = value;
	              }
	            }
	          }
	        }

	        /**
	         * Gather style text for a style element in the template.
	         *
	         * @param {string} cssText Text containing styling to process
	         * @param {string} baseURI Base URI to rebase CSS paths against
	         * @return {string} The processed CSS text
	         * @protected
	         */

	      }, {
	        key: 'connectedCallback',


	        /**
	         * Provides a default implementation of the standard Custom Elements
	         * `connectedCallback`.
	         *
	         * The default implementation enables the property effects system and
	         * flushes any pending properties, and updates shimmed CSS properties
	         * when using the ShadyCSS scoping/custom properties polyfill.
	         *
	         * @suppress {missingProperties, invalidCasts} Super may or may not implement the callback
	         * @return {void}
	         */
	        value: function connectedCallback() {
	          if (window.ShadyCSS && this._template) {
	            window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);
	          }
	          get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'connectedCallback', this).call(this);
	        }

	        /**
	         * Stamps the element template.
	         *
	         * @return {void}
	         * @override
	         */

	      }, {
	        key: 'ready',
	        value: function ready() {
	          if (this._template) {
	            this.root = this._stampTemplate(this._template);
	            this.$ = this.root.$;
	          }
	          get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);
	        }

	        /**
	         * Implements `PropertyEffects`'s `_readyClients` call. Attaches
	         * element dom by calling `_attachDom` with the dom stamped from the
	         * element's template via `_stampTemplate`. Note that this allows
	         * client dom to be attached to the element prior to any observers
	         * running.
	         *
	         * @return {void}
	         * @override
	         */

	      }, {
	        key: '_readyClients',
	        value: function _readyClients() {
	          if (this._template) {
	            this.root = this._attachDom( /** @type {StampedTemplate} */this.root);
	          }
	          // The super._readyClients here sets the clients initialized flag.
	          // We must wait to do this until after client dom is created/attached
	          // so that this flag can be checked to prevent notifications fired
	          // during this process from being handled before clients are ready.
	          get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);
	        }

	        /**
	         * Attaches an element's stamped dom to itself. By default,
	         * this method creates a `shadowRoot` and adds the dom to it.
	         * However, this method may be overridden to allow an element
	         * to put its dom in another location.
	         *
	         * @throws {Error}
	         * @suppress {missingReturn}
	         * @param {StampedTemplate} dom to attach to the element.
	         * @return {ShadowRoot} node to which the dom has been attached.
	         */

	      }, {
	        key: '_attachDom',
	        value: function _attachDom(dom) {
	          if (this.attachShadow) {
	            if (dom) {
	              if (!this.shadowRoot) {
	                this.attachShadow({ mode: 'open' });
	              }
	              this.shadowRoot.appendChild(dom);
	              return this.shadowRoot;
	            }
	            return null;
	          } else {
	            throw new Error('ShadowDOM not available. ' +
	            // TODO(sorvell): move to compile-time conditional when supported
	            'PolymerElement can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
	          }
	        }

	        /**
	         * When using the ShadyCSS scoping and custom property shim, causes all
	         * shimmed styles in this element (and its subtree) to be updated
	         * based on current custom property values.
	         *
	         * The optional parameter overrides inline custom property styles with an
	         * object of properties where the keys are CSS properties, and the values
	         * are strings.
	         *
	         * Example: `this.updateStyles({'--color': 'blue'})`
	         *
	         * These properties are retained unless a value of `null` is set.
	         *
	         * Note: This function does not support updating CSS mixins.
	         * You can not dynamically change the value of an `@apply`.
	         *
	         * @param {Object=} properties Bag of custom property key/values to
	         *   apply to this element.
	         * @return {void}
	         * @suppress {invalidCasts}
	         */

	      }, {
	        key: 'updateStyles',
	        value: function updateStyles(properties) {
	          if (window.ShadyCSS) {
	            window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);
	          }
	        }

	        /**
	         * Rewrites a given URL relative to a base URL. The base URL defaults to
	         * the original location of the document containing the `dom-module` for
	         * this element. This method will return the same URL before and after
	         * bundling.
	         *
	         * Note that this function performs no resolution for URLs that start
	         * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
	         * URL resolution, use `window.URL`.
	         *
	         * @param {string} url URL to resolve.
	         * @param {string=} base Optional base URL to resolve against, defaults
	         * to the element's `importPath`
	         * @return {string} Rewritten URL relative to base
	         */

	      }, {
	        key: 'resolveUrl',
	        value: function resolveUrl$$1(url, base) {
	          if (!base && this.importPath) {
	            base = resolveUrl(this.importPath);
	          }
	          return resolveUrl(url, base);
	        }

	        /**
	         * Overrides `PropertyAccessors` to add map of dynamic functions on
	         * template info, for consumption by `PropertyEffects` template binding
	         * code. This map determines which method templates should have accessors
	         * created for them.
	         *
	         * @override
	         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
	         */

	      }], [{
	        key: '_processStyleText',
	        value: function _processStyleText(cssText, baseURI) {
	          return resolveCss(cssText, baseURI);
	        }

	        /**
	        * Configures an element `proto` to function with a given `template`.
	        * The element name `is` and extends `ext` must be specified for ShadyCSS
	        * style scoping.
	        *
	        * @param {string} is Tag name (or type extension name) for this element
	        * @return {void}
	        * @protected
	        */

	      }, {
	        key: '_finalizeTemplate',
	        value: function _finalizeTemplate(is) {
	          /** @const {HTMLTemplateElement} */
	          var template = this.prototype._template;
	          if (template && !template.__polymerFinalized) {
	            template.__polymerFinalized = true;
	            var importPath = this.importPath;
	            var baseURI = importPath ? resolveUrl(importPath) : '';
	            // e.g. support `include="module-name"`, and ShadyCSS
	            processElementStyles(this, template, is, baseURI);
	            this.prototype._bindTemplate(template);
	          }
	        }
	      }, {
	        key: '_parseTemplateContent',
	        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
	          templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;
	          return get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);
	        }
	      }]);
	      return PolymerElement;
	    }(polymerElementBase);

	    return PolymerElement;
	  });

	  /**
	   * @param {!PolymerElementConstructor} prototype Element prototype to log
	   * @this {this}
	   * @private
	   */
	  function _regLog(prototype) {
	    console.log('[' + prototype.is + ']: registered');
	  }

	  /**
	   * Registers a class prototype for telemetry purposes.
	   * @param {HTMLElement} prototype Element prototype to register
	   * @this {this}
	   * @protected
	   */
	  function register(prototype) {
	    undefined && _regLog(prototype);
	  }

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  /**
	   * Class representing a static string value which can be used to filter
	   * strings by asseting that they have been created via this class. The
	   * `value` property returns the string passed to the constructor.
	   */

	  var LiteralString = function () {
	    function LiteralString(string) {
	      classCallCheck(this, LiteralString);

	      /** @type {string} */
	      this.value = string.toString();
	    }
	    /**
	     * @return {string} LiteralString string value
	     */


	    createClass(LiteralString, [{
	      key: 'toString',
	      value: function toString() {
	        return this.value;
	      }
	    }]);
	    return LiteralString;
	  }();

	  /**
	   * @param {*} value Object to stringify into HTML
	   * @return {string} HTML stringified form of `obj`
	   */


	  function literalValue(value) {
	    if (value instanceof LiteralString) {
	      return (/** @type {!LiteralString} */value.value
	      );
	    } else {
	      throw new Error('non-literal value passed to Polymer\'s htmlLiteral function: ' + value);
	    }
	  }

	  /**
	   * @param {*} value Object to stringify into HTML
	   * @return {string} HTML stringified form of `obj`
	   */
	  function htmlValue(value) {
	    if (value instanceof HTMLTemplateElement) {
	      return (/** @type {!HTMLTemplateElement } */value.innerHTML
	      );
	    } else if (value instanceof LiteralString) {
	      return literalValue(value);
	    } else {
	      throw new Error('non-template value passed to Polymer\'s html function: ' + value);
	    }
	  }

	  /**
	   * A template literal tag that creates an HTML <template> element from the
	   * contents of the string.
	   *
	   * This allows you to write a Polymer Template in JavaScript.
	   *
	   * Templates can be composed by interpolating `HTMLTemplateElement`s in
	   * expressions in the JavaScript template literal. The nested template's
	   * `innerHTML` is included in the containing template.  The only other
	   * values allowed in expressions are those returned from `htmlLiteral`
	   * which ensures only literal values from JS source ever reach the HTML, to
	   * guard against XSS risks.
	   *
	   * All other values are disallowed in expressions to help prevent XSS
	   * attacks; however, `htmlLiteral` can be used to compose static
	   * string values into templates. This is useful to compose strings into
	   * places that do not accept html, like the css text of a `style`
	   * element.
	   *
	   * Example:
	   *
	   *     static get template() {
	   *       return html`
	   *         <style>:host{ content:"..." }</style>
	   *         <div class="shadowed">${this.partialTemplate}</div>
	   *         ${super.template}
	   *       `;
	   *     }
	   *     static get partialTemplate() { return html`<span>Partial!</span>`; }
	   *
	   * @param {!ITemplateArray} strings Constant parts of tagged template literal
	   * @param {...*} values Variable parts of tagged template literal
	   * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement
	   */
	  var html = function html(strings) {
	    var template = /** @type {!HTMLTemplateElement} */document.createElement('template');

	    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      values[_key - 1] = arguments[_key];
	    }

	    template.innerHTML = values.reduce(function (acc, v, idx) {
	      return acc + htmlValue(v) + strings[idx + 1];
	    }, strings[0]);
	    return template;
	  };

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  /**
	   * Base class that provides the core API for Polymer's meta-programming
	   * features including template stamping, data-binding, attribute deserialization,
	   * and property change observation.
	   *
	   * @customElement
	   * @polymer
	   * @constructor
	   * @implements {Polymer_ElementMixin}
	   * @extends HTMLElement
	   * @appliesMixin ElementMixin
	   * @summary Custom element base class that provides the core API for Polymer's
	   *   key meta-programming features including template stamping, data-binding,
	   *   attribute deserialization, and property change observation
	   */
	  var PolymerElement = ElementMixin(HTMLElement);

	  /* globals tt, ttJSBridge */
	  function defaultCallback() {}

	  /* @polymerMixin */
	  var Base = (function (superClass) {
	    return function (_superClass) {
	      inherits(_class, _superClass);

	      function _class() {
	        classCallCheck(this, _class);
	        return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
	      }

	      createClass(_class, [{
	        key: 'ready',
	        value: function ready() {
	          var _this2 = this;

	          get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'ready', this).call(this);
	          // parse event listeners
	          if (this.listeners) {
	            var eventKeys = Object.keys(this.listeners);

	            var _loop = function (i, l) {
	              var item = eventKeys[i];
	              var eventHandler = _this2.listeners[item];
	              var m = item.split('.');
	              var eventTarget = m.length > 1 ? m[0] : null;
	              var eventKey = eventTarget ? m[1] : m[0];
	              window.__addListenerToElement(eventTarget ? _this2.$[eventTarget] : _this2, eventKey, function (e) {
	                return _this2[eventHandler].call(_this2, e);
	              });
	            };

	            for (var i = 0, l = eventKeys.length; i < l; i++) {
	              _loop(i, l);
	            }
	          }
	        }
	      }, {
	        key: 'hasBehavior',
	        value: function hasBehavior(type) {
	          // simple mock of hasBehavior method
	          if (type == 'base') {
	            return true;
	          }

	          return false;
	        }
	      }, {
	        key: 'sendMessage',
	        value: function sendMessage(_ref) {
	          var type = _ref.type,
	              event = _ref.event;

	          tt.publishPageEvent(type, event);
	        }
	      }, {
	        key: 'sendDetail',
	        value: function sendDetail(type, detail) {
	          this.sendMessage({
	            type: type,
	            event: {
	              detail: detail,
	              currentTarget: {
	                id: this.id || '',
	                offsetLeft: this.offsetLeft || 0,
	                offsetTop: this.offsetTop || 0,
	                dataset: this.$$data || {}
	              },
	              target: {
	                id: this.id || '',
	                offsetLeft: this.offsetLeft || 0,
	                offsetTop: this.offsetTop || 0,
	                dataset: this.$$data || {}
	              }
	            }
	          });
	        }
	      }, {
	        key: 'invoke',
	        value: function invoke(methodName, options) {
	          var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultCallback;

	          ttJSBridge.invoke(methodName, options, callback);
	        }
	      }, {
	        key: 'triggerEvent',
	        value: function triggerEvent(eventName) {
	          var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	          // 这个api用来触发组件自己独有的事件，比如swiper的change，input的focus，
	          var e = new CustomEvent(eventName, {
	            detail: detail,
	            bubbles: false, // 微信的做法，这些事件都不会冒泡
	            composed: false
	          });
	          this.dispatchEvent(e);
	        }
	      }, {
	        key: 'triggerReRender',
	        value: function triggerReRender() {
	          document.dispatchEvent(new CustomEvent('pageReRender', {
	            detail: { source: '_base' }
	          }));
	        }
	      }, {
	        key: 'parentCustomComponent',
	        value: function parentCustomComponent() {
	          // find parent custom component
	          var isInComponent = this.eventTriggeredBy && this.eventTriggeredBy.indexOf('component') > -1;
	          if (!isInComponent) {
	            return null;
	          }

	          var result = void 0;
	          this.dispatchEvent(new CustomEvent('get-custom-component-uid', {
	            detail: {
	              templateId: this.eventTriggeredBy.split('__')[1],
	              callback: function (nid) {
	                // 会同步执行的
	                result = nid;
	              }
	            },
	            bubbles: true,
	            composed: true
	          }));

	          return result;
	        }
	      }, {
	        key: '_deserializeValue',
	        value: function _deserializeValue(value, type) {
	          if (type === Boolean) {
	            return !!value;
	          }
	          if (type === String) {
	            if (value === undefined || value === null) {
	              return '';
	            }
	            // compiler会把value=""编译成value: true, 兼容一下
	            if (typeof value === 'boolean' && value) {
	              return '';
	            }
	            return value.toString();
	          }
	          return get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), '_deserializeValue', this).call(this, value, type);
	        }
	      }], [{
	        key: 'properties',
	        get: function () {
	          return {
	            hidden: {
	              type: Boolean,
	              reflectToAttribute: true
	            }
	          };
	        }
	      }]);
	      return _class;
	    }(superClass);
	  });

	  /* globals "web", "web", tt */
	  var ua = window.navigator.userAgent.toLowerCase();

	  var _typeof$1 = function () {
	    return 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function (e) {
	      return typeof e;
	    } : function (e) {
	      return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
	    };
	  }();

	  function is(e) {
	    var devtool = "web" === "web";

	    return {
	      devtool: devtool,
	      mobile: !devtool,
	      iphone: /iphone/.test(ua),
	      android: /android/.test(ua),
	      file: e ? /^file:\/\//.test(e) : false,
	      http: e ? /^(http|https):\/\//.test(e) : false,
	      dataImage: e ? /^\s*data:image\//.test(e) : false,
	      ttfile: e ? /^ttfile:\/\//.test(e) : false
	    };
	  }

	  function getDeviceType() {
	    var device = 'ios';

	    if (tt) {
	      try {
	        device = tt.getPlatform();
	      } catch (e) {/* noop */}
	    }

	    return device;
	  }

	  var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
	  var SUPPORTS_PASSIVE = false;

	  (function () {
	    try {
	      var opts = Object.defineProperty({}, 'passive', {
	        get: function () {
	          SUPPORTS_PASSIVE = true;
	        }
	      });
	      window.addEventListener('test', null, opts);
	      window.removeEventListener('test', null, opts);
	    } catch (e) {/* noop */}
	  })();

	  function touchActionPassiveSupport() {
	    if (HAS_NATIVE_TA && SUPPORTS_PASSIVE) {
	      return { passive: true };
	    } else {
	      return;
	    }
	  }

	  var PASSIVE_TOUCH = touchActionPassiveSupport();

	  /* @polymerMixin */
	  var Hover = (function (superClass) {
	    return function (_superClass) {
	      inherits(_class, _superClass);
	      createClass(_class, [{
	        key: 'hasBehavior',
	        value: function hasBehavior(type) {
	          // simple mock of hasBehavior method
	          if (type == 'hover') {
	            return true;
	          }

	          if (get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'hasBehavior', this)) {
	            return get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'hasBehavior', this).call(this, type);
	          }
	        }
	      }], [{
	        key: 'properties',
	        get: function () {
	          return {
	            hoverStartTime: {
	              type: Number,
	              value: 50
	            },
	            hoverStayTime: {
	              type: Number,
	              value: 400
	            },
	            hoverClass: {
	              type: String,
	              observer: '_hoverClassChange'
	            },
	            hoverStopPropagation: {
	              type: Boolean,
	              observer: '_hoverStopChange'
	            }
	          };
	        }
	      }]);

	      function _class() {
	        classCallCheck(this, _class);

	        var _this = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));

	        _this._hoverClass = [];
	        return _this;
	      }

	      createClass(_class, [{
	        key: 'bindHover',
	        value: function bindHover() {
	          if (!this._bindHover) {
	            this._bindHover = true;

	            this._hoverTouchStartId = this.hoverTouchStart.bind(this);
	            this._hoverTouchEndId = this.hoverTouchEnd.bind(this);
	            this._hoverCancelId = this.hoverCancel.bind(this);

	            this.addEventListener('touchstart', this._hoverTouchStartId, PASSIVE_TOUCH);
	            this.addEventListener('touchend', this._hoverTouchEndId);
	            this.addEventListener('touchcancel', this._hoverCancelId);
	            this.addEventListener('touchmove', this._hoverCancelId, PASSIVE_TOUCH);
	          }
	        }
	      }, {
	        key: 'unbindHover',
	        value: function unbindHover() {
	          if (this._bindHover) {
	            this._bindHover = false;

	            this.removeEventListener('touchstart', this._hoverTouchStartId);
	            this.removeEventListener('touchend', this._hoverTouchEndId);
	            this.removeEventListener('touchcancel', this._hoverCancelId);
	            this.removeEventListener('touchmove', this._hoverCancelId);
	          }
	        }
	      }, {
	        key: 'hoverTouchStart',
	        value: function hoverTouchStart(e) {
	          var _this2 = this;

	          if (!e._hoverPropagationStopped) {

	            if (this.hoverStopPropagation) {
	              e._hoverPropagationStopped = true;
	            }

	            if (this._hoverTouch && e.touches.length > 1 && !this._hovering) {
	              this.hoverCancel();
	              return;
	            }

	            this._hoverTouch = true;

	            if ('none' === this.hoverClass || this.disabled) {
	              return;
	            }

	            this._hoverStyleTimeId = setTimeout(function () {
	              _this2._hovering = true;

	              if (_this2._hoverClass.length > 0) {
	                for (var e = 0; e < _this2._hoverClass.length; e++) {
	                  _this2.classList.toggle(_this2._hoverClass[e], true);
	                }
	              }

	              if (!_this2._hoverTouch) {
	                window.requestAnimationFrame(function () {
	                  clearTimeout(_this2._hoverStayTimeId);

	                  _this2._hoverStayTimeId = setTimeout(function () {
	                    _this2._hoverReset();
	                  }, _this2.hoverStayTime);
	                });
	              }
	            }, this.hoverStartTime);
	          }
	        }
	      }, {
	        key: 'hoverTouchEnd',
	        value: function hoverTouchEnd() {
	          var _this3 = this;

	          this._hoverTouch = false;

	          if (this._hovering) {
	            window.requestAnimationFrame(function () {
	              clearTimeout(_this3._hoverStayTimeId);

	              _this3._hoverStayTimeId = setTimeout(function () {
	                _this3._hoverReset();
	              }, _this3.hoverStayTime);
	            });
	          }
	        }
	      }, {
	        key: 'hoverCancel',
	        value: function hoverCancel() {

	          this._hoverTouch = false;

	          clearTimeout(this._hoverStyleTimeId);

	          this._hoverReset();
	        }
	      }, {
	        key: '_hoverClassChange',
	        value: function _hoverClassChange(targetClassName) {
	          if (!targetClassName) {
	            return;
	          }

	          var classes = targetClassName.split(/\s/);

	          this._hoverClass = [];

	          // remove hover effects
	          if ('none' === targetClassName && !this.hoverStopPropagation) {
	            return this.unbindHover();
	          }

	          for (var n = 0; n < classes.length; n++) {
	            classes[n] && this._hoverClass.push(classes[n]);
	          }

	          this.bindHover();
	        }
	      }, {
	        key: '_hoverStopChange',
	        value: function _hoverStopChange(e) {
	          if ('none' === this.hoverClass && !e) {
	            return this.unbindHover();
	          }

	          this.bindHover();
	        }
	      }, {
	        key: '_hoverReset',
	        value: function _hoverReset() {
	          if (this._hovering) {
	            this._hovering = false;

	            if ('none' !== this.hoverClass && this._hoverClass.length > 0) {
	              for (var e = 0; e < this._hoverClass.length; e++) {
	                if (this.classList.contains(this._hoverClass[e])) {
	                  this.classList.toggle(this._hoverClass[e], false);
	                }
	              }
	            }
	          }
	        }
	      }]);
	      return _class;
	    }(superClass);
	  });

	  var _templateObject = taggedTemplateLiteral(['<style>\n      :host {\n        display: block;\n        white-space: normal;\n      }\n\n      :host([ hidden ]) {\n        display: none!important;\n      }\n\n      #main {\n        /* ios12 special */\n        text-decoration: inherit;\n      }\n    </style><slot id="main"></slot>'], ['<style>\n      :host {\n        display: block;\n        white-space: normal;\n      }\n\n      :host([ hidden ]) {\n        display: none!important;\n      }\n\n      #main {\n        /* ios12 special */\n        text-decoration: inherit;\n      }\n    </style><slot id="main"></slot>']);

	  var IS_IOS_11 = window.navigator.userAgent.match(/iPhone OS 11_[34]/);

	  var View = function (_Hover) {
	    inherits(View, _Hover);

	    function View() {
	      classCallCheck(this, View);
	      return possibleConstructorReturn(this, (View.__proto__ || Object.getPrototypeOf(View)).apply(this, arguments));
	    }

	    createClass(View, [{
	      key: 'ready',
	      value: function ready() {
	        get(View.prototype.__proto__ || Object.getPrototypeOf(View.prototype), 'ready', this).call(this);
	        if (IS_IOS_11) {
	          // ios 11.4或者11.3的兼容问题, 文本节点的text-decoration没了
	          this.$.main.style.textDecoration = 'inherit';
	        }
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        // 不能有回车哦
	        return html(_templateObject);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-view';
	      }
	    }]);
	    return View;
	  }(Hover(Base(PolymerElement)));

	  window.customElements.define(View.is, View);

	  /* @polymerMixin */
	  var TouchTrack = (function (superClass) {
	    return function (_superClass) {
	      inherits(TouchTrack, _superClass);

	      function TouchTrack() {
	        classCallCheck(this, TouchTrack);
	        return possibleConstructorReturn(this, (TouchTrack.__proto__ || Object.getPrototypeOf(TouchTrack)).apply(this, arguments));
	      }

	      createClass(TouchTrack, [{
	        key: 'touchtrack',

	        // TODO: 这个方法做的事情感觉可以直接用手势库的功能代替
	        value: function touchtrack(el, method, n) {
	          var i = this;
	          var r = 0,
	              o = 0,
	              a = 0,
	              s = 0;
	          var l = function (e, state, pageX, pageY) {
	            if (false === i[method].call(i, {
	              target: e.target,
	              currentTarget: e.currentTarget,
	              preventDefault: e.preventDefault.bind(e),
	              stopPropagation: e.stopPropagation.bind(e),
	              touches: e.touches,
	              changedTouches: e.changedTouches,
	              detail: {
	                state: state,
	                x: pageX,
	                y: pageY,
	                dx: pageX - r,
	                dy: pageY - o,
	                ddx: pageX - a,
	                ddy: pageY - s,
	                timeStamp: e.timeStamp
	              }
	            })) {
	              return false;
	            }
	          };

	          var c = null;

	          el.addEventListener('touchstart', function (e) {
	            if (1 === e.touches.length && !c) {
	              c = e;
	              r = a = e.touches[0].pageX;
	              o = s = e.touches[0].pageY;

	              l(e, 'start', r, o);
	            }
	          });

	          el.addEventListener('touchmove', function (e) {
	            if (1 === e.touches.length && c) {
	              var t = l(e, 'move', e.touches[0].pageX, e.touches[0].pageY);

	              a = e.touches[0].pageX;
	              s = e.touches[0].pageY;

	              return t;
	            }
	          });

	          el.addEventListener('touchend', function (e) {
	            if (0 === e.touches.length && c) {
	              c = null;

	              return l(e, 'end', e.changedTouches[0].pageX, e.changedTouches[0].pageY);
	            }
	          });

	          el.addEventListener('touchcancel', function (e) {
	            if (c) {
	              var t = c;
	              c = null;

	              return l(e, n ? 'cancel' : 'end', t.touches[0].pageX, t.touches[0].pageY);
	            }
	          });
	        }
	      }]);
	      return TouchTrack;
	    }(superClass);
	  });

	  var bezier = function () {
	    var kSplineTableSize = 11;
	    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

	    function A(aA1, aA2) {
	      return 1.0 - 3.0 * aA2 + 3.0 * aA1;
	    }
	    function B(aA1, aA2) {
	      return 3.0 * aA2 - 6.0 * aA1;
	    }
	    function C(aA1) {
	      return 3.0 * aA1;
	    }

	    function calcBezier(aT, aA1, aA2) {
	      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
	    }
	    function getSlope(aT, aA1, aA2) {
	      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
	    }

	    function binarySubdivide(aX, aA, aB, mX1, mX2) {
	      var currentX = void 0,
	          currentT = void 0;
	      var i = 0;
	      do {
	        currentT = aA + (aB - aA) / 2.0;
	        currentX = calcBezier(currentT, mX1, mX2) - aX;
	        if (currentX > 0.0) {
	          aB = currentT;
	        } else {
	          aA = currentT;
	        }
	      } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
	      return currentT;
	    }

	    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
	      for (var i = 0; i < 4; ++i) {
	        var currentSlope = getSlope(aGuessT, mX1, mX2);
	        if (currentSlope === 0.0) {
	          return aGuessT;
	        }
	        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	        aGuessT -= currentX / currentSlope;
	      }
	      return aGuessT;
	    }

	    function bezier(mX1, mY1, mX2, mY2) {
	      if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
	        return;
	      }
	      var sampleValues = new Float32Array(kSplineTableSize);

	      if (mX1 !== mY1 || mX2 !== mY2) {
	        for (var i = 0; i < kSplineTableSize; ++i) {
	          sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	        }
	      }

	      function getTForX(aX) {
	        var intervalStart = 0.0;
	        var currentSample = 1;
	        var lastSample = kSplineTableSize - 1;

	        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
	          intervalStart += kSampleStepSize;
	        }

	        --currentSample;

	        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
	        var guessForT = intervalStart + dist * kSampleStepSize;
	        var initialSlope = getSlope(guessForT, mX1, mX2);

	        if (initialSlope >= 0.001) {
	          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	        } else if (initialSlope === 0.0) {
	          return guessForT;
	        } else {
	          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	        }
	      }

	      return function (x) {
	        if (mX1 === mY1 && mX2 === mY2) {
	          return x;
	        }
	        if (x === 0) {
	          return 0;
	        }
	        if (x === 1) {
	          return 1;
	        }
	        return calcBezier(getTForX(x), mY1, mY2);
	      };
	    }

	    return bezier;
	  }();

	  var _templateObject$1 = taggedTemplateLiteral(['\n    <style>\n      :host {\n        display: block;\n        width: 100%;\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n\n      .scroll {\n        position: relative;\n        -webkit-overflow-scrolling: touch;\n        height: 100%;\n        /* display: flex; \u65F6\u5728\u5B89\u5353\u4E0B\u4F1A\u5BFC\u81F4scrollWidth\u548CoffsetWidth\u4E00\u6837 */\n        width: 100%;\n        max-height: inherit;\n      }\n\n      .scroll::-webkit-scrollbar {\n        display: none;\n      }\n\n    </style>\n\n    <div id="wrap" class="scroll">\n      <div id="main" style="overflow-x: hidden; overflow-y: hidden;" class="scroll">\n        <div id="content" style="white-space: nowrap;">\n          <slot></slot>\n        </div>\n      </div>\n    </div>\n    '], ['\n    <style>\n      :host {\n        display: block;\n        width: 100%;\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n\n      .scroll {\n        position: relative;\n        -webkit-overflow-scrolling: touch;\n        height: 100%;\n        /* display: flex; \u65F6\u5728\u5B89\u5353\u4E0B\u4F1A\u5BFC\u81F4scrollWidth\u548CoffsetWidth\u4E00\u6837 */\n        width: 100%;\n        max-height: inherit;\n      }\n\n      .scroll::-webkit-scrollbar {\n        display: none;\n      }\n\n    </style>\n\n    <div id="wrap" class="scroll">\n      <div id="main" style="overflow-x: hidden; overflow-y: hidden;" class="scroll">\n        <div id="content" style="white-space: nowrap;">\n          <slot></slot>\n        </div>\n      </div>\n    </div>\n    ']);

	  var easyOutEasing = bezier(0, 0, 0.58, 1);

	  var device = getDeviceType();

	  var ScrollView = function (_TouchTrack) {
	    inherits(ScrollView, _TouchTrack);

	    function ScrollView() {
	      classCallCheck(this, ScrollView);
	      return possibleConstructorReturn(this, (ScrollView.__proto__ || Object.getPrototypeOf(ScrollView)).apply(this, arguments));
	    }

	    createClass(ScrollView, [{
	      key: 'ready',
	      value: function ready() {
	        var _this2 = this;

	        get(ScrollView.prototype.__proto__ || Object.getPrototypeOf(ScrollView.prototype), 'ready', this).call(this);

	        if (is()['iphone']) {
	          // ios有无法解决的bug，scroll-view滑的时候，软键盘收不起来
	          document.addEventListener('onKeyboardShow', function () {
	            _this2.__hasKeyboard = true;
	          });
	        }

	        this.touchtrack(this.$.main, '_handleTrack');
	        this.__pageRerender = this._pageRerender.bind(this);
	      }
	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        var _this3 = this;

	        get(ScrollView.prototype.__proto__ || Object.getPrototypeOf(ScrollView.prototype), 'connectedCallback', this).call(this);

	        this._attached = true;
	        this._lastScrollTop = this.scrollTop || 0;
	        this._lastScrollLeft = this.scrollLeft || 0;
	        this._lastScrollToUpperTime = 0;
	        this._lastScrollToLowerTime = 0;

	        this._scrollXChanged(this.scrollX);
	        this._scrollYChanged(this.scrollY);
	        this._scrollTopChanged(this.scrollTop);
	        this._scrollLeftChanged(this.scrollLeft);
	        this._scrollIntoViewChanged(this.scrollIntoView);

	        this.__handleTouchMove = function (e) {

	          // 如果当前在做scrollTop的动画，直接清除动画。
	          if (_this3.__rafId) {
	            _this3.__currentAnimCanceled = true;
	            setTimeout(function () {
	              _this3.__currentAnimCanceled = false;
	            }, 50);
	          }
	        };

	        this.__handleTouchStart = function (e) {
	          var $main = _this3.$.main;
	          if ($main.scrollHeight > $main.offsetHeight) {
	            _this3.invoke('disableScrollBounce', {
	              disable: true
	            });
	          }
	        };

	        this.__handleTouchEnd = function () {
	          _this3.invoke('disableScrollBounce', {
	            disable: false
	          });
	        };

	        this.__handleScroll = function (e) {
	          e.preventDefault();
	          e.stopPropagation();

	          _this3._handleScroll(e);

	          document.dispatchEvent(new CustomEvent('tt-scroll-view'));

	          if (_this3.__hasKeyboard) {
	            // 解决ios的bug
	            _this3.__hasKeyboard = false;
	            _this3.invoke('endEditing');
	          }
	        };

	        this.$.main.addEventListener('touchstart', this.__handleTouchStart);
	        this.$.main.addEventListener('touchmove', this.__handleTouchMove);
	        this.$.main.addEventListener('touchend', this.__handleTouchEnd);
	        this.$.main.addEventListener('scroll', this.__handleScroll);

	        if (is().iphone) {
	          var scrollHack = document.getElementById('__scroll_view_hack');
	          if (scrollHack) {
	            scrollHack.parentNode.removeChild(scrollHack);
	          }

	          scrollHack = document.createElement('div');

	          scrollHack.setAttribute('style', 'position: fixed; left: 0; bottom: 0; line-height: 1; font-size: 1px; z-index: 10000; border-radius: 4px; box-shadow: 0 0 8px rgba(0,0,0,.4); width: 1px; height: 1px; overflow: hidden;');
	          scrollHack.innerText = '.';
	          scrollHack.id = '__scroll_view_hack';

	          document.documentElement.appendChild(scrollHack);
	        }
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        get(ScrollView.prototype.__proto__ || Object.getPrototypeOf(ScrollView.prototype), 'disconnectedCallback', this).call(this);

	        this.$.main.removeEventListener('scroll', this.__handleScroll);
	        this.$.main.removeEventListener('touchstart', this.__handleTouchStart);
	        this.$.main.removeEventListener('touchmove', this.__handleTouchMove);
	        this.$.main.removeEventListener('touchend', this.__handleTouchEnd);
	      }
	    }, {
	      key: 'scrollTo',
	      value: function scrollTo(scrollTop, direction) {
	        var main, content, r, getTransformStr;
	        return regeneratorRuntime.async(function scrollTo$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!this.__rafId) {
	                  _context.next = 2;
	                  break;
	                }

	                return _context.abrupt('return');

	              case 2:
	                main = this.$.main;
	                content = this.$.content;


	                if (scrollTop < 0) {
	                  scrollTop = 0;
	                } else if ('x' === direction && scrollTop > main.scrollWidth - main.offsetWidth) {
	                  scrollTop = main.scrollWidth - main.offsetWidth;
	                } else if ('y' === direction && scrollTop > main.scrollHeight - main.offsetHeight) {
	                  scrollTop = main.scrollHeight - main.offsetHeight;
	                }

	                r = 0;


	                if ('x' === direction) {
	                  r = main.scrollLeft - scrollTop;
	                } else if ('y' === direction) {
	                  r = main.scrollTop - scrollTop;
	                }

	                if (!(r !== 0)) {
	                  _context.next = 15;
	                  break;
	                }

	                getTransformStr = function () {
	                  return '';
	                };

	                if ('x' === direction) {
	                  getTransformStr = function (val) {
	                    return 'translateX(' + val + 'px) translateZ(0)';
	                  };
	                } else if ('y' === direction) {
	                  getTransformStr = function (val) {
	                    return 'translateY(' + val + 'px) translateZ(0)';
	                  };
	                }

	                this.__transitionEnd = this._transitionEnd.bind(this, scrollTop, direction);

	                if ('x' === direction) {
	                  if ('ios' != device) {
	                    main.style.overflowX = 'hidden';
	                  }
	                } else if ('y' === direction) {
	                  main.style.overflowY = 'hidden';
	                }

	                _context.next = 14;
	                return regeneratorRuntime.awrap(this._doScrollTopChangeAnimate(content, r, getTransformStr));

	              case 14:
	                this.__transitionEnd();

	              case 15:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, null, this);
	      }
	    }, {
	      key: '_doScrollTopChangeAnimate',
	      value: function _doScrollTopChangeAnimate(content, scrollTop, getTransformStr) {
	        var _this4 = this;

	        return new Promise(function (resolve) {
	          _this4.__rafId = null;
	          var duration = 300;
	          var start = void 0;

	          var animate = function () {
	            var ts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	            start = start || ts;
	            var dt = ts - start;
	            var percent = Math.min(dt / duration, 1);
	            var curTransform = getTransformStr(easyOutEasing(percent) * scrollTop);

	            content.style.transform = curTransform;
	            content.style.webkitTransform = curTransform;

	            if (dt >= duration || _this4.__currentAnimCanceled) {
	              window.cancelAnimationFrame(_this4.__rafId);
	              _this4.__rafId = null;
	              resolve();
	            } else {
	              _this4.__rafId = window.requestAnimationFrame(animate);
	            }
	          };

	          animate();
	        });
	      }
	    }, {
	      key: '_getStyle',
	      value: function _getStyle(overflowX, overflowY) {
	        return 'overflow-x: ' + (overflowX ? 'auto' : 'hidden') + '; overflow-y: ' + (overflowY ? 'auto' : 'hidden') + ';';
	      }
	    }, {
	      key: '_handleTrack',
	      value: function _handleTrack(e) {
	        if (e.detail.state === 'start') {
	          this._noBubble = null;
	          return;
	        }

	        if (e.detail.state === 'end') {
	          this._noBubble = false;
	        }

	        if (null === this._noBubble && this.scrollY) {
	          if (Math.abs(e.detail.ddy) / Math.abs(e.detail.ddx) > 1) {
	            this._noBubble = true;
	          } else {
	            this._noBubble = false;
	          }
	        }

	        if (null === this._noBubble && this.scrollX) {
	          if (Math.abs(e.detail.ddx) / Math.abs(e.detail.ddy) > 1) {
	            this._noBubble = true;
	          } else {
	            this._noBubble = false;
	          }
	        }

	        if (this._noBubble) {
	          e.stopPropagation();
	          // 发个别的事件，避免需要touchmove的场景得不到应有的事件
	          this.dispatchEvent(new CustomEvent('tt-touchmove', {
	            detail: { srcMoveEvent: e },
	            bubbles: true,
	            composed: true
	          }));
	        }
	      }
	    }, {
	      key: '_handleScroll',
	      value: function _handleScroll(e) {
	        if (!(e.timeStamp - this._lastScrollTime < 20)) {
	          this._lastScrollTime = e.timeStamp;

	          var _e$target = e.target,
	              scrollTop = _e$target.scrollTop,
	              scrollHeight = _e$target.scrollHeight,
	              scrollWidth = _e$target.scrollWidth,
	              scrollLeft = _e$target.scrollLeft,
	              offsetHeight = _e$target.offsetHeight,
	              offsetWidth = _e$target.offsetWidth;


	          this.triggerEvent('scroll', {
	            scrollLeft: scrollLeft,
	            scrollTop: scrollTop,
	            scrollHeight: scrollHeight,
	            scrollWidth: scrollWidth,
	            deltaX: this._lastScrollLeft - scrollLeft,
	            deltaY: this._lastScrollTop - scrollTop
	          });

	          if (this.scrollY) {
	            var n = this._lastScrollTop - scrollTop > 0;
	            var i = this._lastScrollTop - scrollTop < 0;

	            if (scrollTop <= this.upperThreshold && n && e.timeStamp - this._lastScrollToUpperTime > 200) {

	              this.triggerEvent('scrolltoupper', {
	                direction: 'top'
	              });

	              this._lastScrollToUpperTime = e.timeStamp;
	            }

	            if (scrollTop + offsetHeight + this.lowerThreshold >= scrollHeight && i && e.timeStamp - this._lastScrollToLowerTime > 200) {

	              this.triggerEvent('scrolltolower', {
	                direction: 'bottom'
	              });

	              this._lastScrollToLowerTime = e.timeStamp;
	            }
	          }

	          if (this.scrollX) {
	            var r = this._lastScrollLeft - scrollLeft > 0;
	            var o = this._lastScrollLeft - scrollLeft < 0;

	            if (scrollLeft <= this.upperThreshold && r && e.timeStamp - this._lastScrollToUpperTime > 200) {

	              this.triggerEvent('scrolltoupper', {
	                direction: 'top'
	              });

	              this._lastScrollToUpperTime = e.timeStamp;
	            }

	            if (scrollLeft + offsetWidth + this.lowerThreshold >= scrollWidth && o && e.timeStamp - this._lastScrollToLowerTime > 200) {

	              this.triggerEvent('scrolltolower', {
	                direction: 'bottom'
	              });

	              this._lastScrollToLowerTime = e.timeStamp;
	            }
	          }

	          this._lastScrollTop = scrollTop;
	          this._lastScrollLeft = scrollLeft;
	        }
	      }
	    }, {
	      key: '_scrollXChanged',
	      value: function _scrollXChanged(e) {
	        var n = window.navigator.userAgent.toLowerCase();

	        if (e) {

	          if (this.scrollY || /android/.test(n)) {
	            document.removeEventListener('pageReRender', this.__pageRerender);
	            this.$.main.style.overflowX = 'auto';
	            this.$.main.style.paddingBottom = '';
	            this.$.wrap.style.overflowY = '';
	            this.$.wrap.style.height = '';
	            this.$.content.style.height = '100%';
	            return;
	          }

	          undefined === this._isAutoHeight && this._checkIsAutoHeight();

	          this.$.main.style.overflowX = 'auto';
	          this.$.main.style.paddingBottom = '20px';
	          this.$.wrap.style.overflowY = 'hidden';

	          if (this._isAutoHeight) {
	            this.$.wrap.style.height = this.$.content.offsetHeight + 'px', this.$.content.style.height = '';
	          } else {
	            this.$.wrap.style.height = '';
	            this.$.content.style.height = this.offsetHeight + 'px';
	          }

	          document.addEventListener('pageReRender', this.__pageRerender);
	        } else {
	          document.removeEventListener('pageReRender', this.__pageRerender);
	          this.$.main.style.overflowX = 'hidden';

	          this.$.main.style.paddingBottom = '';
	          this.$.wrap.style.overflowY = '';
	          this.$.wrap.style.height = '';

	          this.$.content.style.height = '100%';
	        }
	      }
	    }, {
	      key: '_scrollYChanged',
	      value: function _scrollYChanged(e) {
	        this.$.main.style.overflowY = e ? 'auto' : 'hidden';
	      }
	    }, {
	      key: '_checkIsAutoHeight',
	      value: function _checkIsAutoHeight() {
	        this.$.wrap.style.height = 0;

	        var e = getComputedStyle(this);
	        var t = parseFloat(e.borderBottomWidth) || 0;
	        var n = parseFloat(e.borderTopWidth) || 0;
	        var i = parseFloat(e.paddingTop) || 0;
	        var r = parseFloat(e.paddingBottom) || 0;

	        this._isAutoHeight = this.offsetHeight === t + n + i + r;

	        var o = 1e4 * Math.random() | 0;

	        this.$.wrap.style.height = o + 'px';

	        e = getComputedStyle(this);
	        t = parseFloat(e.borderBottomWidth) || 0;
	        n = parseFloat(e.borderTopWidth) || 0;
	        i = parseFloat(e.paddingTop) || 0;
	        r = parseFloat(e.paddingBottom) || 0;

	        this._isAutoHeight = this._isAutoHeight || this.offsetHeight === t + n + i + r + o;
	      }
	    }, {
	      key: '_scrollTopChanged',
	      value: function _scrollTopChanged(scrollTop) {
	        var _this5 = this;

	        if (isNaN(scrollTop)) {
	          scrollTop = 0;
	        }
	        if (this.scrollY) {
	          setTimeout(function () {
	            _this5.scrollWithAnimation ? _this5.scrollTo(scrollTop, 'y') : _this5.$.main.scrollTop = scrollTop;
	          }, 10);
	        }
	      }
	    }, {
	      key: '_scrollLeftChanged',
	      value: function _scrollLeftChanged(scrollLeft) {
	        var _this6 = this;

	        if (isNaN(scrollLeft)) {
	          scrollLeft = 0;
	        }
	        if (this.scrollX) {
	          setTimeout(function () {
	            _this6.scrollWithAnimation ? _this6.scrollTo(scrollLeft, 'x') : _this6.$.main.scrollLeft = scrollLeft;
	          }, 10);
	        }
	      }
	    }, {
	      key: '_scrollIntoViewChanged',
	      value: function _scrollIntoViewChanged(targetId) {
	        var _this7 = this;

	        if (!targetId) {
	          return;
	        }

	        if (!/^[_a-zA-Z][-_a-zA-Z0-9:]*$/.test(targetId)) {
	          logger.group('scroll-into-view="' + targetId + '" 有误');
	          logger.error('target id 属性值格式错误');
	          return logger.groupEnd();
	        }

	        // wait for detached tree ready
	        setTimeout(function () {
	          var targetEle = _this7.querySelector('#' + targetId);

	          if (!targetEle) {
	            return;
	          }

	          var mainStyle = _this7.$.main.getBoundingClientRect();
	          var targetStyle = targetEle.getBoundingClientRect();

	          if (_this7.scrollX) {
	            var gapX = targetStyle.left - mainStyle.left;
	            var mainLeft = _this7.$.main.scrollLeft;
	            var scrollLeft = mainLeft + gapX;

	            _this7.scrollWithAnimation ? _this7.scrollTo(scrollLeft, 'x') : _this7.$.main.scrollLeft = scrollLeft;
	          }

	          if (_this7.scrollY) {
	            var gapY = targetStyle.top - mainStyle.top;
	            var mainScrollTop = _this7.$.main.scrollTop;
	            var scrollTop = mainScrollTop + gapY;

	            _this7.scrollWithAnimation ? _this7.scrollTo(scrollTop, 'y') : _this7.$.main.scrollTop = scrollTop;
	          }
	        }, 10);
	      }
	    }, {
	      key: 'getScrollPosition',
	      value: function getScrollPosition() {
	        var e = this.$.main;
	        return {
	          scrollLeft: e.scrollLeft,
	          scrollTop: e.scrollTop
	        };
	      }
	    }, {
	      key: '_transitionEnd',
	      value: function _transitionEnd(e, oldOne) {
	        var main = this.$.main;
	        var content = this.$.content;

	        content.style.transform = '';
	        content.style.webkitTransform = '';

	        if (oldOne === 'x') {
	          main.style.overflowX = this.scrollX ? 'auto' : 'hidden';
	          main.scrollLeft = e;
	        } else if (oldOne === 'y') {
	          main.style.overflowY = this.scrollY ? 'auto' : 'hidden';
	          main.scrollTop = e;
	        }
	      }
	    }, {
	      key: '_pageRerender',
	      value: function _pageRerender() {
	        var _this8 = this;

	        window.requestAnimationFrame(function () {
	          if (!(_this8.offsetHeight === _this8._lastOutterHeight && _this8.$.content.offsetHeight === _this8._lastContenHeight)) {

	            _this8._checkIsAutoHeight();

	            if (_this8._isAutoHeight) {
	              _this8.$.wrap.style.height = _this8.$.content.offsetHeight + 'px';
	              _this8.$.content.style.height = '';
	            } else {
	              _this8.$.wrap.style.height = '';
	              _this8.$.content.style.height = _this8.offsetHeight + 'px';
	            }

	            _this8._lastOutterHeight = _this8.offsetHeight;
	            _this8._lastContenHeight = _this8.$.content.offsetHeight;
	          }
	        });
	      }
	    }, {
	      key: 'scrollTop',
	      get: function () {
	        return this.$$scrollTop;
	      },
	      set: function (newValue) {
	        var old = this.$$scrollTop;
	        this.$$scrollTop = this._deserializeValue(newValue, Number);
	        if (this._attached) {
	          this._scrollTopChanged(this.$$scrollTop, old);
	        }
	      }
	    }, {
	      key: 'scrollLeft',
	      get: function () {
	        return this.$$scrollLeft;
	      },
	      set: function (newValue) {
	        var old = this.$$scrollLeft;
	        this.$$scrollLeft = this._deserializeValue(newValue, Number);
	        if (this._attached) {
	          this._scrollLeftChanged(this.$$scrollLeft, old);
	        }
	      }
	    }, {
	      key: 'scrollIntoView',
	      get: function () {
	        return this.$$scrollIntoView;
	      },
	      set: function (newValue) {
	        var old = this.$$scrollIntoView;
	        this.$$scrollIntoView = this._deserializeValue(newValue, String);
	        if (this._attached) {
	          this._scrollIntoViewChanged(this.$$scrollIntoView, old);
	        }
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$1);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-scroll-view';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          scrollX: {
	            type: Boolean,
	            value: false,
	            observer: '_scrollXChanged',
	            reflectToAttribute: true
	          },
	          scrollY: {
	            type: Boolean,
	            value: false,
	            observer: '_scrollYChanged',
	            reflectToAttribute: true
	          },
	          upperThreshold: {
	            type: Number,
	            value: 50
	          },
	          lowerThreshold: {
	            type: Number,
	            value: 50
	          },
	          scrollWithAnimation: {
	            type: Boolean,
	            value: false,
	            reflectToAttribute: true
	          }
	        };
	      }
	    }]);
	    return ScrollView;
	  }(TouchTrack(Base(PolymerElement)));

	  window.customElements.define(ScrollView.is, ScrollView);

	  var isClone = false;

	  var Text = function (_HTMLElement) {
	    inherits(Text, _HTMLElement);
	    createClass(Text, [{
	      key: 'selectable',
	      get: function () {
	        if (typeof this.__selectable === 'undefined') {
	          this.__selectable = false;
	        }
	        return this.__selectable;
	      },
	      set: function (newValue) {
	        this.__selectable = newValue;
	        // update style
	        this.$.main.style.userSelect = newValue ? 'text' : '';
	        this.$.main.style.webkitUserSelect = newValue ? 'text' : '';
	      }
	    }], [{
	      key: 'is',
	      get: function () {
	        return 'tt-text';
	      }
	    }]);

	    function Text() {
	      classCallCheck(this, Text);

	      var _this2 = possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this));

	      if (!isClone) {
	        // none-cloneNode
	        var $main = document.createElement('span');
	        var $slot = document.createElement('span');

	        $slot.style.display = 'none';

	        var appendChild = _this2.appendChild.bind(_this2);
	        _this2._readyCallback = function () {
	          appendChild($main);
	          appendChild($slot);
	        };

	        // modify apis
	        ['append', 'prepend', 'appendChild', 'replaceChild', 'removeChild', 'insertBefore'].forEach(function (api) {
	          var _this = _this2;
	          _this2[api] = function () {
	            var _$slot$api;

	            var child = void 0;
	            if (api !== 'removeChild') {
	              child = arguments[0];
	            }
	            child && Object.defineProperty(child, 'parentElement', {
	              get: function () {
	                return _this;
	              }
	            });
	            (_$slot$api = $slot[api]).call.apply(_$slot$api, [$slot].concat(Array.prototype.slice.call(arguments)));
	          };
	        });
	        // modify apis
	        ['childNodes', 'children'].forEach(function (api) {
	          Object.defineProperty(_this2, api, {
	            get: function () {
	              return $slot[api];
	            }
	          });
	        });

	        // modify apis
	        $main.__eventTargetRef = _this2;

	        _this2.$ = {
	          main: $main,
	          slot: $slot
	        };
	      }

	      return _this2;
	    }

	    createClass(Text, [{
	      key: 'connectedCallback',
	      value: function connectedCallback() {

	        if (this._readyCallback) {
	          this._readyCallback();
	          this._readyCallback = null;
	        }

	        if (this.$) {
	          this._update();
	          this._observer = new MutationObserver(this._update.bind(this));
	          this._observer.observe(this.$.slot, { childList: true, subtree: true });
	        }
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        this._observer && this._observer.disconnect();
	      }
	    }, {
	      key: '_update',
	      value: function _update() {
	        var _this3 = this;

	        var textNode = document.createDocumentFragment();
	        var $slot = this.$.slot;

	        Array.from($slot.childNodes).forEach(function (shadowNode) {
	          if (shadowNode.nodeType === shadowNode.TEXT_NODE) {
	            var lines = _this3._decode(shadowNode.textContent).split('\n');

	            for (var i = 0; i < lines.length; i++) {
	              i && textNode.appendChild(document.createElement('br'));
	              textNode.appendChild(document.createTextNode(lines[i]));
	            }
	          } else {
	            if (shadowNode.nodeType === 1 && 'TT-TEXT' === shadowNode.tagName) {

	              var cloneNode = Node.prototype.cloneNode || Element.prototype.cloneNode;
	              var _clone = function (root) {
	                isClone = true;
	                var outer = cloneNode.call(root);
	                isClone = false;

	                outer.$$data = root.$$data;
	                var childNodes = root.$ ? root.$.main.childNodes : root.childNodes;
	                Array.from(childNodes).forEach(function (child) {
	                  if (child.nodeType === 1 && child.tagName === 'TT-TEXT') {
	                    outer.appendChild(_clone(child));
	                  } else {
	                    outer.appendChild(child.cloneNode());
	                  }
	                });

	                return outer;
	              };
	              textNode.appendChild(_clone(shadowNode));
	            }
	          }
	        });

	        this.$.main.innerHTML = '';
	        this.$.main.appendChild(textNode);
	      }
	    }, {
	      key: '_decode',
	      value: function _decode(e) {

	        if (this.space) {
	          'nbsp' === this.space ? e = e.replace(/ /g, '\xa0') : 'ensp' === this.space ? e = e.replace(/ /g, '\u2002') : 'emsp' === this.space && (e = e.replace(/ /g, '\u2003'));
	        }

	        if (this.decode) {
	          e = e.replace(/&nbsp;/g, '\xa0').replace(/&ensp;/g, '\u2002').replace(/&emsp;/g, '\u2003').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&apos;/g, '\'').replace(/&amp;/g, '&');
	        }

	        return e;
	      }
	    }]);
	    return Text;
	  }(HTMLElement);

	  window.customElements.define(Text.is, Text);

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  // Common implementation for mixin & behavior
	  function mutablePropertyChange(inst, property, value, old, mutableData) {
	    var isObject = void 0;
	    if (mutableData) {
	      isObject = typeof value === 'object' && value !== null;
	      // Pull `old` for Objects from temp cache, but treat `null` as a primitive
	      if (isObject) {
	        old = inst.__dataTemp[property];
	      }
	    }
	    // Strict equality check, but return false for NaN===NaN
	    var shouldChange = old !== value && (old === old || value === value);
	    // Objects are stored in temporary cache (cleared at end of
	    // turn), which is used for dirty-checking
	    if (isObject && shouldChange) {
	      inst.__dataTemp[property] = value;
	    }
	    return shouldChange;
	  }

	  /**
	   * Element class mixin to skip strict dirty-checking for objects and arrays
	   * (always consider them to be "dirty"), for use on elements utilizing
	   * `PropertyEffects`
	   *
	   * By default, `PropertyEffects` performs strict dirty checking on
	   * objects, which means that any deep modifications to an object or array will
	   * not be propagated unless "immutable" data patterns are used (i.e. all object
	   * references from the root to the mutation were changed).
	   *
	   * Polymer also provides a proprietary data mutation and path notification API
	   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
	   * mutation and notification of deep changes in an object graph to all elements
	   * bound to the same object graph.
	   *
	   * In cases where neither immutable patterns nor the data mutation API can be
	   * used, applying this mixin will cause Polymer to skip dirty checking for
	   * objects and arrays (always consider them to be "dirty").  This allows a
	   * user to make a deep modification to a bound object graph, and then either
	   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
	   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
	   * elements that wish to be updated based on deep mutations must apply this
	   * mixin or otherwise skip strict dirty checking for objects/arrays.
	   * Specifically, any elements in the binding tree between the source of a
	   * mutation and the consumption of it must apply this mixin or enable the
	   * `OptionalMutableData` mixin.
	   *
	   * In order to make the dirty check strategy configurable, see
	   * `OptionalMutableData`.
	   *
	   * Note, the performance characteristics of propagating large object graphs
	   * will be worse as opposed to using strict dirty checking with immutable
	   * patterns or Polymer's path notification API.
	   *
	   * @mixinFunction
	   * @polymer
	   * @summary Element class mixin to skip strict dirty-checking for objects
	   *   and arrays
	   */
	  var MutableData = dedupingMixin(function (superClass) {

	    /**
	     * @polymer
	     * @mixinClass
	     * @implements {Polymer_MutableData}
	     */
	    var MutableData = function (_superClass) {
	      inherits(MutableData, _superClass);

	      function MutableData() {
	        classCallCheck(this, MutableData);
	        return possibleConstructorReturn(this, (MutableData.__proto__ || Object.getPrototypeOf(MutableData)).apply(this, arguments));
	      }

	      createClass(MutableData, [{
	        key: '_shouldPropertyChange',

	        /**
	         * Overrides `PropertyEffects` to provide option for skipping
	         * strict equality checking for Objects and Arrays.
	         *
	         * This method pulls the value to dirty check against from the `__dataTemp`
	         * cache (rather than the normal `__data` cache) for Objects.  Since the temp
	         * cache is cleared at the end of a turn, this implementation allows
	         * side-effects of deep object changes to be processed by re-setting the
	         * same object (using the temp cache as an in-turn backstop to prevent
	         * cycles due to 2-way notification).
	         *
	         * @param {string} property Property name
	         * @param {*} value New property value
	         * @param {*} old Previous property value
	         * @return {boolean} Whether the property should be considered a change
	         * @protected
	         */
	        value: function _shouldPropertyChange(property, value, old) {
	          return mutablePropertyChange(this, property, value, old, true);
	        }
	      }]);
	      return MutableData;
	    }(superClass);

	    return MutableData;
	  });

	  /**
	   * Element class mixin to add the optional ability to skip strict
	   * dirty-checking for objects and arrays (always consider them to be
	   * "dirty") by setting a `mutable-data` attribute on an element instance.
	   *
	   * By default, `PropertyEffects` performs strict dirty checking on
	   * objects, which means that any deep modifications to an object or array will
	   * not be propagated unless "immutable" data patterns are used (i.e. all object
	   * references from the root to the mutation were changed).
	   *
	   * Polymer also provides a proprietary data mutation and path notification API
	   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
	   * mutation and notification of deep changes in an object graph to all elements
	   * bound to the same object graph.
	   *
	   * In cases where neither immutable patterns nor the data mutation API can be
	   * used, applying this mixin will allow Polymer to skip dirty checking for
	   * objects and arrays (always consider them to be "dirty").  This allows a
	   * user to make a deep modification to a bound object graph, and then either
	   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
	   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
	   * elements that wish to be updated based on deep mutations must apply this
	   * mixin or otherwise skip strict dirty checking for objects/arrays.
	   * Specifically, any elements in the binding tree between the source of a
	   * mutation and the consumption of it must enable this mixin or apply the
	   * `MutableData` mixin.
	   *
	   * While this mixin adds the ability to forgo Object/Array dirty checking,
	   * the `mutableData` flag defaults to false and must be set on the instance.
	   *
	   * Note, the performance characteristics of propagating large object graphs
	   * will be worse by relying on `mutableData: true` as opposed to using
	   * strict dirty checking with immutable patterns or Polymer's path notification
	   * API.
	   *
	   * @mixinFunction
	   * @polymer
	   * @summary Element class mixin to optionally skip strict dirty-checking
	   *   for objects and arrays
	   */
	  var OptionalMutableData = dedupingMixin(function (superClass) {

	    /**
	     * @mixinClass
	     * @polymer
	     * @implements {Polymer_OptionalMutableData}
	     */
	    var OptionalMutableData = function (_superClass2) {
	      inherits(OptionalMutableData, _superClass2);

	      function OptionalMutableData() {
	        classCallCheck(this, OptionalMutableData);
	        return possibleConstructorReturn(this, (OptionalMutableData.__proto__ || Object.getPrototypeOf(OptionalMutableData)).apply(this, arguments));
	      }

	      createClass(OptionalMutableData, [{
	        key: '_shouldPropertyChange',


	        /**
	         * Overrides `PropertyEffects` to provide option for skipping
	         * strict equality checking for Objects and Arrays.
	         *
	         * When `this.mutableData` is true on this instance, this method
	         * pulls the value to dirty check against from the `__dataTemp` cache
	         * (rather than the normal `__data` cache) for Objects.  Since the temp
	         * cache is cleared at the end of a turn, this implementation allows
	         * side-effects of deep object changes to be processed by re-setting the
	         * same object (using the temp cache as an in-turn backstop to prevent
	         * cycles due to 2-way notification).
	         *
	         * @param {string} property Property name
	         * @param {*} value New property value
	         * @param {*} old Previous property value
	         * @return {boolean} Whether the property should be considered a change
	         * @protected
	         */
	        value: function _shouldPropertyChange(property, value, old) {
	          return mutablePropertyChange(this, property, value, old, this.mutableData);
	        }
	      }], [{
	        key: 'properties',
	        get: function () {
	          return {
	            /**
	             * Instance-level flag for configuring the dirty-checking strategy
	             * for this element.  When true, Objects and Arrays will skip dirty
	             * checking, otherwise strict equality checking will be used.
	             */
	            mutableData: Boolean
	          };
	        }
	      }]);
	      return OptionalMutableData;
	    }(superClass);

	    return OptionalMutableData;
	  });

	  // Export for use by legacy behavior
	  MutableData._mutablePropertyChange = mutablePropertyChange;

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  // Base class for HTMLTemplateElement extension that has property effects
	  // machinery for propagating host properties to children. This is an ES5
	  // class only because Babel (incorrectly) requires super() in the class
	  // constructor even though no `this` is used and it returns an instance.
	  var newInstance = null;
	  /**
	   * @constructor
	   * @extends {HTMLTemplateElement}
	   */
	  function HTMLTemplateElementExtension() {
	    return newInstance;
	  }
	  HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
	    constructor: {
	      value: HTMLTemplateElementExtension,
	      writable: true
	    }
	  });
	  /**
	   * @constructor
	   * @implements {Polymer_PropertyEffects}
	   * @extends {HTMLTemplateElementExtension}
	   */
	  var DataTemplate = PropertyEffects(HTMLTemplateElementExtension);
	  /**
	   * @constructor
	   * @implements {Polymer_MutableData}
	   * @extends {DataTemplate}
	   */
	  var MutableDataTemplate = MutableData(DataTemplate);

	  // Applies a DataTemplate subclass to a <template> instance
	  function upgradeTemplate(template, constructor) {
	    newInstance = template;
	    Object.setPrototypeOf(template, constructor.prototype);
	    new constructor();
	    newInstance = null;
	  }

	  // Base class for TemplateInstance's
	  /**
	   * @constructor
	   * @implements {Polymer_PropertyEffects}
	   */
	  var base = PropertyEffects(function () {
	    function _class() {
	      classCallCheck(this, _class);
	    }

	    return _class;
	  }());

	  /**
	   * @polymer
	   * @customElement
	   * @appliesMixin PropertyEffects
	   * @unrestricted
	   */

	  var TemplateInstanceBase = function (_base) {
	    inherits(TemplateInstanceBase, _base);

	    function TemplateInstanceBase(props) {
	      classCallCheck(this, TemplateInstanceBase);

	      var _this = possibleConstructorReturn(this, (TemplateInstanceBase.__proto__ || Object.getPrototypeOf(TemplateInstanceBase)).call(this));

	      _this._configureProperties(props);
	      _this.root = _this._stampTemplate(_this.__dataHost);
	      // Save list of stamped children
	      var children = _this.children = [];
	      for (var n = _this.root.firstChild; n; n = n.nextSibling) {
	        children.push(n);
	        n.__templatizeInstance = _this;
	      }
	      if (_this.__templatizeOwner && _this.__templatizeOwner.__hideTemplateChildren__) {
	        _this._showHideChildren(true);
	      }
	      // Flush props only when props are passed if instance props exist
	      // or when there isn't instance props.
	      var options = _this.__templatizeOptions;
	      if (props && options.instanceProps || !options.instanceProps) {
	        _this._enableProperties();
	      }
	      return _this;
	    }
	    /**
	     * Configure the given `props` by calling `_setPendingProperty`. Also
	     * sets any properties stored in `__hostProps`.
	     * @private
	     * @param {Object} props Object of property name-value pairs to set.
	     * @return {void}
	     */


	    createClass(TemplateInstanceBase, [{
	      key: '_configureProperties',
	      value: function _configureProperties(props) {
	        var options = this.__templatizeOptions;
	        if (options.forwardHostProp) {
	          for (var hprop in this.__hostProps) {
	            this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
	          }
	        }
	        // Any instance props passed in the constructor will overwrite host props;
	        // normally this would be a user error but we don't specifically filter them
	        for (var iprop in props) {
	          this._setPendingProperty(iprop, props[iprop]);
	        }
	      }
	      /**
	       * Forwards a host property to this instance.  This method should be
	       * called on instances from the `options.forwardHostProp` callback
	       * to propagate changes of host properties to each instance.
	       *
	       * Note this method enqueues the change, which are flushed as a batch.
	       *
	       * @param {string} prop Property or path name
	       * @param {*} value Value of the property to forward
	       * @return {void}
	       */

	    }, {
	      key: 'forwardHostProp',
	      value: function forwardHostProp(prop, value) {
	        if (this._setPendingPropertyOrPath(prop, value, false, true)) {
	          this.__dataHost._enqueueClient(this);
	        }
	      }

	      /**
	       * Override point for adding custom or simulated event handling.
	       *
	       * @param {!Node} node Node to add event listener to
	       * @param {string} eventName Name of event
	       * @param {function(!Event):void} handler Listener function to add
	       * @return {void}
	       */

	    }, {
	      key: '_addEventListenerToNode',
	      value: function _addEventListenerToNode(node, eventName, handler) {
	        var _this2 = this;

	        if (this._methodHost && this.__templatizeOptions.parentModel) {
	          // If this instance should be considered a parent model, decorate
	          // events this template instance as `model`
	          this._methodHost._addEventListenerToNode(node, eventName, function (e) {
	            e.model = _this2;
	            handler(e);
	          });
	        } else {
	          // Otherwise delegate to the template's host (which could be)
	          // another template instance
	          var templateHost = this.__dataHost.__dataHost;
	          if (templateHost) {
	            templateHost._addEventListenerToNode(node, eventName, handler);
	          }
	        }
	      }
	      /**
	       * Shows or hides the template instance top level child elements. For
	       * text nodes, `textContent` is removed while "hidden" and replaced when
	       * "shown."
	       * @param {boolean} hide Set to true to hide the children;
	       * set to false to show them.
	       * @return {void}
	       * @protected
	       */

	    }, {
	      key: '_showHideChildren',
	      value: function _showHideChildren(hide) {
	        var c = this.children;
	        for (var i = 0; i < c.length; i++) {
	          var n = c[i];
	          // Ignore non-changes
	          if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
	            if (n.nodeType === Node.TEXT_NODE) {
	              if (hide) {
	                n.__polymerTextContent__ = n.textContent;
	                n.textContent = '';
	              } else {
	                n.textContent = n.__polymerTextContent__;
	              }
	              // remove and replace slot
	            } else if (n.localName === 'slot') {
	              if (hide) {
	                n.__polymerReplaced__ = document.createComment('hidden-slot');
	                n.parentNode.replaceChild(n.__polymerReplaced__, n);
	              } else {
	                var replace = n.__polymerReplaced__;
	                if (replace) {
	                  replace.parentNode.replaceChild(n, replace);
	                }
	              }
	            } else if (n.style) {
	              if (hide) {
	                n.__polymerDisplay__ = n.style.display;
	                n.style.display = 'none';
	              } else {
	                n.style.display = n.__polymerDisplay__;
	              }
	            }
	          }
	          n.__hideTemplateChildren__ = hide;
	          if (n._showHideChildren) {
	            n._showHideChildren(hide);
	          }
	        }
	      }
	      /**
	       * Overrides default property-effects implementation to intercept
	       * textContent bindings while children are "hidden" and cache in
	       * private storage for later retrieval.
	       *
	       * @param {!Node} node The node to set a property on
	       * @param {string} prop The property to set
	       * @param {*} value The value to set
	       * @return {void}
	       * @protected
	       */

	    }, {
	      key: '_setUnmanagedPropertyToNode',
	      value: function _setUnmanagedPropertyToNode(node, prop, value) {
	        if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
	          node.__polymerTextContent__ = value;
	        } else {
	          get(TemplateInstanceBase.prototype.__proto__ || Object.getPrototypeOf(TemplateInstanceBase.prototype), '_setUnmanagedPropertyToNode', this).call(this, node, prop, value);
	        }
	      }
	      /**
	       * Find the parent model of this template instance.  The parent model
	       * is either another templatize instance that had option `parentModel: true`,
	       * or else the host element.
	       *
	       * @return {!Polymer_PropertyEffects} The parent model of this instance
	       */

	    }, {
	      key: 'dispatchEvent',


	      /**
	       * Stub of HTMLElement's `dispatchEvent`, so that effects that may
	       * dispatch events safely no-op.
	       *
	       * @param {Event} event Event to dispatch
	       * @return {boolean} Always true.
	       */
	      value: function dispatchEvent(event) {
	        // eslint-disable-line no-unused-vars
	        return true;
	      }
	    }, {
	      key: 'parentModel',
	      get: function () {
	        var model = this.__parentModel;
	        if (!model) {
	          var options = void 0;
	          model = this;
	          do {
	            // A template instance's `__dataHost` is a <template>
	            // `model.__dataHost.__dataHost` is the template's host
	            model = model.__dataHost.__dataHost;
	          } while ((options = model.__templatizeOptions) && !options.parentModel);
	          this.__parentModel = model;
	        }
	        return model;
	      }
	    }]);
	    return TemplateInstanceBase;
	  }(base);

	  /**
	   * @constructor
	   * @extends {TemplateInstanceBase}
	   * @implements {Polymer_MutableData}
	   */
	  var MutableTemplateInstanceBase = MutableData(TemplateInstanceBase);

	  function findMethodHost(template) {
	    // Technically this should be the owner of the outermost template.
	    // In shadow dom, this is always getRootNode().host, but we can
	    // approximate this via cooperation with our dataHost always setting
	    // `_methodHost` as long as there were bindings (or id's) on this
	    // instance causing it to get a dataHost.
	    var templateHost = template.__dataHost;
	    return templateHost && templateHost._methodHost || templateHost;
	  }

	  /* eslint-disable valid-jsdoc */
	  /**
	   * @suppress {missingProperties} class.prototype is not defined for some reason
	   */
	  function createTemplatizerClass(template, templateInfo, options) {
	    // Anonymous class created by the templatize
	    var base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
	    /**
	     * @constructor
	     * @extends {base}
	     * @private
	     */
	    var klass = function (_base2) {
	      inherits(klass, _base2);

	      function klass() {
	        classCallCheck(this, klass);
	        return possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).apply(this, arguments));
	      }

	      return klass;
	    }(base);
	    klass.prototype.__templatizeOptions = options;
	    klass.prototype._bindTemplate(template);
	    addNotifyEffects(klass, template, templateInfo, options);
	    return klass;
	  }

	  /**
	   * @suppress {missingProperties} class.prototype is not defined for some reason
	   */
	  function addPropagateEffects(template, templateInfo, options) {
	    var userForwardHostProp = options.forwardHostProp;
	    if (userForwardHostProp) {
	      // Provide data API and property effects on memoized template class
	      var klass = templateInfo.templatizeTemplateClass;
	      if (!klass) {
	        var _base3 = options.mutableData ? MutableDataTemplate : DataTemplate;
	        klass = templateInfo.templatizeTemplateClass = function (_base4) {
	          inherits(TemplatizedTemplate, _base4);

	          function TemplatizedTemplate() {
	            classCallCheck(this, TemplatizedTemplate);
	            return possibleConstructorReturn(this, (TemplatizedTemplate.__proto__ || Object.getPrototypeOf(TemplatizedTemplate)).apply(this, arguments));
	          }

	          return TemplatizedTemplate;
	        }(_base3);
	        // Add template - >instances effects
	        // and host <- template effects
	        var hostProps = templateInfo.hostProps;
	        for (var prop in hostProps) {
	          klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });
	          klass.prototype._createNotifyingProperty('_host_' + prop);
	        }
	      }
	      upgradeTemplate(template, klass);
	      // Mix any pre-bound data into __data; no need to flush this to
	      // instances since they pull from the template at instance-time
	      if (template.__dataProto) {
	        // Note, generally `__dataProto` could be chained, but it's guaranteed
	        // to not be since this is a vanilla template we just added effects to
	        Object.assign(template.__data, template.__dataProto);
	      }
	      // Clear any pending data for performance
	      template.__dataTemp = {};
	      template.__dataPending = null;
	      template.__dataOld = null;
	      template._enableProperties();
	    }
	  }
	  /* eslint-enable valid-jsdoc */

	  function createForwardHostPropEffect(hostProp, userForwardHostProp) {
	    return function forwardHostProp(template, prop, props) {
	      userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
	    };
	  }

	  function addNotifyEffects(klass, template, templateInfo, options) {
	    var hostProps = templateInfo.hostProps || {};
	    for (var iprop in options.instanceProps) {
	      delete hostProps[iprop];
	      var userNotifyInstanceProp = options.notifyInstanceProp;
	      if (userNotifyInstanceProp) {
	        klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });
	      }
	    }
	    if (options.forwardHostProp && template.__dataHost) {
	      for (var hprop in hostProps) {
	        klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });
	      }
	    }
	  }

	  function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
	    return function notifyInstanceProp(inst, prop, props) {
	      userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
	    };
	  }

	  function createNotifyHostPropEffect() {
	    return function notifyHostProp(inst, prop, props) {
	      inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
	    };
	  }

	  /**
	   * Returns an anonymous `PropertyEffects` class bound to the
	   * `<template>` provided.  Instancing the class will result in the
	   * template being stamped into a document fragment stored as the instance's
	   * `root` property, after which it can be appended to the DOM.
	   *
	   * Templates may utilize all Polymer data-binding features as well as
	   * declarative event listeners.  Event listeners and inline computing
	   * functions in the template will be called on the host of the template.
	   *
	   * The constructor returned takes a single argument dictionary of initial
	   * property values to propagate into template bindings.  Additionally
	   * host properties can be forwarded in, and instance properties can be
	   * notified out by providing optional callbacks in the `options` dictionary.
	   *
	   * Valid configuration in `options` are as follows:
	   *
	   * - `forwardHostProp(property, value)`: Called when a property referenced
	   *   in the template changed on the template's host. As this library does
	   *   not retain references to templates instanced by the user, it is the
	   *   templatize owner's responsibility to forward host property changes into
	   *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
	   *    method on the generated class should be called to forward host
	   *   properties into the template to prevent unnecessary property-changed
	   *   notifications. Any properties referenced in the template that are not
	   *   defined in `instanceProps` will be notified up to the template's host
	   *   automatically.
	   * - `instanceProps`: Dictionary of property names that will be added
	   *   to the instance by the templatize owner.  These properties shadow any
	   *   host properties, and changes within the template to these properties
	   *   will result in `notifyInstanceProp` being called.
	   * - `mutableData`: When `true`, the generated class will skip strict
	   *   dirty-checking for objects and arrays (always consider them to be
	   *   "dirty").
	   * - `notifyInstanceProp(instance, property, value)`: Called when
	   *   an instance property changes.  Users may choose to call `notifyPath`
	   *   on e.g. the owner to notify the change.
	   * - `parentModel`: When `true`, events handled by declarative event listeners
	   *   (`on-event="handler"`) will be decorated with a `model` property pointing
	   *   to the template instance that stamped it.  It will also be returned
	   *   from `instance.parentModel` in cases where template instance nesting
	   *   causes an inner model to shadow an outer model.
	   *
	   * All callbacks are called bound to the `owner`. Any context
	   * needed for the callbacks (such as references to `instances` stamped)
	   * should be stored on the `owner` such that they can be retrieved via
	   * `this`.
	   *
	   * When `options.forwardHostProp` is declared as an option, any properties
	   * referenced in the template will be automatically forwarded from the host of
	   * the `<template>` to instances, with the exception of any properties listed in
	   * the `options.instanceProps` object.  `instanceProps` are assumed to be
	   * managed by the owner of the instances, either passed into the constructor
	   * or set after the fact.  Note, any properties passed into the constructor will
	   * always be set to the instance (regardless of whether they would normally
	   * be forwarded from the host).
	   *
	   * Note that `templatize()` can be run only once for a given `<template>`.
	   * Further calls will result in an error. Also, there is a special
	   * behavior if the template was duplicated through a mechanism such as
	   * `<dom-repeat>` or `<test-fixture>`. In this case, all calls to
	   * `templatize()` return the same class for all duplicates of a template.
	   * The class returned from `templatize()` is generated only once using
	   * the `options` from the first call. This means that any `options`
	   * provided to subsequent calls will be ignored. Therefore, it is very
	   * important not to close over any variables inside the callbacks. Also,
	   * arrow functions must be avoided because they bind the outer `this`.
	   * Inside the callbacks, any contextual information can be accessed
	   * through `this`, which points to the `owner`.
	   *
	   * @param {!HTMLTemplateElement} template Template to templatize
	   * @param {Polymer_PropertyEffects=} owner Owner of the template instances;
	   *   any optional callbacks will be bound to this owner.
	   * @param {Object=} options Options dictionary (see summary for details)
	   * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
	   *   provided
	   * @suppress {invalidCasts}
	   */
	  function templatize(template, owner, options) {
	    options = /** @type {!TemplatizeOptions} */options || {};
	    if (template.__templatizeOwner) {
	      throw new Error('A <template> can only be templatized once');
	    }
	    template.__templatizeOwner = owner;
	    var ctor = owner ? owner.constructor : TemplateInstanceBase;
	    var templateInfo = ctor._parseTemplate(template);
	    // Get memoized base class for the prototypical template, which
	    // includes property effects for binding template & forwarding
	    var baseClass = templateInfo.templatizeInstanceClass;
	    if (!baseClass) {
	      baseClass = createTemplatizerClass(template, templateInfo, options);
	      templateInfo.templatizeInstanceClass = baseClass;
	    }
	    // Host property forwarding must be installed onto template instance
	    addPropagateEffects(template, templateInfo, options);
	    // Subclass base class and add reference for this specific template
	    /** @private */
	    var klass = function (_baseClass) {
	      inherits(TemplateInstance, _baseClass);

	      function TemplateInstance() {
	        classCallCheck(this, TemplateInstance);
	        return possibleConstructorReturn(this, (TemplateInstance.__proto__ || Object.getPrototypeOf(TemplateInstance)).apply(this, arguments));
	      }

	      return TemplateInstance;
	    }(baseClass);
	    klass.prototype._methodHost = findMethodHost(template);
	    klass.prototype.__dataHost = template;
	    klass.prototype.__templatizeOwner = owner;
	    klass.prototype.__hostProps = templateInfo.hostProps;
	    klass = /** @type {function(new:TemplateInstanceBase)} */klass; //eslint-disable-line no-self-assign
	    return klass;
	  }

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  /**
	   * @summary Collapse multiple callbacks into one invocation after a timer.
	   */
	  var Debouncer = function () {
	    function Debouncer() {
	      classCallCheck(this, Debouncer);

	      this._asyncModule = null;
	      this._callback = null;
	      this._timer = null;
	    }
	    /**
	     * Sets the scheduler; that is, a module with the Async interface,
	     * a callback and optional arguments to be passed to the run function
	     * from the async module.
	     *
	     * @param {!AsyncInterface} asyncModule Object with Async interface.
	     * @param {function()} callback Callback to run.
	     * @return {void}
	     */


	    createClass(Debouncer, [{
	      key: 'setConfig',
	      value: function setConfig(asyncModule, callback) {
	        var _this = this;

	        this._asyncModule = asyncModule;
	        this._callback = callback;
	        this._timer = this._asyncModule.run(function () {
	          _this._timer = null;
	          _this._callback();
	        });
	      }
	      /**
	       * Cancels an active debouncer and returns a reference to itself.
	       *
	       * @return {void}
	       */

	    }, {
	      key: 'cancel',
	      value: function cancel() {
	        if (this.isActive()) {
	          this._asyncModule.cancel(this._timer);
	          this._timer = null;
	        }
	      }
	      /**
	       * Flushes an active debouncer and returns a reference to itself.
	       *
	       * @return {void}
	       */

	    }, {
	      key: 'flush',
	      value: function flush() {
	        if (this.isActive()) {
	          this.cancel();
	          this._callback();
	        }
	      }
	      /**
	       * Returns true if the debouncer is active.
	       *
	       * @return {boolean} True if active.
	       */

	    }, {
	      key: 'isActive',
	      value: function isActive() {
	        return this._timer != null;
	      }
	      /**
	       * Creates a debouncer if no debouncer is passed as a parameter
	       * or it cancels an active debouncer otherwise. The following
	       * example shows how a debouncer can be called multiple times within a
	       * microtask and "debounced" such that the provided callback function is
	       * called once. Add this method to a custom element:
	       *
	       * ```js
	       * import {microtask} from '@polymer/polymer/lib/utils/async.js';
	       * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
	       * // ...
	       *
	       * _debounceWork() {
	       *   this._debounceJob = Debouncer.debounce(this._debounceJob,
	       *       microTask, () => this._doWork());
	       * }
	       * ```
	       *
	       * If the `_debounceWork` method is called multiple times within the same
	       * microtask, the `_doWork` function will be called only once at the next
	       * microtask checkpoint.
	       *
	       * Note: In testing it is often convenient to avoid asynchrony. To accomplish
	       * this with a debouncer, you can use `enqueueDebouncer` and
	       * `flush`. For example, extend the above example by adding
	       * `enqueueDebouncer(this._debounceJob)` at the end of the
	       * `_debounceWork` method. Then in a test, call `flush` to ensure
	       * the debouncer has completed.
	       *
	       * @param {Debouncer?} debouncer Debouncer object.
	       * @param {!AsyncInterface} asyncModule Object with Async interface
	       * @param {function()} callback Callback to run.
	       * @return {!Debouncer} Returns a debouncer object.
	       */

	    }], [{
	      key: 'debounce',
	      value: function debounce(debouncer, asyncModule, callback) {
	        if (debouncer instanceof Debouncer) {
	          debouncer.cancel();
	        } else {
	          debouncer = new Debouncer();
	        }
	        debouncer.setConfig(asyncModule, callback);
	        return debouncer;
	      }
	    }]);
	    return Debouncer;
	  }();

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  var debouncerQueue = [];

	  /**
	   * Adds a `Debouncer` to a list of globally flushable tasks.
	   *
	   * @param {!Debouncer} debouncer Debouncer to enqueue
	   * @return {void}
	   */
	  var enqueueDebouncer = function (debouncer) {
	    debouncerQueue.push(debouncer);
	  };

	  function flushDebouncers() {
	    var didFlush = Boolean(debouncerQueue.length);
	    while (debouncerQueue.length) {
	      try {
	        debouncerQueue.shift().flush();
	      } catch (e) {
	        setTimeout(function () {
	          throw e;
	        });
	      }
	    }
	    return didFlush;
	  }

	  /**
	   * Forces several classes of asynchronously queued tasks to flush:
	   * - Debouncers added via `enqueueDebouncer`
	   * - ShadyDOM distribution
	   *
	   * @return {void}
	   */
	  var flush = function () {
	    var shadyDOM = void 0,
	        debouncers = void 0;
	    do {
	      shadyDOM = window.ShadyDOM && ShadyDOM.flush();
	      if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
	        window.ShadyCSS.ScopingShim.flush();
	      }
	      debouncers = flushDebouncers();
	    } while (shadyDOM || debouncers);
	  };

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  /**
	   * The `<dom-if>` element will stamp a light-dom `<template>` child when
	   * the `if` property becomes truthy, and the template can use Polymer
	   * data-binding and declarative event features when used in the context of
	   * a Polymer element's template.
	   *
	   * When `if` becomes falsy, the stamped content is hidden but not
	   * removed from dom. When `if` subsequently becomes truthy again, the content
	   * is simply re-shown. This approach is used due to its favorable performance
	   * characteristics: the expense of creating template content is paid only
	   * once and lazily.
	   *
	   * Set the `restamp` property to true to force the stamped content to be
	   * created / destroyed when the `if` condition changes.
	   *
	   * @customElement
	   * @polymer
	   * @extends PolymerElement
	   * @summary Custom element that conditionally stamps and hides or removes
	   *   template content based on a boolean flag.
	   */
	  var DomIf = function (_PolymerElement) {
	    inherits(DomIf, _PolymerElement);
	    createClass(DomIf, null, [{
	      key: 'is',


	      // Not needed to find template; can be removed once the analyzer
	      // can find the tag name from customElements.define call
	      get: function () {
	        return 'dom-if';
	      }
	    }, {
	      key: 'template',
	      get: function () {
	        return null;
	      }
	    }, {
	      key: 'properties',
	      get: function () {

	        return {

	          /**
	           * Fired whenever DOM is added or removed/hidden by this template (by
	           * default, rendering occurs lazily).  To force immediate rendering, call
	           * `render`.
	           *
	           * @event dom-change
	           */

	          /**
	           * A boolean indicating whether this template should stamp.
	           */
	          if: {
	            type: Boolean,
	            observer: '__debounceRender'
	          },

	          /**
	           * When true, elements will be removed from DOM and discarded when `if`
	           * becomes false and re-created and added back to the DOM when `if`
	           * becomes true.  By default, stamped elements will be hidden but left
	           * in the DOM when `if` becomes false, which is generally results
	           * in better performance.
	           */
	          restamp: {
	            type: Boolean,
	            observer: '__debounceRender'
	          }

	        };
	      }
	    }]);

	    function DomIf() {
	      classCallCheck(this, DomIf);

	      var _this = possibleConstructorReturn(this, (DomIf.__proto__ || Object.getPrototypeOf(DomIf)).call(this));

	      _this.__renderDebouncer = null;
	      _this.__invalidProps = null;
	      _this.__instance = null;
	      _this._lastIf = false;
	      _this.__ctor = null;
	      return _this;
	    }

	    createClass(DomIf, [{
	      key: '__debounceRender',
	      value: function __debounceRender() {
	        var _this2 = this;

	        // Render is async for 2 reasons:
	        // 1. To eliminate dom creation trashing if user code thrashes `if` in the
	        //    same turn. This was more common in 1.x where a compound computed
	        //    property could result in the result changing multiple times, but is
	        //    mitigated to a large extent by batched property processing in 2.x.
	        // 2. To avoid double object propagation when a bag including values bound
	        //    to the `if` property as well as one or more hostProps could enqueue
	        //    the <dom-if> to flush before the <template>'s host property
	        //    forwarding. In that scenario creating an instance would result in
	        //    the host props being set once, and then the enqueued changes on the
	        //    template would set properties a second time, potentially causing an
	        //    object to be set to an instance more than once.  Creating the
	        //    instance async from flushing data ensures this doesn't happen. If
	        //    we wanted a sync option in the future, simply having <dom-if> flush
	        //    (or clear) its template's pending host properties before creating
	        //    the instance would also avoid the problem.
	        this.__renderDebouncer = Debouncer.debounce(this.__renderDebouncer, microTask, function () {
	          return _this2.__render();
	        });
	        enqueueDebouncer(this.__renderDebouncer);
	      }

	      /**
	       * @return {void}
	       */

	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'disconnectedCallback', this).call(this);
	        if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {
	          this.__teardownInstance();
	        }
	      }

	      /**
	       * @return {void}
	       */

	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'connectedCallback', this).call(this);
	        this.style.display = 'none';
	        if (this.if) {
	          this.__debounceRender();
	        }
	      }

	      /**
	       * Forces the element to render its content. Normally rendering is
	       * asynchronous to a provoking change. This is done for efficiency so
	       * that multiple changes trigger only a single render. The render method
	       * should be called if, for example, template rendering is required to
	       * validate application state.
	       * @return {void}
	       */

	    }, {
	      key: 'render',
	      value: function render() {
	        flush();
	      }
	    }, {
	      key: '__render',
	      value: function __render() {
	        if (this.if) {
	          if (!this.__ensureInstance()) {
	            // No template found yet
	            return;
	          }
	          this._showHideChildren();
	        } else if (this.restamp) {
	          this.__teardownInstance();
	        }
	        if (!this.restamp && this.__instance) {
	          this._showHideChildren();
	        }
	        if (this.if != this._lastIf) {
	          this.dispatchEvent(new CustomEvent('dom-change', {
	            bubbles: true,
	            composed: true
	          }));
	          this._lastIf = this.if;
	        }
	      }
	    }, {
	      key: '__ensureInstance',
	      value: function __ensureInstance() {
	        var _this3 = this;

	        var parentNode = this.parentNode;
	        // Guard against element being detached while render was queued
	        if (parentNode) {
	          if (!this.__ctor) {
	            var template = /** @type {HTMLTemplateElement} */this.querySelector('template');
	            if (!template) {
	              // Wait until childList changes and template should be there by then
	              var observer = new MutationObserver(function () {
	                if (_this3.querySelector('template')) {
	                  observer.disconnect();
	                  _this3.__render();
	                } else {
	                  throw new Error('dom-if requires a <template> child');
	                }
	              });
	              observer.observe(this, { childList: true });
	              return false;
	            }
	            this.__ctor = templatize(template, this, {
	              // dom-if templatizer instances require `mutable: true`, as
	              // `__syncHostProperties` relies on that behavior to sync objects
	              mutableData: true,
	              /**
	               * @param {string} prop Property to forward
	               * @param {*} value Value of property
	               * @this {this}
	               */
	              forwardHostProp: function (prop, value) {
	                if (this.__instance) {
	                  if (this.if) {
	                    this.__instance.forwardHostProp(prop, value);
	                  } else {
	                    // If we have an instance but are squelching host property
	                    // forwarding due to if being false, note the invalidated
	                    // properties so `__syncHostProperties` can sync them the next
	                    // time `if` becomes true
	                    this.__invalidProps = this.__invalidProps || Object.create(null);
	                    this.__invalidProps[root(prop)] = true;
	                  }
	                }
	              }
	            });
	          }
	          if (!this.__instance) {
	            this.__instance = new this.__ctor();
	            parentNode.insertBefore(this.__instance.root, this);
	          } else {
	            this.__syncHostProperties();
	            var c$ = this.__instance.children;
	            if (c$ && c$.length) {
	              // Detect case where dom-if was re-attached in new position
	              var lastChild = this.previousSibling;
	              if (lastChild !== c$[c$.length - 1]) {
	                for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
	                  parentNode.insertBefore(n, this);
	                }
	              }
	            }
	          }
	        }
	        return true;
	      }
	    }, {
	      key: '__syncHostProperties',
	      value: function __syncHostProperties() {
	        var props = this.__invalidProps;
	        if (props) {
	          for (var prop in props) {
	            this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
	          }
	          this.__invalidProps = null;
	          this.__instance._flushProperties();
	        }
	      }
	    }, {
	      key: '__teardownInstance',
	      value: function __teardownInstance() {
	        if (this.__instance) {
	          var c$ = this.__instance.children;
	          if (c$ && c$.length) {
	            // use first child parent, for case when dom-if may have been detached
	            var parent = c$[0].parentNode;
	            for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
	              parent.removeChild(n);
	            }
	          }
	          this.__instance = null;
	          this.__invalidProps = null;
	        }
	      }

	      /**
	       * Shows or hides the template instance top level child elements. For
	       * text nodes, `textContent` is removed while "hidden" and replaced when
	       * "shown."
	       * @return {void}
	       * @protected
	       */

	    }, {
	      key: '_showHideChildren',
	      value: function _showHideChildren() {
	        var hidden = this.__hideTemplateChildren__ || !this.if;
	        if (this.__instance) {
	          this.__instance._showHideChildren(hidden);
	        }
	      }
	    }]);
	    return DomIf;
	  }(PolymerElement);

	  customElements.define(DomIf.is, DomIf);

	  var $_documentContainer = document.createElement('div');
	  $_documentContainer.setAttribute('style', 'display: none;');

	  $_documentContainer.innerHTML = '<dom-module id="tt-button-style">\n  <template>\n    <style>\n      ::slotted(*) {\n        -webkit-user-select: none;\n        user-select: none;\n      }\n\n      :host {\n        position: relative;\n        display: block;\n        margin-left: auto;\n        margin-right: auto;\n        padding-left: 14px;\n        padding-right: 14px;\n        box-sizing: border-box;\n        font-size: 18px;\n        text-align: center;\n        text-decoration: none;\n        line-height: 2.55555556;\n        border-radius: 5px;\n        color: rgba(0,0,0,1);\n        background-color: rgba(244,245,246,1);\n        border-color: rgba(216,216,216,1);\n        -webkit-tap-highlight-color: transparent;\n        -webkit-user-select: none;\n        user-select: none;\n      }\n\n      :host([ hidden ]) {\n        display: none !important;\n      }\n\n      :host:after {\n        content: " ";\n        width: 200%;\n        height: 200%;\n        position: absolute;\n        top: 0;\n        left: 0;\n        border: 1px solid rgba(0, 0, 0, 0.2);\n        -webkit-transform: scale(0.5) translateZ(0);\n        transform: scale(0.5) translateZ(0);\n        -webkit-transform-origin: 0 0;\n        transform-origin: 0 0;\n        box-sizing: border-box;\n        border-radius: 10px;\n      }\n\n      :host([type=primary]) {\n        color: rgba(255,255,255,1);\n        border-color: rgba(248,89,89,1);\n        background-color: rgba(248,89,89,1);\n      }\n      /*\n      :host([type=warn]) {\n        color: #FFFFFF;\n        background-color: #E64340;\n      }\n\n      host[disabled][type=default] */\n      :host([disabled]:not([type])) {\n        opacity: 0.6;\n        background-color: rgba(244,245,246,1);\n        color: rgba(0, 0, 0, 0.3);\n      }\n\n      :host([disabled][type=primary]) {\n        background-color: rgba(252,192,193,1);\n        color: rgba(255,255,255,0.4)\n      }\n\n      :host([disabled][type=warn]) {\n        background-color: #EC8B89;\n      }\n      /*\n      :host([type=primary][plain]) {\n        color: #F85959;\n        border: 1px solid #F85959;\n        background-color: transparent;\n      }\n\n      :host([type=primary][plain][disabled]) {\n        color: rgba(0, 0, 0, 0.2);\n        border-color: rgba(0, 0, 0, 0.2);\n      }\n\n      :host([type=primary][plain]):after {\n        border-width: 0;\n      }\n\n      :host([type=default][plain]) {\n        color: rgba(0,0,0,1);\n        border: 1px solid rgba(216,216,216,1);\n        background-color: transparent;\n      }\n\n      :host([type=default][plain][disabled]) {\n        color: rgba(0, 0, 0, 0.2);\n        border-color: rgba(0, 0, 0, 0.2);\n      }\n\n\n      :host([type=default][plain]):after {\n        border-width: 0;\n      }\n\n      :host([plain]) {\n        color: #353535;\n        border: 1px solid #353535;\n        background-color: transparent;\n      }\n\n      :host([plain][disabled]) {\n        color: rgba(0, 0, 0, 0.2);\n        border-color: rgba(0, 0, 0, 0.2);\n      }\n\n      :host([plain]):after {\n        border-width: 0;\n      }\n\n      :host([type=warn][plain]) {\n        color: #e64340;\n        border: 1px solid #e64340;\n        background-color: transparent;\n      }\n\n      :host([type=warn][plain][disabled]) {\n        color: rgba(0, 0, 0, 0.2);\n        border-color: rgba(0, 0, 0, 0.2);\n      }\n\n      :host([type=warn][plain]):after {\n        border-width: 0;\n      }\n      */\n      :host([size=mini]) {\n        display: inline-block;\n        line-height: 2.3;\n        font-size: 14px;\n        padding: 0 1.34em;\n      }\n\n      :host([loading][type=primary]) {\n        color: rgba(255, 255, 255, 0.6);\n        background-color: rgba(222,79,79,1);\n      }\n      /*\n      :host([loading][type=primary][plain]) {\n        color: #1aad19;\n        background-color: transparent;\n      }\n      */\n\n      :host([loading][type=default]) {\n        color: rgba(34,34,34,0.6);\n        background-color: rgba(219,220,220,1);\n        border-color: rgba(216,216,216,1);\n      }\n      /*\n      :host([loading][type=default][plain]) {\n        color: #353535;\n        background-color: transparent;\n      }\n\n      :host([loading][type=warn]) {\n        color: rgba(255, 255, 255, 0.6);\n        background-color: #CE3C39;\n      }\n\n      :host([loading][type=warn][plain]) {\n        color: #e64340;\n        background-color: transparent;\n      }\n      */\n      @-webkit-keyframes tt-button-loading-animate {\n        0% {\n          -webkit-transform: rotate3d(0, 0, 1, 0deg);\n          transform: rotate3d(0, 0, 1, 0deg);\n        }\n\n        100% {\n          -webkit-transform: rotate3d(0, 0, 1, 360deg);\n          transform: rotate3d(0, 0, 1, 360deg);\n        }\n      }\n\n      @keyframes tt-button-loading-animate {\n        0% {\n          -webkit-transform: rotate3d(0, 0, 1, 0deg);\n          transform: rotate3d(0, 0, 1, 0deg);\n        }\n\n        100% {\n          -webkit-transform: rotate3d(0, 0, 1, 360deg);\n          transform: rotate3d(0, 0, 1, 360deg);\n        }\n      }\n\n      :host(.button-hover) {\n        color: rgba(34,34,34,0.6);\n        background-color: rgba(219,220,220,1);\n        border-color: rgba(216,216,216,1);\n      }\n\n      /*\n      :host(.button-hover[plain]) {\n        color: rgba(53, 53, 53, 0.6);\n        border-color: rgba(53, 53, 53, 0.6);\n        background-color: transparent;\n      }\n      */\n\n      :host(.button-hover[type=primary]) {\n        color: rgba(255, 255, 255, 0.6);\n        background-color: rgba(222,79,79,1);\n      }\n\n      /*\n      :host(.button-hover[type=primary][plain]) {\n        background-color: rgba(222,79,79,1);\n      }\n      */\n\n      /*\n      :host(.button-hover[type=default][plain]) {\n        color: rgba(34,34,34,0.6);\n        background-color: rgba(219,220,220,1);\n        background-color: transparent;\n      }\n\n      :host(.button-hover[type=warn]) {\n        color: rgba(255, 255, 255, 0.6);\n        background-color: #CE3C39;\n      }\n\n      :host(.button-hover[type=warn][plain]) {\n        color: rgba(230, 67, 64, 0.6);\n        border-color: rgba(230, 67, 64, 0.6);\n        background-color: transparent;\n      }\n      */\n\n      :host([loading]) #icon {\n        display: inline-block;\n        width: 18px;\n        height: 18px;\n        vertical-align: middle;\n        -webkit-animation: tt-button-loading-animate 1s steps(12, end) infinite;\n        animation: tt-button-loading-animate 1s steps(12, end) infinite;\n        background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAAXNSR0IArs4c6QAABQ9JREFUWAntmF2IVVUUx+9k5ViJn1MWJpMoioMyZRYYFEVCWVFPvQmCpeiLr74HvYojKUSPPkovvYiiGNijVA8SxkRphR/5nVpO5fT7Xc46s+/cc+7HjPdeH1zwn33O3vus9TvrrLP3uVOpPLDOZqBvuu7Hx8efxsdLaDlagAbQQvQQuoKuocvoR3Sir6/vd9op25SAgZxDxLfRy2gQ6UdA24cbnDvnDPoaHQTeG2rLDNCyAdrP5HfRe8jjRoAzJo3HebRjjB9QgN+mbclaBgZ2HR43o3nI65plVDDnBGBZ5i2ZT4E+StvUmgID6pz30QfI4wAIYLoqp9BJ9Cu6iqxZzZq2ngfRq+hF9CjSzyNZ67H6HO0DfJy21JxYasDq/CNkdjXnmyntJvoS+SK19Ejx9zjz30L6XIQCNvwepm8X/v6mLbRS4CyzH3NVwMYj/Y++r9ChRo4Lo2Wd+J7F4Sak/3gX4skJvbMs042AfblUPHod/on24myUdtoG+Bqc7EWxDMpjHGOM0NZZITCOhpm5FcW47Xk0gqO2lyKuKzViWRrW70oUwM7fQaxDHqRm9moMBzPp+BBZ/HezwRu0e+41rL7xaSJMTryoQsv1CSzWfI3VATP6OnoMWatqDO3HsW9/RyyD3oHzSJBx3EG3eZBaDTB3NJtBgTUvNsu+XD/b0Ukjxrf4/wyZ4dB2mKzv3GqA6X0FuRqYWWEthWOoW/YFgdxIZJDNBG5BuU0GHmJE0JDZvZPP7vABsVzPd6OU6500bD5A6t2VBtC/mQQ9ibptbkY+YXdCMz0E23O0VcuBOVuFIrMOjnLHpTuOEzphxHSt/wZFHdtujFgpsOuh2fVl8w5PoV7ZEQLL5iainkdVM+VhFnia4Ysx0IP2NDEjmWb4mWBIgV2kza7SXCF6ZW4mwSbw4gCJTs8jwzHWS+BzQAiqlWb4n2wwnVi9ogd/ZEiTGeVR0+nbOR9Zx9oTqGtrcDXixB93t7MTp5Vf4ji9C0tgbjYgtMCXs/NuN9bwm0nQfHlNgc1wZNe5biRnPOiBCVgYO68NJljorsPWshpEvTJ3uZBJzTnzAzpHM7pYixezJc7M+rrWENMXTskWx7HUTpCzJfqVdAEJHBNWcNxtM6NmV2B3OdAmfkmnGWas8hMSNrK8jjv24q5Yll1/oBZmV4jJwN/TZ8Fby0pYfyh2y1JYY5ttv2tyqwEm9X6P+uUfGbZ9gTt/Kr+iQwfZk/TzIOrXSHdgivKsRq4BrvZUKt/R3kIB7R2+gUOddcTwba36LzB5zKoSvG7jqgPmjlzSTqC0ll0tNnQCGp/C+cMhWGyFvZ2+bJxXzYFCw5HfoMMoMu0N/IWO4+gS7bSNGP04CdioVd+dm8TwX2F11gjYsdfQIBJah7Y+AT/uT+NU520boGbRElD60G88UcvxWlF26a+m3rbQsse1nsElKBw71wBm4Af0G869iaaGP2t1DjKrJkQ/4VdgYS+VwTLWGNgJBNHxahS/+XSsCWlAM/8Hcmv3JlwW/eeLY/730+XJ5cqPqfiRENelrR9a1xvBMt4c2Eka4M/SrEXxcsQjNEMex3l6I/alpZQCxjyvvwBoYc0yVmNmr2UD2mwtQ8uR4AJE4KkA+/JeAdZrW7K2gMMj4C5zS5Ebio9b8MnAnqvIcNSqm5PfLdaqfW3ZlIDTCMBbl08ifxNas75YtsK68AtoTfvIrwJZtxnQ/8Dumwz8D1o3mfMxYRE2AAAAAElFTkSuQmCC) no-repeat;  background-size: 100%;\n      }\n\n      :host #mask {\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        background: rgba(255,255,255,.775);\n      }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer);

	  var _templateObject$2 = taggedTemplateLiteral(['\n      <style include="tt-button-style">\n      </style>\n      <i id="icon" if="[[loading]]"></i>\n      <slot></slot>\n      <template is="dom-if" if="[[showMask(disabled, type)]]">\n        <div id="mask"></div>\n      </template>\n    '], ['\n      <style include="tt-button-style">\n      </style>\n      <i id="icon" if="[[loading]]"></i>\n      <slot></slot>\n      <template is="dom-if" if="[[showMask(disabled, type)]]">\n        <div id="mask"></div>\n      </template>\n    ']);

	  var Button = function (_Hover) {
	    inherits(Button, _Hover);

	    function Button() {
	      classCallCheck(this, Button);
	      return possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).apply(this, arguments));
	    }

	    createClass(Button, [{
	      key: 'connectedCallback',
	      value: function connectedCallback(e) {
	        get(Button.prototype.__proto__ || Object.getPrototypeOf(Button.prototype), 'connectedCallback', this).call(this);

	        this._defaultHoverClass = 'button-hover';
	      }
	    }, {
	      key: '_onButtonTap',
	      value: function _onButtonTap() {
	        var _this2 = this;

	        if (this.disabled) {
	          return;
	        }
	        if (this.formType) {
	          if ('submit' === this.formType) {
	            this.dispatchEvent(new CustomEvent('formSubmit', {
	              bubbles: true,
	              composed: true
	            }));
	          }

	          if ('reset' === this.formType) {
	            this.dispatchEvent(new CustomEvent('formReset', {
	              bubbles: true,
	              composed: true
	            }));
	          }
	        }

	        if (!this._lock && this.openType) {
	          this._lock = true;

	          setTimeout(function () {
	            _this2._lock = false;
	          }, 1000);

	          if ('share' === this.openType) {
	            ttJSBridge.publish('tapShareButton', {
	              target: {
	                id: this.id,
	                dataset: this.$$data
	                // offsetTop: this.$$.offsetTop,
	                // offsetLeft: this.$$.offsetLeft
	              },
	              channel: this.$$data.channel
	            });
	          }
	        }
	      }
	    }, {
	      key: 'showMask',
	      value: function showMask(disabled, type) {
	        return disabled && type == 'default';
	      }
	    }, {
	      key: 'listeners',
	      get: function () {
	        return {
	          tap: '_onButtonTap'
	        };
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$2);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-button';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          type: {
	            type: String,
	            value: 'default',
	            reflectToAttribute: true
	          },
	          size: {
	            type: String,
	            value: 'default',
	            reflectToAttribute: true
	          },
	          disabled: {
	            type: Boolean,
	            reflectToAttribute: true
	          },
	          plain: {
	            type: Boolean,
	            reflectToAttribute: true
	          },
	          loading: {
	            type: Boolean,
	            reflectToAttribute: true
	          },
	          formType: {
	            type: String
	          },
	          openType: {
	            type: String,
	            value: ''
	          },
	          hoverStartTime: {
	            type: Number,
	            value: 20
	          },
	          hoverStayTime: {
	            type: Number,
	            value: 70
	          },
	          hoverClass: {
	            type: String,
	            value: 'button-hover',
	            observer: '_hoverClassChange'
	          }
	        };
	      }
	    }]);
	    return Button;
	  }(Hover(Base(PolymerElement)));

	  window.customElements.define(Button.is, Button);

	  var $_documentContainer$1 = document.createElement('div');
	  $_documentContainer$1.setAttribute('style', 'display: none;');

	  $_documentContainer$1.innerHTML = '<dom-module id="tt-icon-style">\n  <template>\n    <style>\n      :host {\n        display: inline-block;\n        font-size: 0;\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n\n      #icon {\n        font: normal normal normal 14px/1 "ttui";\n      }\n\n      #icon[class^="tt-icon-"]:before,\n      #icon[class*=" tt-icon-"]:before {\n        margin: 0;\n        box-sizing: border-box;\n      }\n\n      .tt-icon-success { color: #F95959; }\n      .tt-icon-success:before { content: "\\e613"; }\n      .tt-icon-success_no_circle { color: #F95959;}\n      .tt-icon-success_no_circle:before { content: "\\e610";}\n      .tt-icon-info { color: #CACACA; }\n      .tt-icon-info:before { content: "\\e60d"; }\n      .tt-icon-warn { color: #F5A623;}\n      .tt-icon-warn:before { content: "\\e614";}\n      .tt-icon-waiting { color: #50ABF9;}\n      .tt-icon-waiting:before { content: "\\e612";}\n      .tt-icon-clear { color: #F95959;}\n      .tt-icon-clear:before { content: "\\e615";}\n      .tt-icon-cancel { color: #222222;}\n      .tt-icon-cancel:before { content: "\\e611";}\n      .tt-icon-download { color: #222222;}\n      .tt-icon-download:before { content: "\\e60f";}\n      .tt-icon-search { color: #222222;}\n      .tt-icon-search:before { content: "\\e60e";}\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$1);

	  var _templateObject$3 = taggedTemplateLiteral(['<style include="tt-icon-style"></style><i id="icon" class$="tt-icon-[[ type ]]" style$="color: [[ color ]]; font-size: [[ size ]]px"></i>'], ['<style include="tt-icon-style"></style><i id="icon" class\\$="tt-icon-[[ type ]]" style\\$="color: [[ color ]]; font-size: [[ size ]]px"></i>']);

	  var Icon = function (_Base) {
	    inherits(Icon, _Base);

	    function Icon() {
	      classCallCheck(this, Icon);
	      return possibleConstructorReturn(this, (Icon.__proto__ || Object.getPrototypeOf(Icon)).apply(this, arguments));
	    }

	    createClass(Icon, null, [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$3);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-icon';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          type: {
	            type: String
	          },
	          color: {
	            type: String
	          },
	          size: {
	            type: Number,
	            value: 24
	          }
	        };
	      }
	    }]);
	    return Icon;
	  }(Base(PolymerElement));

	  window.customElements.define(Icon.is, Icon);

	  var _templateObject$4 = taggedTemplateLiteral(['\n      <style>\n        :host {\n          display: block;\n        }\n      </style>\n      <slot></slot>\n    '], ['\n      <style>\n        :host {\n          display: block;\n        }\n      </style>\n      <slot></slot>\n    ']);

	  var Form = function (_Base) {
	    inherits(Form, _Base);

	    function Form() {
	      classCallCheck(this, Form);
	      return possibleConstructorReturn(this, (Form.__proto__ || Object.getPrototypeOf(Form)).apply(this, arguments));
	    }

	    createClass(Form, [{
	      key: 'ready',
	      value: function ready() {
	        this.__submitHandler = this.submitHandler.bind(this);
	        this.__resetHandler = this.resetHandler.bind(this);
	      }
	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        get(Form.prototype.__proto__ || Object.getPrototypeOf(Form.prototype), 'connectedCallback', this).call(this);

	        this.addEventListener('formSubmit', this.__submitHandler);
	        this.addEventListener('formReset', this.__resetHandler);
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        get(Form.prototype.__proto__ || Object.getPrototypeOf(Form.prototype), 'disconnectedCallback', this).call(this);

	        this.removeEventListener('formSubmit', this.__submitHandler);
	        this.removeEventListener('formReset', this.__resetHandler);
	      }

	      // every components under should ipl
	      // resetFormData and getFormData func

	    }, {
	      key: 'submitHandler',
	      value: function submitHandler(e) {
	        return regeneratorRuntime.async(function submitHandler$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.t0 = this;
	                _context.t1 = {
	                  id: '',
	                  dataset: Object.assign({}, e.target.$$data),
	                  offsetLeft: e.target.offsetLeft,
	                  offsetTop: e.target.offsetTop
	                };
	                _context.next = 4;
	                return regeneratorRuntime.awrap(this.collectInput());

	              case 4:
	                _context.t2 = _context.sent;
	                _context.t3 = {
	                  target: _context.t1,
	                  value: _context.t2
	                };

	                _context.t0.triggerEvent.call(_context.t0, 'submit', _context.t3);

	              case 7:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, null, this);
	      }
	    }, {
	      key: 'resetHandler',
	      value: function resetHandler(e) {
	        var inputEls = this._dfs(this);

	        inputEls.forEach(function (input) {
	          input.resetFormData();
	        });

	        this.triggerEvent('reset', {
	          target: {
	            id: '',
	            dataset: Object.assign({}, e.target.$$data),
	            offsetLeft: e.target.offsetLeft,
	            offsetTop: e.target.offsetTop
	          }
	        });
	      }
	    }, {
	      key: '_dfs',
	      value: function _dfs(el) {
	        var _this2 = this;

	        var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	        if (!el) {
	          return result;
	        }

	        // has data behaviour
	        if (typeof el.getFormData == 'function') {
	          result.push(el);
	        }

	        if (!el.children || !el.children.length) {
	          return result;
	        }

	        Array.from(el.children).forEach(function (child) {
	          _this2._dfs(child, result);
	        });

	        return result;
	      }
	    }, {
	      key: 'collectInput',
	      value: function collectInput() {
	        var _this3 = this;

	        var inputEls, formData, _loop, i, l;

	        return regeneratorRuntime.async(function collectInput$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                // colloect all data input element by dfs
	                inputEls = this._dfs(this);
	                formData = {};

	                _loop = function _callee(i, l) {
	                  var input, name, val;
	                  return regeneratorRuntime.async(function _callee$(_context2) {
	                    while (1) {
	                      switch (_context2.prev = _context2.next) {
	                        case 0:
	                          input = inputEls[i];
	                          name = input.name;

	                          if (!name) {
	                            _context2.next = 7;
	                            break;
	                          }

	                          _context2.next = 5;
	                          return regeneratorRuntime.awrap(new Promise(function (resolve) {
	                            input.getFormData(resolve);
	                          }));

	                        case 5:
	                          val = _context2.sent;

	                          if (!formData[name]) {
	                            formData[name] = val;
	                          } else {
	                            formData[name] = [].concat(formData[name], val);
	                          }

	                        case 7:
	                        case 'end':
	                          return _context2.stop();
	                      }
	                    }
	                  }, null, _this3);
	                };

	                i = 0, l = inputEls.length;

	              case 4:
	                if (!(i < l)) {
	                  _context3.next = 10;
	                  break;
	                }

	                _context3.next = 7;
	                return regeneratorRuntime.awrap(_loop(i, l));

	              case 7:
	                i++;
	                _context3.next = 4;
	                break;

	              case 10:
	                return _context3.abrupt('return', formData);

	              case 11:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, null, this);
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$4);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-form';
	      }
	    }]);
	    return Form;
	  }(Base(PolymerElement));

	  window.customElements.define(Form.is, Form);

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  // detect native touch action support
	  var HAS_NATIVE_TA$1 = typeof document.head.style.touchAction === 'string';
	  var GESTURE_KEY = '__polymerGestures';
	  var HANDLED_OBJ = '__polymerGesturesHandled';
	  var TOUCH_ACTION = '__polymerGesturesTouchAction';
	  // radius for tap and track
	  var TAP_DISTANCE = 25;
	  var TRACK_DISTANCE = 5;
	  // number of last N track positions to keep
	  var TRACK_LENGTH = 2;

	  // Disabling "mouse" handlers for 2500ms is enough
	  var MOUSE_TIMEOUT = 2500;
	  var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
	  // an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
	  var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
	  var MOUSE_HAS_BUTTONS = function () {
	    try {
	      return new MouseEvent('test', { buttons: 1 }).buttons === 1;
	    } catch (e) {
	      return false;
	    }
	  }();

	  /**
	   * @param {string} name Possible mouse event name
	   * @return {boolean} true if mouse event, false if not
	   */
	  function isMouseEvent(name) {
	    return MOUSE_EVENTS.indexOf(name) > -1;
	  }

	  /* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
	  // check for passive event listeners
	  var SUPPORTS_PASSIVE$1 = false;
	  (function () {
	    try {
	      var opts = Object.defineProperty({}, 'passive', {
	        get: function () {
	          SUPPORTS_PASSIVE$1 = true;
	        }
	      });
	      window.addEventListener('test', null, opts);
	      window.removeEventListener('test', null, opts);
	    } catch (e) {}
	  })();

	  /**
	   * Generate settings for event listeners, dependant on `passiveTouchGestures`
	   *
	   * @param {string} eventName Event name to determine if `{passive}` option is
	   *   needed
	   * @return {{passive: boolean} | undefined} Options to use for addEventListener
	   *   and removeEventListener
	   */
	  function PASSIVE_TOUCH$1(eventName) {
	    if (isMouseEvent(eventName) || eventName === 'touchend') {
	      return;
	    }
	    if (HAS_NATIVE_TA$1 && SUPPORTS_PASSIVE$1 && passiveTouchGestures) {
	      return { passive: true };
	    } else {
	      return;
	    }
	  }

	  // Check for touch-only devices
	  var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

	  // keep track of any labels hit by the mouseCanceller
	  /** @type {!Array<!HTMLLabelElement>} */
	  var clickedLabels = [];

	  /** @type {!Object<boolean>} */
	  var labellable = {
	    'button': true,
	    'input': true,
	    'keygen': true,
	    'meter': true,
	    'output': true,
	    'textarea': true,
	    'progress': true,
	    'select': true
	  };

	  /**
	   * @param {HTMLElement} el Element to check labelling status
	   * @return {boolean} element can have labels
	   */
	  function canBeLabelled(el) {
	    return labellable[el.localName] || false;
	  }

	  /**
	   * @param {HTMLElement} el Element that may be labelled.
	   * @return {!Array<!HTMLLabelElement>} Relevant label for `el`
	   */
	  function matchingLabels(el) {
	    var labels = Array.prototype.slice.call( /** @type {HTMLInputElement} */el.labels || []);
	    // IE doesn't have `labels` and Safari doesn't populate `labels`
	    // if element is in a shadowroot.
	    // In this instance, finding the non-ancestor labels is enough,
	    // as the mouseCancellor code will handle ancstor labels
	    if (!labels.length) {
	      labels = [];
	      var root = el.getRootNode();
	      // if there is an id on `el`, check for all labels with a matching `for` attribute
	      if (el.id) {
	        var matching = root.querySelectorAll('label[for = ' + el.id + ']');
	        for (var i = 0; i < matching.length; i++) {
	          labels.push( /** @type {!HTMLLabelElement} */matching[i]);
	        }
	      }
	    }
	    return labels;
	  }

	  // touch will make synthetic mouse events
	  // `preventDefault` on touchend will cancel them,
	  // but this breaks `<input>` focus and link clicks
	  // disable mouse handlers for MOUSE_TIMEOUT ms after
	  // a touchend to ignore synthetic mouse events
	  var mouseCanceller = function (mouseEvent) {
	    // Check for sourceCapabilities, used to distinguish synthetic events
	    // if mouseEvent did not come from a device that fires touch events,
	    // it was made by a real mouse and should be counted
	    // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
	    var sc = mouseEvent.sourceCapabilities;
	    if (sc && !sc.firesTouchEvents) {
	      return;
	    }
	    // skip synthetic mouse events
	    mouseEvent[HANDLED_OBJ] = { skip: true };
	    // disable "ghost clicks"
	    if (mouseEvent.type === 'click') {
	      var clickFromLabel = false;
	      var path = mouseEvent.composedPath && mouseEvent.composedPath();
	      if (path) {
	        for (var i = 0; i < path.length; i++) {
	          if (path[i].nodeType === Node.ELEMENT_NODE) {
	            if (path[i].localName === 'label') {
	              clickedLabels.push(path[i]);
	            } else if (canBeLabelled(path[i])) {
	              var ownerLabels = matchingLabels(path[i]);
	              // check if one of the clicked labels is labelling this element
	              for (var j = 0; j < ownerLabels.length; j++) {
	                clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;
	              }
	            }
	          }
	          if (path[i] === POINTERSTATE.mouse.target) {
	            return;
	          }
	        }
	      }
	      // if one of the clicked labels was labelling the target element,
	      // this is not a ghost click
	      if (clickFromLabel) {
	        return;
	      }
	      mouseEvent.preventDefault();
	      mouseEvent.stopPropagation();
	    }
	  };

	  /**
	   * @param {boolean=} setup True to add, false to remove.
	   * @return {void}
	   */
	  function setupTeardownMouseCanceller(setup) {
	    var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
	    for (var i = 0, en; i < events.length; i++) {
	      en = events[i];
	      if (setup) {
	        // reset clickLabels array
	        clickedLabels.length = 0;
	        document.addEventListener(en, mouseCanceller, true);
	      } else {
	        document.removeEventListener(en, mouseCanceller, true);
	      }
	    }
	  }

	  function ignoreMouse(e) {
	    if (!POINTERSTATE.mouse.mouseIgnoreJob) {
	      setupTeardownMouseCanceller(true);
	    }
	    var unset = function () {
	      setupTeardownMouseCanceller();
	      POINTERSTATE.mouse.target = null;
	      POINTERSTATE.mouse.mouseIgnoreJob = null;
	    };
	    POINTERSTATE.mouse.target = e.composedPath()[0];
	    POINTERSTATE.mouse.mouseIgnoreJob = Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, timeOut.after(MOUSE_TIMEOUT), unset);
	  }

	  /**
	   * @param {MouseEvent} ev event to test for left mouse button down
	   * @return {boolean} has left mouse button down
	   */
	  function hasLeftMouseButton(ev) {
	    var type = ev.type;
	    // exit early if the event is not a mouse event
	    if (!isMouseEvent(type)) {
	      return false;
	    }
	    // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
	    // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
	    if (type === 'mousemove') {
	      // allow undefined for testing events
	      var buttons = ev.buttons === undefined ? 1 : ev.buttons;
	      if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
	        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
	      }
	      // buttons is a bitmask, check that the left button bit is set (1)
	      return Boolean(buttons & 1);
	    } else {
	      // allow undefined for testing events
	      var button = ev.button === undefined ? 0 : ev.button;
	      // ev.button is 0 in mousedown/mouseup/click for left button activation
	      return button === 0;
	    }
	  }

	  function isSyntheticClick(ev) {
	    if (ev.type === 'click') {
	      // ev.detail is 0 for HTMLElement.click in most browsers
	      if (ev.detail === 0) {
	        return true;
	      }
	      // in the worst case, check that the x/y position of the click is within
	      // the bounding box of the target of the event
	      // Thanks IE 10 >:(
	      var t = _findOriginalTarget(ev);
	      // make sure the target of the event is an element so we can use getBoundingClientRect,
	      // if not, just assume it is a synthetic click
	      if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {
	        return true;
	      }
	      var bcr = /** @type {Element} */t.getBoundingClientRect();
	      // use page x/y to account for scrolling
	      var x = ev.pageX,
	          y = ev.pageY;
	      // ev is a synthetic click if the position is outside the bounding box of the target
	      return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
	    }
	    return false;
	  }

	  var POINTERSTATE = {
	    mouse: {
	      target: null,
	      mouseIgnoreJob: null
	    },
	    touch: {
	      x: 0,
	      y: 0,
	      id: -1,
	      scrollDecided: false
	    }
	  };

	  function firstTouchAction(ev) {
	    var ta = 'auto';
	    var path = ev.composedPath && ev.composedPath();
	    if (path) {
	      for (var i = 0, n; i < path.length; i++) {
	        n = path[i];
	        if (n[TOUCH_ACTION]) {
	          ta = n[TOUCH_ACTION];
	          break;
	        }
	      }
	    }
	    return ta;
	  }

	  function trackDocument(stateObj, movefn, upfn) {
	    stateObj.movefn = movefn;
	    stateObj.upfn = upfn;
	    document.addEventListener('mousemove', movefn);
	    document.addEventListener('mouseup', upfn);
	  }

	  function untrackDocument(stateObj) {
	    document.removeEventListener('mousemove', stateObj.movefn);
	    document.removeEventListener('mouseup', stateObj.upfn);
	    stateObj.movefn = null;
	    stateObj.upfn = null;
	  }

	  // use a document-wide touchend listener to start the ghost-click prevention mechanism
	  // Use passive event listeners, if supported, to not affect scrolling performance
	  document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE$1 ? { passive: true } : false);

	  var gestures = {};
	  var recognizers = [];

	  /**
	   * Finds the element rendered on the screen at the provided coordinates.
	   *
	   * Similar to `document.elementFromPoint`, but pierces through
	   * shadow roots.
	   *
	   * @param {number} x Horizontal pixel coordinate
	   * @param {number} y Vertical pixel coordinate
	   * @return {Element} Returns the deepest shadowRoot inclusive element
	   * found at the screen position given.
	   */
	  function deepTargetFind(x, y) {
	    var node = document.elementFromPoint(x, y);
	    var next = node;
	    // this code path is only taken when native ShadowDOM is used
	    // if there is a shadowroot, it may have a node at x/y
	    // if there is not a shadowroot, exit the loop
	    while (next && next.shadowRoot && !window.ShadyDOM) {
	      // if there is a node at x/y in the shadowroot, look deeper
	      var oldNext = next;
	      next = next.shadowRoot.elementFromPoint(x, y);
	      // on Safari, elementFromPoint may return the shadowRoot host
	      if (oldNext === next) {
	        break;
	      }
	      if (next) {
	        node = next;
	      }
	    }
	    return node;
	  }

	  /**
	   * a cheaper check than ev.composedPath()[0];
	   *
	   * @private
	   * @param {Event} ev Event.
	   * @return {EventTarget} Returns the event target.
	   */
	  function _findOriginalTarget(ev) {
	    // shadowdom
	    if (ev.composedPath) {
	      var targets = /** @type {!Array<!EventTarget>} */ev.composedPath();
	      // It shouldn't be, but sometimes targets is empty (window on Safari).
	      return targets.length > 0 ? targets[0] : ev.target;
	    }
	    // shadydom
	    return ev.target;
	  }

	  /**
	   * @private
	   * @param {Event} ev Event.
	   * @return {void}
	   */
	  function _handleNative(ev) {
	    var handled = void 0;
	    var type = ev.type;
	    var node = ev.currentTarget;
	    var gobj = node[GESTURE_KEY];
	    if (!gobj) {
	      return;
	    }
	    var gs = gobj[type];
	    if (!gs) {
	      return;
	    }
	    if (!ev[HANDLED_OBJ]) {
	      ev[HANDLED_OBJ] = {};
	      if (type.slice(0, 5) === 'touch') {
	        ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign
	        var t = ev.changedTouches[0];
	        if (type === 'touchstart') {
	          // only handle the first finger
	          if (ev.touches.length === 1) {
	            POINTERSTATE.touch.id = t.identifier;
	          }
	        }
	        if (POINTERSTATE.touch.id !== t.identifier) {
	          return;
	        }
	        if (!HAS_NATIVE_TA$1) {
	          if (type === 'touchstart' || type === 'touchmove') {
	            _handleTouchAction(ev);
	          }
	        }
	      }
	    }
	    handled = ev[HANDLED_OBJ];
	    // used to ignore synthetic mouse events
	    if (handled.skip) {
	      return;
	    }
	    // reset recognizer state
	    for (var i = 0, r; i < recognizers.length; i++) {
	      r = recognizers[i];
	      if (gs[r.name] && !handled[r.name]) {
	        if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
	          r.reset();
	        }
	      }
	    }
	    // enforce gesture recognizer order
	    for (var _i = 0, _r; _i < recognizers.length; _i++) {
	      _r = recognizers[_i];
	      if (gs[_r.name] && !handled[_r.name]) {
	        handled[_r.name] = true;
	        _r[type](ev);
	      }
	    }
	  }

	  /**
	   * @private
	   * @param {TouchEvent} ev Event.
	   * @return {void}
	   */
	  function _handleTouchAction(ev) {
	    var t = ev.changedTouches[0];
	    var type = ev.type;
	    if (type === 'touchstart') {
	      POINTERSTATE.touch.x = t.clientX;
	      POINTERSTATE.touch.y = t.clientY;
	      POINTERSTATE.touch.scrollDecided = false;
	    } else if (type === 'touchmove') {
	      if (POINTERSTATE.touch.scrollDecided) {
	        return;
	      }
	      POINTERSTATE.touch.scrollDecided = true;
	      var ta = firstTouchAction(ev);
	      var _prevent = false;
	      var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
	      var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
	      if (!ev.cancelable) ; else if (ta === 'none') {
	        _prevent = true;
	      } else if (ta === 'pan-x') {
	        _prevent = dy > dx;
	      } else if (ta === 'pan-y') {
	        _prevent = dx > dy;
	      }
	      if (_prevent) {
	        ev.preventDefault();
	      } else {
	        _prevent('track');
	      }
	    }
	  }

	  /**
	   * Adds an event listener to a node for the given gesture type.
	   *
	   * @param {!Node} node Node to add listener on
	   * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
	   * @param {!function(!Event):void} handler Event listener function to call
	   * @return {boolean} Returns true if a gesture event listener was added.
	   * @this {Gestures}
	   */
	  function addListener(node, evType, handler) {
	    if (gestures[evType]) {
	      _add(node, evType, handler);
	      return true;
	    }
	    return false;
	  }

	  /**
	   * Removes an event listener from a node for the given gesture type.
	   *
	   * @param {!Node} node Node to remove listener from
	   * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
	   * @param {!function(!Event):void} handler Event listener function previously passed to
	   *  `addListener`.
	   * @return {boolean} Returns true if a gesture event listener was removed.
	   * @this {Gestures}
	   */
	  function removeListener(node, evType, handler) {
	    if (gestures[evType]) {
	      _remove(node, evType, handler);
	      return true;
	    }
	    return false;
	  }

	  /**
	   * automate the event listeners for the native events
	   *
	   * @private
	   * @param {!HTMLElement} node Node on which to add the event.
	   * @param {string} evType Event type to add.
	   * @param {function(!Event)} handler Event handler function.
	   * @return {void}
	   * @this {Gestures}
	   */
	  function _add(node, evType, handler) {
	    var recognizer = gestures[evType];
	    var deps = recognizer.deps;
	    var name = recognizer.name;
	    var gobj = node[GESTURE_KEY];
	    if (!gobj) {
	      node[GESTURE_KEY] = gobj = {};
	    }
	    for (var i = 0, dep, gd; i < deps.length; i++) {
	      dep = deps[i];
	      // don't add mouse handlers on iOS because they cause gray selection overlays
	      if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {
	        continue;
	      }
	      gd = gobj[dep];
	      if (!gd) {
	        gobj[dep] = gd = { _count: 0 };
	      }
	      if (gd._count === 0) {
	        node.addEventListener(dep, _handleNative, PASSIVE_TOUCH$1(dep));
	      }
	      gd[name] = (gd[name] || 0) + 1;
	      gd._count = (gd._count || 0) + 1;
	    }
	    node.addEventListener(evType, handler);
	    if (recognizer.touchAction) {
	      setTouchAction(node, recognizer.touchAction);
	    }
	  }

	  /**
	   * automate event listener removal for native events
	   *
	   * @private
	   * @param {!HTMLElement} node Node on which to remove the event.
	   * @param {string} evType Event type to remove.
	   * @param {function(Event?)} handler Event handler function.
	   * @return {void}
	   * @this {Gestures}
	   */
	  function _remove(node, evType, handler) {
	    var recognizer = gestures[evType];
	    var deps = recognizer.deps;
	    var name = recognizer.name;
	    var gobj = node[GESTURE_KEY];
	    if (gobj) {
	      for (var i = 0, dep, gd; i < deps.length; i++) {
	        dep = deps[i];
	        gd = gobj[dep];
	        if (gd && gd[name]) {
	          gd[name] = (gd[name] || 1) - 1;
	          gd._count = (gd._count || 1) - 1;
	          if (gd._count === 0) {
	            node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH$1(dep));
	          }
	        }
	      }
	    }
	    node.removeEventListener(evType, handler);
	  }

	  /**
	   * Registers a new gesture event recognizer for adding new custom
	   * gesture event types.
	   *
	   * @param {!GestureRecognizer} recog Gesture recognizer descriptor
	   * @return {void}
	   * @this {Gestures}
	   */
	  function register$1(recog) {
	    recognizers.push(recog);
	    for (var i = 0; i < recog.emits.length; i++) {
	      gestures[recog.emits[i]] = recog;
	    }
	  }

	  /**
	   * @private
	   * @param {string} evName Event name.
	   * @return {Object} Returns the gesture for the given event name.
	   * @this {Gestures}
	   */
	  function _findRecognizerByEvent(evName) {
	    for (var i = 0, r; i < recognizers.length; i++) {
	      r = recognizers[i];
	      for (var j = 0, n; j < r.emits.length; j++) {
	        n = r.emits[j];
	        if (n === evName) {
	          return r;
	        }
	      }
	    }
	    return null;
	  }

	  /**
	   * Sets scrolling direction on node.
	   *
	   * This value is checked on first move, thus it should be called prior to
	   * adding event listeners.
	   *
	   * @param {!Element} node Node to set touch action setting on
	   * @param {string} value Touch action value
	   * @return {void}
	   */
	  function setTouchAction(node, value) {
	    if (HAS_NATIVE_TA$1) {
	      // NOTE: add touchAction async so that events can be added in
	      // custom element constructors. Otherwise we run afoul of custom
	      // elements restriction against settings attributes (style) in the
	      // constructor.
	      microTask.run(function () {
	        node.style.touchAction = value;
	      });
	    }
	    node[TOUCH_ACTION] = value;
	  }

	  /**
	   * Dispatches an event on the `target` element of `type` with the given
	   * `detail`.
	   * @private
	   * @param {!EventTarget} target The element on which to fire an event.
	   * @param {string} type The type of event to fire.
	   * @param {!Object=} detail The detail object to populate on the event.
	   * @return {void}
	   */
	  function _fire(target, type, detail) {
	    var ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
	    ev.detail = detail;
	    target.dispatchEvent(ev);
	    // forward `preventDefault` in a clean way
	    if (ev.defaultPrevented) {
	      var preventer = detail.preventer || detail.sourceEvent;
	      if (preventer && preventer.preventDefault) {
	        preventer.preventDefault();
	      }
	    }
	  }

	  /**
	   * Prevents the dispatch and default action of the given event name.
	   *
	   * @param {string} evName Event name.
	   * @return {void}
	   * @this {Gestures}
	   */
	  function prevent(evName) {
	    var recognizer = _findRecognizerByEvent(evName);
	    if (recognizer.info) {
	      recognizer.info.prevent = true;
	    }
	  }

	  /**
	   * Reset the 2500ms timeout on processing mouse input after detecting touch input.
	   *
	   * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.
	   * This method should only be called during testing with simulated touch inputs.
	   * Calling this method in production may cause duplicate taps or other Gestures.
	   *
	   * @return {void}
	   */
	  function resetMouseCanceller() {
	    if (POINTERSTATE.mouse.mouseIgnoreJob) {
	      POINTERSTATE.mouse.mouseIgnoreJob.flush();
	    }
	  }

	  /* eslint-disable valid-jsdoc */

	  register$1({
	    name: 'downup',
	    deps: ['mousedown', 'touchstart', 'touchend'],
	    flow: {
	      start: ['mousedown', 'touchstart'],
	      end: ['mouseup', 'touchend']
	    },
	    emits: ['down', 'up'],

	    info: {
	      movefn: null,
	      upfn: null
	    },

	    /**
	     * @this {GestureRecognizer}
	     * @return {void}
	     */
	    reset: function () {
	      untrackDocument(this.info);
	    },

	    /**
	     * @this {GestureRecognizer}
	     * @param {MouseEvent} e
	     * @return {void}
	     */
	    mousedown: function (e) {
	      if (!hasLeftMouseButton(e)) {
	        return;
	      }
	      var t = _findOriginalTarget(e);
	      var self = this;
	      var movefn = function movefn(e) {
	        if (!hasLeftMouseButton(e)) {
	          self._fire('up', t, e);
	          untrackDocument(self.info);
	        }
	      };
	      var upfn = function upfn(e) {
	        if (hasLeftMouseButton(e)) {
	          self._fire('up', t, e);
	        }
	        untrackDocument(self.info);
	      };
	      trackDocument(this.info, movefn, upfn);
	      this._fire('down', t, e);
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {TouchEvent} e
	     * @return {void}
	     */
	    touchstart: function (e) {
	      this._fire('down', _findOriginalTarget(e), e.changedTouches[0], e);
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {TouchEvent} e
	     * @return {void}
	     */
	    touchend: function (e) {
	      this._fire('up', _findOriginalTarget(e), e.changedTouches[0], e);
	    },
	    /**
	     * @param {string} type
	     * @param {!EventTarget} target
	     * @param {Event} event
	     * @param {Function} preventer
	     * @return {void}
	     */
	    _fire: function (type, target, event, preventer) {
	      _fire(target, type, {
	        x: event.clientX,
	        y: event.clientY,
	        sourceEvent: event,
	        preventer: preventer,
	        prevent: function (e) {
	          return prevent(e);
	        }
	      });
	    }
	  });

	  register$1({
	    name: 'track',
	    touchAction: 'none',
	    deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
	    flow: {
	      start: ['mousedown', 'touchstart'],
	      end: ['mouseup', 'touchend']
	    },
	    emits: ['track'],

	    info: {
	      x: 0,
	      y: 0,
	      state: 'start',
	      started: false,
	      moves: [],
	      /** @this {GestureRecognizer} */
	      addMove: function (move) {
	        if (this.moves.length > TRACK_LENGTH) {
	          this.moves.shift();
	        }
	        this.moves.push(move);
	      },
	      movefn: null,
	      upfn: null,
	      prevent: false
	    },

	    /**
	     * @this {GestureRecognizer}
	     * @return {void}
	     */
	    reset: function () {
	      this.info.state = 'start';
	      this.info.started = false;
	      this.info.moves = [];
	      this.info.x = 0;
	      this.info.y = 0;
	      this.info.prevent = false;
	      untrackDocument(this.info);
	    },

	    /**
	     * @this {GestureRecognizer}
	     * @param {number} x
	     * @param {number} y
	     * @return {boolean}
	     */
	    hasMovedEnough: function (x, y) {
	      if (this.info.prevent) {
	        return false;
	      }
	      if (this.info.started) {
	        return true;
	      }
	      var dx = Math.abs(this.info.x - x);
	      var dy = Math.abs(this.info.y - y);
	      return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {MouseEvent} e
	     * @return {void}
	     */
	    mousedown: function (e) {
	      if (!hasLeftMouseButton(e)) {
	        return;
	      }
	      var t = _findOriginalTarget(e);
	      var self = this;
	      var movefn = function movefn(e) {
	        var x = e.clientX,
	            y = e.clientY;
	        if (self.hasMovedEnough(x, y)) {
	          // first move is 'start', subsequent moves are 'move', mouseup is 'end'
	          self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
	          if (self.info.state === 'start') {
	            // if and only if tracking, always prevent tap
	            prevent('tap');
	          }
	          self.info.addMove({ x: x, y: y });
	          if (!hasLeftMouseButton(e)) {
	            // always _fire "end"
	            self.info.state = 'end';
	            untrackDocument(self.info);
	          }
	          self._fire(t, e);
	          self.info.started = true;
	        }
	      };
	      var upfn = function upfn(e) {
	        if (self.info.started) {
	          movefn(e);
	        }

	        // remove the temporary listeners
	        untrackDocument(self.info);
	      };
	      // add temporary document listeners as mouse retargets
	      trackDocument(this.info, movefn, upfn);
	      this.info.x = e.clientX;
	      this.info.y = e.clientY;
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {TouchEvent} e
	     * @return {void}
	     */
	    touchstart: function (e) {
	      var ct = e.changedTouches[0];
	      this.info.x = ct.clientX;
	      this.info.y = ct.clientY;
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {TouchEvent} e
	     * @return {void}
	     */
	    touchmove: function (e) {
	      var t = _findOriginalTarget(e);
	      var ct = e.changedTouches[0];
	      var x = ct.clientX,
	          y = ct.clientY;
	      if (this.hasMovedEnough(x, y)) {
	        if (this.info.state === 'start') {
	          // if and only if tracking, always prevent tap
	          prevent('tap');
	        }
	        this.info.addMove({ x: x, y: y });
	        this._fire(t, ct);
	        this.info.state = 'track';
	        this.info.started = true;
	      }
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {TouchEvent} e
	     * @return {void}
	     */
	    touchend: function (e) {
	      var t = _findOriginalTarget(e);
	      var ct = e.changedTouches[0];
	      // only trackend if track was started and not aborted
	      if (this.info.started) {
	        // reset started state on up
	        this.info.state = 'end';
	        this.info.addMove({ x: ct.clientX, y: ct.clientY });
	        this._fire(t, ct, e);
	      }
	    },

	    /**
	     * @this {GestureRecognizer}
	     * @param {!EventTarget} target
	     * @param {Touch} touch
	     * @return {void}
	     */
	    _fire: function (target, touch) {
	      var secondlast = this.info.moves[this.info.moves.length - 2];
	      var lastmove = this.info.moves[this.info.moves.length - 1];
	      var dx = lastmove.x - this.info.x;
	      var dy = lastmove.y - this.info.y;
	      var ddx = void 0,
	          ddy = 0;
	      if (secondlast) {
	        ddx = lastmove.x - secondlast.x;
	        ddy = lastmove.y - secondlast.y;
	      }
	      _fire(target, 'track', {
	        state: this.info.state,
	        x: touch.clientX,
	        y: touch.clientY,
	        dx: dx,
	        dy: dy,
	        ddx: ddx,
	        ddy: ddy,
	        sourceEvent: touch,
	        hover: function () {
	          return deepTargetFind(touch.clientX, touch.clientY);
	        }
	      });
	    }

	  });

	  register$1({
	    name: 'tap',
	    deps: ['mousedown', 'click', 'touchstart', 'touchend'],
	    flow: {
	      start: ['mousedown', 'touchstart'],
	      end: ['click', 'touchend']
	    },
	    emits: ['tap'],
	    info: {
	      x: NaN,
	      y: NaN,
	      prevent: false
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @return {void}
	     */
	    reset: function () {
	      this.info.x = NaN;
	      this.info.y = NaN;
	      this.info.prevent = false;
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {MouseEvent} e
	     * @return {void}
	     */
	    save: function (e) {
	      this.info.x = e.clientX;
	      this.info.y = e.clientY;
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {MouseEvent} e
	     * @return {void}
	     */
	    mousedown: function (e) {
	      if (hasLeftMouseButton(e)) {
	        this.save(e);
	      }
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {MouseEvent} e
	     * @return {void}
	     */
	    click: function (e) {
	      if (hasLeftMouseButton(e)) {
	        this.forward(e);
	      }
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {TouchEvent} e
	     * @return {void}
	     */
	    touchstart: function (e) {
	      this.save(e.changedTouches[0], e);
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {TouchEvent} e
	     * @return {void}
	     */
	    touchend: function (e) {
	      this.forward(e.changedTouches[0], e);
	    },
	    /**
	     * @this {GestureRecognizer}
	     * @param {Event | Touch} e
	     * @param {Event=} preventer
	     * @return {void}
	     */
	    forward: function (e, preventer) {
	      var dx = Math.abs(e.clientX - this.info.x);
	      var dy = Math.abs(e.clientY - this.info.y);
	      // find original target from `preventer` for TouchEvents, or `e` for MouseEvents
	      var t = _findOriginalTarget(preventer || e);
	      if (!t || t.disabled) {
	        return;
	      }
	      // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
	      if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
	        // prevent taps from being generated if an event has canceled them
	        if (!this.info.prevent) {
	          _fire(t, 'tap', {
	            x: e.clientX,
	            y: e.clientY,
	            sourceEvent: e,
	            preventer: preventer
	          });
	        }
	      }
	    }
	  });

	  /* eslint-enable valid-jsdoc */

	  /** @deprecated */
	  var findOriginalTarget = _findOriginalTarget;

	  /** @deprecated */
	  var add = addListener;

	  /** @deprecated */
	  var remove = removeListener;

	  var gestures$0 = /*#__PURE__*/Object.freeze({
	    gestures: gestures,
	    recognizers: recognizers,
	    deepTargetFind: deepTargetFind,
	    addListener: addListener,
	    removeListener: removeListener,
	    register: register$1,
	    setTouchAction: setTouchAction,
	    prevent: prevent,
	    resetMouseCanceller: resetMouseCanceller,
	    findOriginalTarget: findOriginalTarget,
	    add: add,
	    remove: remove
	  });

	  /**
	  @license
	  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	  Code distributed by Google as part of the polymer project is also
	  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	  */

	  var gestures$1 = gestures$0;

	  /**
	   * Element class mixin that provides API for adding Polymer's cross-platform
	   * gesture events to nodes.
	   *
	   * The API is designed to be compatible with override points implemented
	   * in `TemplateStamp` such that declarative event listeners in
	   * templates will support gesture events when this mixin is applied along with
	   * `TemplateStamp`.
	   *
	   * @mixinFunction
	   * @polymer
	   * @summary Element class mixin that provides API for adding Polymer's
	   *   cross-platform
	   * gesture events to nodes
	   */
	  var GestureEventListeners = dedupingMixin(function (superClass) {

	    /**
	     * @polymer
	     * @mixinClass
	     * @implements {Polymer_GestureEventListeners}
	     */
	    var GestureEventListeners = function (_superClass) {
	      inherits(GestureEventListeners, _superClass);

	      function GestureEventListeners() {
	        classCallCheck(this, GestureEventListeners);
	        return possibleConstructorReturn(this, (GestureEventListeners.__proto__ || Object.getPrototypeOf(GestureEventListeners)).apply(this, arguments));
	      }

	      createClass(GestureEventListeners, [{
	        key: '_addEventListenerToNode',


	        /**
	         * Add the event listener to the node if it is a gestures event.
	         *
	         * @param {!Node} node Node to add event listener to
	         * @param {string} eventName Name of event
	         * @param {function(!Event):void} handler Listener function to add
	         * @return {void}
	         */
	        value: function _addEventListenerToNode(node, eventName, handler) {
	          if (!gestures$1.addListener(node, eventName, handler)) {
	            get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_addEventListenerToNode', this).call(this, node, eventName, handler);
	          }
	        }

	        /**
	         * Remove the event listener to the node if it is a gestures event.
	         *
	         * @param {!Node} node Node to remove event listener from
	         * @param {string} eventName Name of event
	         * @param {function(!Event):void} handler Listener function to remove
	         * @return {void}
	         */

	      }, {
	        key: '_removeEventListenerFromNode',
	        value: function _removeEventListenerFromNode(node, eventName, handler) {
	          if (!gestures$1.removeListener(node, eventName, handler)) {
	            get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_removeEventListenerFromNode', this).call(this, node, eventName, handler);
	          }
	        }
	      }]);
	      return GestureEventListeners;
	    }(superClass);

	    return GestureEventListeners;
	  });

	  var $_documentContainer$2 = document.createElement('div');
	  $_documentContainer$2.setAttribute('style', 'display: none;');

	  $_documentContainer$2.innerHTML = '<dom-module id="tt-input-style">\n  <template>\n    <style>\n      :host {\n        display: block;\n        height: 1.4rem;\n        text-overflow: clip;\n        overflow: hidden;\n        white-space: nowrap;\n        font-family: PingFang SC, -apple-system, helvetica, sans-serif;;\n        min-height: 1.4rem;\n        -webkit-tap-highlight-color: transparent;\n      }\n\n      :host input {\n        position: relative;\n        min-height: 1.4rem;\n        border: none;\n        height: inherit;\n        width: 100%;\n        font-size: inherit;\n        font-weight: inherit;\n        color: inherit;\n        background: transparent;\n        display: inherit;\n        padding: 0;\n        margin: 0;\n        outline: none;\n        vertical-align: middle;\n        text-align: inherit;\n        overflow: inherit;\n        white-space: inherit;\n        text-overflow: inherit;\n        -webkit-tap-highlight-color: transparent;\n        z-index: 2;\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n\n      :host div {\n        position: relative;\n        min-height: 1.4rem;\n        text-overflow: inherit;\n        border: none;\n        height: 100%;\n        font-size: inherit;\n        font-weight: inherit;\n        font-family: PingFang SC, -apple-system, helvetica, sans-serif;;\n        color: inherit;\n        /*background: inherit;*/\n        padding: 0;\n        margin: 0;\n        outline: none;\n        text-align: inherit;\n        -webkit-tap-highlight-color: transparent;\n        padding-right: 10px;\n        white-space: nowrap;\n        overflow: hidden;\n      }\n\n      :host div.input-placeholder {\n        color: #CACACA;\n      }\n\n      :host div[type=password] div {\n        color: black;\n      }\n\n      :host div div {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        line-height: 100%;\n        height: inherit;\n        min-height: 1.4rem;\n        white-space: pre;\n        text-align: inherit;\n        overflow: hidden;\n        vertical-align: middle;\n        z-index: 1;\n      }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$2);

	  /* @polymerMixin */
	  var Data = (function (superClass) {
	    return function (_superClass) {
	      inherits(_class, _superClass);

	      function _class() {
	        classCallCheck(this, _class);
	        return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
	      }

	      createClass(_class, [{
	        key: 'getFormData',
	        value: function getFormData(fn) {
	          fn(this.value || '');
	        }
	      }, {
	        key: 'resetFormData',
	        value: function resetFormData() {
	          // will be overwritten by subClass
	        }
	      }, {
	        key: 'hasBehavior',
	        value: function hasBehavior(type) {
	          if (type == 'tt-data') {
	            return true;
	          }

	          return get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'hasBehavior', this).call(this, type);
	        }
	      }], [{
	        key: 'properties',
	        get: function () {
	          return {
	            name: {
	              type: String
	            }
	          };
	        }
	      }]);
	      return _class;
	    }(superClass);
	  });

	  var _templateObject$5 = taggedTemplateLiteral(['\n    <style include="tt-input-style">\n    </style>\n    <div id="wrapper"">\n      <input id="inputElement"\n        disabled$="[[ disabled ]]"\n        class$="input-placeholder [[ _prefixedPlaceholderClass ]]"\n        on-focus="_onFocus"\n        on-blur="_onBlur"\n        on-keyDown="_onKeyDown"\n        on-keyUp="_onKeyUp"\n        placeholder$="[[placeholder]]"\n        maxlength="[[maxlength]]"\n        type$="[[type]]"\n        value="[[value]]"\n        style="[[styles]]"\n        >\n    </div>\n'], ['\n    <style include="tt-input-style">\n    </style>\n    <div id="wrapper"">\n      <input id="inputElement"\n        disabled\\$="[[ disabled ]]"\n        class\\$="input-placeholder [[ _prefixedPlaceholderClass ]]"\n        on-focus="_onFocus"\n        on-blur="_onBlur"\n        on-keyDown="_onKeyDown"\n        on-keyUp="_onKeyUp"\n        placeholder\\$="[[placeholder]]"\n        maxlength="[[maxlength]]"\n        type\\$="[[type]]"\n        value="[[value]]"\n        style="[[styles]]"\n        >\n    </div>\n']);

	  // Web input

	  var WebInput = function (_Data) {
	    inherits(WebInput, _Data);

	    function WebInput() {
	      classCallCheck(this, WebInput);
	      return possibleConstructorReturn(this, (WebInput.__proto__ || Object.getPrototypeOf(WebInput)).apply(this, arguments));
	    }

	    createClass(WebInput, [{
	      key: 'ready',
	      value: function ready() {
	        get(WebInput.prototype.__proto__ || Object.getPrototypeOf(WebInput.prototype), 'ready', this).call(this);

	        if (typeof this.$$focus === 'undefined') {
	          this.$$focus = false;
	        }
	      }
	    }, {
	      key: 'getFormData',
	      value: function getFormData(fn) {
	        'function' == typeof fn && fn(this.filteredValue);
	      }
	    }, {
	      key: 'resetFormData',
	      value: function resetFormData() {
	        this.value = '';
	      }
	    }, {
	      key: '_event',
	      value: function _event(type) {
	        var target = {
	          id: this.id || '',
	          offsetLeft: this.offsetLeft,
	          offsetTop: this.offsetTop,
	          dataset: this.$$data
	        };

	        return {
	          type: type,
	          currentTarget: target,
	          target: target,
	          timsStamp: 0
	        };
	      }
	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        get(WebInput.prototype.__proto__ || Object.getPrototypeOf(WebInput.prototype), 'connectedCallback', this).call(this);
	        this._attached = true;
	        this.setProperty();
	        this._checkAutoFocus();
	        this.styles = this.getComputedStyleString();
	        this.$.inputElement.addEventListener('input', this._onChange.bind(this));
	      }
	    }, {
	      key: 'setProperty',
	      value: function setProperty() {
	        var isUsePassword = this.password;
	        if (isUsePassword) {
	          this.type = 'password';
	        }
	        this.$.inputElement.setAttribute('type', this.type);
	        if (this.maxlength > 0) {
	          this.$.inputElement.setAttribute('maxlength', this.maxlength);
	        }
	        if (this.type == 'number') {
	          this.$.inputElement.setAttribute('type', 'text');
	          this.$.inputElement.setAttribute('pattern', '\d*');
	        }
	      }
	    }, {
	      key: 'getComputedStyleString',
	      value: function getComputedStyleString() {
	        var style = window.getComputedStyle(this);
	        return Object.keys(style).filter(function (name) {
	          return ['fontFamily', 'fontSize', 'color', 'backgroundColor'].indexOf(name) > -1;
	        }).reduce(function (current, next) {
	          if (next && style[next]) {
	            return current + (next + ': ' + style[next] + ';');
	          } else {
	            return current;
	          }
	        }, this.style);
	      }
	    }, {
	      key: 'maxlengthChanged',
	      value: function maxlengthChanged(newValue, oldValue) {
	        this.maxlength = newValue;
	        if (newValue && newValue > 0) {
	          this.$.inputElement.setAttribute('maxlength', this.maxlength);
	        }
	        if (isNaN(newValue)) {
	          this.$.inputElement.setAttribute('maxlength', '');
	        }
	      }
	    }, {
	      key: 'defaultTypeChange',
	      value: function defaultTypeChange(newValue, oldValue) {
	        this.$.inputElement.setAttribute('pattern', '');
	      }
	    }, {
	      key: 'filterValue',
	      value: function filterValue(val, maxlength) {
	        if (!val) {
	          return '';
	        }
	        if (maxlength > 0) {
	          return val.slice(0, maxlength);
	        }
	        return val;
	      }
	    }, {
	      key: '_onChange',
	      value: function _onChange(e) {
	        e.stopPropagation();
	        var value = this.value = this.$.inputElement.value;
	        if (value.length > this.maxlength) {
	          this.value = value.slice(0, this.maxlength);
	          return;
	        }
	        this.triggerEvent('input', {
	          value: value
	        });
	      }
	    }, {
	      key: '_onKeyDown',
	      value: function _onKeyDown() {
	        var value = this.value = this.$.inputElement.value;
	        if (value.length > this.maxlength) {
	          return false;
	        }
	      }
	    }, {
	      key: '_onKeyUp',
	      value: function _onKeyUp(e) {
	        if (13 == e.keyCode) {
	          var value = this.value = this.$.inputElement.value;
	          this.triggerEvent('confirm', {
	            value: value
	          });
	          this.$.inputElement.blur();
	        }
	      }
	    }, {
	      key: '_onFocus',
	      value: function _onFocus(e) {
	        e.stopPropagation();
	        this.focus = true;
	        var value = this.value = this.$.inputElement.value;
	        this.triggerEvent('focus', {
	          value: value
	        });
	      }
	    }, {
	      key: '_onBlur',
	      value: function _onBlur(e) {
	        e.stopPropagation();
	        this.focus = false;
	        var value = this.value = this.$.inputElement.value;
	        this.triggerEvent('blur', {
	          value: value
	        });
	      }
	    }, {
	      key: '_checkPlaceholderStyle',
	      value: function _checkPlaceholderStyle() {
	        var $input = this.$.inputElement;
	        $input.classList.remove('input-placeholder');
	      }
	    }, {
	      key: '_checkAutoFocus',
	      value: function _checkAutoFocus() {
	        if (this.autoFocus || this.focus) {
	          this._couldFocus(true);
	        }
	      }
	    }, {
	      key: '_couldFocus',
	      value: function _couldFocus(focus) {
	        if (this._attached) {
	          if (focus) {
	            this.$.inputElement.focus();
	          } else {
	            this.$.inputElement.blur();
	          }
	        }
	      }
	    }, {
	      key: '_placeholderStyleChange',
	      value: function _placeholderStyleChange(newValue, oldValue) {
	        if (newValue && newValue !== oldValue) {
	          var styleArray = this.shadowRoot.querySelectorAll('style');
	          var lastStyleElm = styleArray[styleArray.length - 1];
	          if (!lastStyleElm.innerHTML) {
	            lastStyleElm.innerHTML = '';
	          }
	          lastStyleElm.innerHTML += '\ninput::placeholder: {' + newValue + '}\ninput::-webkit-input-placeholder{' + newValue + '}';
	        }
	      }
	    }, {
	      key: 'defaultValueChange',
	      value: function defaultValueChange(newValue, oldValue) {
	        newValue = newValue || '';
	        if (this.maxlength > 0) {
	          newValue = newValue.slice(0, this.maxlength);
	          this.setAttribute('value', newValue);
	        }
	        this._checkPlaceholderStyle();
	      }
	    }, {
	      key: 'destoryEvents',
	      value: function destoryEvents() {
	        this.$.inputElement.removeEventListener('input', this._onChange.bind(this));
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        get(WebInput.prototype.__proto__ || Object.getPrototypeOf(WebInput.prototype), 'disconnectedCallback', this).call(this);
	        this.destoryEvents();
	      }
	    }, {
	      key: 'focus',
	      get: function () {
	        return this.$$focus;
	      },
	      set: function (newValue) {
	        this.$$focus = this._deserializeValue(newValue, Boolean);
	        this._couldFocus(this.$$focus);
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$5);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-input';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          autoFocus: {
	            type: Boolean,
	            value: false
	          },
	          placeholder: {
	            type: String,
	            value: ''
	          },
	          placeholderStyle: {
	            type: String,
	            value: '',
	            observer: '_placeholderStyleChange'
	          },
	          placeholderClass: {
	            type: String,
	            value: ''
	          },
	          dropdownStyle: {
	            type: Object,
	            value: {}
	          },
	          value: {
	            type: String,
	            default: '',
	            observer: 'defaultValueChange',
	            reflectToAttribute: true
	          },
	          filteredValue: {
	            type: String,
	            computed: 'filterValue(value, maxlength)'
	          },
	          showValue: {
	            type: String,
	            value: ''
	          },
	          maxlength: {
	            type: Number,
	            value: 140,
	            reflectToAttribute: true,
	            observer: 'maxlengthChanged'
	          },
	          type: {
	            type: String,
	            value: 'text',
	            observer: 'defaultTypeChange'
	          },
	          password: {
	            type: Boolean,
	            value: false
	          },
	          disabled: {
	            type: Boolean,
	            value: false
	          },
	          cursorSpacing: {
	            type: Number,
	            value: 0
	          },
	          cursor: {
	            type: null,
	            value: -1
	          },
	          style: {
	            type: String,
	            defaultValue: ''
	          }
	        };
	      }
	    }]);
	    return WebInput;
	  }(Data(GestureEventListeners(Base(PolymerElement))));

	  window.customElements.define(WebInput.is, WebInput);

	  var _templateObject$6 = taggedTemplateLiteral(['\n    <style>\n      :host {\n        width: 300px;\n        height: 150px;\n        display: block;\n        position: relative;\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n      div {\n        word-break: break-all;\n        line-height: 1.2;\n        font-family: inherit;\n        position: absolute;\n        font-family: inherit;\n      }\n      .textarea-placeholder {\n        color: grey;\n        width: 100%;\n        padding: 0;\n        background-color: transparent;\n        resize: none;\n        outline: none;\n        border: none;\n        z-index: 2;\n        position: absolute;\n        font-family: inherit;\n      }\n      .compute {\n        color: transparent;\n        top: 0;\n        z-index: 0;\n      }\n    </style>\n    <div id="wrapper">\n      <textarea id="textarea"\n        class$="textarea-placeholder [[ _prefixedPlaceholderClass ]]"\n        value="[[ value ]]"\n        style="[[ styles ]]"\n        placeholder="[[placeholder]]"\n        disabled="[[ disabled ]]"\n      ></textarea>\n      <div id="compute" class="compute"></div>\n    </div>\n    '], ['\n    <style>\n      :host {\n        width: 300px;\n        height: 150px;\n        display: block;\n        position: relative;\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n      div {\n        word-break: break-all;\n        line-height: 1.2;\n        font-family: inherit;\n        position: absolute;\n        font-family: inherit;\n      }\n      .textarea-placeholder {\n        color: grey;\n        width: 100%;\n        padding: 0;\n        background-color: transparent;\n        resize: none;\n        outline: none;\n        border: none;\n        z-index: 2;\n        position: absolute;\n        font-family: inherit;\n      }\n      .compute {\n        color: transparent;\n        top: 0;\n        z-index: 0;\n      }\n    </style>\n    <div id="wrapper">\n      <textarea id="textarea"\n        class\\$="textarea-placeholder [[ _prefixedPlaceholderClass ]]"\n        value="[[ value ]]"\n        style="[[ styles ]]"\n        placeholder="[[placeholder]]"\n        disabled="[[ disabled ]]"\n      ></textarea>\n      <div id="compute" class="compute"></div>\n    </div>\n    ']);

	  var Textarea = function (_Base) {
	    inherits(Textarea, _Base);

	    function Textarea() {
	      classCallCheck(this, Textarea);
	      return possibleConstructorReturn(this, (Textarea.__proto__ || Object.getPrototypeOf(Textarea)).apply(this, arguments));
	    }

	    createClass(Textarea, [{
	      key: 'ready',
	      value: function ready() {
	        get(Textarea.prototype.__proto__ || Object.getPrototypeOf(Textarea.prototype), 'ready', this).call(this);

	        if (typeof this.$$focus === 'undefined') {
	          this.$$focus = false;
	        }
	      }
	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        get(Textarea.prototype.__proto__ || Object.getPrototypeOf(Textarea.prototype), 'connectedCallback', this).call(this);
	        this.tttextarea = this.$.textarea;
	        this.__scale = 750 / window.innerWidth;
	        this.lineCount = 0;
	        this._attached = true;
	        this.checkRows(this.value), this.styles = this.getComputedStyleString();
	        document.addEventListener('pageReRender', this.__updateTextArea.bind(this));
	        this.tttextarea.addEventListener('input', this.__onInput.bind(this));
	        this.tttextarea.addEventListener('focus', this.__onFocus.bind(this));
	        this.tttextarea.addEventListener('blur', this.__onBlur.bind(this));
	      }
	    }, {
	      key: 'getComputedStyleString',
	      value: function getComputedStyleString() {
	        var style = window.getComputedStyle(this);
	        return Object.keys(style).filter(function (name) {
	          return ['fontFamily', 'fontSize', 'color', 'backgroundColor'].indexOf(name) > -1;
	        }).reduce(function (current, next) {
	          if (next && style[next]) {
	            return current + (next + ': ' + style[next] + ';');
	          } else {
	            return current;
	          }
	        }, this.style);
	      }
	    }, {
	      key: 'defaultValueChange',
	      value: function defaultValueChange(value) {
	        if (this.safeMaxlength > 0 && value.length > this.safeMaxlength) {
	          value = value.slice(0, this.safeMaxlength);
	        }
	        if (this._attached) {
	          this.tttextarea.value = value;
	        }

	        this._attached && this.checkRows(value);
	      }
	    }, {
	      key: 'checkPlaceholderStyle',
	      value: function checkPlaceholderStyle(e) {
	        e ? this.$.placeholder.style.display = 'none' : (this._getComputePlaceholderStyle(), this.$.placeholder.style.display = '');
	      }
	    }, {
	      key: 'getComputedStyle',
	      value: function getComputedStyle() {
	        var that = this;
	        window.requestAnimationFrame(function () {
	          var style = window.getComputedStyle(that),
	              rect = that.getBoundingClientRect(),
	              landscapeBorder = ['Left', 'Right'].map(function (name) {
	            return parseFloat(style['border' + name + 'Width']) + parseFloat(style['padding' + name]);
	          }),
	              portraitBorder = ['Top', 'Bottom'].map(function (name) {
	            return parseFloat(style['border' + name + 'Width']) + parseFloat(style['padding' + name]);
	          }),
	              r = that.tttextarea;
	          r.style.width = rect.width - landscapeBorder[0] - landscapeBorder[1] + 'px', r.style.height = rect.height - portraitBorder[0] - portraitBorder[1] + 'px', r.style.fontWeight = style.fontWeight, r.style.fontSize = style.fontSize || '16px', r.style.color = style.color, r.style.lineHeight = Math.max(1.2 * parseFloat(style.fontSize), parseFloat(style.lineHeight)) + 'px', r.style.textAlign = style.textAlign, that.$.compute.style.fontSize = style.fontSize || '16px', that.$.compute.style.width = r.style.width, that._styleMaxHeight = parseFloat(style.maxHeight.replace('px')), that.autoHeight && that._lineHeight && that._lineHeight > that._styleMaxHeight && (that.style.maxHeight = that._lineHeight + 'px'), that.disabled ? r.setAttribute('disabled', !0) : r.removeAttribute('disabled');
	        });
	      }
	    }, {
	      key: 'autoHeightChanged',
	      value: function autoHeightChanged(autoHeightVal) {
	        var that = this;
	        autoHeightVal && this.getCurrentRows(this.value, function (styles) {
	          var realHeight = styles.height < styles.lineHeight ? styles.lineHeight : styles.height;
	          that.tttextarea.style.height = realHeight + 'px', that.getComputedStyle();
	        });
	      }
	    }, {
	      key: 'getCurrentRows',
	      value: function getCurrentRows(value, cb) {
	        var that = this;
	        window.requestAnimationFrame(function () {
	          var style = window.getComputedStyle(that.$.compute),
	              lineHeight = 1.2 * (parseFloat(style.fontSize) || 16);
	          that.$.compute.innerText = value;
	          that.$.compute.appendChild(document.createElement('br'));

	          cb({
	            height: Math.max(that.$.compute.scrollHeight, lineHeight),
	            heightRpx: that.__scale * that.$.compute.scrollHeight,
	            lineHeight: lineHeight,
	            lineCount: Math.ceil(that.$.compute.scrollHeight / lineHeight)
	          });
	        });
	      }
	    }, {
	      key: 'checkRows',
	      value: function checkRows(value) {
	        var that = this;
	        this.getCurrentRows(value, function (option) {
	          if (that.lastRows != option.lineCount) {
	            if (that.lastRows = option.lineCount, that.autoHeight) {
	              var realHeight = option.height < option.lineHeight ? option.lineHeight : option.height;
	              that._lineHeight = realHeight / (option.lineCount || 1), that.style.height = realHeight + 'px', that.getComputedStyle();
	            }
	            that.triggerEvent('linechange', value);
	          }
	        });
	      }
	    }, {
	      key: '__updateTextArea',
	      value: function __updateTextArea() {
	        this.checkAutoFocus(), this.getComputedStyle(), this.autoHeightChanged(this.autoHeight);
	      }
	    }, {
	      key: '__onInput',
	      value: function __onInput(e) {
	        e.stopPropagation();
	        var values = this.tttextarea.value;
	        this.defaultValueChange(values);
	        this.triggerEvent('input', {
	          value: values,
	          cursor: values.length
	        });
	      }
	    }, {
	      key: '__onFocus',
	      value: function __onFocus(e) {
	        e.stopPropagation();
	        var values = this.tttextarea.value;
	        this.triggerEvent('focus', {
	          value: values,
	          height: '100px' // height 键盘弹起高度, IDE 不是很好模拟，给一个固定值
	        });
	      }
	    }, {
	      key: '__onBlur',
	      value: function __onBlur(e) {
	        e.stopPropagation();
	        var values = this.tttextarea.value;
	        this.triggerEvent('blur', {
	          value: values,
	          cursor: values.length
	        });
	        this.triggerEvent('confirm', {
	          value: values
	        });
	      }
	    }, {
	      key: 'getFormData',
	      value: function getFormData(fn) {
	        'function' == typeof fn && fn(this.value);
	      }
	    }, {
	      key: '_placeholderStyleChange',
	      value: function _placeholderStyleChange(newValue, oldValue) {
	        if (newValue && newValue !== oldValue) {
	          var styleArray = this.shadowRoot.querySelectorAll('style');
	          var lastStyleElm = styleArray[styleArray.length - 1];
	          if (!lastStyleElm.innerHTML) {
	            lastStyleElm.innerHTML = '';
	          }
	          lastStyleElm.innerHTML += '\ttextarea::placeholder: {' + newValue + '}\ttextarea::-webkit-input-placeholder{' + newValue + '}';
	        }
	      }
	    }, {
	      key: 'checkAutoFocus',
	      value: function checkAutoFocus() {
	        if (this.autoFocus || this.focus) {
	          this._couldFocus(true);
	        }
	      }
	    }, {
	      key: '_couldFocus',
	      value: function _couldFocus(focus) {
	        if (this._attached) {
	          if (focus) {
	            this.tttextarea.focus();
	          } else {
	            this.tttextarea.blur();
	          }
	        }
	      }
	    }, {
	      key: '_getSafeMaxlength',
	      value: function _getSafeMaxlength(value) {
	        return this.checkNumber(value, 140);
	      }
	    }, {
	      key: 'checkNumber',
	      value: function checkNumber(num, defaultValue) {
	        if (Object.prototype.toString.call(num) === '[object Number]' && !isNaN(num)) {
	          return num;
	        }
	        return defaultValue || 0;
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        get(Textarea.prototype.__proto__ || Object.getPrototypeOf(Textarea.prototype), 'disconnectedCallback', this).call(this);
	        document.removeEventListener('pageReRender', this.__updateTextArea.bind(this));
	        this.tttextarea.removeEventListener('input', this.__onInput.bind(this));
	        this.tttextarea.removeEventListener('focus', this.__onFocus.bind(this));
	        this.tttextarea.removeEventListener('blur', this.__onBlur.bind(this));
	      }
	    }, {
	      key: 'focus',
	      get: function () {
	        return this.$$focus;
	      },
	      set: function (newValue) {
	        this.$$focus = this._deserializeValue(newValue, Boolean);
	        this._couldFocus(this.$$focus);
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$6);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-textarea';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          value: {
	            type: String,
	            value: ''
	          },
	          maxlength: {
	            type: Number,
	            value: 140
	          },
	          safeMaxlength: {
	            type: Number,
	            value: 140,
	            computed: '_getSafeMaxlength(maxlength)'
	          },
	          placeholder: {
	            type: String,
	            value: ''
	          },
	          disabled: {
	            type: Boolean,
	            value: false
	          },
	          hidden: {
	            type: Boolean,
	            value: false
	          },
	          focus: {
	            type: Boolean,
	            value: false
	          },
	          autoFocus: {
	            type: Boolean,
	            value: false
	          },
	          placeholderStyle: {
	            type: String,
	            value: '',
	            observer: '_placeholderStyleChange'
	          },
	          placeholderClass: {
	            type: String,
	            value: 'textarea-placeholder'
	          },
	          autoHeight: {
	            type: Boolean,
	            value: false,
	            observer: 'autoHeightChanged'
	          },
	          confirm: {
	            type: Boolean,
	            value: true
	          },
	          bindinput: {
	            type: String,
	            value: ''
	          },
	          bindfocus: {
	            type: String
	          },
	          bindblur: {
	            type: String
	          },
	          bindlinechange: {
	            type: String
	          },
	          bindconfirm: {
	            type: String
	          },
	          cursorSpacing: {
	            type: Number,
	            value: 0
	          },
	          cursor: {
	            type: null,
	            value: -1
	          },
	          selectionStart: {
	            type: null,
	            value: -1
	          },
	          selectionEnd: {
	            type: null,
	            value: -1
	          },
	          style: {
	            type: String,
	            defaultValue: ''
	          }
	        };
	      }
	    }]);
	    return Textarea;
	  }(Base(PolymerElement));

	  window.customElements.define(Textarea.is, Textarea);

	  var $_documentContainer$3 = document.createElement('div');
	  $_documentContainer$3.setAttribute('style', 'display: none;');

	  $_documentContainer$3.innerHTML = '<dom-module id="tt-image-style">\n  <template>\n    <style>\n      #imageWrapper {\n        height: 100%;\n        width: 100%;\n      }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$3);

	  var _templateObject$7 = taggedTemplateLiteral(['\n    <style include="tt-image-style">\n      :host {\n        width: 300px;\n        height: 225px;\n        display: inline-block;\n        overflow: hidden;\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n\n    </style>\n    <div style="background-size:100% 100%;background-repeat: no-repeat;" id="imageWrapper"></div>\n  '], ['\n    <style include="tt-image-style">\n      :host {\n        width: 300px;\n        height: 225px;\n        display: inline-block;\n        overflow: hidden;\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n\n    </style>\n    <div style="background-size:100% 100%;background-repeat: no-repeat;" id="imageWrapper"></div>\n  ']);

	  var scrollUtil = function () {
	    var e = {}; // registered images
	    var t = 0; // auto increment id

	    var debounce = function (func, wait) {
	      var ctx = void 0,
	          args = void 0,
	          output = void 0,
	          timer = null,
	          lasttick = 0;

	      var l = function () {
	        lasttick = Date.now();
	        output = func.apply(ctx, args);
	        timer = ctx = args = null;
	      };

	      return function () {

	        var currenttick = Date.now();

	        var timetowait = wait - (currenttick - lasttick);

	        ctx = this;
	        args = arguments;

	        if (timetowait <= 0 || timetowait > wait) {
	          if (timer) {
	            clearTimeout(timer);
	            timer = null;
	          }

	          lasttick = currenttick;
	          output = func.apply(ctx, args);
	          ctx = args = null;
	        } else if (!timer) {
	          timer = setTimeout(l, timetowait);
	        }

	        return output;
	      };
	    };

	    var i = function () {
	      for (var _t in e) {
	        var n = e[_t];
	        hasScrollViewParent(n) && isNodeVisible(n) && n._showImage(n._changeId);
	      }
	    };

	    var r = debounce(function () {
	      for (var _t2 in e) {
	        var n = e[_t2];
	        isNodeVisible(n) && n._showImage(n._changeId);
	      }
	    }, 200);

	    document.addEventListener('tt-scroll-view', debounce(i, 200));
	    document.addEventListener('scroll', r);

	    var _uid = function () {
	      for (var n = t++; e[n];) {
	        n = t++;
	      }
	      return n;
	    };

	    var hasScrollViewParent = function (t) {
	      var n = t.parentNode;
	      if (!n) {
	        return false;
	      }
	      if (n.tagName == 'TT-SCROLL-VIEW') {
	        return true;
	      }
	      return hasScrollViewParent(n);
	    };

	    var l = function (e, t) {
	      return !(e.left > t.right || e.top > t.bottom || t.left > e.right || t.top > e.bottom);
	    };

	    var isNodeVisible = function (e) {
	      var t = 2 * document.documentElement.clientWidth;
	      var n = 2 * document.documentElement.clientHeight;

	      return l(e.getBoundingClientRect(), {
	        top: -n,
	        right: document.documentElement.clientWidth + t,
	        bottom: document.documentElement.clientHeight + n,
	        left: -t
	      });
	    };

	    return {
	      registerInstance: function (t) {
	        if (!t._imageInstanceId) {
	          var n = t._imageInstanceId = _uid();
	          e[n] = t;
	        }
	      },
	      deregisterInstance: function (t) {
	        if (t._imageInstanceId) {
	          delete e[t._imageInstanceId];
	          t._imageInstanceId = undefined;
	        }
	      },
	      hasScrollViewParent: hasScrollViewParent,
	      isNodeVisible: isNodeVisible,
	      checkUnloadedImages: r
	    };
	  }();

	  var _Image = function (_Base) {
	    inherits(_Image, _Base);
	    createClass(_Image, null, [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$7);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-image';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          src: {
	            type: String,
	            observer: 'srcChanged'
	          },
	          mode: {
	            type: String,
	            observer: 'modeChanged'
	          },
	          backgroundSize: {
	            type: String,
	            observer: 'backgroundSizeChanged'
	          },
	          backgroundPosition: {
	            type: String,
	            observer: 'backgroundPositionChanged'
	          },
	          backgroundRepeat: {
	            type: String,
	            observer: 'backgroundRepeatChanged'
	          },
	          _disableSizePositionRepeat: {
	            type: Boolean
	          },
	          width: {
	            type: String,
	            observer: '__widthChanged'
	          },
	          height: {
	            type: String,
	            observer: '__heightChanged'
	          },
	          lazyLoad: {
	            type: Boolean,
	            observer: 'lazyLoadChanged'
	          }
	        };
	      }
	    }]);

	    function _Image() {
	      classCallCheck(this, _Image);

	      var _this = possibleConstructorReturn(this, (_Image.__proto__ || Object.getPrototypeOf(_Image)).call(this));

	      _this._attached = false;
	      _this._changeId = 0;
	      _this.__pageReRenderCallback = _this._pageReRenderCallback.bind(_this);
	      return _this;
	    }

	    createClass(_Image, [{
	      key: 'connectedCallback',
	      value: function connectedCallback(e) {
	        var _this2 = this;

	        get(_Image.prototype.__proto__ || Object.getPrototypeOf(_Image.prototype), 'connectedCallback', this).call(this);

	        this._attached = true;
	        this._originalHeight = this.style.height || '';

	        if (this.src) {
	          setTimeout(function () {
	            return _this2._initialize(_this2.lazyLoad);
	          });
	        }
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        get(_Image.prototype.__proto__ || Object.getPrototypeOf(_Image.prototype), 'disconnectedCallback', this).call(this);

	        this._attached = false;
	        if (this.lazyLoad) {
	          scrollUtil.deregisterInstance(this);
	        }
	        document.removeEventListener('pageReRender', this.__pageReRenderCallback);
	      }
	    }, {
	      key: 'srcChanged',
	      value: function srcChanged(old, newOne) {
	        var _this3 = this;

	        if (this._attached && old !== newOne) {
	          setTimeout(function () {
	            _this3._changeId++;
	            document.removeEventListener('pageReRender', _this3.__pageReRenderCallback);
	            _this3._showImage(_this3._changeId);
	          });
	        }
	      }
	    }, {
	      key: 'modeChanged',
	      value: function modeChanged(type, oldMode) {
	        // not giving mode
	        if (!this._checkMode(type)) {
	          this._disableSizePositionRepeat = false;
	          return;
	        }

	        if (oldMode === 'widthFix') {
	          this.style.height = this._originalHeight;
	        }

	        this._disableSizePositionRepeat = true;
	        this.$.imageWrapper.style.backgroundSize = 'auto auto';
	        this.$.imageWrapper.style.backgroundPosition = '0% 0%';
	        this.$.imageWrapper.style.backgroundRepeat = 'no-repeat';

	        switch (type) {
	          case 'scaleToFill':
	            this.$.imageWrapper.style.backgroundSize = '100% 100%';
	            break;

	          case 'aspectFit':
	            this.$.imageWrapper.style.backgroundSize = 'contain';
	            this.$.imageWrapper.style.backgroundPosition = 'center center';
	            break;

	          case 'aspectFill':
	            this.$.imageWrapper.style.backgroundSize = 'cover';
	            this.$.imageWrapper.style.backgroundPosition = 'center center';
	            break;

	          case 'widthFix':
	            this.$.imageWrapper.style.backgroundSize = '100% 100%';
	            break;

	          case 'top':
	            this.$.imageWrapper.style.backgroundPosition = 'top center';
	            break;

	          case 'bottom':
	            this.$.imageWrapper.style.backgroundPosition = 'bottom center';
	            break;

	          case 'center':
	            this.$.imageWrapper.style.backgroundPosition = 'center center';
	            break;

	          case 'left':
	            this.$.imageWrapper.style.backgroundPosition = 'center left';
	            break;

	          case 'right':
	            this.$.imageWrapper.style.backgroundPosition = 'center right';
	            break;

	          case 'top left':
	            this.$.imageWrapper.style.backgroundPosition = 'top left';
	            break;

	          case 'top right':
	            this.$.imageWrapper.style.backgroundPosition = 'top right';
	            break;

	          case 'bottom left':
	            this.$.imageWrapper.style.backgroundPosition = 'bottom left';
	            break;

	          case 'bottom right':
	            this.$.imageWrapper.style.backgroundPosition = 'bottom right';
	        }
	      }
	    }, {
	      key: 'getWidth',
	      value: function getWidth() {
	        var e = this.$.imageWrapper.offsetWidth;
	        var t = window.getComputedStyle(this.$.imageWrapper);

	        return e - ((parseFloat(t.borderLeftWidth) || 0) + (parseFloat(t.borderRightWidth) || 0)) - ((parseFloat(t.paddingLeft) || 0) + (parseFloat(t.paddingRight) || 0));
	      }
	    }, {
	      key: 'backgroundSizeChanged',
	      value: function backgroundSizeChanged(e, t) {
	        if (!this._disableSizePositionRepeat) {
	          this.$.imageWrapper.style.backgroundSize = e;
	        }
	      }
	    }, {
	      key: 'backgroundPositionChanged',
	      value: function backgroundPositionChanged(e, t) {
	        if (!this._disableSizePositionRepeat) {
	          this.$.imageWrapper.style.backgroundPosition = e;
	        }
	      }
	    }, {
	      key: 'backgroundRepeatChanged',
	      value: function backgroundRepeatChanged(e, t) {
	        if (!this._disableSizePositionRepeat) {
	          this.$.imageWrapper.style.backgroundRepeat = e;
	        }
	      }
	    }, {
	      key: 'lazyLoadChanged',
	      value: function lazyLoadChanged(e, t) {
	        e !== t && t && this._initialize(e);
	      }
	    }, {
	      key: '_checkMode',
	      value: function _checkMode(mode) {
	        var modes = ['scaleToFill', 'aspectFit', 'aspectFill', 'top', 'bottom', 'center', 'left', 'right', 'top left', 'top right', 'bottom left', 'bottom right'];

	        return !!modes.filter(function (m) {
	          return m === mode;
	        }).length;
	      }
	    }, {
	      key: '_initialize',
	      value: function _initialize(lazyLoad) {
	        if (!lazyLoad || scrollUtil.isNodeVisible(this)) {
	          this._showImage(this._changeId);
	        } else {
	          scrollUtil.registerInstance(this);
	        }
	      }
	    }, {
	      key: '_showImage',
	      value: function _showImage(id) {
	        var _this4 = this;

	        this._getImagePath(this.src, function (src) {
	          _this4.$.imageWrapper.style.backgroundImage = 'url(\'' + src + '\')';

	          var img = new Image();

	          img.onerror = function (e) {
	            e.stopPropagation();

	            if (id === _this4._changeId) {

	              img = null;

	              _this4.triggerEvent('error', {
	                errMsg: 'GET ' + src + ' 404 (Not Found)'
	              });
	            }
	          };

	          img.onload = function (e) {
	            e.stopPropagation();

	            if (id === _this4._changeId) {

	              var radio = _this4.ratio = img.naturalWidth / img.naturalHeight;

	              if (_this4.mode === 'widthFix') {
	                _this4.style.height = _this4.getWidth() / radio + 'px';
	                _this4.triggerReRender();
	              }

	              // img = null

	              document.addEventListener('pageReRender', _this4.__pageReRenderCallback);

	              // 忘了为啥了
	              window.requestAnimationFrame(function () {
	                _this4.$.imageWrapper.style.transform = 'translateZ(0)';
	                window.requestAnimationFrame(function () {
	                  _this4.$.imageWrapper.style.transform = '';
	                });
	              });

	              _this4.triggerEvent('load', {
	                width: img.naturalWidth,
	                height: img.naturalHeight
	              });
	            }
	          };

	          scrollUtil.deregisterInstance(_this4);

	          img.src = src;
	        });
	      }
	    }, {
	      key: '_pageReRenderCallback',
	      value: function _pageReRenderCallback() {
	        if ('widthFix' === this.mode && null !== this.ratio) {
	          this.style.height = this.getWidth() / this.ratio + 'px';
	        }
	        scrollUtil.checkUnloadedImages();
	      }
	    }, {
	      key: '_getImagePath',
	      value: function _getImagePath(e, callback) {
	        var _is = is(),
	            devtool = _is.devtool;

	        var dirname_abs = this.__dirname_abs;
	        if (dirname_abs) {
	          dirname_abs = dirname_abs.slice(1, dirname_abs.lastIndexOf('.'));
	        }

	        if (null !== (null === e ? 'undefined' : _typeof$1(e)) && 'function' == typeof callback) {
	          e = e ? e.trim() : '';
	          if (e.slice(0, 2) === '//') {
	            e = 'http:' + e;
	          }
	          // 绝对地址
	          if (is(e).file || is(e).http || is(e).dataImage) {
	            callback(e);
	          } else if (is(e).ttfile) {
	            tt.getProtocolXPath(e, callback);
	          } else {
	            if (!devtool) {
	              callback(tt.getRealRoute(dirname_abs ? dirname_abs : window.__route__, e));
	            } else {
	              var dirName = window.dirName;
	              var httpPath = 'http://127.0.0.1:' + staticPort + '/static/dist/public/' + dirName + '/tmp';
	              e = tt.getRealRoute(httpPath, tt.getRealRoute(dirname_abs ? dirname_abs : window.__route__, e));
	              callback(e);
	            }
	          }
	        }
	      }
	    }, {
	      key: '__widthChanged',
	      value: function __widthChanged(val) {
	        if (val) {
	          var numberVal = Number(val);
	          if (numberVal) {
	            val += 'px';
	          }
	          this.style.width = val;
	        }
	      }
	    }, {
	      key: '__heightChanged',
	      value: function __heightChanged(val) {
	        if (val) {
	          var numberVal = Number(val);
	          if (numberVal) {
	            val += 'px';
	          }
	          this.style.height = val;
	        }
	      }
	    }]);
	    return _Image;
	  }(Base(PolymerElement));

	  window.customElements.define(_Image.is, _Image);

	  /* @polymerMixin */
	  var ClassPrefix = (function (superClass) {
	    return function (_superClass) {
	      inherits(_class, _superClass);

	      function _class() {
	        classCallCheck(this, _class);
	        return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
	      }

	      createClass(_class, [{
	        key: 'connectedCallback',
	        value: function connectedCallback() {
	          get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'connectedCallback', this).call(this);

	          this._classPrefix = '';

	          if (this.shadowRoot) {
	            var e = this.classList._prefix;
	            e && (this._classPrefix = e + '--');
	          }
	        }
	      }, {
	        key: 'getClassPrefix',
	        value: function getClassPrefix() {
	          return this._classPrefix;
	        }
	      }]);
	      return _class;
	    }(superClass);
	  });

	  /* eslint-disable */

	  var e = {
	    rules: {
	      a: 'nA',
	      abbr: 'nA',
	      b: 'nA',
	      blockquote: 'nA',
	      br: 'nA',
	      code: 'nA',
	      col: 'fA',
	      colgroup: 'fA',
	      dd: 'nA',
	      del: 'nA',
	      div: 'nA',
	      dl: 'nA',
	      dt: 'nA',
	      em: 'nA',
	      fieldset: 'nA',
	      h1: 'nA',
	      h2: 'nA',
	      h3: 'nA',
	      h4: 'nA',
	      h5: 'nA',
	      h6: 'nA',
	      hr: 'nA',
	      i: 'nA',
	      img: 'fA',
	      ins: 'nA',
	      label: 'nA',
	      legend: 'nA',
	      li: 'nA',
	      ol: 'fA',
	      p: 'nA',
	      q: 'nA',
	      span: 'nA',
	      strong: 'nA',
	      sub: 'nA',
	      sup: 'nA',
	      table: 'fA',
	      tbody: 'nA',
	      td: 'fA',
	      tfoot: 'nA',
	      th: 'fA',
	      thead: 'nA',
	      tr: 'nA',
	      ul: 'nA'
	    },
	    fA: function (t, n, i, r) {
	      var o = {
	        col: {
	          span: 'nF',
	          width: 'nF'
	        },
	        colgroup: {
	          span: 'nF',
	          width: 'nF'
	        },
	        img: {
	          alt: 'nF',
	          src: 'fL',
	          height: 'nF',
	          width: 'nF'
	        },
	        ol: {
	          start: 'nF',
	          type: 'nF'
	        },
	        table: {
	          width: 'nF'
	        },
	        td: {
	          colspan: 'nF',
	          height: 'nF',
	          rowspan: 'nF',
	          width: 'nF'
	        },
	        th: {
	          colspan: 'nF',
	          height: 'nF',
	          rowspan: 'nF',
	          width: 'nF'
	        }
	      },
	          a = o[i][t];
	      if (o.hasOwnProperty(i) && o[i].hasOwnProperty(t)) {
	        switch (a) {
	          case void 0:
	            break;

	          case 'nF':
	            r.setAttribute(t, n);
	            break;

	          default:
	            return e[a] && e[a](t, n, i, r);
	        }
	      }
	    },
	    fL: function (e, t, n, i) {
	      i.setAttribute(e, t);
	    },
	    parse: function (n, i, r) {
	      n.map(function (n) {
	        if ('object' === (void 0 === n ? 'undefined' : _typeof$1(n))) {
	          if (void 0 === n.type || 'node' === n.type || '' === n.type) {

	            if ('string' == typeof n.name && '' !== n.name) {
	              var o = n.name.toLowerCase();

	              if (e.rules.hasOwnProperty(o)) {
	                var a = e.rules[o];
	                var s = document.createElement(o);

	                if (s) {
	                  if ('object' === _typeof$1(n.attrs)) {
	                    for (var l in n.attrs) {
	                      var c = l.toLowerCase();
	                      var u = t.decodeEntities(n.attrs[l]);

	                      if ('class' === c) {
	                        var d = r ? u.replace(/\S+/g, function (e) {
	                          return r + e;
	                        }) : u;

	                        s.setAttribute('class', d);
	                      } else {
	                        'style' === c ? s.setAttribute('style', u) : 'nA' !== a && e[a] && e[a](c, u, o, s);
	                      }
	                    }
	                  }

	                  'object' === _typeof$1(n.children) && n.children instanceof Array && n.children.length && e.parse(n.children, s, r);

	                  i.appendChild(s);
	                }
	              }
	            }
	          } else {
	            'text' === n.type && 'string' == typeof n.text && '' !== n.text && i.appendChild(document.createTextNode(t.decodeEntities(n.text)));
	          }
	        }
	      });

	      return i;
	    }
	  };

	  var t = function () {
	    var e = function () {
	      var e = function () {};
	      e.prototype = Object.create(Object.prototype, {
	        constructor: {
	          value: e,
	          writable: !0,
	          configurable: !0
	        }
	      });

	      var t = function (e, t) {
	        var n = t - 30 + 1;
	        n < 0 && (n = 0);

	        return 'L' + ((e.slice(0, t).match(/(\r|\n|\r\n)/g) || []).length + 1) + ': ' + e.slice(n, t + 1);
	      };

	      e.create = function (t, n) {
	        var i = Object.create(e.prototype);
	        i._cbs = n;
	        var r = i._stateTable = {},
	            o = i._stateRecTable = {},
	            a = {},
	            s = {},
	            l = function (e, n, i, r, o) {
	          if (Object.prototype.hasOwnProperty.call(t, i)) {
	            if (o[i]) {
	              if (!o[i].overwrite) {
	                throw new Error('State "' + e + '" has multiple possible rules on symbol "' + i + '".');
	              }
	            } else {
	              o[i] = n;
	            }
	          } else if ('ALL' !== i && 'NULL' !== i && i.length > 1) {
	            if (r[i]) {
	              if (!r[i].overwrite) {
	                throw new Error('State "' + e + '" has multiple possible rules on symbol "' + i + '".');
	              }
	            } else {
	              for (var a = 0; a < i.length; a++) {
	                if ('-' === i[a + 1] && i[a + 2]) {
	                  for (var s = i.charCodeAt(a + 2), l = i.charCodeAt(a); l <= s; l++) {
	                    r[String.fromCharCode(l)] = n;
	                  }
	                  a += 2;
	                } else {
	                  r[i[a]] = n;
	                }
	              }
	            }
	          } else if (r[i]) {
	            if (!r[i].overwrite) {
	              throw new Error('State "' + e + '" has multiple possible rules on symbol "' + i + '".');
	            }
	          } else {
	            r[i] = n;
	          }
	        },
	            c = '';
	        for (c in t) {
	          for (var u = t[c], d = r[c] = {}, h = o[c] = {}, p = a[c] = {}, f = s[c] = {}, g = 0; g < u.length; g++) {
	            var v = u[g],
	                A = v.states[0];
	            A === c ? (A = v.states[1], l(c, v, A, h, f)) : l(c, v, A, d, p);
	          }
	        }
	        var _ = null,
	            w = function e(t, n, i) {
	          if (2 !== _[t]) {
	            if (1 === _[t]) {
	              throw new Error('State "' + t + '" has illegal recursive rule definition.');
	            }
	            _[t] = 1;
	            var o = n[t],
	                a = i[t];
	            for (var s in o) {
	              e(s, n, i);
	              var l = r[s];
	              for (var c in l) {
	                if (a[c]) {
	                  if (!a[c].overwrite) {
	                    throw new Error('State "' + t + '" has multiple possible rules on symbol "' + c + '".');
	                  }
	                } else {
	                  a[c] = o[s];
	                }
	              }
	            }
	            _[t] = 2;
	          }
	        };
	        _ = {};
	        for (c in a) {
	          w(c, a, r);
	        }
	        _ = {};
	        for (c in s) {
	          w(c, s, o);
	        }
	        return i;
	      }, e.prototype.parse = function (e, i, r) {
	        var o = {
	          str: i,
	          pos: 0
	        },
	            a = n(this._stateTable, this._stateRecTable, e, o, this._cbs, r);
	        if (o.str.length > o.pos) {
	          throw new Error('Unexpected character "' + o.str[o.pos] + '" in position ' + t(o.str, o.pos) + o.pos + ', near ');
	        }
	        return a;
	      };
	      var n = function e(n, i, r, o, a, s) {
	        var l = n[r],
	            c = null;
	        if (o.str.length > o.pos && (c = l[o.str[o.pos]]), !c && (o.str.length > o.pos && (c = l.ALL), !c)) {
	          if (!(c = l.NULL)) {
	            throw new Error('Unexpected character "' + o.str[o.pos] + '" in position ' + o.pos + ' (in state "' + r + '"), near ' + t(o.str, o.pos));
	          }
	          if ('NULL' === c.states[0]) {
	            return a[c.id] ? a[c.id]([], s) : {
	              r: c.id,
	              c: []
	            };
	          }
	        }
	        for (var u = function (l, c, u) {
	          var d = l.states,
	              h = [];
	          c && h.push(u);
	          for (var p = c ? 1 : 0; p < d.length; p++) {
	            var f = d[p];
	            if (Object.prototype.hasOwnProperty.call(n, f)) {
	              h.push(e(n, i, f, o, a, s));
	            } else if ('ALL' === f) {
	              h.push(o.str[o.pos]), o.pos++;
	            } else {
	              for (var g = o.str[o.pos], v = o.str.charCodeAt(o.pos), A = 0; A < f.length; A++) {
	                if ('-' === f[A + 1] && f[A + 2]) {
	                  var _ = f.charCodeAt(A),
	                      w = f.charCodeAt(A + 2);
	                  if (_ <= v && v <= w) {
	                    break;
	                  }
	                  A += 2;
	                } else if (g === f[A]) {
	                  break;
	                }
	              }
	              if (A === f.length) {
	                throw new Error('Unexpected character "' + g + '" in position ' + o.pos + ' (expect "' + f + '" in state "' + r + '"), near ' + t(o.str, o.pos));
	              }
	              h.push(g), o.pos++;
	            }
	          }
	          return a[l.id] ? a[l.id](h, s) : {
	            r: l.id,
	            c: h
	          };
	        }, d = u(c); o.str.length > o.pos && ((c = i[r][o.str[o.pos]]) || (c = i[r].ALL));) {
	          d = u(c, !0, d);
	        }
	        return d;
	      };
	      return e;
	    }();

	    var t = {
	      TAG_START: 1,
	      TAG_END: -1,
	      TEXT: 3,
	      COMMENT: 8
	    },
	        n = {
	      amp: '&',
	      gt: '>',
	      lt: '<',
	      nbsp: ' ',
	      quot: '"',
	      apos: '\''
	    },
	        i = function (e) {
	      return e.replace(/&([a-zA-Z]*?);/g, function (e, t) {
	        if (n.hasOwnProperty(t) && n[t]) {
	          return n[t];
	        }
	        if (/^#[0-9]{1,4}$/.test(t)) {
	          return String.fromCharCode(t.slice(1));
	        }
	        if (/^#x[0-9a-f]{1,4}$/i.test(t)) {
	          return String.fromCharCode('0' + t.slice(1));
	        }
	        throw new Error('HTML Entity "' + e + '" is not supported.');
	      });
	    },
	        r = function (e) {
	      switch (e) {
	        case 'area':
	        case 'base':
	        case 'basefont':
	        case 'br':
	        case 'col':
	        case 'frame':
	        case 'hr':
	        case 'img':
	        case 'input':
	        case 'keygen':
	        case 'link':
	        case 'meta':
	        case 'param':
	        case 'source':
	        case 'track':
	          return !0;

	        default:
	          return !1;
	      }
	    },
	        o = null,
	        a = function () {
	      o = e.create({
	        TEXT: [{
	          id: 'tag',
	          states: ['TEXT', 'TAG']
	        }, {
	          id: 'text',
	          states: ['TEXT', 'ALL']
	        }, {
	          id: 'tag1',
	          states: ['TAG']
	        }, {
	          id: 'text1',
	          states: ['ALL']
	        }, {
	          id: '_null',
	          states: ['NULL'],
	          overwrite: !0
	        }],
	        TAG: [{
	          id: '_blank',
	          states: ['<', 'TAG_START']
	        }],
	        TAG_END: [{
	          id: '_concat',
	          states: ['/', '>']
	        }, {
	          id: '_jump',
	          states: ['>']
	        }],
	        TAG_START: [{
	          id: 'comment',
	          states: ['!', '-', '-', 'COMMENT_CONTENT']
	        }, {
	          id: 'endTag',
	          states: ['/', 'TAG_NAME', '>']
	        }, {
	          id: 'startTag',
	          states: ['TAG_NAME', 'ATTRS', 'TAG_END']
	        }],
	        TAG_NAME: [{
	          id: '_concat',
	          states: ['TAG_NAME', '-_a-zA-Z0-9.:']
	        }, {
	          id: '_jump',
	          states: ['a-zA-Z']
	        }],
	        ATTRS: [{
	          id: '_blank',
	          states: [' \n\r\t\f', 'ATTRS']
	        }, {
	          id: '_jump',
	          states: ['ATTRS', ' \n\r\t\f']
	        }, {
	          id: 'attrs',
	          states: ['ATTR', 'ATTRS']
	        }, {
	          id: '_null',
	          states: ['NULL'],
	          overwrite: !0
	        }],
	        ATTR: [{
	          id: 'attr',
	          states: ['ATTR_NAME', 'ATTR_NAME_AFTER']
	        }],
	        ATTR_NAME: [{
	          id: '_concat',
	          states: ['ATTR_NAME', '-_a-zA-Z0-9.:$&']
	        }, {
	          id: '_jump',
	          states: ['-_a-zA-Z0-9.:$&']
	        }],
	        ATTR_NAME_AFTER: [{
	          id: '_blank',
	          states: ['=', 'ATTR_VALUE']
	        }, {
	          id: '_empty',
	          states: ['NULL']
	        }],
	        ATTR_VALUE: [{
	          id: '_blank',
	          states: ['"', 'ATTR_VALUE_INNER_1']
	        }, {
	          id: '_blank',
	          states: ['\'', 'ATTR_VALUE_INNER_2']
	        }],
	        ATTR_VALUE_INNER_1: [{
	          id: '_empty',
	          states: ['"']
	        }, {
	          id: '_concat',
	          states: ['ALL', 'ATTR_VALUE_INNER_1']
	        }],
	        ATTR_VALUE_INNER_2: [{
	          id: '_empty',
	          states: ['\'']
	        }, {
	          id: '_concat',
	          states: ['ALL', 'ATTR_VALUE_INNER_2']
	        }],
	        COMMENT_CONTENT: [{
	          id: '_concat',
	          states: ['ALL', 'COMMENT_CONTENT']
	        }, {
	          id: '_concat',
	          states: ['-', 'COMMENT_CONTENT_DASH_1']
	        }],
	        COMMENT_CONTENT_DASH_1: [{
	          id: '_concat',
	          states: ['ALL', 'COMMENT_CONTENT']
	        }, {
	          id: '_concat',
	          states: ['-', 'COMMENT_CONTENT_DASH_2']
	        }],
	        COMMENT_CONTENT_DASH_2: [{
	          id: '_concat',
	          states: ['ALL', 'COMMENT_CONTENT']
	        }, {
	          id: '_concat',
	          states: ['-', 'COMMENT_CONTENT_DASH_2']
	        }, {
	          id: '_jump',
	          states: ['>']
	        }]
	      }, {
	        _null: function () {},
	        _empty: function () {
	          return '';
	        },
	        _jump: function (e) {
	          return e[0];
	        },
	        _concat: function (e) {
	          return e[0] + e[1];
	        },
	        _blank: function (e) {
	          return e[1];
	        },
	        attr: function (e) {
	          return {
	            n: e[0],
	            v: e[1]
	          };
	        },
	        attrs: function (e) {
	          var t = e[1] || {};
	          return t[e[0].n] = e[0].v, t;
	        },
	        startTag: function (e) {
	          var n = e[0].toLowerCase();
	          return {
	            t: t.TAG_START,
	            n: n,
	            a: e[1] || {},
	            selfClose: '/>' === e[2] || r(n)
	          };
	        },
	        endTag: function (e) {
	          return {
	            t: t.TAG_END,
	            n: e[1].toLowerCase()
	          };
	        },
	        comment: function (e) {
	          return {
	            t: t.COMMENT,
	            c: e[3].slice(0, -3)
	          };
	        },
	        tag1: function (e) {
	          return [e[0]];
	        },
	        text1: function (e) {
	          return [{
	            t: t.TEXT,
	            c: e[0]
	          }];
	        },
	        tag: function (e) {
	          return e[0].push(e[1]), e[0];
	        },
	        text: function (e) {
	          var n = e[0];
	          return n[n.length - 1].t === t.TEXT ? n[n.length - 1].c += e[1] : n.push({
	            t: t.TEXT,
	            c: e[1]
	          }), n;
	        }
	      });
	    },
	        s = function (e) {
	      for (var n = {
	        children: []
	      }, i = n, r = [], o = null, a = 0; a < e.length; a++) {
	        var s = e[a];
	        if (s.t === t.TAG_START) {
	          o = {
	            name: s.n,
	            attrs: s.a,
	            children: []
	          }, i.children.push(o), s.selfClose || (r.push(i), i = o);
	        } else if (s.t === t.TAG_END) {
	          for (; s.n !== i.name;) {
	            if (!(i = r.pop())) {
	              throw new Error('No matching start tag found for "</' + s.n + '>"');
	            }
	          }
	          i = r.pop();
	        } else {
	          s.t === t.TEXT && s.c && i.children.push({
	            type: 'text',
	            text: s.c
	          });
	        }
	      }
	      return n;
	    };

	    return {
	      parse: function (e) {
	        o || a();
	        var t = o.parse('TEXT', e) || [];
	        return s(t).children;
	      },
	      decodeEntities: i
	    };
	  }();

	  var _templateObject$8 = taggedTemplateLiteral(['\n      <div id="richText"><slot></slot></div>\n    '], ['\n      <div id="richText"><slot></slot></div>\n    ']);

	  var RichText = function (_ClassPrefix) {
	    inherits(RichText, _ClassPrefix);
	    createClass(RichText, null, [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$8);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-rich-text';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          nodes: {
	            type: Object,
	            value: [],
	            observer: '_nodesObserver'
	          }
	        };
	      }
	    }]);

	    function RichText() {
	      classCallCheck(this, RichText);

	      var _this = possibleConstructorReturn(this, (RichText.__proto__ || Object.getPrototypeOf(RichText)).call(this));

	      _this._ready = false;
	      _this._cachedVal = null;
	      return _this;
	    }

	    createClass(RichText, [{
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        get(RichText.prototype.__proto__ || Object.getPrototypeOf(RichText.prototype), 'connectedCallback', this).call(this);

	        this._ready = true;

	        if (this._cachedVal) {
	          var e$$1 = this._cachedVal;
	          this._cachedVal = null;
	          this._nodesObserver(e$$1);
	        }
	      }
	    }, {
	      key: '_nodesObserver',
	      value: function _nodesObserver(nodes) {
	        if (!this._ready) {
	          this._cachedVal = nodes;
	          return;
	        }

	        if ('string' == typeof nodes) {
	          try {
	            nodes = t.parse(nodes);
	          } catch (e$$1) {
	            logger.error(e$$1);
	            return;
	          }
	        }

	        this.$.richText.innerHTML = '';

	        if (nodes && typeof nodes === 'object' && nodes instanceof Array) {
	          this.$.richText.appendChild(e.parse(nodes, document.createDocumentFragment(), this.getClassPrefix()));
	          return;
	        }

	        logger.group(new Date() + ' nodes属性只支持 String 和 Array 类型');
	        logger.warn('For developer:nodes属性只支持 String 和 Array 类型，请检查输入的值。');
	        logger.groupEnd();
	      }
	    }]);
	    return RichText;
	  }(ClassPrefix(Base(PolymerElement)));

	  window.customElements.define(RichText.is, RichText);

	  var _templateObject$9 = taggedTemplateLiteral(['\n      <style>\n        :host {\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n        }\n      </style>\n      <slot></slot>\n    '], ['\n      <style>\n        :host {\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n        }\n      </style>\n      <slot></slot>\n    ']);

	  var Label = function (_Base) {
	    inherits(Label, _Base);

	    function Label() {
	      classCallCheck(this, Label);
	      return possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).apply(this, arguments));
	    }

	    createClass(Label, [{
	      key: '_dfs',
	      value: function _dfs(parent) {
	        // 查找子节点中isLabelTarget为true的结点
	        if (parent.isLabelTarget) {
	          return parent;
	        }

	        var children = Array.from(parent.children);
	        for (var i = 0; i < children.length; i++) {
	          var target = this._dfs(children[i]);
	          if (target) {
	            return target;
	          }
	        }
	      }
	    }, {
	      key: 'onTap',
	      value: function onTap(e) {
	        var labelTarget = void 0;
	        var labelFor = this.htmlFor; // tma-html-compiler会把for输出到htmlFor
	        if (labelFor) {
	          labelTarget = this.querySelector('#' + labelFor) || document.getElementById(labelFor);
	        } else {
	          labelTarget = this._dfs(this);
	        }

	        if (labelTarget && labelTarget.handleLabelTap && e.target !== labelTarget) {
	          labelTarget.handleLabelTap(e);
	        }
	      }
	    }, {
	      key: 'listeners',
	      get: function () {
	        return {
	          tap: 'onTap'
	        };
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$9);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-label';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {};
	      }
	    }]);
	    return Label;
	  }(Base(PolymerElement));

	  window.customElements.define(Label.is, Label);

	  var _templateObject$10 = taggedTemplateLiteral(['\n      <style>\n        :host {\n          z-index: 1000;\n          position: fixed;\n          background-color: rgba(0, 0, 0, 0.6);\n        }\n\n        .tt-mask {\n          position: fixed;\n          z-index: inherit;\n          width: 100%;\n          height: 100%;\n          top: 0;\n          left: 0;\n          transition: background-color 0.3s;\n          background-color: inherit;\n        }\n\n        .tt-mask-transparent {\n          background-color: rgba(0, 0, 0, 0);\n        }\n      </style>\n      <div id="mask" class="tt-mask" style="display:none;">\n      </div>\n    '], ['\n      <style>\n        :host {\n          z-index: 1000;\n          position: fixed;\n          background-color: rgba(0, 0, 0, 0.6);\n        }\n\n        .tt-mask {\n          position: fixed;\n          z-index: inherit;\n          width: 100%;\n          height: 100%;\n          top: 0;\n          left: 0;\n          transition: background-color 0.3s;\n          background-color: inherit;\n        }\n\n        .tt-mask-transparent {\n          background-color: rgba(0, 0, 0, 0);\n        }\n      </style>\n      <div id="mask" class="tt-mask" style="display:none;">\n      </div>\n    ']);

	  var Mask = function (_Base) {
	    inherits(Mask, _Base);

	    function Mask() {
	      classCallCheck(this, Mask);
	      return possibleConstructorReturn(this, (Mask.__proto__ || Object.getPrototypeOf(Mask)).apply(this, arguments));
	    }

	    createClass(Mask, [{
	      key: 'hiddenChange',
	      value: function hiddenChange(hidden) {
	        var $mask = this.$.mask;
	        if (hidden === true) {
	          setTimeout(function () {
	            $mask.style.display = 'none';
	          }, 300);
	          $mask.classList.add('tt-mask-transparent');
	        } else {
	          $mask.style.display = 'block';
	          $mask.focus();
	          $mask.classList.remove('tt-mask-transparent');
	        }
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$10);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-mask';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          hidden: {
	            type: Boolean,
	            value: false,
	            reflectToAttribute: true,
	            observer: 'hiddenChange'
	          }
	        };
	      }
	    }]);
	    return Mask;
	  }(Base(PolymerElement));

	  window.customElements.define(Mask.is, Mask);

	  var $_documentContainer$4 = document.createElement('div');
	  $_documentContainer$4.setAttribute('style', 'display: none;');

	  $_documentContainer$4.innerHTML = '<dom-module id="tt-checkbox-style">\n  <template>\n    <style>\n        :host {\n          -webkit-tap-highlight-color: transparent;\n          display: inline-block;\n        }\n        :host([ hidden ]) {\n          display: none;\n        }\n        :host .tt-checkbox-wrapper {\n          display: -webkit-inline-flex;\n          display: inline-flex;\n          -webkit-align-items: center;\n          align-items: center;\n          vertical-align: middle;\n        }\n\n        :host .tt-checkbox-input {\n          margin-right: 5px;\n          -webkit-appearance: none;\n          appearance: none;\n          outline: 0;\n          background-color: #FFF;\n          border: 1px solid #E8E8E8;\n          border-radius: 100%;\n          width: 22px;\n          height: 22px;\n          position: relative;\n        }\n\n        :host .tt-checkbox-input.tt-checkbox-input-checked:before {\n          font: normal normal normal 14px/1 "ttui";\n          content: "\\e601";\n          font-size: 28px;\n          color: #FFFFFF;\n          position: absolute;\n          top: 50%;\n          left: 50%;\n          transform: translate(-50%, -48%) scale(0.73);\n          -webkit-transform: translate(-50%, -48%) scale(0.73);\n        }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$4);

	  /* @polymerMixin */

	  // what the f**k
	  var LabelTarget = (function (superClass) {
	    return function (_superClass) {
	      inherits(_class, _superClass);

	      function _class() {
	        classCallCheck(this, _class);
	        return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
	      }

	      createClass(_class, [{
	        key: "handleLabelTap",
	        value: function handleLabelTap(e) {}
	      }, {
	        key: "isLabelTarget",
	        get: function () {
	          return true;
	        }
	      }]);
	      return _class;
	    }(superClass);
	  });

	  /*
	  * WAWebview 中使用的是this.triggerEvent, 我们改成polymer原生的dispatchEvent
	  */

	  /* @polymerMixin */
	  var Item = (function (superClass) {
	    return function (_superClass) {
	      inherits(_class, _superClass);

	      function _class() {
	        classCallCheck(this, _class);
	        return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
	      }

	      createClass(_class, [{
	        key: 'hasBehavior',
	        value: function hasBehavior(type) {
	          if (type == 'tt-item') {
	            return true;
	          }
	          return get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'hasBehavior', this).call(this, type);
	        }
	      }, {
	        key: 'connectedCallback',
	        value: function connectedCallback() {
	          get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'connectedCallback', this).call(this);
	          this.dispatchEvent(new CustomEvent('itemAdded', {
	            detail: { item: this },
	            bubbles: true
	          }));
	        }
	      }, {
	        key: 'disconnectedCallback',
	        value: function disconnectedCallback() {
	          get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'disconnectedCallback', this).call(this);

	          if (this._relatedGroup) {
	            this._relatedGroup.dispatchEvent(new CustomEvent('itemRemoved', {
	              detail: { item: this }
	            }));
	            this._relatedGroup = null;
	          }
	        }
	      }, {
	        key: 'moved',
	        value: function moved() {
	          if (this._relatedGroup) {
	            this._relatedGroup.dispatchEvent(new CustomEvent('itemRemoved'));
	            this._relatedGroup = null;
	          }

	          this.dispatchEvent(new CustomEvent('itemAdded', {
	            detail: { item: this },
	            bubbles: true
	          }));
	        }
	      }, {
	        key: 'valueChange',
	        value: function valueChange(e, t) {
	          if (this._relatedGroup) {
	            this._relatedGroup.dispatchEvent(new CustomEvent('itemValueChanged', {
	              detail: {
	                item: this,
	                newVal: e,
	                oldVal: t
	              }
	            }));
	          }
	        }
	      }, {
	        key: 'checkedChange',
	        value: function checkedChange(newValue, oldValue) {
	          if (typeof oldValue != 'undefined' && newValue !== oldValue && this._relatedGroup) {
	            this._relatedGroup.dispatchEvent(new CustomEvent('itemCheckedChanged', {
	              detail: { item: this }
	            }));
	          }
	        }
	      }, {
	        key: 'changedByTap',
	        value: function changedByTap() {
	          if (this._relatedGroup) {
	            this._relatedGroup.dispatchEvent(new CustomEvent('itemChangedByTap'));
	          }
	        }
	      }, {
	        key: 'resetFormData',
	        value: function resetFormData() {
	          this.checked = false;
	        }
	      }], [{
	        key: 'properties',
	        get: function () {
	          return {
	            value: {
	              type: String,
	              observer: 'valueChange'
	            },
	            checked: {
	              type: Boolean,
	              value: false,
	              observer: 'checkedChange'
	            }
	          };
	        }
	      }]);
	      return _class;
	    }(superClass);
	  });

	  /* @polymerMixin */
	  var Disabled = (function (superClass) {
	    return function (_superClass) {
	      inherits(_class, _superClass);

	      function _class() {
	        classCallCheck(this, _class);
	        return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
	      }

	      createClass(_class, null, [{
	        key: "properties",
	        get: function () {
	          return {
	            disabled: {
	              type: Boolean,
	              value: false
	            }
	          };
	        }
	      }]);
	      return _class;
	    }(superClass);
	  });

	  var _templateObject$11 = taggedTemplateLiteral(['\n    <style include="tt-checkbox-style">\n    </style>\n    <div class="tt-checkbox-wrapper">\n      <div id="input" class$="tt-checkbox-input [[hasCheckedClass(checked)]] [[hasDisabledClass(disabled)]]" style$="border-color: [[judgeDisableColor(color)]];background-color: [[judgeDisableColor(checkedColor)]];">\n      </div>\n      <slot></slot>\n    </div>\n    '], ['\n    <style include="tt-checkbox-style">\n    </style>\n    <div class="tt-checkbox-wrapper">\n      <div id="input" class\\$="tt-checkbox-input [[hasCheckedClass(checked)]] [[hasDisabledClass(disabled)]]" style\\$="border-color: [[judgeDisableColor(color)]];background-color: [[judgeDisableColor(checkedColor)]];">\n      </div>\n      <slot></slot>\n    </div>\n    ']);

	  var Checkbox = function (_Disabled) {
	    inherits(Checkbox, _Disabled);

	    function Checkbox() {
	      classCallCheck(this, Checkbox);
	      return possibleConstructorReturn(this, (Checkbox.__proto__ || Object.getPrototypeOf(Checkbox)).apply(this, arguments));
	    }

	    createClass(Checkbox, [{
	      key: 'handleBoxTap',
	      value: function handleBoxTap() {
	        if (this.disabled) {
	          return;
	        }
	        this.checked = !this.checked;
	        this.changedByTap();
	      }
	    }, {
	      key: 'handleLabelTap',
	      value: function handleLabelTap() {
	        this.handleBoxTap();
	      }
	    }, {
	      key: 'hasCheckedClass',
	      value: function hasCheckedClass(checked) {
	        return checked ? 'tt-checkbox-input-checked' : '';
	      }
	    }, {
	      key: 'hasDisabledClass',
	      value: function hasDisabledClass(disabled) {
	        return disabled ? 'tt-checkbox-input-disabled' : '';
	      }
	    }, {
	      key: '_getColor',
	      value: function _getColor(checked, color) {
	        return checked ? color : '';
	      }
	    }, {
	      key: 'judgeDisableColor',
	      value: function judgeDisableColor(color) {
	        return this.disabled ? '#E8E8E8E' : color;
	      }
	    }, {
	      key: 'listeners',
	      get: function () {
	        return {
	          tap: 'handleBoxTap'
	        };
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$11);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-checkbox';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          color: {
	            type: String,
	            value: '#F85959'
	          },
	          checkedColor: {
	            type: String,
	            computed: '_getColor(checked, color)'
	          }
	        };
	      }
	    }]);
	    return Checkbox;
	  }(Disabled(Item(LabelTarget(Base(PolymerElement)))));

	  window.customElements.define(Checkbox.is, Checkbox);

	  /* @polymerMixin */
	  var Group = (function (superClass) {
	    return function (_superClass) {
	      inherits(_class, _superClass);

	      function _class() {
	        classCallCheck(this, _class);
	        return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
	      }

	      createClass(_class, [{
	        key: 'ready',
	        value: function ready() {
	          get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'ready', this).call(this);

	          this.addEventListener('itemValueChanged', this._handleItemValueChanged);
	          this.addEventListener('itemAdded', this._handleItemAdded);
	          this.addEventListener('itemCheckedChanged', this._handleItemCheckedChanged);
	          this.addEventListener('itemRemoved', this._handleItemRemoved);
	          this.addEventListener('itemChangedByTap', this._handleChangedByTap);
	        }
	      }, {
	        key: '_handleItemValueChanged',
	        value: function _handleItemValueChanged(e) {
	          this.renameItem(e.detail.item, e.detail.newVal, e.detail.oldVal);
	        }
	      }, {
	        key: '_handleItemCheckedChanged',
	        value: function _handleItemCheckedChanged(e) {
	          this.changed(e.detail.item);
	        }
	      }, {
	        key: '_handleItemAdded',
	        value: function _handleItemAdded(e) {
	          e.detail.item._relatedGroup = this;
	          this.addItem(e.detail.item);
	          return false;
	        }
	      }, {
	        key: '_handleItemRemoved',
	        value: function _handleItemRemoved(e) {
	          this.removeItem(e.detail.item);

	          return false;
	        }
	      }, {
	        key: '_handleChangedByTap',
	        value: function _handleChangedByTap() {
	          this.triggerEvent('change', {
	            value: this.value
	          });
	        }
	      }, {
	        key: 'resetFormData',
	        value: function resetFormData() {
	          if (this.hasBehavior('tt-data')) {
	            !function dfs(t) {
	              t.childNodes && Array.from(t.childNodes).forEach(function (t) {
	                if (t.hasBehavior) {
	                  if (t.hasBehavior('tt-group')) {
	                    return;
	                  }
	                  // reset all <tt-item>check
	                  if (t.hasBehavior('tt-item')) {
	                    return t.resetFormData();
	                  }
	                }
	                dfs(t);
	              });
	            }(this);
	          }
	        }

	        // methods below should be overwrited when mixin

	      }, {
	        key: 'addItem',
	        value: function addItem() {}
	      }, {
	        key: 'removeItem',
	        value: function removeItem() {}
	      }, {
	        key: 'renameItem',
	        value: function renameItem() {}
	      }, {
	        key: 'changed',
	        value: function changed() {}
	      }, {
	        key: 'hasBehavior',
	        value: function hasBehavior(type) {
	          if (type == 'tt-group') {
	            return true;
	          }

	          return get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'hasBehavior', this).call(this, type);
	        }
	      }]);
	      return _class;
	    }(superClass);
	  });

	  var _templateObject$12 = taggedTemplateLiteral(['\n      <style>\n        :host {\n          display: block;\n        }\n        :host([ hidden ]) {\n          display: none;\n        }\n      </style>\n      <slot></slot>\n    '], ['\n      <style>\n        :host {\n          display: block;\n        }\n        :host([ hidden ]) {\n          display: none;\n        }\n      </style>\n      <slot></slot>\n    ']);

	  var CheckboxGroup = function (_Group) {
	    inherits(CheckboxGroup, _Group);

	    function CheckboxGroup() {
	      classCallCheck(this, CheckboxGroup);

	      var _this = possibleConstructorReturn(this, (CheckboxGroup.__proto__ || Object.getPrototypeOf(CheckboxGroup)).call(this));

	      _this.value = [];
	      return _this;
	    }

	    createClass(CheckboxGroup, [{
	      key: 'addItem',
	      value: function addItem(e) {
	        if (e.checked) {
	          this.value.push(e.value);
	        }
	      }
	    }, {
	      key: 'removeItem',
	      value: function removeItem(e) {
	        if (e.checked) {
	          var t = this.value.indexOf(e.value);
	          t >= 0 && this.value.splice(t, 1);
	        }
	      }
	    }, {
	      key: 'renameItem',
	      value: function renameItem(e, t, n) {
	        if (e.checked) {
	          var i = this.value.indexOf(n);
	          i >= 0 && (this.value[i] = t);
	        }
	      }
	    }, {
	      key: 'changed',
	      value: function changed(e) {
	        if (e.checked) {
	          this.value.push(e.value);
	        } else {
	          var t = this.value.indexOf(e.value);
	          t >= 0 && this.value.splice(t, 1);
	        }
	      }
	    }, {
	      key: 'childItemType',
	      get: function () {
	        return 'tt-checkbox';
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$12);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-checkbox-group';
	      }
	    }]);
	    return CheckboxGroup;
	  }(Group(Data(Base(PolymerElement))));

	  window.customElements.define(CheckboxGroup.is, CheckboxGroup);

	  var $_documentContainer$5 = document.createElement('div');
	  $_documentContainer$5.setAttribute('style', 'display: none;');

	  $_documentContainer$5.innerHTML = '<dom-module id="tt-radio-style">\n  <template>\n    <style>\n      :host {\n        -webkit-tap-highlight-color: transparent;\n        display: inline-block;\n      }\n      :host([ hidden ]) {\n        display: none;\n      }\n      :host .tt-radio-wrapper {\n        display: -webkit-inline-flex;\n        display: inline-flex;\n        -webkit-align-items: center;\n                align-items: center;\n        vertical-align: middle;\n      }\n      :host .tt-radio-input {\n        -webkit-appearance: none;\n                appearance: none;\n        margin-right: 5px;\n        outline: 0;\n        border: 1px solid #E8E8E8;\n        border-radius: 50%;\n        background-color: #FFFFFF;\n        width: 22px;\n        height: 22px;\n        position: relative;\n      }\n     \n      :host .tt-radio-input.tt-radio-input-checked:before {\n        font: normal normal normal 14px/1 "ttui";\n        content: "\\e601";\n        color: #ffffff;\n        font-size: 28px;\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -48%) scale(0.73);\n        -webkit-transform: translate(-50%, -48%) scale(0.73);\n      }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$5);

	  var _templateObject$13 = taggedTemplateLiteral(['\n      <style include="tt-radio-style">\n      </style>\n      <div class="tt-radio-wrapper">\n        <div id="input" class$="tt-radio-input [[hasCheckedClass(checked)]] [[hasDisabledClass(disabled)]]" style$="background-color: [[judgeDisableColor(checkedColor)]]; border-color: [[judgeDisableColor(checkedColor)]]">\n        </div>\n        <slot></slot>\n      </div>\n    '], ['\n      <style include="tt-radio-style">\n      </style>\n      <div class="tt-radio-wrapper">\n        <div id="input" class\\$="tt-radio-input [[hasCheckedClass(checked)]] [[hasDisabledClass(disabled)]]" style\\$="background-color: [[judgeDisableColor(checkedColor)]]; border-color: [[judgeDisableColor(checkedColor)]]">\n        </div>\n        <slot></slot>\n      </div>\n    ']);

	  var Radio = function (_Disabled) {
	    inherits(Radio, _Disabled);

	    function Radio() {
	      classCallCheck(this, Radio);
	      return possibleConstructorReturn(this, (Radio.__proto__ || Object.getPrototypeOf(Radio)).apply(this, arguments));
	    }

	    createClass(Radio, [{
	      key: 'onInputTap',
	      value: function onInputTap() {
	        if (this.disabled) {
	          return;
	        }

	        if (!this.checked) {
	          this.checked = true;
	          this.changedByTap();
	        }
	      }
	    }, {
	      key: 'handleLabelTap',
	      value: function handleLabelTap() {
	        this.onInputTap();
	      }
	    }, {
	      key: 'hasCheckedClass',
	      value: function hasCheckedClass(checked) {
	        return checked ? 'tt-radio-input-checked' : '';
	      }
	    }, {
	      key: 'hasDisabledClass',
	      value: function hasDisabledClass(disabled) {
	        return disabled ? 'tt-radio-input-disabled' : '';
	      }
	    }, {
	      key: '_getColor',
	      value: function _getColor(e, t) {
	        return e ? t : '';
	      }
	    }, {
	      key: 'judgeDisableColor',
	      value: function judgeDisableColor(color) {
	        return this.disabled ? '#e8e8e8' : color;
	      }
	    }, {
	      key: 'listeners',
	      get: function () {
	        return {
	          tap: 'onInputTap'
	        };
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$13);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-radio';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          color: {
	            type: String,
	            value: '#F85959'
	          },
	          checkedColor: {
	            type: String,
	            computed: '_getColor(checked, color)'
	          }
	        };
	      }
	    }]);
	    return Radio;
	  }(Disabled(Item(LabelTarget(Base(PolymerElement)))));

	  window.customElements.define(Radio.is, Radio);

	  var _templateObject$14 = taggedTemplateLiteral(['\n    <style>\n      :host {\n        display: block;\n      }\n      :host([ hidden ]) {\n        display: none;\n      }\n    </style>\n    <slot></slot>\n    '], ['\n    <style>\n      :host {\n        display: block;\n      }\n      :host([ hidden ]) {\n        display: none;\n      }\n    </style>\n    <slot></slot>\n    ']);

	  var RadioGroup = function (_Group) {
	    inherits(RadioGroup, _Group);
	    createClass(RadioGroup, [{
	      key: 'childItemType',
	      get: function () {
	        return 'tt-radio';
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$14);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-radio-group';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        // 和小功能文档不太一致，文档写的属性只有一个bindchange, WAWebview里是value
	        return {
	          value: {
	            type: String
	          }
	        };
	      }
	    }]);

	    function RadioGroup() {
	      classCallCheck(this, RadioGroup);

	      var _this = possibleConstructorReturn(this, (RadioGroup.__proto__ || Object.getPrototypeOf(RadioGroup)).call(this));

	      _this._selectedItem = null;
	      return _this;
	    }

	    createClass(RadioGroup, [{
	      key: 'addItem',
	      value: function addItem(e) {
	        if (e.checked) {
	          if (this._selectedItem) {
	            this._selectedItem.checked = false;
	          }

	          this.value = e.value;
	          this._selectedItem = e;
	        }
	      }
	    }, {
	      key: 'removeItem',
	      value: function removeItem(e) {
	        if (this._selectedItem === e) {
	          this.value = '';
	          this._selectedItem = null;
	        }
	      }
	    }, {
	      key: 'renameItem',
	      value: function renameItem(e, t) {
	        this._selectedItem === e && (this.value = t);
	      }
	    }, {
	      key: 'changed',
	      value: function changed(e) {
	        if (this._selectedItem === e) {
	          this.removeItem(e);
	        } else {
	          this.addItem(e);
	        }
	      }
	    }]);
	    return RadioGroup;
	  }(Group(Data(Base(PolymerElement))));

	  window.customElements.define(RadioGroup.is, RadioGroup);

	  var $_documentContainer$6 = document.createElement('div');
	  $_documentContainer$6.setAttribute('style', 'display: none;');

	  $_documentContainer$6.innerHTML = '<dom-module id="tt-switch-style">\n  <template>\n    <style>\n      :host {\n        -webkit-tap-highlight-color: transparent;\n        display: inline-block;\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n\n      :host .tt-switch-wrapper {\n        display: -webkit-inline-flex;\n        display: inline-flex;\n        -webkit-align-items: center;\n                align-items: center;\n        vertical-align: middle;\n      }\n      :host .tt-switch-input {\n        -webkit-appearance: none;\n                appearance: none;\n        position: relative;\n        width: 52px;\n        height: 32px;\n        margin-right: 5px;\n        border: 1px solid #DFDFDF;\n        outline: 0;\n        border-radius: 16px;\n        box-sizing: border-box;\n        background-color: #DFDFDF;\n        transition: background-color 0.1s, border 0.1s;\n      }\n      :host .tt-switch-input .before {\n        content: " ";\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 50px;\n        height: 30px;\n        border-radius: 15px;\n        background-color: #FDFDFD;\n        transition: -webkit-transform .3s;\n        transition: transform .3s;\n        transition: transform .3s, -webkit-transform .3s;\n      }\n      :host .tt-switch-input:after {\n        content: " ";\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 30px;\n        height: 30px;\n        border-radius: 15px;\n        background-color: #FFFFFF;\n        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);\n        transition: -webkit-transform .3s;\n        transition: transform .3s;\n        transition: transform .3s, -webkit-transform .3s;\n      }\n      :host .tt-switch-input.tt-switch-input-checked {\n        border-color: #F85959;\n        background-color: #F85959;\n      }\n      :host .tt-switch-input.tt-switch-input-checked .before {\n        -webkit-transform: scale(0);\n                transform: scale(0);\n      }\n      :host .tt-switch-input.tt-switch-input-checked:after {\n        -webkit-transform: translateX(20px);\n                transform: translateX(20px);\n      }\n      :host .tt-checkbox-input {\n        margin-right: 5px;\n        -webkit-appearance: none;\n                appearance: none;\n        outline: 0;\n        border: 1px solid #D1D1D1;\n        background-color: #FFFFFF;\n        border-radius: 3px;\n        width: 22px;\n        height: 22px;\n        position: relative;\n        color: #09BB07;\n      }\n      :host .tt-checkbox-input.tt-checkbox-input-checked:before {\n        font: normal normal normal 14px/1 "ttui";\n        content: "\\e601";\n        color: inherit;\n        font-size: 28px;\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -48%) scale(0.73);\n        -webkit-transform: translate(-50%, -48%) scale(0.73);\n      }\n      :host .tt-checkbox-input.tt-checkbox-input-disabled {\n        background-color: #E1E1E1;\n      }\n      :host .tt-checkbox-input.tt-checkbox-input-disabled:before {\n        color: #ADADAD;\n      }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$6);

	  var _templateObject$15 = taggedTemplateLiteral(['\n    <style include="tt-switch-style">\n    </style>\n    <div class="tt-switch-wrapper">\n      <template is="dom-if" if="[[isSwitch]]">\n        <div id="switchInput"\n          class$="tt-switch-input [[checkedClsSwitch(checked)]] [[disabledClsSwitch(disabled)]]"\n          style$="background-color: [[color]]; border-color: [[checkedColor]]"><i class="before"/></div>\n        <slot></slot>\n      </template>\n      <template is="dom-if" if="[[!isSwitch]]">\n        <div id="checkboxInput" class$="tt-checkbox-input [[checkedClsBox(checked)]] [[disabledClsBox(disabled)]]" style$="color: [[color]]"></div>\n        <slot></slot>\n      </template>\n    </div>\n'], ['\n    <style include="tt-switch-style">\n    </style>\n    <div class="tt-switch-wrapper">\n      <template is="dom-if" if="[[isSwitch]]">\n        <div id="switchInput"\n          class\\$="tt-switch-input [[checkedClsSwitch(checked)]] [[disabledClsSwitch(disabled)]]"\n          style\\$="background-color: [[color]]; border-color: [[checkedColor]]"><i class="before"/></div>\n        <slot></slot>\n      </template>\n      <template is="dom-if" if="[[!isSwitch]]">\n        <div id="checkboxInput" class\\$="tt-checkbox-input [[checkedClsBox(checked)]] [[disabledClsBox(disabled)]]" style\\$="color: [[color]]"></div>\n        <slot></slot>\n      </template>\n    </div>\n']);

	  var Switch = function (_Data) {
	    inherits(Switch, _Data);

	    function Switch() {
	      classCallCheck(this, Switch);
	      return possibleConstructorReturn(this, (Switch.__proto__ || Object.getPrototypeOf(Switch)).apply(this, arguments));
	    }

	    createClass(Switch, [{
	      key: '_isSwitch',
	      value: function _isSwitch(e) {
	        return e !== 'checkbox';
	      }
	    }, {
	      key: '_getSwitchBorderColor',
	      value: function _getSwitchBorderColor(e, t) {
	        return e ? t : '';
	      }
	    }, {
	      key: 'handleLabelTap',
	      value: function handleLabelTap() {
	        this.onInputChange();
	      }
	    }, {
	      key: 'onInputChange',
	      value: function onInputChange(e) {
	        if (this.disabled) {
	          return;
	        }

	        this.checked = !this.checked;

	        try {
	          // ios 下有震动反馈
	          'switch' === this.type && vibrateShort();
	        } catch (e) {/* skip */}

	        this.triggerEvent('change', {
	          value: this.checked
	        });
	      }
	    }, {
	      key: 'getFormData',
	      value: function getFormData(callback) {
	        callback(this.checked);
	      }
	    }, {
	      key: 'resetFormData',
	      value: function resetFormData() {
	        this.checked = false;
	      }
	    }, {
	      key: 'checkedClsSwitch',
	      value: function checkedClsSwitch(checked) {
	        if (!this.isSwitch) {
	          return '';
	        }

	        return checked ? 'tt-switch-input-checked' : '';
	      }
	    }, {
	      key: 'disabledClsSwitch',
	      value: function disabledClsSwitch(disabled) {
	        if (!this.isSwitch) {
	          return '';
	        }

	        return disabled ? 'tt-switch-input-disabled' : '';
	      }
	    }, {
	      key: 'checkedClsBox',
	      value: function checkedClsBox(checked) {
	        if (this.isSwitch) {
	          return '';
	        }

	        return checked ? 'tt-checkbox-input-checked' : '';
	      }
	    }, {
	      key: 'disabledClsBox',
	      value: function disabledClsBox(disabled) {
	        if (this.isSwitch) {
	          return '';
	        }

	        return disabled ? 'tt-checkbox-input-disabled' : '';
	      }
	    }, {
	      key: 'listeners',
	      get: function () {
	        return {
	          tap: 'onInputChange'
	        };
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$15);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-switch';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          checked: {
	            type: Boolean,
	            value: false
	          },
	          type: {
	            type: String,
	            value: 'switch'
	          },
	          color: {
	            type: String,
	            value: '#F85959'
	          },
	          checkedColor: {
	            type: String,
	            computed: '_getSwitchBorderColor(checked, color)'
	          },
	          isSwitch: {
	            type: String,
	            computed: '_isSwitch(type)'
	          }
	        };
	      }
	    }]);
	    return Switch;
	  }(Data(Disabled(LabelTarget(Base(PolymerElement)))));

	  function vibrateShort() {
	    window.tt && window.tt.getPlatform() === 'ios' && 'function' == typeof window.tt.vibrateShort && window.tt.vibrateShort();
	  }

	  window.customElements.define(Switch.is, Switch);

	  var $_documentContainer$7 = document.createElement('div');
	  $_documentContainer$7.setAttribute('style', 'display: none;');

	  $_documentContainer$7.innerHTML = '<dom-module id="tt-slider-style">\n  <template>\n    <style>\n      :host {\n        margin: 10px 18px;\n        padding: 0;\n        display: block;\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n\n      :host * {\n        -webkit-tap-highlight-color: rgba(0,0,0,0);\n      }\n\n      :host .tt-slider-wrapper {\n        display: -webkit-flex;\n        display: flex;\n        -webkit-align-items: center;\n                align-items: center;\n        min-height: 16px;\n      }\n      :host .tt-slider-tap-area {\n        -webkit-flex: 1;\n                flex: 1;\n        padding: 8px 0;\n      }\n      :host .tt-slider-handle-wrapper {\n        position: relative;\n        height: 2px;\n        border-radius: 5px;\n        background-color: #e9e9e9;\n        cursor: pointer;\n        transition: background-color 0.3s ease;\n        -webkit-tap-highlight-color: transparent;\n      }\n      :host .tt-slider-track {\n        height: 100%;\n        border-radius: 6px;\n        background-color: #1aad19;\n        transition: background-color 0.3s ease;\n      }\n      :host .tt-slider-handle,\n      :host .tt-slider-thumb {\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        cursor: pointer;\n        border-radius: 50%;\n        transition: border-color 0.3s ease;\n      }\n      :host .tt-slider-handle {\n        width: 28px;\n        height: 28px;\n        margin-top: -14px;\n        margin-left: -14px;\n        background-color: transparent;\n        z-index: 3;\n        border: 0 solid rgba(0,0,0,0.04);\n        /*box-shadow: 0 3px 8px 0 rgba(0,0,0,0.15);*/\n      }\n      :host .tt-slider-thumb {\n        z-index: 2;\n        /*box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);*/\n        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);\n      }\n      :host .tt-slider-step {\n        position: absolute;\n        width: 100%;\n        height: 2px;\n        background: transparent;\n        z-index: 1;\n      }\n      :host .tt-slider-value {\n        color: #888;\n        font-size: 14px;\n        margin-left: 1em;\n      }\n      :host .tt-slider-disabled .tt-slider-track {\n        background-color: #ccc;\n      }\n      :host .tt-slider-disabled .tt-slider-thumb {\n        background-color: #FFF;\n        border-color: #ccc;\n      }\n      :host * {\n        margin: 0;\n      }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$7);

	  var _templateObject$16 = taggedTemplateLiteral(['\n    <style include="tt-slider-style"></style>\n\n    <div class$="tt-slider-wrapper [[disabledClass(disabled)]]">\n      <div id="wrapper" class="tt-slider-tap-area">\n        <div class="tt-slider-handle-wrapper" style$="background-color: [[_getBackgroundColor(color, backgroundColor)]];">\n          <div id="handle" class="tt-slider-handle" style$="left: [[_getValueWidth(_filteredValue, min, max)]];">\n          </div>\n          <div class="tt-slider-thumb" style$="[[_getThumbStyles(_filteredValue)]]">\n          </div>\n          <div class="tt-slider-track" style$="width: [[_getValueWidth(_filteredValue, min, max)]];background-color: [[_getActiveColor(selectedColor, activeColor)]];">\n          </div>\n          <div id="step" class="tt-slider-step"></div>\n        </div>\n      </div>\n      <template is="dom-if" if="{{showValue}}">\n        <span class="tt-slider-value">[[_filteredValue]]</span>\n      </template>\n    </div>\n'], ['\n    <style include="tt-slider-style"></style>\n\n    <div class\\$="tt-slider-wrapper [[disabledClass(disabled)]]">\n      <div id="wrapper" class="tt-slider-tap-area">\n        <div class="tt-slider-handle-wrapper" style\\$="background-color: [[_getBackgroundColor(color, backgroundColor)]];">\n          <div id="handle" class="tt-slider-handle" style\\$="left: [[_getValueWidth(_filteredValue, min, max)]];">\n          </div>\n          <div class="tt-slider-thumb" style\\$="[[_getThumbStyles(_filteredValue)]]">\n          </div>\n          <div class="tt-slider-track" style\\$="width: [[_getValueWidth(_filteredValue, min, max)]];background-color: [[_getActiveColor(selectedColor, activeColor)]];">\n          </div>\n          <div id="step" class="tt-slider-step"></div>\n        </div>\n      </div>\n      <template is="dom-if" if="{{showValue}}">\n        <span class="tt-slider-value">[[_filteredValue]]</span>\n      </template>\n    </div>\n']);

	  var Slider = function (_TouchTrack) {
	    inherits(Slider, _TouchTrack);

	    function Slider() {
	      classCallCheck(this, Slider);
	      return possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).apply(this, arguments));
	    }

	    createClass(Slider, [{
	      key: 'ready',
	      value: function ready() {
	        get(Slider.prototype.__proto__ || Object.getPrototypeOf(Slider.prototype), 'ready', this).call(this);

	        this.touchtrack(this.$.handle, '_onTrack');
	      }
	    }, {
	      key: '_filterValue',
	      value: function _filterValue(e) {
	        if (e < this.min) {
	          return this.min;
	        } else if (e > this.max) {
	          return this.max;
	        }

	        return Math.round((e - this.min) / this.step) * this.step + this.min;
	      }
	    }, {
	      key: '_revalicateRange',
	      value: function _revalicateRange() {
	        var n = this._filterValue(this.value);

	        if (e$1(this.min) || e$1(this.max) || e$1(this.step)) {

	          var i = Math.max(t$1(this.min), t$1(this.max), t$1(this.step));
	          n = +n.toFixed(i);
	        }

	        this._filteredValue = n;
	      }
	    }, {
	      key: '_getValueWidth',
	      value: function _getValueWidth(e, t, n) {
	        e = e || 0;
	        if (n == t) {
	          return e - t ? '100%' : '0%';
	        }
	        return 100 * (e - t) / (n - t) + '%';
	      }
	    }, {
	      key: '_getBlockSize',
	      value: function _getBlockSize(e) {
	        return n(e, 12, 28);
	      }
	    }, {
	      key: '_getBackgroundColor',
	      value: function _getBackgroundColor(e, t) {
	        return '#FFFFFF' !== t ? t : '#FFFFFF' !== e ? e : '#FFFFFF';
	      }
	    }, {
	      key: '_getActiveColor',
	      value: function _getActiveColor(e, t) {
	        return '#F85959' !== t ? t : '#F85959' !== e ? e : '#F85959';
	      }
	    }, {
	      key: '_getThumbStyles',
	      value: function _getThumbStyles(filteredValue) {
	        var width = this._getBlockSize(this.blockSize);
	        var height = width;
	        var marginLeft = -width / 2;
	        var marginTop = -width / 2;
	        var left = this._getValueWidth(filteredValue, this.min, this.max);
	        var backgroundColor = this.blockColor;

	        return 'width: ' + width + 'px;height: ' + height + 'px;margin-left: ' + marginLeft + 'px;margin-top: ' + marginTop + 'px;left: ' + left + ';background-color: ' + backgroundColor + ';';
	      }
	    }, {
	      key: '_onUserChangedValue',
	      value: function _onUserChangedValue(e) {
	        var t = this.$.step.offsetWidth;
	        var n = this.$.step.getBoundingClientRect().left;
	        var i = (e.detail.x - n) * (this.max - this.min) / t + this.min;

	        i = this._filterValue(i);
	        this.value = i;
	      }
	    }, {
	      key: '_onTrack',
	      value: function _onTrack(e) {
	        if (!this.disabled) {
	          if ('move' === e.detail.state) {
	            e.preventDefault();
	            this._onUserChangedValue(e);
	            this.triggerEvent('changing', {
	              value: this.value
	            });
	            return false;
	          }

	          if ('end' === e.detail.state) {
	            this.triggerEvent('change', {
	              value: this.value
	            });
	          }
	        }
	      }
	    }, {
	      key: '_onTap',
	      value: function _onTap(e) {
	        if (!this.disabled) {
	          this._onUserChangedValue(e);
	          this.triggerEvent('change', {
	            value: this.value
	          });
	        }
	      }
	    }, {
	      key: 'resetFormData',
	      value: function resetFormData() {
	        this.value = this.min;
	      }
	    }, {
	      key: 'disabledClass',
	      value: function disabledClass(disabled) {
	        return disabled ? 'tt-slider-disabled' : '';
	      }
	    }, {
	      key: 'listeners',
	      get: function () {
	        return {
	          'wrapper.tap': '_onTap'
	        };
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$16);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-slider';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          min: {
	            type: Number,
	            value: 0,
	            observer: '_revalicateRange'
	          },
	          max: {
	            type: Number,
	            value: 100,
	            observer: '_revalicateRange'
	          },
	          step: {
	            type: Number,
	            value: 1
	          },
	          value: {
	            type: Number,
	            value: 0,
	            observer: '_revalicateRange'
	          },
	          showValue: {
	            type: Boolean,
	            value: false
	          },
	          activeColor: {
	            type: String,
	            value: '#F85959'
	          },
	          backgroundColor: {
	            type: String,
	            value: '#E8E8E8'
	          },
	          blockSize: {
	            type: Number,
	            value: 28
	          },
	          blockColor: {
	            type: String,
	            value: '#FFFFFF'
	          },
	          selectedColor: {
	            type: String,
	            value: '#F85959'
	          },
	          color: {
	            type: String,
	            value: '#E8E8E8'
	          },
	          _filteredValue: {
	            type: Number
	          }
	        };
	      }
	    }]);
	    return Slider;
	  }(TouchTrack(Disabled(Data(Base(PolymerElement)))));

	  function e$1(e) {
	    return e % 1 != 0;
	  }

	  function t$1(t) {
	    t = +t;
	    return isNaN(t) || !e$1(t) ? 0 : t.toString().split('.')[1].length;
	  }

	  function n(e, t, n) {
	    return e < t ? t : e > n ? n : e;
	  }

	  window.customElements.define(Slider.is, Slider);

	  var _templateObject$17 = taggedTemplateLiteral(['\n      <style>\n        :host {\n          display: block;\n          -webkit-user-select: none;\n          user-select: none;\n        }\n        #wrapper {\n          -webkit-tap-highlight-color: transparent;\n        }\n        ::slotted(*) {\n          -webkit-user-select: none;\n          user-select: none;\n          -webkit-tap-highlight-color: transparent;\n        }\n      </style>\n      <div id="wrapper">\n        <slot></slot>\n      </div>\n    '], ['\n      <style>\n        :host {\n          display: block;\n          -webkit-user-select: none;\n          user-select: none;\n        }\n        #wrapper {\n          -webkit-tap-highlight-color: transparent;\n        }\n        ::slotted(*) {\n          -webkit-user-select: none;\n          user-select: none;\n          -webkit-tap-highlight-color: transparent;\n        }\n      </style>\n      <div id="wrapper">\n        <slot></slot>\n      </div>\n    ']);
	  // region data

	  var padNumber = function (d) {
	    d = parseInt(d);
	    if (isNaN(d)) {
	      return '';
	    }
	    return d < 10 ? '0' + d : d.toString();
	  };

	  var Picker = function (_Data) {
	    inherits(Picker, _Data);

	    function Picker() {
	      classCallCheck(this, Picker);
	      return possibleConstructorReturn(this, (Picker.__proto__ || Object.getPrototypeOf(Picker)).apply(this, arguments));
	    }

	    createClass(Picker, [{
	      key: 'ready',
	      value: function ready() {
	        var _this3 = this;

	        get(Picker.prototype.__proto__ || Object.getPrototypeOf(Picker.prototype), 'ready', this).call(this);

	        document.addEventListener('onKeyboardShow', function () {
	          _this3.__hasKeyboard = true;
	        });
	        document.addEventListener('onKeyboardComplete', function () {
	          _this3.__hasKeyboard = false;
	          if (typeof _this3.__whenKeyboardComplete === 'function') {
	            _this3.__whenKeyboardComplete();
	            _this3.__whenKeyboardComplete = null;
	          }
	        });
	      }
	    }, {
	      key: 'resetFormData',
	      value: function resetFormData() {
	        if ('selector' == this.mode) {
	          this.value = -1;
	        } else if ('region' === this.mode || 'multiSelector' === this.mode) {
	          this.value = [];
	        } else {
	          this.value = '';
	        }
	      }
	    }, {
	      key: 'getFormData',
	      value: function getFormData(cb) {
	        if (this.__pickerShow) {
	          this.__formCallback = cb;
	        } else if ('function' == typeof cb) {
	          var result = void 0;
	          if ('region' === this.mode || 'multiSelector' === this.mode) {
	            result = Array.isArray(this.value) ? this.value : [];
	          } else {
	            result = this.value;
	          }
	          cb(result);
	        }
	      }
	    }, {
	      key: 'formGetDataCallback',
	      value: function formGetDataCallback() {
	        if ('function' == typeof this.__formCallback) {
	          this.__formCallback(this.value);
	        }
	        this.__formCallback = undefined;
	      }
	    }, {
	      key: 'showPickerView',
	      value: function showPickerView() {
	        if (this.__hasKeyboard) {
	          this.__whenKeyboardComplete = this._showPickerView;
	        } else {
	          this._showPickerView();
	        }
	      }
	    }, {
	      key: '_showPickerView',
	      value: function _showPickerView() {
	        if ('date' == this.mode || 'time' == this.mode) {
	          this.showDatePickerView();
	        } else if ('multiSelector' === this.mode) {
	          this.showMultiPickerView();
	        } else if ('region' === this.mode) {
	          this.showRegionView();
	        } else if ('selector' === this.mode) {
	          this.showSelector();
	        }
	      }
	    }, {
	      key: 'showSelector',
	      value: function showSelector(e) {
	        var _this = this;
	        if (!this.disabled) {
	          var n = parseInt(this.value);
	          if (isNaN(n) || n >= this.range.length) {
	            n = 0;
	          }

	          var i = [];
	          if (this.rangeKey) {
	            for (var r = 0; r < this.range.length; r++) {
	              var o = this.range[r];
	              i.push(o[this.rangeKey] + '');
	            }
	          } else {
	            for (var _r = 0; _r < this.range.length; _r++) {
	              i.push(this.range[_r] + '');
	            }
	          }

	          ttJSBridge.invoke('showPickerView', {
	            array: i,
	            current: n
	          }, function (e) {
	            if (/:ok/.test(e.errMsg)) {
	              _this.value = e.index.toString();
	              _this.triggerEvent('change', {
	                value: _this.value
	              });
	            } else {
	              _this.triggerEvent('cancel', {});
	            }

	            _this.resetPickerState();
	            _this.formGetDataCallback();
	          });

	          this.__pickerShow = true;
	        }
	      }
	    }, {
	      key: 'showDatePickerView',
	      value: function showDatePickerView() {
	        var _this = this;
	        if (!this.disabled) {
	          var safeValue = this.value;
	          if (!safeValue) {
	            var now = new Date();
	            var YYYY = now.getFullYear();
	            var MM = padNumber(now.getMonth() + 1);
	            var DD = padNumber(now.getDate());
	            var hh = padNumber(now.getHours());
	            var mm = padNumber(now.getMinutes());
	            safeValue = this.mode == 'date' ? YYYY + '-' + MM + '-' + DD : hh + ':' + mm;
	          }

	          ttJSBridge.invoke('showDatePickerView', {
	            range: {
	              start: this.start,
	              end: this.end
	            },
	            mode: this.mode,
	            current: safeValue,
	            fields: this.fields
	          }, function (e) {

	            if (/:ok/.test(e.errMsg)) {
	              _this.value = e.value;
	              _this.triggerEvent('change', {
	                value: _this.value
	              });
	            } else {
	              _this.triggerEvent('cancel', {});
	            }

	            _this.resetPickerState();
	            _this.formGetDataCallback();
	          });

	          this.__pickerShow = true;
	        }
	      }
	    }, {
	      key: 'showMultiPickerView',
	      value: function showMultiPickerView(e, t, n) {
	        var _this = this;
	        if (!this.disabled) {

	          var r = [],
	              o = [];

	          if (typeof e != 'undefined') {
	            this.value = r = e.current;
	            this.range = o = e.array;
	          } else {

	            for (var a = 0; a < this.range.length; a++) {

	              if (this.value && Array.isArray(this.value)) {
	                r.push(parseInt(this.value[a]));
	                if (isNaN(r[a]) || r[a] >= this.range[a].length) {
	                  r[a] = 0;
	                }
	              } else {
	                r.push(0);
	              }

	              var s = [];
	              if (this.rangeKey) {

	                for (var l = 0; l < this.range[a].length; l++) {
	                  var c = this.range[a][l];
	                  s.push(c[this.rangeKey] + '');
	                }
	              } else {
	                for (var _l = 0; _l < this.range[a].length; _l++) {
	                  s.push(this.range[a][_l] + '');
	                }
	              }
	              o.push(s);
	            }

	            if (!this.value || !Array.isArray(this.value)) {
	              // show multipicker的时候，value必须是一个数组
	              this.value = r;
	            }
	          }

	          ttJSBridge.invoke('showMultiPickerView', {
	            array: o,
	            current: r
	          }, function (e) {
	            if (/:ok/.test(e.errMsg)) {
	              _this.value = e.current;
	              _this.triggerEvent('change', {
	                value: 'function' == typeof n ? n(_this.value) : _this.value
	              });
	            } else {
	              _this.triggerEvent('cancel', {});
	            }

	            _this.resetPickerState();
	            _this.formGetDataCallback();
	          });

	          this.__pickerShow = true;
	          this.__multi_picker_watching = true;

	          ttJSBridge.on('onMultiPickerViewChange', function (e) {

	            if (_this.__pickerShow && _this.value[e.column] !== e.current) {

	              _this.value[e.column] = e.current;

	              'function' == typeof t ? t(e) : _this.triggerEvent('columnchange', {
	                column: e.column,
	                value: e.current
	              });
	            }
	          });
	        }
	      }
	    }, {
	      key: 'showRegionView',
	      value: function showRegionView() {
	        if (!this.disabled) {
	          var value = this.value;
	          if (!value || !Array.isArray(value)) {
	            value = []; // 传空，交给端上处理
	          }
	          var _this = this;
	          ttJSBridge.invoke('showRegionPickerView', {
	            current: value,
	            customItem: this.customItem
	          }, function (e) {
	            if (/:ok/.test(e.errMsg)) {
	              _this.value = e.value;
	              _this.triggerEvent('change', {
	                value: _this.value
	              });
	            } else {
	              _this.triggerEvent('cancel', {});
	            }

	            _this.resetPickerState();
	            _this.formGetDataCallback();
	          });
	        }
	      }
	    }, {
	      key: 'resetPickerState',
	      value: function resetPickerState() {
	        this.__pickerShow = false;
	      }
	    }, {
	      key: 'valueChanged',
	      value: function valueChanged(e, t) {
	        var n = this;

	        if (this.__pickerShow && this.__multi_picker_watching) {

	          !function i(r, o) {

	            if (r < o) {

	              if (e[r] !== t[r]) {

	                var a = e[r] >= n.range[r].length ? 0 : e[r];
	                var s = [];

	                if (n.rangeKey) {
	                  for (var l = 0; l < n.range[r].length; l++) {
	                    var c = n.range[r][l];
	                    s.push(c[n.rangeKey] + '');
	                  }
	                } else {
	                  for (var _l2 = 0; _l2 < n.range[r].length; _l2++) {
	                    s.push(n.range[r][_l2] + '');
	                  }
	                }

	                ttJSBridge.invoke('updateMultiPickerView', {
	                  column: r,
	                  array: s,
	                  current: a
	                }, function (e) {
	                  if (/:ok/.test(e.errMsg)) {
	                    n.value[r] = a;
	                    i(r + 1, o);
	                  }
	                });
	              } else {
	                i(r + 1, o);
	              }
	            }
	          }(0, e.length);
	        }
	      }
	    }, {
	      key: 'rangeChanged',
	      value: function rangeChanged(e, t) {
	        var n = this;

	        if (this.__pickerShow && this.__multi_picker_watching) {
	          !function i(r, o) {
	            if (r < o) {

	              if (n._diffArray(e[r], t[r])) {
	                i(r + 1, o);
	              } else {

	                var a = n.value[r] >= e[r].length ? 0 : n.value[r];
	                var s = [];

	                if (n.rangeKey) {

	                  for (var l = 0; l < e[r].length; l++) {
	                    var c = e[r][l];
	                    s.push(c[n.rangeKey] + '');
	                  }
	                } else {
	                  for (var _l3 = 0; _l3 < e[r].length; _l3++) {
	                    s.push(e[r][_l3] + '');
	                  }
	                }

	                ttJSBridge.invoke('updateMultiPickerView', {
	                  column: r,
	                  array: s,
	                  current: a
	                }, function (e) {
	                  if (/:ok/.test(e.errMsg)) {
	                    n.value[r] = a;
	                    i(r + 1, o);
	                  }
	                });
	              }
	            }
	          }(0, e.length);
	        }
	      }
	    }, {
	      key: '_diffArray',
	      value: function _diffArray(e, t) {
	        if (e.length !== t.length) {
	          return !1;
	        }
	        for (var n = 0, i = e.length; n < i; n++) {
	          if ('object' === _typeof$1(e[n]) && 'object' === _typeof$1(t[n])) {
	            if (e[n][this.rangeKey] !== t[n][this.rangeKey]) {
	              return !1;
	            }
	          } else if (_typeof$1(e[n]) !== _typeof$1(t[n]) || e[n] !== t[n]) {
	            return !1;
	          }
	        }
	        return true;
	      }
	    }, {
	      key: 'listeners',
	      get: function () {
	        return {
	          tap: 'showPickerView'
	        };
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$17);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-picker';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          range: {
	            type: Array,
	            value: [],
	            observer: 'rangeChanged'
	          },
	          value: {
	            type: Object,
	            observer: 'valueChanged'
	          },
	          mode: {
	            type: String,
	            value: 'selector'
	          },
	          fields: {
	            type: String,
	            value: 'day'
	          },
	          start: {
	            type: String,
	            value: ''
	          },
	          end: {
	            type: String,
	            value: ''
	          },
	          disabled: {
	            type: Boolean,
	            value: false
	          },
	          rangeKey: {
	            type: String,
	            value: ''
	          },
	          customItem: {
	            type: String
	          }
	        };
	      }
	    }]);
	    return Picker;
	  }(Data(Base(PolymerElement)));

	  window.customElements.define(Picker.is, Picker);

	  var _templateObject$18 = taggedTemplateLiteral(['\n      <style>\n        :host {\n          display: block;\n        }\n        :host .wrapper {\n          display: -webkit-flex;\n          display: flex;\n          position: relative;\n          overflow: hidden;\n        }\n        :host([hidden]) {\n          display: none;\n        }\n      </style>\n      <div id="wrapper" class="wrapper">\n        <slot></slot>\n      </div>\n    '], ['\n      <style>\n        :host {\n          display: block;\n        }\n        :host .wrapper {\n          display: -webkit-flex;\n          display: flex;\n          position: relative;\n          overflow: hidden;\n        }\n        :host([hidden]) {\n          display: none;\n        }\n      </style>\n      <div id="wrapper" class="wrapper">\n        <slot></slot>\n      </div>\n    ']);

	  var PickerView = function (_Data) {
	    inherits(PickerView, _Data);

	    function PickerView() {
	      classCallCheck(this, PickerView);
	      return possibleConstructorReturn(this, (PickerView.__proto__ || Object.getPrototypeOf(PickerView)).apply(this, arguments));
	    }

	    createClass(PickerView, [{
	      key: 'ready',
	      value: function ready() {
	        get(PickerView.prototype.__proto__ || Object.getPrototypeOf(PickerView.prototype), 'ready', this).call(this);

	        this.addEventListener('pickerColumnValueChanged', this._columnValueChanged);
	        this.addEventListener('pickerColumnChanged', this._initColumns);
	      }
	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        get(PickerView.prototype.__proto__ || Object.getPrototypeOf(PickerView.prototype), 'connectedCallback', this).call(this);

	        this.__updateColumns = this._updateColumns.bind(this);
	        document.addEventListener('pageReRender', this.__updateColumns);
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        get(PickerView.prototype.__proto__ || Object.getPrototypeOf(PickerView.prototype), 'disconnectedCallback', this).call(this);
	        document.removeEventListener('pageReRender', this.__updateColumns);
	      }
	    }, {
	      key: '_initColumns',
	      value: function _initColumns(e) {
	        var col = e.detail.col;
	        var isAdd = e.detail.add;

	        // update this._columns
	        this._columns = this._columns || [];
	        this._height = this.offsetHeight;

	        var values = '[object Array]' === Object.prototype.toString.call(this.value) ? this.value : [];

	        if (isAdd) {
	          var i = this._columns.length;
	          this._columns.push(col);

	          col._setStyle(this.indicatorStyle, this.maskStyle);
	          col._setClass(this.indicatorClass, this.maskClass);
	          col._setHeight(this._height);
	          col._setCurrent(values[i] || 0);
	          col._init();
	        } else {
	          var _i = this._columns.indexOf(col);
	          _i != -1 && this._columns.splice(_i, 1);
	        }

	        this._valueChanged(this.value);
	      }
	    }, {
	      key: '_updateColumns',
	      value: function _updateColumns() {
	        var e = this;
	        if (this._columns && 0 !== this._columns.length) {
	          var t = false;

	          this._columns.forEach(function (column) {
	            if (column._height !== column.offsetHeight) {
	              t = true;
	            }
	          });

	          if ((t || this._height !== this.offsetHeight) && this.offsetHeight != 0) {
	            this._height = this.offsetHeight;
	            this._columns.forEach(function (column) {
	              column._setHeight(e._height);
	              column._update();
	            });
	          }
	        }
	      }
	    }, {
	      key: '_columnValueChanged',
	      value: function _columnValueChanged() {
	        var e = this._columns.map(function (e) {
	          return e._getCurrent();
	        });

	        this.triggerEvent('change', {
	          value: e
	        });
	      }
	    }, {
	      key: '_valueChanged',
	      value: function _valueChanged(newValue, oldVaule) {
	        // 防止在 bindChange 时 setState，返回旧的 value，导致重排，定位不准
	        if (newValue && oldVaule && newValue.toString() === oldVaule.toString()) {
	          return;
	        }
	        newValue = newValue || [];
	        var columns = this._columns || [];
	        columns.forEach(function (col, i) {
	          col._setCurrent(newValue[i] || 0);
	          // A workaround to wait the slot of picker-view-column been ready
	          setTimeout(function () {
	            col._update();
	          }, 0);
	        });
	      }
	    }, {
	      key: '_updateStyle',
	      value: function _updateStyle(newVlaue, oldValue) {
	        var _this2 = this;

	        if (newVlaue === oldValue) {
	          return;
	        }
	        var cols = this._columns;
	        cols && cols.forEach(function (col) {
	          col._setStyle(_this2.indicatorStyle, _this2.maskStyle);
	          col._setHeight(_this2._height);
	        });
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$18);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-picker-view';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          value: {
	            type: Array,
	            value: [],
	            observer: '_valueChanged'
	          },
	          indicatorStyle: {
	            type: String,
	            value: '',
	            observer: '_updateStyle'
	          },
	          indicatorClass: {
	            type: String,
	            value: ''
	          },
	          maskStyle: {
	            type: String,
	            value: '',
	            observer: '_updateStyle'
	          },
	          maskClass: {
	            type: String,
	            value: ''
	          }
	        };
	      }
	    }]);
	    return PickerView;
	  }(Data(ClassPrefix(Base(PolymerElement))));

	  window.customElements.define(PickerView.is, PickerView);

	  var $_documentContainer$8 = document.createElement('div');
	  $_documentContainer$8.setAttribute('style', 'display: none;');

	  $_documentContainer$8.innerHTML = '<dom-module id="tt-picker-style">\n  <template>\n    <style>\n      :host {\n        -webkit-flex: 1;\n        flex: 1;\n        position: relative;\n        height: 100%;\n        overflow: hidden;\n        text-align: center;\n      }\n      :host .tt-picker__mask {\n        transform: translateZ(0);\n        -webkit-transform: translateZ(0);\n      }\n      :host .tt-picker__indicator,\n      :host .tt-picker__mask {\n        position: absolute;\n        left: 0;\n        width: 100%;\n        z-index: 3;\n      }\n      :host .tt-picker__mask {\n        top: 0;\n        height: 100%;\n        margin: 0 auto;\n        background: linear-gradient(180deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.6)), linear-gradient(0deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.6));\n        background-position: top,bottom;\n        background-size: 100% 102px;\n        background-repeat: no-repeat;\n      }\n      :host .tt-picker__indicator {\n        height: 34px;\n        top: 102px;\n      }\n      :host .tt-picker__indicator,\n      :host .tt-picker__mask {\n        position: absolute;\n        left: 0;\n        width: 100%;\n        z-index: 3;\n        pointer-events: none;\n      }\n      :host .tt-picker__content {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        will-change: transform;\n      }\n      :host ::slotted(*) {\n        white-space: nowrap;\n      }\n      :host .tt-picker__indicator:after,\n      :host .tt-picker__indicator:before {\n        content: " ";\n        position: absolute;\n        left: 0;\n        right: 0;\n        height: 1px;\n        color: #e5e5e5;\n      }\n      :host .tt-picker__indicator:before {\n        top: 0;\n        border-top: 1px solid #e5e5e5;\n        -webkit-transform-origin: 0 0;\n        transform-origin: 0 0;\n        -webkit-transform: scaleY(0.5);\n        transform: scaleY(0.5);\n      }\n      :host .tt-picker__indicator:after {\n        bottom: 0;\n        border-bottom: 1px solid #e5e5e5;\n        -webkit-transform-origin: 0 100%;\n        transform-origin: 0 100%;\n        -webkit-transform: scaleY(0.5);\n        transform: scaleY(0.5);\n      }\n      :host .tt-picker__indicator:after,\n      :host .tt-picker__indicator:before {\n        content: " ";\n        position: absolute;\n        left: 0;\n        right: 0;\n        height: 1px;\n        color: #e5e5e5;\n      }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$8);

	  /* eslint-disable */

	  function e$2() {
	    if (!p) {
	      var e;
	      e = f ? window.atob('UklGRl4RAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YToRAAABAAAAAgD9/wQA9f88ACIA3P/M/63/kP+p/xIAFAAfABYAIQAfACAAIgAdACMAFwAiAAsALAAr/yf+T/5V/nv+jf6y/s3+7f4U/yv/kP8+Ac4BxAHUAcgBzAG1AbkBlQGcAV4BgAH7/2n+mf6c/sr+2f76/hP/Lf9P/2X/jv+b/8b/yv+CADsCiAJlAlICLgIRAuoBwQGZAR0A/f0a/dT9o/7d/gD/DP8p/zX/UP9k/3v/j//x/54BKAL/AfABzAGyAYwBawE/ARoB6ADAAJQAYAAE/679Ev31/E79DP4u/mz+2P4lANsAyQDQALwAtwCkAJsAjAB8AGgAWQBGADQAJQAOAPb/y/7u/er99f0b/kP+Zf6Z/sH+CP91/1wAKgExAUEBNwE8ATEBKwEgAQ4B8ADn/y3/CP8M/x3/Nf9I/2T/dv+N/6f/uf/V/+b/AAAcAEoAkgAEAZYB+wEEAuYBuwEgAX8ADADB/5v/e/9y/2v/c/99/4r/mf+q/8T/6v86ANsAjgGWAXoBYgFDASEBBQHdAL8AmAB2AE4AMwAHAPD/wv+o/1b/Iv8M/zb/Sf9E/zv/M/8n/yj/Gv8h/xX/Hf8Z/x3/JP8i/zL/MP8+/0P/S/85/9T+of6V/qb+wv7r/hb/UP+I/8v/FABdAKcA4QADARABFgH/ANEAnwBzAFIAPgA0ADIANgA8AEYATgBYAGIAbAB0AIIAiQCZAKkAuQDTAOYA+gAKAQ4BBgH1ANUAswCKAGQAQQAfAAsA8v/r/+H/4//t//7/HgBIAIIAnwCLAHYAXwBCAC8AEAD7/+T//v8DAP3/AgD+/wIA/v8CAP7/AQAAAAAAAAAAAP//AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAEA/v8CAP3/AwD+/wIA/f8DAP3/AgAAAP//AQD//wAAAQAAAP//AQD+/wMA/f8DAP3/AgD//wAAAQD+/wMA/f8DAP7/AAABAAAA//8BAP//AAACAP3/AgD/////AwD8/wQA/P8EAPz/BAD8/wMA/v8CAP//AAAAAP//AgD//wAAAAAAAP//AwD8/wQA/f8BAAAA//8CAP//AAD//wEA//8CAP7/AQD//wIA/f8EAPv/BAD/////AgD+/wEA//8CAP7/AgD+/wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEA/v8CAP7/AwD9/wIA//8AAAEA//8BAP//AQD//wEA//8CAP3/AwD+/wEA//8CAP3/BAD8/wMA/v8BAAAAAAD//wIA/f8DAP7/AAACAP3/AwD9/wIA//8BAP//AQAAAP7/BAD7/wYA+v8FAPz/BAD8/wMA/v8BAAAAAAD+/wQA/P8DAP7/AQAAAAAAAQD+/wEAAQD9/wUA+/8DAP////8DAP3/AgD+/wEAAQD//wAAAQD9/wQA/f8BAAEA/v8BAAAAAAAAAAAA//8BAAAAAAD//wEAAAD//wIA/f8DAP7/AgD+/wEAAAAAAAAAAAD//wIA/v8CAP7/AgD+/wIA//8AAAAAAQD//wAAAQD+/wIA//8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//wIA/v8BAAAA//8BAP//AQD//wEA//8AAAEA/v8CAP//AAABAP7/AgD//wAAAQD//wEA//8BAP//AQAAAP7/BAD7/wUA/P8CAP//AAABAP//AAAAAAAAAAABAP7/AgD+/wIA/v8CAP7/AgD+/wIA/f8EAPz/AwD/////AgD/////AgD+/wEAAAAAAAAA//8CAP3/BAD8/wMA/v8CAP3/BAD8/wMA/////wEAAAAAAP//AgD9/wQA/P8DAP7/AgD+/wIA/v8BAAEA/f8DAP7/AAABAP7/AgD+/wIA//8AAAEA/v8DAP7/AAABAAAA//8DAPv/BQD8/wIAAAAAAAAAAAD//wEAAAD//wEAAAD//wIA/f8DAP7/AQAAAAAA//8CAP7/AQAAAP//AgD+/wEAAAAAAAAAAAD//wIA/v8CAP7/AQABAP7/AQAAAP//AwD9/wIA/v8CAP7/AwD9/wIA/////wMA/P8EAP3/AQABAP7/AgAAAP//AAABAP//AQAAAP//AQAAAP//AQD//wIA/f8EAPv/BQD9/wEAAAAAAAAAAQD+/wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEA/v8CAP//AAABAP//AAACAPz/BgD5/wYA/f8AAAIA/f8DAP7/AQAAAP//AgD9/wMA/v8BAAAA/v8DAP3/AwD9/wIA//8AAAAAAAABAP//AAABAP3/BQD7/wQA/f8CAP7/AwD9/wIA//8AAAEA//8BAP//AQD//wIA/f8CAP//AAABAAAA/v8DAPz/AwD//wAAAQD+/wIA/v8CAP7/AgD+/wMA/P8EAP3/AgD//wAAAQD//wEA//8BAP7/AwD8/wUA/P8CAP//AAACAP3/AwD9/wMA/v8BAP//AQD//wEA//8BAAAA//8BAP//AgD+/wIA/v8BAAEA/v8CAP7/AQABAP7/AgD/////AgD+/wIA//8AAP//AwD9/wIA/////wIA//8BAP//AAABAP//AAABAP7/AwD9/wIA/v8CAP//AAABAP//AAAAAAEA//8BAP7/AgD+/wMA/f8CAP7/AgD+/wMA/P8EAPz/BAD8/wMA//8AAAEA/f8DAP7/AwD8/wQA+/8FAP3/AQAAAAAAAAAAAAAA//8CAP7/AgD+/wIA/v8CAP3/AwD//wAAAAD//wEAAAAAAP//AgD+/wIA/v8CAP7/AgD//wAAAQD+/wIA/v8CAP7/AgD+/wEAAQD9/wQA/P8DAP7/AgD+/wEAAAAAAAAAAQD+/wIA/v8CAP//AQD+/wIA/v8CAP//AAAAAAEA/v8DAPz/BAD9/wIA//8AAAAAAQD+/wMA/f8CAP//AAABAAAA/v8DAP3/AgAAAP7/AwD9/wIA//8BAP//AQD+/wMA/f8DAP3/AgAAAP//AQD//wEA//8BAAAA/v8DAPz/BAD9/wIA//8AAAAAAAAAAAAAAQD+/wIA//8AAAAAAQD+/wMA/f8CAP//AAABAP//AQD//wAAAQD//wIA/f8DAP7/AQAAAAAA//8CAP7/AgD+/wEAAAAAAAAAAAAAAAAA//8CAP7/AwD8/wMA/v8CAP//AAAAAP//AgD+/wIA/////wIA/f8DAP7/AgD+/wEA//8CAP3/AwD+/wIA/v8BAP//AgD+/wEAAAD//wEAAAD//wEAAAD//wEAAAD//wEA//8BAAAAAAD//wIA/v8BAAEA/f8EAP3/AQAAAAAA//8CAP7/AgD+/wIA/f8EAPz/AwD//wAAAAAAAP//AQABAP7/AgD+/wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8CAP7/AgD+/wEAAAD//wIA/v8BAAAA//8CAP7/AQAAAAAAAAAAAP//AgD/////AgD9/wMA/v8BAAAA//8BAAAA//8BAAAA//8CAP7/AQAAAAAAAAD//wIA/v8CAP7/AgD+/wIA/v8CAP//AQD+/wIA/v8DAP3/AgD+/wIA/v8CAP7/AgD//wAAAQD9/wUA+/8EAP3/AQAAAAAAAAAAAP//AgD+/wIA/////wMA/f8CAP//AAABAP//AAABAP//AAABAP7/AwD9/wIA/v8DAPz/BQD6/wYA+/8EAP3/AQABAP7/AgD+/wEAAAAAAP//AgD9/wMA/v8BAAAA//8BAAAAAAAAAAAAAAD//wIA/v8CAP////8CAP7/AQAAAP//AQD//wEAAAD//wEA//8BAP//AgD+/wEA//8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//wEAAAD//wIA/v8AAAMA+/8FAPz/AwD/////AgD9/wQA/P8EAPz/AwD+/wIA//8AAAAAAAAAAAEA/v8DAPz/BAD9/wIA//8AAAAAAQD//wAAAAAAAAAAAQD//wAAAAAAAAAAAAABAP7/AgD/////AgD+/wIA//8AAAAAAAAAAAEA//8AAAEA/v8DAP7/AQD//wEA//8CAP3/AwD9/wMA/v8AAAEA/v8DAP3/AgD//wAAAQD+/wMA/P8FAPz/AgAAAP7/AwD+/wEAAAD//wEA//8BAP//AQD//wAAAAABAP//AQD+/wIA/v8CAP//AAAAAP//AQAAAAAAAAD//wEAAAAAAAEA/v8CAP7/AgD//wEA/v8DAPz/BQD7/wQA/f8CAP//AAABAP//AQD//wAAAQD//wEAAAD+/wMA/f8DAP7/AAACAP3/AwD///7/BAD8/wQA/P8EAPz/AwD/////AgD+/wEAAAAAAAAAAAAAAP//AwD9/wMA/P8EAPz/BQD8/wIA//8AAAEA//8BAP//AQD//wAAAAABAP//AQD+/wIA/v8DAP3/AgD//wAAAgD9/wMA/f8DAP3/AwD+/wEAAAD//wEA//8BAP//AQD//wEA//8AAAAAAAABAP//AAAAAAAAAQD//wAAAQD+/wIA//8AAAEA/v8CAP//AAAAAAEA/v8DAP3/AgAAAP7/AwD9/wMA/v8BAP//AQD//wEAAAD//wEA//8BAP//AQD//wEA//8BAP//AQD//wEA//8CAP7/AgD9/wMA//8BAP//AAAAAAEAAAD//wAAAQD//wEA//8BAP7/AwD9/wIAAAD+/wMA/f8CAP//AQD//wAAAQD//wEAAAD//wEAAAD//wIA/v8BAP//AQAAAAAA//8BAP7/BAD8/wMA/f8DAP7/AgD+/wEAAAAAAAEA/v8DAP3/AgD+/wIA//8BAP7/AQAAAAAA//8CAP3/AwD+/wEAAAAAAP//AgD9/wQA/P8DAP7/AQD//wEA//8BAP7/AwD9/wIA//8AAAAAAQD+/wIA/v8CAP7/AwD8/wMA//8AAAEA/v8BAAEA/v8CAP7/AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAEA/v8DAPz/AwD+/wIA//8AAP//AQAAAP//AgD9/wMA/v8BAAAA//8BAAAA//8BAP//AQD//wIA/f8DAP3/AwD+/wEAAAD//wEA//8AAAIA/P8FAPv/AwD/////AwD9/wEAAQD+/wIA/////wMA/f8CAP//AAAAAAEA/v8DAP3/AgD//wAAAAABAP//AAAAAP//AwD8/wQA/P8DAP7/AQAAAAAA//8BAP//AQABAP7/AQAAAP//AwD9/wIA//8AAAEA//8BAP//AQD//wEAAAD//wEA//8BAP//AQD//wEA//8BAP//AQAAAP7/BAD8/wMA/v8BAP//AgD+/wIA/v8CAP////8DAPz/BAD+////AgD/////AgD+/wEAAQD+/wEA//8CAP7/AgD9/wMA/f8DAP7/AQAAAP//AAABAP//AQD//wEA//8BAP//AQD//wEAAAD//wIA/v8BAP//AQAAAAAAAAAAAP//AgD+/wIA/v8CAP7/AgD//wAAAAABAP7/AwD9/wIA//8AAAAAAQD+/wIA/v8CAP7/AQAAAAAAAAD//wIA/f8EAPz/AwD+/wIA/f8DAP////8CAP7/AQABAP3/AwD+/wEAAQD9/wMA/v8BAAAAAAD//wIA/////wIA/f8DAP////8BAP//AAACAP3/AgD//wAAAQD//wEA//8BAP//AQD//wEAAAAAAAAA//8BAAAAAAAAAAAA//8CAP7/AQABAP3/AwD+/wIA/v8BAP//AAACAP3/AwD+/wAAAgD8/wYA+v8FAPz/AwD//wAAAAAAAAAAAQD+/wMA/P8EAP3/AQACAPz/AwD/////AwD9/wEAAQD+/wIA//8AAAEA/v8DAPz/BAD8/wQA/P8FAPr/BQD9/wEAAQD+/wIA//8AAAAAAAABAP//AQA=') : window.atob('UklGRl4RAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YToRAAAPAPX/IQDT/z0AgP9mAkgBnf72/b/8qPuZ/KwA1gAXAQUBJgFNATYBWwEeAWEB2ABpAVwAxAGn94ftHO9P78DwmPHi8g/0SfWq9tT3hvtxDBoSjxFgEsAR/REWETQR1g8REL0N8g7f/wHwDvIS8uXzfvTC9bH21vcC+Qb6evsg/KP9/v3/BGAWQhn4FzMXzxWoFCUTiRH5DyIB7ev04lzqQfLB9OX1jvaF9xv4Ivnl+dH6hvt+/xwQoRXmE2kT7hH/EHUPKQ6CDO4KIAmFB7oFyAMn9srouuKT4fXkn+yx7UTwbvRsAZUI2wcbCFoHKgdgBhQGbwXeBBkEaQPGAgUCdwGIAKH/5/NY6x7riesp7XfuJPDM8aLzUfZ++r0DegsMDG4MQwxDDPQLqgs6C6MKRQkf/6H3dPZW9j/38/f2+MD5svqA+3b8Vv05/gj///8fAdgCuwUsCtAP6RMBFCETMRFWC+0EdgCU/ff76vpi+jX6fvrb+m777fu3/I39S/8cAqQIjA/ND9oOxw2ZDGALEArFCGAH/wWHBC0D0gF2AC//yP1f/I75Fveu9v736vig+E/48vem92T3OfcS9wb39vYP9yb3UPeC98H3A/hd+Jf4Avki+GD0NfLj8WvyoPMf9fj2BPlb++79xQCsA38GywgZCqgK2Ar3CSoINAZ9BDcDawIHAvcBGAJdArMCDwN1A9EDNQSWBPcEdAXuBZcGTgclCAUJzAlcCowKRAqFCV8I8QZrBecDgQJOAUwAlf8T/9j+4f48//H/JgHQAh4FKgZ1BZ8EowOxArEBwADG/9/+/P8CAAAA//8CAP7/AQAAAAAAAAAAAAAA//8CAP7/AgD+/wEAAAD//wEAAQD9/wMA/v8BAAAAAAD//wIA/v8CAP3/BAD8/wQA/P8CAAAA//8CAPz/BQD7/wUA+/8EAP3/AwD9/wMA/f8DAP3/AgD//wAAAQD//wAAAAAAAAAAAAABAP7/AgD+/wEAAAABAP////8CAP7/AgD+/wIA/f8FAPr/BgD6/wUA/P8EAP3/AgD+/wEAAAD//wIA/v8BAAAA//8BAAAA//8CAP3/AwD+/wIA/v8BAP//AQAAAAAA//8CAP3/AwD/////AgD+/wEAAAAAAAAAAAAAAP//AgD//wAAAAABAP7/AwD9/wIA//8BAP7/AwD9/wEAAQD+/wIA/v8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8BAP//AgD+/wEAAAD//wEAAQD+/wMA/f8CAP//AQD//wIA/f8DAP7/AQD//wEAAAD//wEA//8AAAEAAAD//wAAAQD+/wQA+/8EAP3/AgD//wEA//8AAAAAAAAAAAEA/v8CAP3/AwD+/wEAAAD+/wMA/f8CAP//AAABAP//AAAAAAAAAQD+/wIA//8AAAAAAAAAAAAAAQD9/wMA//8AAAAAAAAAAAAAAQD+/wIAAAD+/wMA/P8DAP7/AgD/////AQD//wEAAAAAAP//AgD9/wMA/v8BAAAAAAD//wIA/f8DAP7/AgD/////AQD//wIA/v8CAP7/AQAAAAAAAAAAAAAA//8CAP7/AQD//wEA//8BAP//AQD//wEA//8CAP7/AgD+/wEAAAD//wIA/v8BAP//AAABAP//AQD//wAAAQD//wAAAQD+/wMA/f8BAAEA/v8CAAAA/f8FAPr/BgD7/wQA/f8CAP//AAABAP//AQD//wAAAQD//wEA//8AAAAAAAAAAAEA//8AAAAAAQD+/wMA/f8CAP//AQD+/wMA/f8CAP//AAABAP7/AwD8/wQA/f8CAP7/AgD+/wIAAAD+/wIA/v8CAP//AQD/////AwD8/wUA+/8EAP3/AgD//wEA/v8CAP//AQD//wEA/v8CAAAA/v8EAPv/BAD+/wEAAAD//wEA//8CAP3/BAD8/wMA/f8DAP7/AgD9/wQA+/8FAPz/AwD+/wEA//8AAAIA/f8CAP//AAABAP//AQD+/wIA/v8CAAAA//8AAAEA//8BAAAA//8CAP7/AgD9/wMA/v8BAAAAAAD//wEA//8BAAEA/v8AAAEAAAD//wEA//8AAAEA//8AAAEA/v8BAAEA/v8CAP//AAAAAAAAAAAAAAEA/v8CAP7/AgD+/wIA/v8CAP//AAAAAAAAAAAAAAAAAAAAAAAAAAD//wIA/v8CAP7/AQAAAAAA//8CAP7/AgD+/wIA/v8CAP7/AQABAP7/AQD//wIA/f8EAPv/BAD+/wEAAAD//wEA//8BAAAA//8BAP//AQD//wIA/f8CAP//AAABAP//AAABAP7/AgD/////AgD+/wIA/v8BAP7/BAD8/wIAAAD+/wMA/v8AAAIA/f8CAP//AAACAP3/AgD/////AgD+/wEAAQD9/wQA+/8EAP7/AQAAAAAA//8BAP//AQAAAAAAAAD+/wMA/f8DAP////8BAAAA//8CAP7/AgD+/wIA/v8CAP7/AgD9/wMA//8AAAAAAAD//wMA/P8EAP3/AgD//wAAAAABAP//AQD+/wMA/P8FAPv/BAD+////AwD8/wQA/f8BAAEA/v8CAP//AAABAP//AAABAP//AQD//wEA/v8CAP//AAABAP7/AgD//wAAAAABAP7/AwD8/wQA/f8CAP//AAABAP//AQD//wEA//8CAP3/BAD7/wUA/P8DAP7/AAACAPz/BQD7/wQA/f8CAP//AQD//wAAAQD//wEA//8BAP//AQD//wAAAgD9/wQA+/8EAP7/AQAAAAAA//8BAP//AgD9/wQA/P8EAP3/AQAAAAAAAAACAPz/BAD8/wQA/P8EAPz/AwD+/wIA/v8CAP7/AQAAAAAAAAABAP7/AQAAAP//AwD8/wQA/f8BAAEA//8AAAIA/P8EAP7/AAABAP//AAABAP//AAABAP//AQD//wAAAQD//wEA//8BAAAA//8BAP//AQABAP7/AQAAAAAAAAABAP3/AwD//wAAAAD//wEAAAAAAP//AQD+/wQA/P8DAP7/AAABAAAAAAAAAAAA//8CAP////8CAP7/AgD/////AQAAAAAAAAAAAP//AgD9/wQA+/8FAPz/AwD9/wIAAAD+/wMA/P8EAP7/AAABAP//AAABAP7/AwD9/wMA/f8DAP7/AQAAAAAAAAAAAAEA//8AAAEA/f8EAP3/AgD//wAAAAAAAAAAAQD+/wIA//8BAP////8CAAAA//8CAPz/BAD+/wEAAAD//wAAAQD//wIA/f8CAP//AQD//wEA/v8DAP3/AwD9/wEAAQD//wEA//8AAAAAAQD//wAAAQD+/wIA//8AAAAAAAD//wMA/f8CAP7/AQAAAAAAAQD+/wIA/v8BAAEA/v8CAP//AAABAP7/AwD9/wMA/f8CAP//AQD+/wMA/P8EAP3/AQABAP7/AgD9/wQA/f8BAAAA/v8EAPz/AwD+/wAAAQAAAAAAAAD//wEAAAAAAAEA/f8EAPz/BAD9/wEAAQD9/wQA/P8DAP////8BAP//AQD//wEA//8BAAAA//8BAAAA//8BAP//AQAAAP7/BAD6/wcA+f8HAPr/BQD8/wMA//8AAAAAAQD9/wQA+/8GAPv/AwD+/wEAAAAAAAAAAAABAP//AQD+/wMA/f8DAP7/AAABAAAA/v8DAP3/AgAAAP7/AwD9/wMA/v8AAAEA//8BAAAA//8AAAEA/v8DAPz/BAD9/wIA//8AAAAAAAABAP//AQD//wAAAQAAAP//AQAAAAAAAAAAAAAAAAABAP//AAAAAAEA//8AAAAAAAABAP//AAAAAAEA//8BAP//AQD//wIA/v8BAAAA/v8EAPz/AwD///7/BAD7/wUA/P8DAP7/AAABAAAA//8BAP//AAACAP3/AwD9/wIA//8AAAEA//8AAAEA/v8BAAEA/v8DAPz/AwD//wAAAAAAAAAAAQD+/wIA/v8CAP7/AgD+/wIA/v8BAAAAAAAAAAAAAAAAAAAAAAD//wIA/v8CAP3/AwD9/wMA/v8BAAAA/v8DAP3/AwD+/wAAAQD+/wIA/v8DAPz/AwD+/wEAAQD+/wEA//8CAP3/BQD6/wUA/f8AAAIA/////wIA/v8BAAEA/v8CAP3/BAD8/wQA/f8AAAIA/f8DAP7/AAACAPz/BQD7/wQA/f8DAP7/AQD//wEA//8BAAAA//8CAP3/AgD//wIA/v8CAP7/AQABAP7/AgD+/wEAAQD+/wIA/v8AAAIA/v8CAP7/AQAAAP//AgD+/wEAAQD9/wQA/P8DAP////8CAP7/AgD+/wEAAAD//wMA/P8DAP7/AQAAAAAAAAD//wIA/v8BAAEA/f8EAPz/AwD+/wIA/v8CAP7/AQAAAAAA//8DAPz/BAD8/wMA/v8CAP7/AgD+/wIA/v8BAAEA/v8DAPz/BAD9/wMA/f8CAP7/AgAAAP7/AwD8/wMA//8AAAAAAAAAAP//AgD+/wEAAAD//wEAAAD//wEA//8BAP//AQD+/wIA//8BAP//AQD+/wIA//8BAP//AQD//wAAAgD9/wIA//8BAAAA//8BAP7/AwD9/wMA/f8DAP3/AgAAAP//AAABAP//AQAAAP//AAAAAAIA/P8FAPv/BAD+/wAAAQD//wEAAAD//wEAAAD//wIA/f8DAP7/AQABAPz/BgD6/wUA/f8BAAAA//8CAP7/AwD8/wMA/////wMA/P8EAP3/AQABAP7/AwD8/wQA/f8DAP3/AgD+/wIA//8AAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8CAP7/AgD+/wEAAAD//wIA/v8BAP//AgD+/wEAAAD//wEAAAAAAAAAAAAAAP//AwD8/wMA/////wEAAQD+/wIA/v8CAP3/BQD5/wcA/P8AAAIA/f8DAP7/AgD9/wMA/f8CAAAA/v8DAP3/AQAAAAAAAQD+/wIA/f8FAPv/AwD/////BAD7/wQA/v8AAAEA//8AAAIA/P8FAPv/BQD8/wIA//8BAAAA//8BAAAA//8BAP//AQAAAAAA//8BAP//AQAAAP//AAAAAAEA//8BAP7/AgD+/wIA//8BAP//AAABAP7/AwD9/wIA//8AAAAAAQD+/wIA/v8BAAEA/v8CAP////8DAPz/BAD9/wIA//8AAAAAAAAAAAEA/v8CAP7/AgD+/wMA/P8EAP3/AQABAP7/AgD+/wIA/v8CAP////8DAP3/AQACAPz/BAD9/wIA//8BAP//AAAAAAEA//8BAP//AQD//wIA/f8CAAAA//8BAP//AAABAP//AAAAAAAAAQD//wAAAAABAP//AQD//wEA//8BAP//AQAAAP//AAABAP//AQD//wAAAAABAP7/AgD+/wIA/v8BAP//AgD9/wQA+/8EAP7/AQAAAP//AAACAP7/AgD+/wEAAQD+/wIA//8AAAEA/f8EAP3/AQABAP7/AQABAP3/BAD9/wIA//8AAAAAAAAAAAEA/f8FAPr/BQD9/wEAAQD+/wIA/v8CAP//AAAAAAAAAAAAAAEA/v8CAP7/AgD+/wIA//8AAAAA//8CAP7/AgD9/wQA/P8EAPz/AwD+/wIA/v8CAP7/AQAAAAAAAAD//wEAAAAAAAAA//8BAAAAAQD+/wIA/v8DAP3/AgD//wAAAQD//wAAAAAAAAEA/v8CAP//AAABAP7/AwD+/wAAAgD8/wUA/P8CAAAA//8BAP//AQD+/wQA+v8GAPv/AwD//wAAAAAAAAAAAAABAP//AAAAAAAAAQD//wAAAQD+/wMA/f8CAP//AQD//wEAAAD+/wMA/f8CAAAA/v8DAP3/AgD//wAAAQD+/wMA/f8CAP//AAACAP3/AgD//wAAAQD//wAAAQD+/wMA/f8BAAEA//8AAAEA/v8=');
	      for (var t = e.length, n = new Uint8Array(t), i = 0; i < t; i++) {
	        n[i] = e.charCodeAt(i);
	      }
	      p = !0, u = new (window.AudioContext || window.webkitAudioContext)(), u.decodeAudioData(n.buffer, function (e) {
	        d = e;
	      });
	    }
	  }
	  function t$2(e, t) {
	    e && !e.stoped && (e.stop(t), e.stoped = !0);
	  }
	  function n$1() {
	    f && window.tt && window.tt.vibrateShort && window.tt.vibrateShort();
	  }
	  function i$1(e, t, n) {
	    function i(t, n, r, o) {
	      if (!t || !t.cancelled) {
	        r(n);
	        var a = e.done();
	        a || t.cancelled || (t.id = requestAnimationFrame(i.bind(null, t, n, r, o))), a && o && o(n);
	      }
	    }
	    function r(e) {
	      e && e.id && cancelAnimationFrame(e.id), e && (e.cancelled = !0);
	    }
	    var o = {
	      id: 0,
	      cancelled: !1
	    };
	    return i(o, e, t, n), {
	      cancel: r.bind(null, o),
	      model: e
	    };
	  }
	  function r(e) {
	    this._drag = e, this._dragLog = Math.log(e), this._x = 0, this._v = 0, this._startTime = 0;
	  }
	  function o(e, t, n) {
	    return e > t - n && e < t + n;
	  }
	  function a(e, t) {
	    return o(e, 0, t);
	  }
	  function s(e, t, n) {
	    this._m = e, this._k = t, this._c = n, this._solution = null, this._endPosition = 0, this._startTime = 0;
	  }
	  function l(e) {
	    this._extent = e, this._friction = new r(0.01), this._spring = new s(1, 90, 20), this._startTime = 0, this._springing = !1, this._springOffset = 0;
	  }

	  var u,
	      d,
	      h = (window.AudioContext || window.webkitAudioContext) && window.atob && window.Uint8Array,
	      p = !1,
	      f = 'ios' === (window.tt ? window.tt.getPlatform() : 'ios');
	  r.prototype.set = function (e, t) {
	    this._x = e, this._v = t, this._startTime = new Date().getTime();
	  }, r.prototype.setVelocityByEnd = function (e) {
	    this._v = (e - this._x) * this._dragLog / (Math.pow(this._drag, 100) - 1);
	  }, r.prototype.x = function (e) {
	    void 0 === e && (e = (new Date().getTime() - this._startTime) / 1e3);
	    var t;
	    return t = e === this._dt && this._powDragDt ? this._powDragDt : this._powDragDt = Math.pow(this._drag, e), this._dt = e, this._x + this._v * t / this._dragLog - this._v / this._dragLog;
	  }, r.prototype.dx = function (e) {
	    void 0 === e && (e = (new Date().getTime() - this._startTime) / 1e3);
	    var t;
	    return t = e === this._dt && this._powDragDt ? this._powDragDt : this._powDragDt = Math.pow(this._drag, e), this._dt = e, this._v * t;
	  }, r.prototype.done = function () {
	    return Math.abs(this.dx()) < 3;
	  }, r.prototype.reconfigure = function (e) {
	    var t = this.x(),
	        n = this.dx();
	    this._drag = e, this._dragLog = Math.log(e), this.set(t, n);
	  }, r.prototype.configuration = function () {
	    var e = this;
	    return [{
	      label: 'Friction',
	      read: function () {
	        return e._drag;
	      },
	      write: function (t) {
	        e.reconfigure(t);
	      },
	      min: 0.001,
	      max: 0.1,
	      step: 0.001
	    }];
	  };
	  s.prototype._solve = function (e, t) {
	    var n = this._c,
	        i = this._m,
	        r = this._k,
	        o = n * n - 4 * i * r;
	    if (0 == o) {
	      var a = -n / (2 * i),
	          s = e,
	          l = t / (a * e);
	      return {
	        x: function (e) {
	          return (s + l * e) * Math.pow(Math.E, a * e);
	        },
	        dx: function (e) {
	          var t = Math.pow(Math.E, a * e);
	          return a * (s + l * e) * t + l * t;
	        }
	      };
	    }
	    if (o > 0) {
	      var c = (-n - Math.sqrt(o)) / (2 * i),
	          u = (-n + Math.sqrt(o)) / (2 * i),
	          l = (t - c * e) / (u - c),
	          s = e - l;
	      return {
	        x: function (e) {
	          var t, n;
	          return e === this._t && (t = this._powER1T, n = this._powER2T), this._t = e, t || (t = this._powER1T = Math.pow(Math.E, c * e)), n || (n = this._powER2T = Math.pow(Math.E, u * e)), s * t + l * n;
	        },
	        dx: function (e) {
	          var t, n;
	          return e === this._t && (t = this._powER1T, n = this._powER2T), this._t = e, t || (t = this._powER1T = Math.pow(Math.E, c * e)), n || (n = this._powER2T = Math.pow(Math.E, u * e)), s * c * t + l * u * n;
	        }
	      };
	    }
	    var d = Math.sqrt(4 * i * r - n * n) / (2 * i),
	        a = -n / 2 * i,
	        s = e,
	        l = (t - a * e) / d;
	    return {
	      x: function (e) {
	        return Math.pow(Math.E, a * e) * (s * Math.cos(d * e) + l * Math.sin(d * e));
	      },
	      dx: function (e) {
	        var t = Math.pow(Math.E, a * e),
	            n = Math.cos(d * e),
	            i = Math.sin(d * e);
	        return t * (l * d * n - s * d * i) + a * t * (l * i + s * n);
	      }
	    };
	  }, s.prototype.x = function (e) {
	    return void 0 == e && (e = (new Date().getTime() - this._startTime) / 1e3), this._solution ? this._endPosition + this._solution.x(e) : 0;
	  }, s.prototype.dx = function (e) {
	    return void 0 == e && (e = (new Date().getTime() - this._startTime) / 1e3), this._solution ? this._solution.dx(e) : 0;
	  }, s.prototype.setEnd = function (e, t, n) {
	    if (n || (n = new Date().getTime()), e != this._endPosition || !a(t, 0.4)) {
	      t = t || 0;
	      var i = this._endPosition;
	      this._solution && (a(t, 0.4) && (t = this._solution.dx((n - this._startTime) / 1e3)), i = this._solution.x((n - this._startTime) / 1e3), a(t, 0.4) && (t = 0), a(i, 0.4) && (i = 0), i += this._endPosition), this._solution && a(i - e, 0.4) && a(t, 0.4) || (this._endPosition = e, this._solution = this._solve(i - this._endPosition, t), this._startTime = n);
	    }
	  }, s.prototype.snap = function (e) {
	    this._startTime = new Date().getTime(), this._endPosition = e, this._solution = {
	      x: function () {
	        return 0;
	      },
	      dx: function () {
	        return 0;
	      }
	    };
	  }, s.prototype.done = function (e) {
	    return e || (e = new Date().getTime()), o(this.x(), this._endPosition, 0.4) && a(this.dx(), 0.4);
	  }, s.prototype.reconfigure = function (e, t, n) {
	    this._m = e, this._k = t, this._c = n, this.done() || (this._solution = this._solve(this.x() - this._endPosition, this.dx()), this._startTime = new Date().getTime());
	  }, s.prototype.springConstant = function () {
	    return this._k;
	  }, s.prototype.damping = function () {
	    return this._c;
	  }, s.prototype.configuration = function () {
	    function e(e, t) {
	      e.reconfigure(1, t, e.damping());
	    }
	    function t(e, t) {
	      e.reconfigure(1, e.springConstant(), t);
	    }
	    return [{
	      label: 'Spring Constant',
	      read: this.springConstant.bind(this),
	      write: e.bind(this, this),
	      min: 100,
	      max: 1e3
	    }, {
	      label: 'Damping',
	      read: this.damping.bind(this),
	      write: t.bind(this, this),
	      min: 1,
	      max: 500
	    }];
	  }, l.prototype.snap = function (e, t) {
	    this._springOffset = 0, this._springing = !0, this._spring.snap(e), this._spring.setEnd(t);
	  }, l.prototype.set = function (e, t) {
	    this._friction.set(e, t), e > 0 && t >= 0 ? (this._springOffset = 0, this._springing = !0, this._spring.snap(e), this._spring.setEnd(0)) : e < -this._extent && t <= 0 ? (this._springOffset = 0, this._springing = !0, this._spring.snap(e), this._spring.setEnd(-this._extent)) : this._springing = !1, this._startTime = new Date().getTime();
	  }, l.prototype.x = function (e) {
	    if (!this._startTime) {
	      return 0;
	    }
	    if (e || (e = (new Date().getTime() - this._startTime) / 1e3), this._springing) {
	      return this._spring.x() + this._springOffset;
	    }
	    var t = this._friction.x(e),
	        n = this.dx(e);
	    return (t > 0 && n >= 0 || t < -this._extent && n <= 0) && (this._springing = !0, this._spring.setEnd(0, n), t < -this._extent ? this._springOffset = -this._extent : this._springOffset = 0, t = this._spring.x() + this._springOffset), t;
	  }, l.prototype.dx = function (e) {
	    var t = 0;
	    return t = this._lastTime === e ? this._lastDx : this._springing ? this._spring.dx(e) : this._friction.dx(e), this._lastTime = e, this._lastDx = t, t;
	  }, l.prototype.done = function () {
	    return this._springing ? this._spring.done() : this._friction.done();
	  }, l.prototype.setVelocityByEnd = function (e) {
	    this._friction.setVelocityByEnd(e);
	  }, l.prototype.configuration = function () {
	    var e = this._friction.configuration();
	    return e.push.apply(e, this._spring.configuration()), e;
	  };

	  function Scroller(el, n) {
	    n = n || {};

	    this._element = el;

	    this._options = n, this._enableSnap = n.enableSnap || !1, this._itemSize = n.itemSize || 0, this._enableX = n.enableX || !1, this._enableY = n.enableY || !1, this._shouldDispatchScrollEvent = !!n.onScroll, this._enableX ? (this._extent = (n.scrollWidth || this._element.offsetWidth) - this._element.parentElement.offsetWidth, this._scrollWidth = n.scrollWidth) : (this._extent = (n.scrollHeight || this._element.offsetHeight) - this._element.parentElement.offsetHeight, this._scrollHeight = n.scrollHeight), this._position = 0, this._scroll = new l(this._extent), this._onTransitionEnd = this.onTransitionEnd.bind(this), this.updatePosition(), h && !d && e$2();
	  }

	  Scroller.prototype.onTouchStart = function () {
	    if (this._startPosition = this._position, this._lastChangePos = this._startPosition, this._startPosition > 0 ? this._startPosition /= 0.5 : this._startPosition < -this._extent && (this._startPosition = (this._startPosition + this._extent) / 0.5 - this._extent), this._animation && (this._animation.cancel(), this._scrolling = !1), this.updatePosition(), d) {
	      this._sound && (clearInterval(this._vibrateTimer), this._sound.loop = !1, t$2(this._sound, 0.04), this._sound = null);
	      var e = u.createBufferSource();
	      e.buffer = d, e.connect(u.destination), e.start(0), e.stop(0);
	    }
	  };

	  Scroller.prototype.onTouchMove = function (e, i) {
	    var r = this,
	        o = this._startPosition;
	    this._position;
	    if (this._enableX ? o += e : this._enableY && (o += i), o > 0 ? o *= 0.5 : o < -this._extent && (o = 0.5 * (o + this._extent) - this._extent), this._position = o, this.updatePosition(), this.dispatchScroll(), d && o < 0 && o > -this._extent) {
	      var a = Math.floor(Math.abs(o / this._itemSize));
	      Math.abs(o - this._lastChangePos) > this._itemSize / 2 && 'number' == typeof this._lastIdx && this._lastIdx !== a && (n$1(), setTimeout(function () {
	        t$2(r._sound, 0.04);
	        var e = r._sound = u.createBufferSource();
	        e.buffer = d, e.connect(u.destination), e.start(0);
	      }), this._lastChangePos = o), this._lastIdx = a;
	    }
	  };

	  Scroller.prototype.onTouchEnd = function (e, r, o) {
	    var a = this;
	    if (this._enableSnap && this._position > -this._extent && this._position < 0) {
	      if (this._enableY && (Math.abs(r) < this._itemSize && Math.abs(o.y) < 300 || Math.abs(o.y) < 150)) {
	        return void this.snap();
	      }
	      if (this._enableX && (Math.abs(e) < this._itemSize && Math.abs(o.x) < 300 || Math.abs(o.x) < 150)) {
	        return void this.snap();
	      }
	    }
	    if (this._enableX ? this._scroll.set(this._position, o.x) : this._enableY && this._scroll.set(this._position, o.y), this._enableSnap) {
	      var s = this._scroll._friction.x(100),
	          l = s % this._itemSize,
	          c = Math.abs(l) > this._itemSize / 2 ? s - (this._itemSize - Math.abs(l)) : s - l;
	      c <= 0 && c >= -this._extent && this._scroll.setVelocityByEnd(c);
	    }
	    this._lastTime = Date.now(), this._lastDelay = 0, this._scrolling = !0, this._lastChangePos = this._position, this._lastIdx = Math.floor(Math.abs(this._position / this._itemSize));
	    if (d && Math.abs(o.y) > 800) {
	      n$1();
	      var h = this._vibrateTimer = setInterval(function () {
	        n$1();
	      }, 30),
	          p = this._sound = u.createBufferSource();
	      p.buffer = d, p.connect(u.destination), p.loopStart = 0, p.loopEnd = 0.04, p.loop = !0, p.start(0);
	    }
	    this._animation = i$1(this._scroll, function () {
	      var e = Date.now(),
	          i = (e - a._scroll._startTime) / 1e3,
	          r = a._scroll.x(i);
	      a._position = r, a.updatePosition();
	      var o = a._scroll.dx(i),
	          s = a._scroll._springing;
	      if ((Math.abs(o) <= 800 || s) && p && (clearInterval(h), p.loop = !1, t$2(p, 0.04), p = a._sound = null, a._lastIdx = Math.floor(Math.abs(r / a._itemSize))), !s && !p && d) {
	        var l = Math.floor(Math.abs(r / a._itemSize)),
	            c = Math.abs(r % a._itemSize);
	        Math.abs(r - a._lastChangePos) > a._itemSize / 2 && (a._lastIdx !== l || o < 5 && (c < 1 || a._itemSize - c < 1)) && (n$1(), setTimeout(function () {
	          t$2(a._sound, 0.04);
	          var e = a._sound = u.createBufferSource();
	          e.buffer = d, e.connect(u.destination), e.start(0);
	        }), a._lastChangePos = r), a._lastIdx = l;
	      }
	      a._shouldDispatchScrollEvent && e - a._lastTime > a._lastDelay && (a.dispatchScroll(), a._lastDelay = Math.abs(2e3 / o), a._lastTime = e);
	    }, function () {
	      a._enableSnap && (c <= 0 && c >= -a._extent && (a._position = c, a.updatePosition()), 'function' == typeof a._options.onSnap && a._options.onSnap(Math.floor(Math.abs(a._position) / a._itemSize))), a._shouldDispatchScrollEvent && a.dispatchScroll(), a._scrolling = !1;
	    });
	  };

	  Scroller.prototype.onTransitionEnd = function () {
	    this._element.style.transition = '', this._element.style.webkitTransition = '', this._element.removeEventListener('transitionend', this._onTransitionEnd), this._element.removeEventListener('webkitTransitionEnd', this._onTransitionEnd), this._snapping && (this._snapping = !1), this.dispatchScroll();
	  };

	  Scroller.prototype.snap = function () {
	    var e = this._itemSize,
	        t = this._position % e,
	        i = Math.abs(t) > this._itemSize / 2 ? this._position - (e - Math.abs(t)) : this._position - t;
	    this._position !== i && (d && this._startPosition !== i && setTimeout(function () {
	      n$1();
	      var e = u.createBufferSource();
	      e.buffer = d, e.connect(u.destination), e.start(0);
	    }, 200), this._snapping = !0, this.scrollTo(-i), 'function' == typeof this._options.onSnap && this._options.onSnap(Math.floor(Math.abs(this._position) / this._itemSize)));
	  };

	  Scroller.prototype.scrollTo = function (e, t) {

	    if (this._animation) {
	      this._animation.cancel();
	      this._scrolling = !1;
	    }

	    'number' == typeof e && (this._position = -e), this._position < -this._extent ? this._position = -this._extent : this._position > 0 && (this._position = 0), this._element.style.transition = 'transform ' + (t || 0.2) + 's ease-out', this._element.style.webkitTransition = '-webkit-transform ' + (t || 0.2) + 's ease-out', this.updatePosition(), this._element.addEventListener('transitionend', this._onTransitionEnd), this._element.addEventListener('webkitTransitionEnd', this._onTransitionEnd);
	  };

	  Scroller.prototype.dispatchScroll = function () {
	    if ('function' == typeof this._options.onScroll && Math.round(this._lastPos) !== Math.round(this._position)) {
	      this._lastPos = this._position;
	      var e = {
	        target: {
	          scrollLeft: this._enableX ? -this._position : 0,
	          scrollTop: this._enableY ? -this._position : 0,
	          scrollHeight: this._scrollHeight || this._element.offsetHeight,
	          scrollWidth: this._scrollWidth || this._element.offsetWidth,
	          offsetHeight: this._element.parentElement.offsetHeight,
	          offsetWidth: this._element.parentElement.offsetWidth
	        }
	      };
	      this._options.onScroll(e);
	    }
	  };

	  Scroller.prototype.update = function (e, t, n) {
	    var i = 0,
	        r = this._position;
	    if (this._enableX) {
	      i = this._element.children.length ? (t || this._element.offsetWidth) - this._element.parentElement.offsetWidth : 0;

	      this._scrollWidth = t;
	    } else {
	      if (this._element.children.length) {
	        i = (t || this._element.offsetHeight) - this._element.parentElement.offsetHeight;
	      }

	      this._scrollHeight = t;
	    }

	    if ('number' == typeof e) {
	      this._position = -e;
	    }

	    if (this._position < -i) {
	      this._position = -i;
	    } else if (this._position > 0) {
	      this._position = 0;
	    }

	    this._itemSize = n || this._itemSize;

	    this.updatePosition();

	    if (r !== this._position) {
	      this.dispatchScroll();

	      if ('function' == typeof this._options.onSnap) {
	        this._options.onSnap(Math.floor(Math.abs(this._position) / this._itemSize));
	      }
	    }

	    this._extent = i;
	    this._scroll._extent = i;
	  };

	  Scroller.prototype.updatePosition = function () {
	    var e = '';

	    this._enableX ? e = 'translateX(' + this._position + 'px) translateZ(0)' : this._enableY && (e = 'translateY(' + this._position + 'px) translateZ(0)');

	    this._element.style.webkitTransform = e;
	    this._element.style.transform = e;
	  };

	  Scroller.prototype.isScrolling = function () {
	    return this._scrolling || this._snapping;
	  };

	  /* @polymerMixin */
	  var Scroller$1 = (function (superClass) {
	    return function (_superClass) {
	      inherits(_class, _superClass);

	      function _class() {
	        classCallCheck(this, _class);
	        return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
	      }

	      createClass(_class, [{
	        key: 'initScroller',
	        value: function initScroller(e, t) {
	          this._touchInfo = {
	            trackingID: -1,
	            maxDy: 0,
	            maxDx: 0
	          };

	          this._scroller = new Scroller(e, t);
	          this.__handleTouchStart = this._handleTouchStart.bind(this);
	          this.__handleTouchMove = this._handleTouchMove.bind(this);
	          this.__handleTouchEnd = this._handleTouchEnd.bind(this);
	          this._initedScroller = true;
	        }
	      }, {
	        key: '_findDelta',
	        value: function _findDelta(e) {
	          var t = this._touchInfo;

	          return 'move' == e.detail.state || 'end' == e.detail.state ? {
	            x: e.detail.dx,
	            y: e.detail.dy
	          } : {
	            x: e.screenX - t.x,
	            y: e.screenY - t.y
	          };
	        }
	      }, {
	        key: '_handleTouchStart',
	        value: function _handleTouchStart(e) {
	          var t = this._touchInfo;
	          var n = this._scroller;

	          n && ('start' == e.detail.state ? (t.trackingID = 'touch', t.x = e.detail.x, t.y = e.detail.y) : (t.trackingID = 'mouse', t.x = e.screenX, t.y = e.screenY), t.maxDx = 0, t.maxDy = 0, t.historyX = [0], t.historyY = [0], t.historyTime = [e.detail.timeStamp], t.listener = n, n.onTouchStart && n.onTouchStart());
	        }
	      }, {
	        key: '_handleTouchMove',
	        value: function _handleTouchMove(e) {
	          var t = this._touchInfo;

	          if (-1 != t.trackingID) {
	            e.preventDefault();
	            var n = this._findDelta(e);
	            if (n) {
	              for (t.maxDy = Math.max(t.maxDy, Math.abs(n.y)), t.maxDx = Math.max(t.maxDx, Math.abs(n.x)), t.historyX.push(n.x), t.historyY.push(n.y), t.historyTime.push(e.detail.timeStamp); t.historyTime.length > 10;) {
	                t.historyTime.shift(), t.historyX.shift(), t.historyY.shift();
	              }
	              t.listener && t.listener.onTouchMove && t.listener.onTouchMove(n.x, n.y, e.detail.timeStamp);
	            }
	          }
	        }
	      }, {
	        key: '_handleTouchEnd',
	        value: function _handleTouchEnd(e) {
	          var t = this._touchInfo;

	          if (-1 != t.trackingID) {
	            e.preventDefault();

	            var n = this._findDelta(e);

	            if (n) {
	              var i = t.listener;
	              t.trackingID = -1, t.listener = null;
	              var r = t.historyTime.length,
	                  o = {
	                x: 0,
	                y: 0
	              };
	              if (r > 2) {
	                for (var a = t.historyTime.length - 1, s = t.historyTime[a], l = t.historyX[a], c = t.historyY[a]; a > 0;) {
	                  a--;
	                  var u = t.historyTime[a],
	                      d = s - u;
	                  if (d > 30 && d < 50) {
	                    o.x = (l - t.historyX[a]) / (d / 1e3), o.y = (c - t.historyY[a]) / (d / 1e3);
	                    break;
	                  }
	                }
	              }
	              t.historyTime = [], t.historyX = [], t.historyY = [], i && i.onTouchEnd && i.onTouchEnd(n.x, n.y, o);
	            }
	          }
	        }
	      }]);
	      return _class;
	    }(superClass);
	  });

	  var _templateObject$19 = taggedTemplateLiteral(['\n      <style include="tt-picker-style">\n      </style>\n      <div id="main" class="tt-picker__group">\n        <div id="mask" class="tt-picker__mask"></div>\n        <div id="indicator" class="tt-picker__indicator"></div>\n        <div id="content" class="tt-picker__content">\n          <slot id="slot"></slot>\n        </div>\n      </div>\n    '], ['\n      <style include="tt-picker-style">\n      </style>\n      <div id="main" class="tt-picker__group">\n        <div id="mask" class="tt-picker__mask"></div>\n        <div id="indicator" class="tt-picker__indicator"></div>\n        <div id="content" class="tt-picker__content">\n          <slot id="slot"></slot>\n        </div>\n      </div>\n    ']);

	  var PickerViewColumn = function (_Scroller) {
	    inherits(PickerViewColumn, _Scroller);

	    function PickerViewColumn() {
	      classCallCheck(this, PickerViewColumn);
	      return possibleConstructorReturn(this, (PickerViewColumn.__proto__ || Object.getPrototypeOf(PickerViewColumn)).apply(this, arguments));
	    }

	    createClass(PickerViewColumn, [{
	      key: 'ready',
	      value: function ready() {
	        get(PickerViewColumn.prototype.__proto__ || Object.getPrototypeOf(PickerViewColumn.prototype), 'ready', this).call(this);

	        this.touchtrack(this.$.main, '_handleTrack', true);
	        this.__pageRerender = this._pageRerender.bind(this);
	      }
	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        var _this2 = this;

	        get(PickerViewColumn.prototype.__proto__ || Object.getPrototypeOf(PickerViewColumn.prototype), 'connectedCallback', this).call(this);

	        this._attached = true;

	        this._subtreeModified = false;
	        this._observer = new MutationObserver(function () {
	          _this2._subtreeModified = true;
	        });

	        this._observer.observe(this, {
	          childList: true,
	          subtree: true
	        });

	        document.addEventListener('pageReRender', this.__pageRerender);

	        this.dispatchEvent(new CustomEvent('pickerColumnChanged', {
	          detail: { add: true, col: this },
	          bubbles: true,
	          composed: true
	        }));
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        get(PickerViewColumn.prototype.__proto__ || Object.getPrototypeOf(PickerViewColumn.prototype), 'disconnectedCallback', this).call(this);

	        this._attached = false;

	        this.dispatchEvent(new CustomEvent('pickerColumnChanged', {
	          detail: { add: false, col: this },
	          bubbles: true,
	          composed: true
	        }));

	        this._observer.disconnect();

	        document.removeEventListener('pageReRender', this.__pageRerender);
	      }
	    }, {
	      key: '_pageRerender',
	      value: function _pageRerender() {
	        if (this._subtreeModified) {

	          var e = this.$.indicator.offsetHeight;
	          var t = this.children;
	          var n = 0,
	              i = t.length;

	          for (; n < i; n++) {
	            var r = t.item(n);
	            r.style.height = e + 'px';
	            r.style.overflow = 'hidden';
	          }

	          this._itemHeight = e;
	          this._scroller.update();
	          this._subtreeModified = false;
	        }
	      }
	    }, {
	      key: '_handleTrack',
	      value: function _handleTrack(e) {
	        if (this._scroller) {
	          switch (e.detail.state) {
	            case 'start':
	              this._handleTouchStart(e);
	              break;

	            case 'move':
	              this._handleTouchMove(e);
	              break;

	            case 'end':
	            case 'cancel':
	              this._handleTouchEnd(e);
	          }
	        }
	      }
	    }, {
	      key: '_handleTap',
	      value: function _handleTap(e) {
	        if (e.target !== e.currentTarget && !this._scroller.isScrolling()) {

	          var t = e.touches && e.touches[0] && e.touches[0].clientY;

	          var n = 'number' == typeof t ? t : e.detail.y - document.body.scrollTop;

	          var i = this.getBoundingClientRect();
	          var r = n - i.top - this._height / 2;
	          var o = this._itemHeight / 2;

	          if (!(Math.abs(r) <= o)) {

	            var a = Math.ceil((Math.abs(r) - o) / this._itemHeight);
	            var s = r < 0 ? -a : a;

	            this._current += s;
	            this._scroller.scrollTo(this._current * this._itemHeight);

	            this.dispatchEvent(new CustomEvent('pickerColumnValueChanged', {
	              detail: { idx: this._current },
	              bubbles: true,
	              composed: true
	            }));
	          }
	        }
	      }
	    }, {
	      key: '_getCurrent',
	      value: function _getCurrent() {
	        return this._current || 0;
	      }
	    }, {
	      key: '_setCurrent',
	      value: function _setCurrent(e) {
	        var t = Math.max(this.children.length - 1, 0);
	        this._current = Math.min(e, t);
	      }
	    }, {
	      key: '_setStyle',
	      value: function _setStyle(e, t) {
	        // convert e, t to rpx
	        this.$.indicator.setAttribute('style', tt.transformRpx(e));
	        this.$.mask.setAttribute('style', tt.transformRpx(t));
	      }
	    }, {
	      key: '_setClass',
	      value: function _setClass(e, t) {
	        e = this.getClassPrefix() + e;
	        t = this.getClassPrefix() + t;

	        this.$.indicator.setAttribute('class', 'tt-picker__indicator ' + e);
	        this.$.mask.setAttribute('class', 'tt-picker__mask ' + t);
	      }
	    }, {
	      key: '_setHeight',
	      value: function _setHeight(e) {
	        var t = this.$.indicator.offsetHeight;
	        var n = this.children;

	        for (var i = 0, r = n.length; i < r; i++) {
	          var o = n[i];

	          o.style.height = t + 'px';
	          o.style.overflow = 'hidden';
	        }

	        this._itemHeight = t;
	        this.$.main.style.height = e + 'px';

	        var a = (e - t) / 2;

	        this.$.mask.style.backgroundSize = '100% ' + a + 'px';
	        this.$.indicator.style.top = a + 'px';
	        this.$.content.style.padding = a + 'px 0';
	        this._height = this.offsetHeight;
	      }
	    }, {
	      key: '_init',
	      value: function _init() {
	        var _this3 = this;

	        this.initScroller(this.$.content, {
	          enableY: true,
	          enableX: false,
	          enableSnap: true,
	          itemSize: this._itemHeight,
	          onSnap: function (t) {
	            if (_this3._attached && t !== _this3._current) {
	              _this3._current = t;
	              _this3.dispatchEvent(new CustomEvent('pickerColumnValueChanged', {
	                detail: { idx: t },
	                bubbles: true,
	                composed: true
	              }));
	            }
	          }
	        });
	      }
	    }, {
	      key: '_update',
	      value: function _update() {
	        this._scroller.update(this._current * this._itemHeight, undefined, this._itemHeight);
	      }
	    }, {
	      key: 'listeners',
	      get: function () {
	        return {
	          tap: '_handleTap'
	        };
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$19);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-picker-view-column';
	      }
	    }]);
	    return PickerViewColumn;
	  }(Scroller$1(ClassPrefix(TouchTrack(Base(PolymerElement)))));

	  window.customElements.define(PickerViewColumn.is, PickerViewColumn);

	  var $_documentContainer$9 = document.createElement('div');
	  $_documentContainer$9.setAttribute('style', 'display: none;');

	  $_documentContainer$9.innerHTML = '<dom-module id="tt-video-style">\n  <template>\n    <style>\n    :host {\n      width: 300px;\n      height: 225px;\n      display: inline-block;\n      line-height: 0;\n      overflow: hidden;\n      position: relative;\n      z-index: 1;\n    }\n\n    :host([ hidden ]) {\n      display: none;\n    }\n\n    #container {\n      width: 100%;\n      height: 100%;\n      background-color: black;\n      display: inline-block;\n      position: absolute;\n      top: 0;\n      left: 0;\n    }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$9);

	  var _templateObject$20 = taggedTemplateLiteral(['\n      <style include="tt-video-style">\n      </style>\n      <video id="video" src="[[ src ]]"\n        autoplay="[[ autoplay ]]"\n        controls\n        style="width: 100%; height: 100%;"\n        on-play="_handle" on-pause="_handle" on-ended="_handle"\n      ></video>\n    '], ['\n      <style include="tt-video-style">\n      </style>\n      <video id="video" src="[[ src ]]"\n        autoplay="[[ autoplay ]]"\n        controls\n        style="width: 100%; height: 100%;"\n        on-play="_handle" on-pause="_handle" on-ended="_handle"\n      ></video>\n    ']);

	  var Video = function (_Base) {
	    inherits(Video, _Base);

	    function Video() {
	      classCallCheck(this, Video);
	      return possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
	    }

	    createClass(Video, [{
	      key: '_handle',
	      value: function _handle(e) {
	        this.triggerEvent(e.type);
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$20);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-video';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          src: {
	            type: String
	          },
	          autoplay: {
	            type: Boolean,
	            value: false
	          }
	        };
	      }
	    }]);
	    return Video;
	  }(Base(GestureEventListeners(PolymerElement)));

	  window.customElements.define(Video.is, Video);

	  var $_documentContainer$10 = document.createElement('div');
	  $_documentContainer$10.setAttribute('style', 'display: none;');

	  $_documentContainer$10.innerHTML = '<dom-module id="tt-swiper-style">\n  <template>\n    <style>\n      ::slotted(*) {\n        -webkit-user-select: none;\n        user-select: none;\n      }\n      :host {\n        display: block;\n        height: 150px;\n        -webkit-user-select: none;\n        user-select: none;\n      }\n      :host([hidden]) {\n        display: none;\n      }\n      :host .tt-swiper-wrapper {\n        overflow: hidden;\n        position: relative;\n        width: 100%;\n        height: 100%;\n        -webkit-transform: translateZ(0);\n                transform: translateZ(0);\n      }\n      :host .tt-swiper-slides {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n      }\n      :host .tt-swiper-slide-frame {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        will-change: transform;\n      }\n      :host .tt-swiper-dots {\n        position: absolute;\n        font-size: 0;\n      }\n      :host .tt-swiper-dots-horizontal {\n        left: 50%;\n        bottom: 10px;\n        text-align: center;\n        white-space: nowrap;\n        -webkit-transform: translate(-50%, 0);\n        transform: translate(-50%, 0);\n      }\n      :host .tt-swiper-dots-horizontal .tt-swiper-dot {\n        margin-right: 8px;\n      }\n      :host .tt-swiper-dots-horizontal .tt-swiper-dot:last-child {\n        margin-right: 0;\n      }\n      :host .tt-swiper-dots-vertical {\n        right: 10px;\n        top: 50%;\n        text-align: right;\n        -webkit-transform: translate(0, -50%);\n        transform: translate(0, -50%);\n      }\n      :host .tt-swiper-dots-vertical .tt-swiper-dot {\n        display: block;\n        margin-bottom: 9px;\n      }\n      :host .tt-swiper-dots-vertical .tt-swiper-dot:last-child {\n        margin-bottom: 0;\n      }\n      :host .tt-swiper-dot {\n        display: inline-block;\n        width: 8px;\n        height: 8px;\n        cursor: pointer;\n        transition-property: background-color;\n        transition-timing-function: ease;\n        background: rgba(0, 0, 0, 0.3);\n        border-radius: 50%;\n      }\n      :host .tt-swiper-dot-active {\n        background-color: #000000;\n      }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$10);

	  var _templateObject$21 = taggedTemplateLiteral(['\n    <style include="tt-swiper-style">\n    </style>\n    <div id="slidesWrapper" class="tt-swiper-wrapper">\n\n      <div id="slides" class="tt-swiper-slides">\n        <div id="slideFrame" class="tt-swiper-slide-frame">\n          <slot></slot>\n        </div>\n      </div>\n\n      <div id="slidesDots" style$="display: [[showDots(indicatorDots)]]" class$="tt-swiper-dots [[dotsClassIfVertical(vertical)]]"></div>\n    </div>\n    '], ['\n    <style include="tt-swiper-style">\n    </style>\n    <div id="slidesWrapper" class="tt-swiper-wrapper">\n\n      <div id="slides" class="tt-swiper-slides">\n        <div id="slideFrame" class="tt-swiper-slide-frame">\n          <slot></slot>\n        </div>\n      </div>\n\n      <div id="slidesDots" style\\$="display: [[showDots(indicatorDots)]]" class\\$="tt-swiper-dots [[dotsClassIfVertical(vertical)]]"></div>\n    </div>\n    ']);

	  var device$1 = getDeviceType();

	  var Swiper = function (_TouchTrack) {
	    inherits(Swiper, _TouchTrack);
	    createClass(Swiper, null, [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$21);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-swiper';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          indicatorDots: {
	            type: Boolean,
	            value: false
	          },
	          vertical: {
	            type: Boolean,
	            value: false,
	            observer: '_updateLayout'
	          },
	          autoplay: {
	            type: Boolean,
	            value: false,
	            observer: '_autoplayChanged'
	          },
	          circular: {
	            type: Boolean,
	            value: false,
	            observer: '_updateLayout'
	          },
	          interval: {
	            type: Number,
	            value: 5e3,
	            observer: '_autoplayChanged'
	          },
	          duration: {
	            type: Number,
	            value: 500
	          },
	          current: {
	            type: Number,
	            value: 0,
	            observer: '_currentChanged'
	          },
	          indicatorSize: {
	            type: Number,
	            value: 8
	          },
	          indicatorColor: {
	            type: String,
	            value: '',
	            observer: '_updateDotsColor'
	          },
	          indicatorActiveColor: {
	            type: String,
	            value: '',
	            observer: '_updateDotsColor'
	          },
	          previousMargin: {
	            type: String,
	            value: '',
	            observer: '_updateMargin'
	          },
	          nextMargin: {
	            type: String,
	            value: '',
	            observer: '_updateMargin',
	            public: true
	          },
	          currentItemId: {
	            type: String,
	            value: '',
	            observer: '_currentItemIdChanged'
	          },
	          skipHiddenItemLayout: {
	            type: Boolean,
	            value: false,
	            observer: '_skipHiddenItemLayoutChanged'
	          },
	          displayMultipleItems: {
	            type: Number,
	            value: 1,
	            observer: '_displayMultiItemsChanged'
	          }
	        };
	      }
	    }]);

	    function Swiper() {
	      classCallCheck(this, Swiper);

	      var _this = possibleConstructorReturn(this, (Swiper.__proto__ || Object.getPrototypeOf(Swiper)).call(this));

	      _this._attached = false;
	      _this._invalid = true;
	      _this._circularEnabled = false;
	      _this._currentChangeSource = '';
	      _this._viewportPosition = 0;
	      _this._marginSpecified = false;
	      _this._viewportMoveRatio = 1;
	      _this._scheduleTimeoutObj = null;
	      _this._animating = null;
	      _this._requestedAnimation = false;
	      _this._animateFrameFunc = _this._animateFrameFuncProto.bind(_this);
	      _this._itemIdItemMap = {};
	      _this._items = [];
	      _this._itemListDirty = false;
	      _this._userTracking = false;
	      _this._userDirectionChecked = false;
	      _this._contentTrackViewport = 0;
	      _this._contentTrackSpeed = 0;
	      _this._contentTrackT = 0;
	      _this._skipHiddenItemLayoutModified = false;

	      _this.__resetLayout_defer_id = null;
	      _this.__resetLayout = function () {
	        // Throttled layout function
	        clearTimeout(_this.__resetLayout_defer_id);
	        _this.__resetLayout_defer_id = setTimeout(_this._resetLayout.bind(_this), 0);
	      };
	      return _this;
	    }

	    createClass(Swiper, [{
	      key: 'ready',
	      value: function ready() {
	        var _this2 = this;

	        get(Swiper.prototype.__proto__ || Object.getPrototypeOf(Swiper.prototype), 'ready', this).call(this);

	        this.touchtrack(this.$.slidesWrapper, '_handleContentTrack', true);

	        // watch children
	        this.addEventListener('swiper-item-link', function (e) {
	          e.stopPropagation();
	          _this2._itemListChanged();
	          _this2.__resetLayout();
	        });

	        this.addEventListener('swiper-item-unlink', function (e) {
	          e.stopPropagation();
	          _this2._itemListChanged();

	          if (_this2._getPositionFromCurrent() < 0) {
	            // 说明原来的current值已经无效了
	            _this2._currentChangeSource = '__none__';
	            _this2.current = 0;
	          }

	          _this2.__resetLayout();
	        });

	        this.addEventListener('swiper-item-idupdate', function (e) {
	          e.stopPropagation();
	          var _e$detail = e.detail,
	              el = _e$detail.el,
	              value = _e$detail.value,
	              oldValue = _e$detail.oldValue;

	          _this2._itemIdUpdated(el, value, oldValue);
	        });
	      }
	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        get(Swiper.prototype.__proto__ || Object.getPrototypeOf(Swiper.prototype), 'connectedCallback', this).call(this);

	        this._attached = true;
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        get(Swiper.prototype.__proto__ || Object.getPrototypeOf(Swiper.prototype), 'disconnectedCallback', this).call(this);

	        this._attached = false;
	        this._cancelSchedule();
	      }
	    }, {
	      key: '_itemIdUpdated',
	      value: function _itemIdUpdated(e, t, n) {
	        if (t !== n) {
	          this._itemListChanged();
	          this.currentItemId && this._currentItemIdChanged();
	        }
	      }
	    }, {
	      key: '_currentItemIdChanged',
	      value: function _currentItemIdChanged(e) {
	        if ('__none__' === this._currentChangeSource) {
	          this._currentChangeSource = '';
	          return;
	        }

	        if (e !== '') {
	          this.current = this._getPositionFromCurrent();
	        }
	      }
	    }, {
	      key: '_currentChanged',
	      value: function _currentChanged(e, t) {
	        if ('__none__' === this._currentChangeSource) {
	          this._currentChangeSource = '';
	          return;
	        }

	        var n = this._currentChangeSource;
	        this._currentChangeSource = '';

	        if (!this._isCurrentValueLegal(e)) {
	          this.__resetLayout();
	          return;
	        }

	        if (!this._isCurrentValueLegal(t)) {
	          this.__resetLayout();
	          return;
	        }

	        if (!n) {
	          this._animateViewport(e, '', 0);
	        }

	        if (e != t) {
	          var i = this._getItems()[e];

	          if (i) {
	            this.currentItemId = i.itemId;

	            this.triggerEvent('change', {
	              current: this.current,
	              currentItemId: i.itemId,
	              source: n
	            });
	          }

	          this._updateDots(e);
	        }
	      }
	    }, {
	      key: '_updateMargin',
	      value: function _updateMargin() {
	        this._marginSpecified = true;
	        this.__resetLayout();
	      }
	    }, {
	      key: '_skipHiddenItemLayoutChanged',
	      value: function _skipHiddenItemLayoutChanged() {
	        this._skipHiddenItemLayoutModified = true;
	        this._updateLayout();
	      }
	    }, {
	      key: '_updateLayout',
	      value: function _updateLayout() {
	        this.__resetLayout();
	      }
	    }, {
	      key: '_displayMultiItemsChanged',
	      value: function _displayMultiItemsChanged() {
	        var items = this._getItems();
	        if (items.length >= this.displayMultipleItems && items.length - this.displayMultipleItems < this.current) {
	          this.current = items.length - this.displayMultipleItems;
	          if (this.currentItemId) {
	            this.currentItemId = items[this.current].itemId;
	          }
	          this._currentChangeSource = '__none__';
	        }
	        this.__resetLayout();
	      }
	    }, {
	      key: '_autoplayChanged',
	      value: function _autoplayChanged(e) {
	        e ? this._scheduleAutoplay() : this._cancelSchedule();
	      }
	    }, {
	      key: '_itemListChanged',
	      value: function _itemListChanged() {
	        this._itemListDirty = true;
	      }
	    }, {
	      key: '_updateItemList',
	      value: function _updateItemList() {
	        var _this3 = this;

	        this._itemListDirty = false;
	        // get children connected to me
	        var swiperItems = Array.prototype.slice.call(this.querySelectorAll('tt-swiper-item'));
	        this._items = swiperItems.filter(function (i) {
	          return _this3._isThatMyItem(i);
	        });
	        this._items.forEach(function (t) {
	          if (t.itemId && !_this3._itemIdItemMap[t.itemId]) {
	            _this3._itemIdItemMap[t.itemId] = t;
	          }
	        });
	      }
	    }, {
	      key: '_getItems',
	      value: function _getItems() {
	        this._itemListDirty && this._updateItemList();

	        return this._items;
	      }
	    }, {
	      key: '_getItemByItemId',
	      value: function _getItemByItemId(e) {
	        this._itemListDirty && this._updateItemList();

	        return this._itemIdItemMap[e];
	      }
	    }, {
	      key: '_isThatMyItem',
	      value: function _isThatMyItem(target) {
	        var _this4 = this;

	        var isMe = function (node) {
	          if (node.tagName.toUpperCase() === 'TT-SWIPER') {
	            if (node === _this4) {
	              return true;
	            } else {
	              return false;
	            }
	          }
	          if (node.parentElement) {
	            return isMe(node.parentElement);
	          }
	          return false;
	        };
	        return isMe(target.parentElement);
	      }
	    }, {
	      key: '_scheduleAutoplay',
	      value: function _scheduleAutoplay() {
	        var e = this;

	        this._cancelSchedule();

	        if (!this._attached || this._invalid || this._getItems().length <= this.displayMultipleItems) {
	          return;
	        }

	        var t = function () {
	          e._currentChangeSource = 'autoplay';

	          if (e._circularEnabled) {
	            e.current = e._normalizeCurrentValue(e.current + 1);
	          } else {
	            e.current = e.current + e.displayMultipleItems < e._getItems().length ? e.current + 1 : 0;
	          }

	          e._animateViewport(e.current, 'autoplay', e._circularEnabled ? 1 : 0);
	          e._scheduleTimeoutObj = setTimeout(t, e.interval);
	        };

	        this._scheduleTimeoutObj = setTimeout(t, this.interval);
	      }
	    }, {
	      key: '_cancelSchedule',
	      value: function _cancelSchedule() {
	        if (this._scheduleTimeoutObj) {
	          clearTimeout(this._scheduleTimeoutObj);
	          this._scheduleTimeoutObj = null;
	        }
	      }
	    }, {
	      key: '_updateDots',
	      value: function _updateDots(current) {
	        var valid = !this._invalid;
	        var $slidesDots = this.$.slidesDots;

	        $slidesDots.innerHTML = '';

	        var items = this._getItems();

	        for (var i = 0, l = items.length; i < l; i++) {
	          var a = document.createElement('div');
	          var MIN_INDICATOR_SIZE = 4;
	          var size = this.indicatorSize > 0 ? this.indicatorSize : MIN_INDICATOR_SIZE;

	          a.setAttribute('data-dot-index', i);
	          a.style.width = a.style.height = a.style.marginRight = size + 'px';
	          $slidesDots.appendChild(a);

	          if (valid && i >= current && i < current + this.displayMultipleItems || i < current + this.displayMultipleItems - l) {
	            a.setAttribute('class', 'tt-swiper-dot tt-swiper-dot-active');

	            if (this.indicatorActiveColor) {
	              a.style.backgroundColor = this.indicatorActiveColor;
	            }
	          } else {
	            a.setAttribute('class', 'tt-swiper-dot');
	            if (this.indicatorColor) {
	              a.style.backgroundColor = this.indicatorColor;
	            }
	          }
	        }
	      }
	    }, {
	      key: '_updateDotsColor',
	      value: function _updateDotsColor() {
	        for (var e = this.$.slidesDots, t = 0; t < e.childNodes.length; t++) {
	          var n = e.childNodes[t];

	          if (n.getAttribute('class').indexOf('tt-swiper-dot-active') >= 0) {
	            if (this.indicatorActiveColor) {
	              n.style.backgroundColor = this.indicatorActiveColor;
	            }
	          } else {
	            if (this.indicatorColor) {
	              n.style.backgroundColor = this.indicatorColor;
	            }
	          }
	        }
	      }
	    }, {
	      key: '_normalizeCurrentValue',
	      value: function _normalizeCurrentValue(e) {
	        var t = this._getItems().length;

	        if (!t) {
	          return -1;
	        }

	        var n = (Math.round(e) % t + t) % t;

	        if (this._circularEnabled) {
	          if (t <= this.displayMultipleItems) {
	            return 0;
	          }
	        } else if (n > t - this.displayMultipleItems) {
	          return t - this.displayMultipleItems;
	        }

	        return n;
	      }
	    }, {
	      key: '_isCurrentValueLegal',
	      value: function _isCurrentValueLegal(e) {
	        return !!this._getItems().length && e === this._normalizeCurrentValue(e);
	      }
	    }, {
	      key: '_transformPropRpx',
	      value: function _transformPropRpx(e) {
	        if (/^\s*[+-]?\d+(\.\d+)?(px)?\s*$/i.test(e)) {
	          return 'px' !== e.slice(-2) ? e + 'px' : e;
	        } else if (/^\s*[+-]?\d+(\.\d+)?rpx\s*$/i.test(e)) {
	          tt.transformRpx(e);
	        } else {
	          return '';
	        }
	      }
	    }, {
	      key: '_getPositionFromCurrent',
	      value: function _getPositionFromCurrent() {
	        if (this.currentItemId) {
	          return this._getItems().indexOf(this._getItemByItemId(this.currentItemId));
	        }

	        if (this._isCurrentValueLegal(this.current)) {
	          return this.current;
	        }

	        return -2;
	      }
	    }, {
	      key: '_updateHiddenItemDisplay',
	      value: function _updateHiddenItemDisplay(e) {
	        if (this._skipHiddenItemLayoutModified) {
	          for (var t = this._getItems(), n = 0; n < t.length; n++) {
	            var i = t[n];
	            var r = i._position <= e - 2 || i._position >= e + this.displayMultipleItems + 1;

	            i.style.display = r ? 'none' : i._originalDisplay;
	          }
	        }
	      }
	    }, {
	      key: '_resetLayout',
	      value: function _resetLayout() {
	        if (this._attached) {
	          this._cancelSchedule();
	          this._endViewportAnimation();

	          var items = this._getItems();

	          if (this.currentItemId) {
	            this.current = this._getPositionFromCurrent();
	            if ('__none__' === this._currentChangeSource) {
	              this._currentChangeSource = '';
	            }
	          }

	          var $slides = this.$.slides;
	          var $slideFrame = this.$.slideFrame;

	          if (this.vertical) {

	            if (this._marginSpecified) {
	              $slides.style.left = 0;
	              $slides.style.right = 0;
	              $slides.style.top = this._transformPropRpx(this.previousMargin);
	              $slides.style.bottom = this._transformPropRpx(this.nextMargin);
	            }

	            $slideFrame.style.width = '100%';
	            $slideFrame.style.height = Math.abs(100 / this.displayMultipleItems) + '%';
	          } else {
	            if (this._marginSpecified) {
	              $slides.style.top = 0;
	              $slides.style.bottom = 0;
	              $slides.style.left = this._transformPropRpx(this.previousMargin);
	              $slides.style.right = this._transformPropRpx(this.nextMargin);
	            }

	            $slideFrame.style.height = '100%';
	            $slideFrame.style.width = Math.abs(100 / this.displayMultipleItems) + '%';
	          }

	          this._itemPos = [];

	          for (var i = 0; i < items.length; i++) {
	            if (this._skipHiddenItemLayoutModified) {
	              items[i].style.display = items[i]._originalDisplay;
	            }

	            this._updateItemPos(i, i);
	          }

	          this._viewportMoveRatio = 1;

	          if (1 === this.displayMultipleItems && items.length) {
	            var r = items[0].getBoundingClientRect();
	            var o = this.$.slideFrame.getBoundingClientRect();

	            this._viewportMoveRatio = r.width / o.width;

	            if (this._viewportMoveRatio > 1) {
	              this._viewportMoveRatio = 1;
	            }
	          }

	          this._circularEnabled = this.circular && items.length > this.displayMultipleItems;

	          var a = this._viewportPosition;
	          this._viewportPosition = -2;

	          var s = this._getPositionFromCurrent();

	          if (s >= 0) {

	            this._invalid = false;

	            if (this._userTracking) {
	              this._updateViewport(a + s - this._contentTrackViewport);
	              this._contentTrackViewport = s;
	            } else {
	              this._updateViewport(s);
	            }

	            this.autoplay && this._scheduleAutoplay();
	          } else {
	            this._invalid = true;
	            this._updateViewport(-this.displayMultipleItems - 1);
	          }

	          this._updateDots(s);
	        }
	      }
	    }, {
	      key: '_checkCircularLayout',
	      value: function _checkCircularLayout(e) {
	        if (!this._invalid) {
	          var t = this._getItems();
	          var n = t.length;
	          var i = e + this.displayMultipleItems;

	          for (var r = 0; r < n; r++) {
	            var o = t[r];
	            var a = o._position;
	            var s = Math.floor(e / n) * n + r;
	            var l = s + n;
	            var c = s - n;
	            var u = Math.max(e - (s + 1), s - i, 0);
	            var d = Math.max(e - (l + 1), l - i, 0);
	            var h = Math.max(e - (c + 1), c - i, 0);
	            var p = Math.min(u, d, h);
	            var f = [s, l, c][[u, d, h].indexOf(p)];

	            a !== f && this._updateItemPos(r, f);
	          }
	        }
	      }
	    }, {
	      key: '_updateItemPos',
	      value: function _updateItemPos(e, t) {
	        // 计算各元素的位置偏移
	        var x = this.vertical ? '0' : 100 * t + '%';
	        var y = this.vertical ? 100 * t + '%' : '0';
	        var transfrom = 'translate(' + x + ', ' + y + ') translateZ(0)';
	        var item = this._getItems()[e];

	        item.style['-webkit-transform'] = transfrom;
	        item.style.transform = transfrom;
	        item.style.position = 'absolute';
	        item.style.width = '100%';
	        item.style.height = '100%';
	        item._position = t;
	      }
	    }, {
	      key: '_updateViewport',
	      value: function _updateViewport(e) {
	        if (Math.floor(2 * this._viewportPosition) !== Math.floor(2 * e) || Math.ceil(2 * this._viewportPosition) === Math.ceil(2 * e)) {

	          this._circularEnabled && this._checkCircularLayout(e);
	          this.skipHiddenItemLayout && this._updateHiddenItemDisplay(e);
	        }

	        var t = this.vertical ? '0' : 100 * -e * this._viewportMoveRatio + '%';
	        var n = this.vertical ? 100 * -e * this._viewportMoveRatio + '%' : '0';
	        var i = 'translate(' + t + ', ' + n + ') translateZ(0)';

	        this.$.slideFrame.style['-webkit-transform'] = i;
	        this.$.slideFrame.style.transform = i;
	        this._viewportPosition = e;

	        window.__virtualDOM__.scheduleIntersectionUpdate();
	      }
	    }, {
	      key: '_animateFrameFuncProto',
	      value: function _animateFrameFuncProto() {
	        if (!this._animating) {
	          this._requestedAnimation = false;
	          return;
	        }

	        var e = this._animating;
	        var t = e.toPos;
	        var n = e.acc;
	        var i = e.endTime;
	        var r = e.source;
	        var o = i - Date.now();

	        if (o <= 0) {
	          this._updateViewport(t);
	          this._animating = null;
	          this._requestedAnimation = false;

	          var a = this._getItems()[this.current];

	          a && this.triggerEvent('animationfinish', {
	            current: this.current,
	            currentItemId: a.itemId,
	            source: r
	          });

	          return;
	        }

	        var s = n * o * o / 2;
	        var l = t + s;

	        this._updateViewport(l);
	        window.requestAnimationFrame(this._animateFrameFunc);
	      }
	    }, {
	      key: '_animateViewport',
	      value: function _animateViewport(e, t, n) {
	        this._cancelViewportAnimation();

	        var i = this.duration;
	        var r = this._getItems().length;
	        var o = this._viewportPosition;

	        if (n < 0) {
	          while (o < e) {
	            o += r;
	          }
	          while (o - r > e) {
	            o -= r;
	          }
	        } else if (n > 0) {
	          while (o > e) {
	            o -= r;
	          }
	          while (o + r < e) {
	            o += r;
	          }
	        } else {
	          while (o + r < e) {
	            o += r;
	          }
	          while (o - r > e) {
	            o -= r;
	          }
	          if (o + r - e < e - o) {
	            o += r;
	          }
	        }

	        this._animating = {
	          toPos: e,
	          acc: 2 * (o - e) / (i * i),
	          endTime: Date.now() + i,
	          source: t
	        };

	        if (!this._requestedAnimation) {
	          this._requestedAnimation = true;
	          window.requestAnimationFrame(this._animateFrameFunc);
	        }
	      }
	    }, {
	      key: '_cancelViewportAnimation',
	      value: function _cancelViewportAnimation() {
	        this._animating = null;
	      }
	    }, {
	      key: '_endViewportAnimation',
	      value: function _endViewportAnimation() {
	        if (this._animating) {
	          this._updateViewport(this._animating.toPos);
	          this._animating = null;
	        }
	      }
	    }, {
	      key: '_handleTrackStart',
	      value: function _handleTrackStart(e) {
	        this._inDangerArea = e.x <= 53 && 'ios' === device$1; // ios设备在屏幕左侧该区域右滑会触发webview返回

	        this._cancelSchedule();
	        this._contentTrackViewport = this._viewportPosition;
	        this._contentTrackSpeed = 0;
	        this._contentTrackT = Date.now();
	        this._cancelViewportAnimation();
	      }
	    }, {
	      key: '_handleTrackMove',
	      value: function _handleTrackMove(e) {
	        var _this5 = this;

	        var lastT = this._contentTrackT;

	        this._contentTrackT = Date.now();
	        var ellapsedT = this._contentTrackT - lastT;

	        if (this._frozen) {
	          return;
	        }

	        if (e.x < 0 || e.y < 0) {
	          this._frozen = true;
	          return;
	        }

	        if (e.x <= 55 && e.ddx > 0 && this._inDangerArea) {
	          this._frozen = true;
	          return;
	        }

	        if (ellapsedT === 0) {
	          return;
	        }

	        var i = this._getItems().length;
	        var r = i - this.displayMultipleItems;

	        var o = function (e) {
	          return 0.5 - 0.25 / (e + 0.5);
	        };

	        var a = function (e, n) {
	          var i = _this5._contentTrackViewport + e;

	          _this5._contentTrackSpeed = 0.6 * _this5._contentTrackSpeed + 0.4 * n;

	          if (!_this5._circularEnabled && (i < 0 || i > r)) {
	            if (i < 0) {
	              i = -o(-i);
	            } else if (i > r) {
	              i = r + o(i - r);
	            }

	            _this5._contentTrackSpeed = 0;
	          }
	          _this5._updateViewport(i);
	        };

	        if (this.vertical) {
	          a(-e.dy / this.$.slideFrame.offsetHeight, -e.ddy / ellapsedT);
	        } else {
	          a(-e.dx / this.$.slideFrame.offsetWidth, -e.ddx / ellapsedT);
	        }
	      }
	    }, {
	      key: '_handleTrackEnd',
	      value: function _handleTrackEnd(e) {

	        this.autoplay && this._scheduleAutoplay();
	        this._userTracking = false;
	        this._frozen = false;

	        var t = this._contentTrackSpeed / Math.abs(this._contentTrackSpeed);
	        var n = 0;

	        if (!e && Math.abs(this._contentTrackSpeed) > 0.2) {
	          n = 0.5 * t;
	        }

	        var i = this._normalizeCurrentValue(this._viewportPosition + n);

	        if (e) {
	          this._updateViewport(this._contentTrackViewport);
	        } else if (this.current !== i) {
	          this._currentChangeSource = 'touch';
	          this.current = i;
	          this._animateViewport(i, 'touch', n);
	        } else {
	          this._animateViewport(i, 'touch', n);
	        }
	      }
	    }, {
	      key: '_handleContentTrack',
	      value: function _handleContentTrack(e) {
	        if (!this._invalid) {
	          if ('start' === e.detail.state) {
	            this._userTracking = true;
	            this._userDirectionChecked = false;
	            return this._handleTrackStart(e.detail);
	          }
	          if ('end' === e.detail.state) {
	            return this._handleTrackEnd(false);
	          }

	          if ('cancel' === e.detail.state) {
	            return this._handleTrackEnd(true);
	          }

	          if (this._userTracking) {
	            if (!this._userDirectionChecked) {
	              this._userDirectionChecked = true;

	              var t = Math.abs(e.detail.dx);
	              var n = Math.abs(e.detail.dy);

	              if (t >= n && this.vertical) {
	                this._userTracking = false;
	              } else if (t <= n && !this.vertical) {
	                this._userTracking = false;
	              }

	              if (!this._userTracking) {
	                this.autoplay && this._scheduleAutoplay();
	                return;
	              }
	            }
	            // touchmove事件不冒泡，与微信对齐
	            e.stopPropagation();
	            this.dispatchEvent(new CustomEvent('tt-touchmove', {
	              detail: { srcMoveEvent: e },
	              bubbles: true,
	              composed: true
	            }));
	            // 避免页面滑动
	            e.preventDefault();
	            this._handleTrackMove(e.detail);
	            return false;
	          }
	        }
	      }
	    }, {
	      key: 'getScrollPosition',
	      value: function getScrollPosition() {
	        return {
	          scrollLeft: 0,
	          scrollTop: 0
	        };
	      }
	    }, {
	      key: 'dotsClassIfVertical',
	      value: function dotsClassIfVertical(vertical) {
	        return vertical ? 'tt-swiper-dots-vertical' : 'tt-swiper-dots-horizontal';
	      }
	    }, {
	      key: 'showDots',
	      value: function showDots(yes) {
	        return yes ? 'block' : 'none';
	      }
	    }]);
	    return Swiper;
	  }(TouchTrack(Base(PolymerElement)));

	  window.customElements.define(Swiper.is, Swiper);

	  var _templateObject$22 = taggedTemplateLiteral(['\n    <style>\n      :host {\n        display: block;\n        overflow: hidden;\n        will-change: \'transform\';\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n    </style>\n    <slot></slot>\n    '], ['\n    <style>\n      :host {\n        display: block;\n        overflow: hidden;\n        will-change: \'transform\';\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n    </style>\n    <slot></slot>\n    ']);

	  var SwiperItem = function (_Base) {
	    inherits(SwiperItem, _Base);

	    function SwiperItem() {
	      classCallCheck(this, SwiperItem);
	      return possibleConstructorReturn(this, (SwiperItem.__proto__ || Object.getPrototypeOf(SwiperItem)).apply(this, arguments));
	    }

	    createClass(SwiperItem, [{
	      key: 'ready',
	      value: function ready() {
	        get(SwiperItem.prototype.__proto__ || Object.getPrototypeOf(SwiperItem.prototype), 'ready', this).call(this);

	        this._relatedSwiper = this._findSwiper(this.parentElement);
	        if (!this._relatedSwiper) {
	          throw new Error('<swiper-item> can only be used as child of <swiper>');
	        }
	      }
	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        get(SwiperItem.prototype.__proto__ || Object.getPrototypeOf(SwiperItem.prototype), 'connectedCallback', this).call(this);

	        this._originalDisplay = this.style.display;
	        this._relatedSwiper.dispatchEvent(new CustomEvent('swiper-item-link', {
	          detail: { el: this },
	          bubbles: true
	        }));
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        this._relatedSwiper.dispatchEvent(new CustomEvent('swiper-item-unlink', {
	          detail: { el: this },
	          bubbles: true
	        }));

	        get(SwiperItem.prototype.__proto__ || Object.getPrototypeOf(SwiperItem.prototype), 'disconnectedCallback', this).call(this);
	      }
	    }, {
	      key: '_findSwiper',
	      value: function _findSwiper(el) {
	        if (el.tagName === 'TT-SWIPER') {
	          return el;
	        }
	        var parent = el.parentElement;
	        if (!parent) {
	          return null;
	        }
	        return this._findSwiper(parent);
	      }
	    }, {
	      key: '_updateId',
	      value: function _updateId(e, t) {
	        this.dispatchEvent(new CustomEvent('swiper-item-idupdate', {
	          detail: {
	            value: e,
	            oldValue: t
	          },
	          bubbles: true
	        }));
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$22);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-swiper-item';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          itemId: {
	            type: String,
	            value: '',
	            observer: '_updateId'
	          }
	        };
	      }
	    }]);
	    return SwiperItem;
	  }(Base(PolymerElement));

	  window.customElements.define(SwiperItem.is, SwiperItem);

	  var _templateObject$23 = taggedTemplateLiteral(['<style>\n      :host {\n        display: inline-block;\n        font-size: 0;\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n    </style>\n    <canvas width="0" height="0" id="mainCanvas"></canvas>'], ['<style>\n      :host {\n        display: inline-block;\n        font-size: 0;\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n    </style>\n    <canvas width="0" height="0" id="mainCanvas"></canvas>']);

	  var DEFAULT_WIDTH = 300;
	  var DEFAULT_HEIGHT = 225;

	  var stylePromise = null;

	  var ttCanvas = function (_Base) {
	    inherits(ttCanvas, _Base);

	    function ttCanvas() {
	      classCallCheck(this, ttCanvas);
	      return possibleConstructorReturn(this, (ttCanvas.__proto__ || Object.getPrototypeOf(ttCanvas)).apply(this, arguments));
	    }

	    createClass(ttCanvas, [{
	      key: 'ready',
	      value: function ready() {
	        var _this2 = this;

	        get(ttCanvas.prototype.__proto__ || Object.getPrototypeOf(ttCanvas.prototype), 'ready', this).call(this);

	        this._actionsDefer = [];
	        this._actionsWaiting = false;
	        this._images = {};

	        this.ctx = this.$.mainCanvas.getContext('2d');
	        // this.ctx.scale(devicePixelRatio, devicePixelRatio);

	        // 浏览器兼容性问题，ready的时候不一定能取到组件真实的宽高
	        stylePromise = Promise.resolve().then(function () {
	          stylePromise = null;
	          _this2._updateWidth(_this2.width);
	          _this2._updateHeight(_this2.height);
	        });
	      }
	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        get(ttCanvas.prototype.__proto__ || Object.getPrototypeOf(ttCanvas.prototype), 'connectedCallback', this).call(this);

	        this.__pageRerender = this._pageRerender.bind(this);
	        document.addEventListener('pageReRender', this.__pageRerender);
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback() {
	        get(ttCanvas.prototype.__proto__ || Object.getPrototypeOf(ttCanvas.prototype), 'disconnectedCallback', this).call(this);

	        document.removeEventListener('pageReRender', this.__pageRerender);
	      }
	    }, {
	      key: '_updateCanvasId',
	      value: function _updateCanvasId(newCanvasId, oldCanvasId) {
	        if (!newCanvasId) {
	          this.hidden = true;
	          this.triggerEvent('error', {
	            errMsg: 'canvas-id attribute is undefined'
	          });
	          console.error('canvas-id attribute is undefined');
	        } else if (newCanvasId !== oldCanvasId) {
	          this.init();
	        }
	      }
	    }, {
	      key: '_pageRerender',
	      value: function _pageRerender() {
	        var currentWidth = parseFloat(window.getComputedStyle(this).width);
	        var currentHeight = parseFloat(window.getComputedStyle(this).height);
	        if (currentWidth != this._width || currentHeight != this._height) {
	          if (currentWidth != this._width) {
	            this._updateWidth();
	          }
	          if (currentHeight != this._height) {
	            this._updateHeight();
	          }

	          // rerender
	          this.draw(this._lastReserve, this._lastActions, this._lastRandid);
	        }
	      }
	    }, {
	      key: '_updateWidth',
	      value: function _updateWidth(width) {
	        var realWidth = parseFloat(window.getComputedStyle(this).width);
	        if (!realWidth) {
	          realWidth = width || DEFAULT_WIDTH;
	        }
	        this._width = realWidth;
	        this.$.mainCanvas.style.width = realWidth + 'px';
	        this.$.mainCanvas.width = realWidth * devicePixelRatio;
	      }
	    }, {
	      key: '_updateHeight',
	      value: function _updateHeight(height) {
	        var realHeight = parseFloat(window.getComputedStyle(this).height);
	        if (!realHeight) {
	          realHeight = height || DEFAULT_HEIGHT;
	        }
	        this._height = realHeight;
	        this.$.mainCanvas.style.height = realHeight + 'px';
	        this.$.mainCanvas.height = realHeight * devicePixelRatio;
	      }
	    }, {
	      key: 'init',
	      value: function init() {
	        var _this3 = this;

	        ttJSBridge.subscribe('canvas' + this.canvasId + 'Draw', function (_ref) {
	          var actions = _ref.actions,
	              reserve = _ref.reserve,
	              randid = _ref.randid;

	          var item = {
	            reserve: reserve,
	            actions: actions,
	            randid: randid,
	            ts: Date.now()
	          };

	          if (_this3._queue) {
	            _this3._queue.push(item);
	          } else {
	            _this3._queue = [item];
	            _this3._drain();
	          }
	        });

	        ttJSBridge.subscribe('canvas' + this.canvasId + 'ToBase64', function (_ref2) {
	          var data = _ref2.data;
	          var x = data.x,
	              y = data.y,
	              width = data.width,
	              height = data.height,
	              destWidth = data.destWidth,
	              destHeight = data.destHeight;


	          _this3._box = _this3._getBox();

	          x = x || 0;
	          y = y || 0;

	          (x < 0 || x > _this3._box.width) && (x = 0);
	          (y < 0 || y > _this3._box.height) && (y = 0);

	          width = width ? Math.min(width, _this3._box.width - x) : _this3._box.width - x;

	          height = height ? Math.min(height, _this3._box.height - y) : _this3._box.height - y;

	          destWidth = destWidth || width;
	          destHeight = destHeight || height;

	          var cvs2 = document.createElement('canvas');
	          cvs2.width = destWidth;
	          cvs2.height = destHeight;
	          cvs2.getContext('2d').drawImage(_this3.$.mainCanvas, x * devicePixelRatio, y * devicePixelRatio, width * devicePixelRatio, height * devicePixelRatio, 0, 0, destWidth, destHeight);

	          ttJSBridge.publish('canvas' + _this3.canvasId + 'ToBase64Done', {
	            dataUrl: cvs2.toDataURL().replace(/^data:image\/(jpg|png);base64,/, '')
	          });
	        });

	        tt.publish('canvasInsert', {
	          canvasId: this.canvasId
	        });
	      }
	    }, {
	      key: '_drain',
	      value: function _drain() {
	        if (!this._queue.length) {
	          this._queue = null;
	          return;
	        }

	        var item = void 0;
	        while (this._queue.length) {
	          item = this._queue.shift();
	          // 测试发现16.7太苛刻了，放宽到20ms丢弃
	          if (Date.now() - item.ts < 20) {
	            break;
	          }
	        }

	        var _item = item,
	            reserve = _item.reserve,
	            actions = _item.actions,
	            randid = _item.randid;

	        this._lastActions = [].concat(toConsumableArray(actions));
	        this._lastReserve = reserve;
	        this._lastRandid = randid;
	        this.draw(reserve, actions, randid);
	        window.requestAnimationFrame(this._drain.bind(this));
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {
	        var reserve = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	        var _this4 = this;

	        var actions = arguments[1];
	        var randid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	        var ctx, mainCanvas, promiseSeries;
	        return regeneratorRuntime.async(function draw$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                if (!(stylePromise !== null)) {
	                  _context2.next = 3;
	                  break;
	                }

	                _context2.next = 3;
	                return regeneratorRuntime.awrap(stylePromise);

	              case 3:
	                ctx = this.ctx;
	                mainCanvas = this.$.mainCanvas;

	                if (!(!Array.isArray(actions) || !this.ctx)) {
	                  _context2.next = 7;
	                  break;
	                }

	                return _context2.abrupt('return');

	              case 7:

	                ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
	                // clear canvas
	                if (reserve === false) {
	                  ctx.fillStyle = '#000000';
	                  ctx.strokeStyle = '#000000';
	                  ctx.shadowColor = '#000000';
	                  ctx.shadowBlur = 0;
	                  ctx.shadowOffsetX = 0;
	                  ctx.shadowOffsetY = 0;
	                  ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
	                }

	                promiseSeries = function (tasks, initial) {
	                  if (!Array.isArray(tasks)) {
	                    return Promise.reject(new TypeError('promise.series only accepts an array of functions'));
	                  }
	                  return tasks.reduce(function (current, next) {
	                    return current.then(next);
	                  }, Promise.resolve(initial));
	                };

	                promiseSeries(actions.map(function (_ref3) {
	                  var method = _ref3.method,
	                      data = _ref3.data;

	                  if (method === 'drawImage') {
	                    var n = _toArray(data);
	                    n[0] = _this4.getRealPath(n[0]);
	                    var imgPath = n[0];
	                    var p;
	                    if (!_this4._images[imgPath]) {
	                      p = _this4.preloadImage(imgPath);
	                    }

	                    return function _callee() {
	                      return regeneratorRuntime.async(function _callee$(_context) {
	                        while (1) {
	                          switch (_context.prev = _context.next) {
	                            case 0:
	                              if (_this4._images[imgPath].ready) {
	                                _context.next = 3;
	                                break;
	                              }

	                              _context.next = 3;
	                              return regeneratorRuntime.awrap(p);

	                            case 3:
	                              return _context.abrupt('return', _this4.drawMethod(method, n));

	                            case 4:
	                            case 'end':
	                              return _context.stop();
	                          }
	                        }
	                      }, null, _this4);
	                    };
	                  }

	                  return function () {
	                    return _this4.drawMethod(method, data);
	                  };
	                })).then(function () {
	                  ttJSBridge.publish('canvas' + _this4.canvasId + 'DrawDone' + randid, {});
	                }).catch(function () {});

	              case 11:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, null, this);
	      }
	    }, {
	      key: 'getRealPath',
	      value: function getRealPath(imgPath) {
	        if (is(imgPath).file || is(imgPath).http || is(imgPath).dataImage) ; else if (is(imgPath).ttfile) {
	          tt.getProtocolXPath(imgPath, function (absPath) {
	            imgPath = absPath;
	          });
	        } else {
	          imgPath = tt.getRealRoute(window.__route__, imgPath);
	        }
	        return imgPath;
	      }
	    }, {
	      key: 'preloadImage',
	      value: function preloadImage(imgPath) {
	        var _this5 = this;

	        return new Promise(function (resolve, reject) {
	          _this5._images[imgPath] = new Image();
	          _this5._images[imgPath].crossOrigin = 'anonymous';
	          _this5._images[imgPath].queue = [];
	          _this5._images[imgPath].onload = function () {
	            _this5._images[imgPath].ready = true;
	            resolve();
	          };
	          _this5._images[imgPath].onerror = function () {
	            console.error('Failed to load image ' + imgPath + ' \n the server responded with a status of 404 (HTTP/1.1 404 Not Found)');
	            resolve();
	          };
	          // query 千万不能改，端上对 zhangxuefeng=zhangxuefeng 设置了响应值，允许跨域
	          _this5._images[imgPath].src = imgPath + '?zhangxuefeng=zhangxuefeng';
	        });
	      }
	    }, {
	      key: 'drawMethod',
	      value: function drawMethod(method, data) {
	        var _this6 = this;

	        return new Promise(function (resolve, reject) {
	          var ctx = _this6.ctx;

	          // check if a setter
	          if (method.indexOf('set') === 0) {
	            var setterName = lowerCase(method.substr(3));
	            var value = null;

	            if ('fillStyle' === setterName || 'strokeStyle' === setterName) {
	              if ('normal' === data[0]) {
	                value = resolveColor(data[1]);
	              } else if ('linear' === data[0]) {
	                var d = ctx.createLinearGradient.apply(ctx, data[1]);
	                data[2].forEach(function (e) {
	                  var t = e[0],
	                      n = resolveColor(e[1]);
	                  d.addColorStop(t, n);
	                });
	              } else if ('radial' === data[0]) {
	                /* eslint-disable no-redeclare */
	                var u = data[1][0],
	                    h = data[1][1],
	                    p = data[1][2],
	                    f = [u, h, 0, u, h, p],
	                    d = ctx.createRadialGradient.apply(ctx, f);

	                data[2].forEach(function (e) {
	                  var t = e[0];
	                  var n = resolveColor(e[1]);

	                  d.addColorStop(t, n);
	                });
	              }

	              ctx[setterName] = value;
	              return resolve();
	            } else if ('globalAlpha' === setterName) {
	              ctx[setterName] = data[0] / 255;
	              return resolve();
	            } else if ('shadow' === setterName) {
	              var A = ['shadowOffsetX', 'shadowOffsetY', 'shadowBlur', 'shadowColor'];
	              data.forEach(function (e, t) {
	                ctx[A[t]] = 'shadowColor' === A[t] ? resolveColor(e) : e;
	              });
	              return resolve();
	            } else {
	              if ('fontSize' === setterName) {
	                ctx.font = ctx.font.replace(/\d+\.?\d*px/, data[0] + 'px');
	              } else if ('lineDash' === setterName) {
	                ctx.setLineDash(data[0]);
	                ctx.lineDashOffset = data[1] || 0;
	              } else if ('textBaseline' === setterName) {
	                'normal' === data[0] && (data[0] = 'alphabetic');
	                ctx.textBaseline = data[0];
	              } else {
	                ctx[setterName] = data[0];
	              }
	            }
	            return resolve();
	          } else if ('fillPath' === method || 'strokePath' === method) {
	            method = method.replace(/Path/, '');
	            ctx.beginPath();
	            data.forEach(function (e) {
	              ctx[e.method].apply(ctx, e.data);
	            });
	            ctx[method]();
	            return resolve();
	          } else if ('drawImage' === method) {
	            var n = _toArray(data);
	            var imgPath = n[0];
	            var posParamArray = n.slice(1);

	            _this6._images[imgPath].ready ? ctx.drawImage.apply(ctx, [_this6._images[imgPath]].concat(toConsumableArray(posParamArray))) : _this6._images[imgPath].queue.push(posParamArray);
	            return resolve();
	          } else if ('clip' === method) {
	            data.forEach(function (e) {
	              return ctx[e.method].apply(ctx, e.data);
	            });
	            ctx.clip();
	            return resolve();
	          } else {
	            ctx[method] && ctx[method].apply(ctx, data);
	            return resolve();
	          }
	        });
	      }
	    }, {
	      key: '_getBox',
	      value: function _getBox(e, isRelative) {
	        var style = this.getBoundingClientRect();

	        var pos = {
	          left: style.left + window.scrollX,
	          top: style.top + window.scrollY,
	          width: this.$.mainCanvas.offsetWidth,
	          height: this.$.mainCanvas.offsetHeight
	        };

	        if (isRelative) {
	          return pos;
	        }

	        var r = e || window.getComputedStyle(this);
	        var o = parseFloat(r.getPropertyValue('border-top-width')) || 0;
	        var a = parseFloat(r.getPropertyValue('border-bottom-width')) || 0;
	        var s = parseFloat(r.getPropertyValue('border-left-width')) || 0;
	        var l = parseFloat(r.getPropertyValue('border-right-width')) || 0;

	        pos.left += s;
	        pos.top += o;
	        // pos.width -= s + l;
	        // pos.height -= o + a;


	        return pos;
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$23);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-canvas';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          canvasId: {
	            type: String,
	            observer: '_updateCanvasId',
	            value: ''
	          },
	          width: {
	            type: Number
	          },
	          height: {
	            type: Number
	          }
	        };
	      }
	    }]);
	    return ttCanvas;
	  }(Base(PolymerElement));

	  function lowerCase(str) {
	    return str.charAt(0).toLowerCase() + str.substr(1);
	  }

	  function _toArray(e) {
	    return Array.isArray(e) ? e : Array.from(e);
	  }

	  function resolveColor(e) {
	    var t = e.slice(0);
	    t[3] = t[3] / 255;
	    return 'rgba(' + t.join(',') + ')';
	  }

	  window.customElements.define(ttCanvas.is, ttCanvas);

	  var _templateObject$24 = taggedTemplateLiteral(['\n    <style>\n      :host {\n        height: auto;\n        width: auto;\n        display: block;\n      }\n\n      :host(.navigator-hover) {\n        background-color: rgba(0, 0, 0, 0.1);\n        opacity: .7;\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n    </style>\n    <slot></slot>\n    '], ['\n    <style>\n      :host {\n        height: auto;\n        width: auto;\n        display: block;\n      }\n\n      :host(.navigator-hover) {\n        background-color: rgba(0, 0, 0, 0.1);\n        opacity: .7;\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n    </style>\n    <slot></slot>\n    ']);

	  var Navigator = function (_Hover) {
	    inherits(Navigator, _Hover);

	    function Navigator() {
	      classCallCheck(this, Navigator);
	      return possibleConstructorReturn(this, (Navigator.__proto__ || Object.getPrototypeOf(Navigator)).apply(this, arguments));
	    }

	    createClass(Navigator, [{
	      key: 'connectCallback',
	      value: function connectCallback() {
	        get(Navigator.prototype.__proto__ || Object.getPrototypeOf(Navigator.prototype), 'connectedCallback', this).call(this);
	        this._lock = false;
	      }
	    }, {
	      key: 'navigateTo',
	      value: function navigateTo() {
	        var _this2 = this;

	        if ('navigateBack' !== this.openType && !this.url) {
	          return void logger.error('<navigator/> should have url attribute when using navigateTo, redirectTo or switchTab');
	        }

	        if (!this._lock) {
	          this._lock = true;

	          setTimeout(function () {
	            _this2._lock = false;
	          }, 1000);

	          if (this.redirect) {
	            return void tt.redirectTo({
	              url: this.url
	            });
	          }

	          switch (this.openType) {
	            case 'navigate':
	            case 'navigateTo':
	              return void tt.navigateTo({
	                url: this.url
	              });

	            case 'redirect':
	            case 'redirectTo':
	              return void tt.redirectTo({
	                url: this.url
	              });

	            case 'switchTab':
	              return void tt.switchTab({
	                url: this.url
	              });

	            case 'navigateBack':
	              return void tt.navigateBack({
	                delta: this.delta
	              });

	            case 'reLaunch':
	              return void tt.reLaunch({
	                url: this.url
	              });

	            default:
	              return void logger.error('<navigator/> with invalid openType ' + this.openType);
	          }
	        }
	      }
	    }, {
	      key: 'listeners',
	      get: function () {
	        return {
	          tap: 'navigateTo'
	        };
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$24);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-navigator';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          url: {
	            type: String
	          },
	          delta: {
	            type: Number,
	            value: 1
	          },
	          redirect: {
	            type: Boolean,
	            value: false
	          },
	          openType: {
	            type: String,
	            value: 'navigate'
	          },
	          hoverClass: {
	            type: String,
	            value: 'navigator-hover',
	            observer: '_hoverClassChange'
	          }
	        };
	      }
	    }]);
	    return Navigator;
	  }(Hover(Base(PolymerElement)));

	  window.customElements.define(Navigator.is, Navigator);

	  /* @polymerMixin */
	  var Native = (function (superClass) {
	    return function (_superClass) {
	      inherits(_class, _superClass);
	      createClass(_class, null, [{
	        key: 'properties',
	        get: function () {
	          return {
	            hidden: {
	              type: Boolean,
	              reflectToAttribute: true,
	              observer: 'hiddenChanged'
	            }
	          };
	        }
	      }]);

	      function _class() {
	        classCallCheck(this, _class);

	        var _this = possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));

	        _this._deferred = [];
	        _this._isReady = false;
	        _this._box = {
	          left: 0,
	          top: 0,
	          width: 0,
	          height: 0
	        };
	        return _this;
	      }

	      createClass(_class, [{
	        key: 'hiddenChanged',
	        value: function hiddenChanged(e, t) {
	          this._isReady ? this._hiddenChanged && this._hiddenChanged(e, t) : this._deferred.push({
	            callback: 'hiddenChanged',
	            args: [e, t]
	          });
	        }
	      }, {
	        key: '_getBox',
	        value: function _getBox(e, isRelative) {
	          var style = this.getBoundingClientRect();
	          var pos = {
	            left: style.left + window.scrollX,
	            top: style.top + window.scrollY,
	            width: this.offsetWidth,
	            height: this.offsetHeight
	          };

	          if (isRelative) {
	            return pos;
	          }

	          var r = e || window.getComputedStyle(this);
	          var o = parseFloat(r.getPropertyValue('border-top-width')) || 0;
	          var a = parseFloat(r.getPropertyValue('border-bottom-width')) || 0;
	          var s = parseFloat(r.getPropertyValue('border-left-width')) || 0;
	          var l = parseFloat(r.getPropertyValue('border-right-width')) || 0;

	          pos.left += s;
	          pos.top += o;
	          pos.width -= s + l;
	          pos.height -= o + a;

	          return pos;
	        }
	      }, {
	        key: '_diff',
	        value: function _diff() {
	          var box = this._getBox();

	          for (var t in box) {
	            if (box[t] !== this._box[t]) {
	              return box;
	            }
	          }

	          return false;
	        }
	      }, {
	        key: 'push2defferd',
	        value: function push2defferd(_ref) {
	          var callback = _ref.callback,
	              args = _ref.args;

	          this._deferred.push({
	            callback: callback,
	            args: args
	          });
	        }
	      }, {
	        key: '_ready',
	        value: function _ready() {
	          this._isReady = true;
	          this._deferred.forEach(function (e) {
	            this[e.callback].apply(this, e.args);
	          }, this);
	          this._deferred = [];
	        }
	      }]);
	      return _class;
	    }(superClass);
	  });

	  var _templateObject$25 = taggedTemplateLiteral(['\n    <style>\n      :host {\n        display: block;\n      }\n    </style>\n    <div id="main"></div>\n    '], ['\n    <style>\n      :host {\n        display: block;\n      }\n    </style>\n    <div id="main"></div>\n    ']);

	  // if web-view already exist
	  var exist = false;

	  var WebView = function (_Native) {
	    inherits(WebView, _Native);

	    function WebView() {
	      classCallCheck(this, WebView);
	      return possibleConstructorReturn(this, (WebView.__proto__ || Object.getPrototypeOf(WebView)).apply(this, arguments));
	    }

	    createClass(WebView, [{
	      key: 'connectedCallback',
	      value: function connectedCallback() {
	        var _this2 = this;

	        get(WebView.prototype.__proto__ || Object.getPrototypeOf(WebView.prototype), 'connectedCallback', this).call(this);

	        this.createdTimestamp = Date.now();

	        if (exist) {
	          return logger.error('一个页面只能插入一个 \'<web-view />\'');
	        }

	        tt.getSystemInfo({
	          success: function (_ref) {
	            var windowHeight = _ref.windowHeight,
	                windowWidth = _ref.windowWidth;

	            var $body = document.body;

	            _this2.$.main.style.width = windowWidth + 'px';
	            _this2.$.main.style.height = windowHeight + 'px';

	            $body.style.height = windowHeight + 'px';
	            $body.style.overflowY = 'hidden';

	            _this2.invoke('insertHTMLWebView', {
	              position: {
	                left: 0,
	                top: 0,
	                width: windowWidth,
	                height: windowHeight
	              }
	            }, function (_ref2) {
	              var errMsg = _ref2.errMsg,
	                  htmlId = _ref2.htmlId;

	              if (/ok/.test(errMsg)) {
	                _this2.htmlId = htmlId;
	                _this2._ready();
	                exist = true;
	                tt.publish('webViewInserted', {
	                  bindmessage: _this2.bindmessage,
	                  target: {
	                    dataset: _this2.$$data,
	                    id: _this2.id,
	                    offsetTop: _this2.offsetTop,
	                    offsetLeft: _this2.offsetLeft
	                  },
	                  createdTimestamp: _this2.createdTimestamp
	                });
	              } else {
	                _this2.triggerEvent('error', {
	                  errMsg: errMsg
	                });
	              }
	            });
	          }
	        });
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback(e) {
	        get(WebView.prototype.__proto__ || Object.getPrototypeOf(WebView.prototype), 'disconnectedCallback', this).call(this);

	        this.invoke('removeHTMLWebView', {
	          htmlId: this.htmlId
	        }, function (t) {
	          document.body.style.height = '';
	          document.body.style.overflowY = '';

	          exist = false;
	        });

	        tt.publish('webViewRemoved', {});
	      }
	    }, {
	      key: 'srcChanged',
	      value: function srcChanged(src, oldSrc) {
	        if (this._isReady) {
	          return this.invoke('updateHTMLWebView', {
	            htmlId: this.htmlId,
	            src: (src || '').trim()
	          });
	        }

	        this._deferred.push({
	          callback: 'srcChanged',
	          args: [src, oldSrc]
	        });
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$25);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-web-view';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          src: {
	            type: String,
	            observer: 'srcChanged'
	          },
	          bindmessage: {
	            type: String
	          }
	        };
	      }
	    }]);
	    return WebView;
	  }(Native(Base(PolymerElement)));

	  window.customElements.define(WebView.is, WebView);

	  var $_documentContainer$11 = document.createElement('div');
	  $_documentContainer$11.setAttribute('style', 'display: none;');

	  $_documentContainer$11.innerHTML = '<dom-module id="tt-progress-style">\n  <template>\n    <style>\n        :host {\n            display: block;\n            width: 100%;\n        }\n        :host .tt-progress-inner{\n            width: 0;\n            height: 100%;\n        }\n    </style>\n  </template>\n</dom-module>';

	  document.head.appendChild($_documentContainer$11);

	  var _templateObject$26 = taggedTemplateLiteral(['\n      <style include="tt-progress-style">\n      </style>\n      <div class="tt-progress-wrapper" style$="background-color: [[backgroundColor]]; height: [[strokeWidth]]px;">\n        <div class="tt-progress-inner" style$="width: [[currentPercent]]%; background-color: [[activeColor]]; ">\n        </div>\n      </div>\n    '], ['\n      <style include="tt-progress-style">\n      </style>\n      <div class="tt-progress-wrapper" style\\$="background-color: [[backgroundColor]]; height: [[strokeWidth]]px;">\n        <div class="tt-progress-inner" style\\$="width: [[currentPercent]]%; background-color: [[activeColor]]; ">\n        </div>\n      </div>\n    ']);

	  var DEFAULT_BACKGROUND_COLOR = '#EBEBEB';
	  var DEFAULT_ACTIVE_COLOR = '#F85959';
	  var BACKWARDS = 'backwards';
	  var FORWARDS = 'forwards';

	  var Progress = function (_Base) {
	    inherits(Progress, _Base);

	    function Progress() {
	      classCallCheck(this, Progress);
	      return possibleConstructorReturn(this, (Progress.__proto__ || Object.getPrototypeOf(Progress)).apply(this, arguments));
	    }

	    createClass(Progress, [{
	      key: 'percentChange',
	      value: function percentChange(newValue, oldValue) {
	        if (newValue < 0) {
	          this.percent = 0;
	        }
	        if (newValue > 100) {
	          this.percent = 100;
	        }

	        if (this.timerid) {
	          clearInterval(this.timerid);
	        }

	        // 第一次执行percentChange时，参数oldValue一定为undefined;
	        // 如果将undefined赋值给lastPercent,会影响下方timer函数（line: 99）的执行
	        // 所以令lastPercent = percent
	        this.lastPercent = oldValue === undefined ? this.percent : oldValue;

	        this.activeChange(this.active);
	      }
	    }, {
	      key: 'activeChange',
	      value: function activeChange(newValue) {
	        // false => true
	        if (newValue) {
	          var timer = function () {
	            if (this.percent <= this.currentPercent + 1) {
	              this.currentPercent = this.percent;
	              clearInterval(this.timerid);
	            } else {
	              ++this.currentPercent;
	            }
	          };

	          this.currentPercent = FORWARDS === this.activeMode ? this.lastPercent : 0;
	          this.timerid = setInterval(timer.bind(this), 30);
	          timer.call(this);
	        } else {
	          this.currentPercent = this.percent;
	        }
	      }
	    }, {
	      key: 'connectedCallback',
	      value: function connectedCallback(e) {
	        get(Progress.prototype.__proto__ || Object.getPrototypeOf(Progress.prototype), 'connectedCallback', this).call(this);

	        this.lastPercent = this.percent || 0;
	      }
	    }, {
	      key: 'disconnectedCallback',
	      value: function disconnectedCallback(e) {
	        get(Progress.prototype.__proto__ || Object.getPrototypeOf(Progress.prototype), 'disconnectedCallback', this).call(this);

	        if (this.timerid) {
	          clearInterval(this.timerid);
	        }
	      }
	    }], [{
	      key: 'template',
	      get: function () {
	        return html(_templateObject$26);
	      }
	    }, {
	      key: 'is',
	      get: function () {
	        return 'tt-progress';
	      }
	    }, {
	      key: 'properties',
	      get: function () {
	        return {
	          percent: {
	            type: Number,
	            value: 0,
	            observer: 'percentChange'
	          },
	          currentPercent: {
	            type: Number
	          },
	          strokeWidth: {
	            type: Number,
	            value: 6
	          },
	          showInfo: {
	            type: Boolean,
	            value: false
	          },
	          // 不建议使用，为了兼容
	          color: {
	            type: String,
	            value: DEFAULT_ACTIVE_COLOR
	          },
	          activeColor: {
	            type: String,
	            value: DEFAULT_ACTIVE_COLOR
	          },
	          backgroundColor: {
	            type: String,
	            value: DEFAULT_BACKGROUND_COLOR
	          },
	          active: {
	            type: Boolean,
	            value: false,
	            observer: 'activeChange'
	          },
	          activeMode: {
	            type: String,
	            value: BACKWARDS
	          }
	        };
	      }
	    }]);
	    return Progress;
	  }(Base(PolymerElement));

	  window.customElements.define(Progress.is, Progress);

	  function catchError(fn) {
	    return function () {
	      for (var t = arguments.length, n = Array(t), i = 0; i < t; i++) {
	        n[i] = arguments[i];
	      }

	      try {
	        fn.apply(null, n);
	      } catch (error) {
	        error && console.error(error.stack);

	        Reporter && Reporter.errorReport({
	          key: 'parserScriptError',
	          error: error
	        });
	      }
	    };
	  }

	  function catchWindowError() {
	    window.onerror = function (msg, url, line, col, error) {
	      error && console.error(error.stack);

	      Reporter && Reporter.errorReport({
	        key: 'webviewScriptError',
	        error: error,
	        extend: msg
	      });
	      // if ("ios" === tt.getPlatform()) {
	      //   webkit.messageHandlers
	      //     .publishHandler
	      //     .postMessage("wawebview sdk error:" + err.msg);
	      // }
	    };
	  }

	  (function () {
	    try {
	      WebviewRuntime.addGlobalErrorListener(function (error, _ref) {
	        var message = _ref.message;

	        Reporter && Reporter.errorReport({
	          key: 'webviewScriptError',
	          error: error,
	          extend: message
	        });
	      });
	    } catch (err) {}
	  })();

	  var components = {};

	  function reportComponent(id, info) {
	    components[id] = info;
	  }

	  function removeComponent(id) {
	    components[id] = null;
	  }

	  function getAllComponent() {
	    return components;
	  }

	  function onRequestComponentInfo() {
	    components = {};

	    tt.onRequestComponentInfo(function (_ref) {
	      var reqs = _ref.reqs,
	          reqId = _ref.reqId;

	      var res = [];

	      reqs.forEach(function (_ref2) {
	        var selector = _ref2.selector,
	            single = _ref2.single,
	            fields = _ref2.fields,
	            component = _ref2.component;

	        if (component === 0) {
	          return res.push(initResParams(fields));
	        }

	        var result = null;
	        var tree = window.__DOMTree__;

	        if (components[component]) {
	          tree = components[component];
	        }

	        if (single) {
	          var element = tree ? tree.querySelector(selector) : null;

	          result = element ? filterFields(element, fields) : null;
	        } else {
	          var elements = tree ? Array.from(tree.querySelectorAll(selector)) : [];

	          result = elements.map(function (item) {
	            return filterFields(item, fields);
	          });
	        }

	        res.push(result);
	      });

	      tt.sendComponentInfo({
	        reqId: reqId,
	        res: res
	      });
	    });
	  }

	  function filterFields(node, fields) {
	    var i = {};

	    if (fields.id) {
	      i.id = node.id || '';
	    }

	    if (fields.dataset) {
	      i.dataset = node.$$data || {};
	    }

	    if (fields.rect || fields.size) {
	      var r = node.getBoundingClientRect();

	      if (fields.rect) {
	        i.left = r.left;
	        i.right = r.right;
	        i.top = r.top;
	        i.bottom = r.bottom;
	      }

	      if (fields.size) {
	        i.width = r.width;
	        i.height = r.height;
	      }
	    }

	    if (fields.properties) {
	      fields.properties.forEach(function (t) {
	        var key = fields.replace(/-([a-z])/g, function (e, t) {
	          return t.toUpperCase();
	        });

	        i[key] = node[key];
	      });
	    }

	    if (fields.scrollOffset) {
	      if (node.getScrollPosition && typeof node.getScrollPosition === 'function') {
	        var o = node.getScrollPosition();

	        i.scrollLeft = o.scrollLeft;
	        i.scrollTop = o.scrollTop;
	      } else {
	        i.scrollLeft = 0;
	        i.scrollTop = 0;
	      }
	    }

	    return i;
	  }

	  function initResParams(req) {
	    var res = {};

	    if (req.id) {
	      res.id = '';
	    }

	    if (req.dataset) {
	      res.dataset = {};
	    }

	    if (req.rect) {
	      res.left = 0;
	      res.right = 0;
	      res.top = 0;
	      res.bottom = 0;
	    }

	    if (req.size) {
	      res.width = document.documentElement.clientWidth;
	      res.height = document.documentElement.clientHeight;
	    }

	    if (req.scrollOffset) {
	      res.scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft || 0;
	      res.scrollTop = document.documentElement.scrollTop || document.body.scrollTop || 0;
	    }

	    return res;
	  }

	  var WebviewSdkKnownError = function (_Error) {
	    inherits(WebviewSdkKnownError, _Error);

	    function WebviewSdkKnownError(msg) {
	      classCallCheck(this, WebviewSdkKnownError);

	      var _this = possibleConstructorReturn(this, (WebviewSdkKnownError.__proto__ || Object.getPrototypeOf(WebviewSdkKnownError)).call(this, 'Webview-SDK:' + msg));

	      _this.type = 'WebviewSdkKnownError';
	      return _this;
	    }

	    return WebviewSdkKnownError;
	  }(Error);

	  function noop() {}

	  var SideEffectFnQueue = function () {
	    function SideEffectFnQueue() {
	      classCallCheck(this, SideEffectFnQueue);


	      /**
	       * {
	       *  id: {
	       *    positive: Function,
	       *    negative: Function,
	       *    count: Number
	       *  },
	       * }
	       */
	      this.queues = {};
	    }

	    createClass(SideEffectFnQueue, [{
	      key: 'register',
	      value: function register(id) {
	        var positive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
	        var negative = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

	        var obj = this.queues[id] || (this.queues[id] = {});
	        obj.positive = positive;
	        obj.negative = negative;
	        obj.count = 0;
	      }
	    }, {
	      key: 'get',
	      value: function get$$1(id) {
	        return this.queues[id] || {};
	      }
	    }, {
	      key: 'add',
	      value: function add(id) {
	        if (!this.queues[id]) {
	          this.register(id);
	        }

	        this.queues[id].count++;
	      }
	    }, {
	      key: 'remove',
	      value: function remove(id) {
	        if (!this.queues[id]) {
	          this.register(id);
	        }

	        this.queues[id].count--;
	      }
	    }, {
	      key: 'clear',
	      value: function clear() {
	        this.queues = {};
	      }
	    }, {
	      key: 'trigger',
	      value: function trigger(id) {
	        if (!this.queues[id]) {
	          return;
	        }

	        var _queues$id = this.queues[id],
	            count = _queues$id.count,
	            positive = _queues$id.positive,
	            negative = _queues$id.negative;


	        if (count > 0) {
	          while (count-- > 0) {
	            positive();
	          }
	        } else if (count < 0) {
	          while (count++ < 0) {
	            negative();
	          }
	        }
	      }
	    }, {
	      key: 'triggerAll',
	      value: function triggerAll() {
	        var _this2 = this;

	        Object.keys(this.queues).forEach(function (id) {
	          _this2.trigger(id);
	        });
	      }
	    }]);
	    return SideEffectFnQueue;
	  }();

	  function getType(arg) {
	    return Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
	  }

	  // 判断是不是自定义组件
	  function isCustomComponent(obj) {
	    return obj && obj.tagName && obj.tagName.toUpperCase() === 'TT-CUSTOM-COMPONENT';
	  }

	  function parsePath(path) {
	    var isArrayStarted = false;
	    var len = path.length;
	    var pathArray = [];
	    var result = '';
	    for (var digits = 0, i = 0; i < len; i++) {
	      var char = path[i];
	      if ('\\' === char) {
	        // 处理转义字符
	        i + 1 < len && ('.' === path[i + 1] || '[' === path[i + 1] || ']' === path[i + 1]) ? (result += path[i + 1], i++) : result += '\\';
	      } else if ('.' === char) {
	        // 用点分割，特性之一
	        result && (pathArray.push(result), result = '');
	      } else if ('[' === char) {
	        result && (pathArray.push(result), result = '');
	        isArrayStarted = true;
	      } else if (']' === char) {
	        isArrayStarted = false;
	        pathArray.push(digits);
	        digits = 0;
	      } else if (isArrayStarted) {
	        digits = 10 * digits + char.charCodeAt(0) - 48;
	      } else {
	        result += char;
	      }
	    }
	    result && pathArray.push(result);

	    return pathArray;
	  }

	  var _nid = 1;

	  document.addEventListener('customComponentsRender', catchError(function (_ref) {
	    var generateFunc = _ref.detail.generateFunc;

	    if (!window.__componentconfig__ || !window.customComponents || Object.keys(window.customComponents).length === 0) {
	      return;
	    }

	    var CustomComponent = function (_HTMLElement) {
	      inherits(CustomComponent, _HTMLElement);
	      createClass(CustomComponent, null, [{
	        key: 'is',
	        get: function () {
	          return 'tt-custom-component';
	        }
	      }, {
	        key: 'reservedAttrs',
	        get: function () {
	          return ['id', '__template__'];
	        }
	      }]);

	      function CustomComponent() {
	        classCallCheck(this, CustomComponent);

	        var _this = possibleConstructorReturn(this, (CustomComponent.__proto__ || Object.getPrototypeOf(CustomComponent)).call(this));

	        _this._id = _nid++;
	        return _this;
	      }

	      createClass(CustomComponent, [{
	        key: 'connectedCallback',
	        value: function connectedCallback(e) {
	          var _this2 = this;

	          var cb = function () {

	            _this2._init();

	            _this2._trigger('created', {}, true);

	            _this2._syncInitPropsAndDataset();

	            _this2._observes();

	            _this2._listenComponentDataChange();

	            _this2._listenComponentCustomEvents();

	            _this2._render(function () {
	              _this2._trigger('attached', e, true);

	              _this2._bindEvents();

	              _this2._initRelationQueue();

	              // 触发节点的relations
	              _this2._relationHandler('attached');
	            });

	            // setTimeout(() => this._trigger('ready', e, true), 200);
	            _this2._trigger('ready', e, true);
	          };

	          var sideEffectFnQueue = window.__SideEffectFnQueues[window.__SideEffectFnQueues.length - 1];
	          if (sideEffectFnQueue) {
	            var _sideEffectFnQueue$ge = sideEffectFnQueue.get(this._id),
	                positive = _sideEffectFnQueue$ge.positive,
	                negative = _sideEffectFnQueue$ge.negative;

	            if (!positive) {
	              sideEffectFnQueue.register(this._id, cb, negative);
	            }

	            sideEffectFnQueue.add(this._id);
	          } else {
	            cb();
	          }
	        }
	      }, {
	        key: 'disconnectedCallback',
	        value: function disconnectedCallback(e) {
	          var _this3 = this;

	          var cb = function () {
	            _this3._trigger('detached', e, true);

	            removeComponent(_this3._id);

	            _this3._relationHandler('detached');
	          };
	          var sideEffectFnQueue = window.__SideEffectFnQueues[window.__SideEffectFnQueues.length - 1];

	          if (sideEffectFnQueue) {
	            var _sideEffectFnQueue$ge2 = sideEffectFnQueue.get(this._id),
	                positive = _sideEffectFnQueue$ge2.positive,
	                negative = _sideEffectFnQueue$ge2.negative;

	            if (!negative) {
	              sideEffectFnQueue.register(this._id, positive, cb);
	            }

	            sideEffectFnQueue.remove(this._id);
	          } else {
	            cb();
	          }
	        }
	      }, {
	        key: 'adoptedCallback',
	        value: function adoptedCallback(e) {
	          this._trigger('moved', e, true);

	          this._relationHandler('attached');
	        }
	      }, {
	        key: '_init',
	        value: function _init(cb) {
	          if (this.__template__ && !this.__inited) {

	            this.config = window.customComponents[this.__template__];
	            this.uuid = this.config.abs.substr(1);

	            this._config = _loadConfigs(this.uuid);
	            this._data = this._fetchInitData();

	            this.__inited = 1;

	            'function' === typeof cb && cb();
	          }
	        }
	      }, {
	        key: '_syncInitPropsAndDataset',
	        value: function _syncInitPropsAndDataset() {
	          var _this4 = this;

	          var attrs = this._config.properties || {};
	          var attrkeys = Object.keys(attrs);

	          if (!attrkeys.length) {
	            return;
	          }

	          this._syncData('properties', attrkeys.reduce(function (sofar, key) {
	            // 减少数据大小，未定义的数据不发送
	            if (_this4[key] !== undefined) {
	              sofar[key] = _this4._data[key];
	            }

	            return sofar;
	          }, {}));

	          var _data = this._datasets;
	          this._syncData('dataset', _data);
	        }
	      }, {
	        key: '_initRelationQueue',
	        value: function _initRelationQueue() {
	          var _this5 = this;

	          var initContext = this._config.raw;

	          this.relationQueue = [];
	          this.ancestors = initContext.ancestors;
	          var relationMap = this.relationMap = initContext.relationMap;
	          this.relationLinks = {};
	          this.relations = {};

	          for (var type in relationMap) {
	            var relation = relationMap[type];
	            this.relationLinks[type] = [];

	            for (var i = 0, l = relation.length; i < l; i++) {
	              this.relationLinks[type].push(null);
	              this.relations[relation[i]['originalKey']] = relation[i];
	            }
	          }

	          if (relationMap.parent) {
	            this.relationQueue.push(function (status) {
	              _this5._triggerRelations(relationMap.parent, _this5.relationLinks['parent'], _this5.ancestors, 'parent', status === 'attached');
	            });
	          }

	          if (relationMap.ancestor) {
	            this.relationQueue.push(function (status) {
	              _this5._triggerRelations(relationMap.ancestor, _this5.relationLinks['ancestor'], _this5.ancestors, 'ancestor', status === 'attached');
	            });
	          }
	        }
	      }, {
	        key: '_relationHandler',
	        value: function _relationHandler(status) {
	          this.relationQueue.forEach(function (cb) {
	            cb(status);
	          });
	        }
	      }, {
	        key: '_observes',
	        value: function _observes() {
	          var _this6 = this;

	          var attrs = this._config.properties || {};
	          var attrkeys = Object.keys(attrs);

	          if (!attrkeys.length) {
	            return;
	          }

	          // 后续有this.xxx操作，有可能拿到用户的setData
	          var attrData = this._data;

	          attrkeys.forEach(function (attr) {
	            Object.defineProperty(_this6, attr, {
	              get: function () {
	                return attrData[attr];
	              },
	              set: function (value) {
	                value = validateData(attr, value, attrs);
	                attrData[attr] = value;

	                if (_this6.renderer) {
	                  var o = {};
	                  o[attr] = value;
	                  _this6._syncData('properties', o);
	                  _this6._rerender();
	                }
	              }
	            });
	          });

	          var datasets = Object.keys(this.$$data);
	          this._datasets = Object.assign({}, this.$$data);

	          if (datasets.length) {
	            // sync attr `data-a-b` > this.dataset.a
	            datasets.forEach(function (key) {
	              Object.defineProperty(_this6.$$data, key, {
	                get: function () {
	                  return _this6._datasets[key];
	                },
	                set: function (value) {
	                  _this6._datasets[key] = value;
	                  var o = {};
	                  o[key] = value;
	                  _this6._syncData('dataset', o);
	                }
	              });
	            });
	          }
	        }
	      }, {
	        key: '_syncData',
	        value: function _syncData() {
	          var dataType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'properties';
	          var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	          tt.publishComponentDataChange(dataType, data, this._id);
	        }
	      }, {
	        key: '_trigger',
	        value: function _trigger() {
	          var method = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'created';
	          var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	          var isLifetimeMethod = arguments[2];

	          tt.publishComentEvent(method, data, // call argvs
	          this._id, isLifetimeMethod, this.uuid);
	        }
	      }, {
	        key: '_wrapEvent',
	        value: function _wrapEvent(detail, type) {
	          var currentTarget = {
	            id: this.id || '',
	            offsetLeft: this.offsetLeft || 0,
	            offsetTop: this.offsetTop || 0,
	            dataset: this.$$data || {}
	          };

	          return {
	            type: type || 'custom-component',
	            timeStamp: performance.now(),
	            target: currentTarget,
	            currentTarget: currentTarget,
	            detail: detail
	          };
	        }
	      }, {
	        key: '_bindEvents',
	        value: function _bindEvents() {
	          var _this7 = this;

	          if (!this.__eventInited) {
	            this.addEventListener('custom-component-event', function (e) {
	              var eventName = e.detail.__name;
	              var isChildMethod = e.detail.__child_method;
	              var parentEvent = _this7.$$eventHandleNames && _this7.$$eventHandleNames[eventName];
	              var hasEventTriggeredTag = !!_this7.eventTriggeredBy;
	              var isTriggeredByComponent = hasEventTriggeredTag && _this7.eventTriggeredBy.indexOf('component') > -1;
	              var eventTriggerByTargets = e.detail.__trigger_targets;

	              if (isChildMethod) {
	                var isTrigger = true;
	                if (eventTriggerByTargets) {
	                  isTrigger = eventTriggerByTargets.split(',').some(function (eventTriggerByTarget) {
	                    return _this7.__template__ === eventTriggerByTarget;
	                  });
	                }
	                isTrigger && _this7._trigger(eventName, e.detail.__pass_by ? _this7._wrapEvent(e.detail, e.detail.__original_event_name || eventName) : e.detail);
	              } else if (parentEvent) {
	                if (hasEventTriggeredTag) {
	                  if (isTriggeredByComponent) {
	                    var __trigger_targets = _this7.eventTriggeredBy.split('__')[1] || '';
	                    _this7.dispatchEvent(new CustomEvent('custom-component-event', {
	                      detail: Object.assign({}, e.detail, {
	                        __name: parentEvent,
	                        __original_event_name: eventName,
	                        __child_method: true,
	                        __pass_by: true,
	                        __trigger_targets: __trigger_targets
	                      }),
	                      bubbles: true,
	                      composed: true
	                    }));
	                  } else {
	                    tt.publishPageEvent(parentEvent, _this7._wrapEvent(e.detail, eventName));
	                  }
	                } else {
	                  // cause we do not know who is the parent of this very component,
	                  // its parent may be a custom component or a page instance.
	                  _this7.dispatchEvent(new CustomEvent('custom-component-event', {
	                    detail: Object.assign({}, e.detail, {
	                      __name: parentEvent,
	                      __original_event_name: eventName,
	                      __child_method: true,
	                      __pass_by: true
	                    }),
	                    bubbles: true,
	                    composed: true
	                  }));

	                  tt.publishPageEvent(parentEvent, _this7._wrapEvent(e.detail, eventName));
	                }
	              }
	            });

	            this.addEventListener('get-custom-component-uid', function (e) {
	              var _e$detail = e.detail,
	                  _e$detail$templateId = _e$detail.templateId,
	                  templateId = _e$detail$templateId === undefined ? '' : _e$detail$templateId,
	                  callback = _e$detail.callback;

	              if (templateId.split(',').indexOf(_this7.__template__) > -1) {
	                typeof callback === 'function' && callback(_this7._id);
	              }
	            });

	            this.shadowRoot.addEventListener('scroll', function (e) {
	              _this7.dispatchEvent(new CustomEvent('scroll', {
	                bubbles: false,
	                passive: true
	              }));
	            }, {
	              capture: true,
	              passive: true
	            });

	            this.__eventInited = 1;
	          }

	          reportComponent(this._id, this.shadowRoot);
	        }
	      }, {
	        key: '_triggerCustomEvent',
	        value: function _triggerCustomEvent(_ref2) {
	          var eventName = _ref2.eventName,
	              _ref2$eventDetail = _ref2.eventDetail,
	              eventDetail = _ref2$eventDetail === undefined ? {} : _ref2$eventDetail,
	              _ref2$eventOption = _ref2.eventOption,
	              eventOption = _ref2$eventOption === undefined ? {} : _ref2$eventOption;

	          this.dispatchEvent(new CustomEvent('custom-component-event', Object.assign({}, {
	            detail: Object.assign({}, eventDetail, {
	              __name: eventName,
	              __child_method: null,
	              __pass_by: null
	            })
	          }, eventOption)));
	        }

	        // 用户定义的配置，关联类型，组件状态

	      }, {
	        key: '_triggerRelations',
	        value: function _triggerRelations(settings, links, ancestors, type, isAttached) {
	          var isParent = type === 'parent';

	          // 缓存一下所有需要同步到jsc的事件
	          var needCallJSCQueue = [];

	          // 遍历发生dom操作的节点的配置
	          for (var i = 0, l = settings.length; i < l; i++) {
	            var setting = settings[i];
	            var newParentNode = null;
	            var oldParentNode = links[i];

	            // 如果节点被移除，links中的父节点需要被重置
	            if (isAttached) {
	              // 遍历节点的父节点
	              for (var parent = this.parentNode; parent; parent = parent.parentNode) {
	                if (parent.ancestors && parent.ancestors.indexOf(setting.target) > -1) {
	                  var parentSettings = isParent ? parent.relationMap.child : parent.relationMap.descendant;

	                  // 找到父节点后查找父节点是否配置了和子节点相关的配置
	                  for (var j = 0, len = parentSettings.length; j < len; j++) {
	                    var parentSetting = parentSettings[j];

	                    if (ancestors.indexOf(parentSetting.target) > -1) {
	                      newParentNode = {
	                        parent: parent,
	                        relation: parentSetting
	                      };
	                      break;
	                    }
	                  }
	                }
	                // parent 关系中，不需要遍历多级节点
	                // 如果找到父节点后，也不需要去判断后面的节点（所以会忽略掉parent节点中重复的配置）
	                if (isParent || newParentNode) {
	                  break;
	                }
	              }
	            }

	            links[i] = newParentNode;

	            if (oldParentNode && (!newParentNode || oldParentNode.parent !== newParentNode.parent)) {
	              // unlinked
	              needCallJSCQueue.push({
	                nodeid: oldParentNode.parent._id,
	                originalKey: oldParentNode.relation.originalKey,
	                type: 'unlinked',
	                target: this._id
	              }, {
	                nodeid: this._id,
	                originalKey: setting.originalKey,
	                type: 'unlinked',
	                target: oldParentNode.parent._id
	              });
	            }

	            if (newParentNode && (!oldParentNode || oldParentNode.parent !== newParentNode.parent)) {
	              // linked
	              needCallJSCQueue.push({
	                nodeid: newParentNode.parent._id,
	                originalKey: newParentNode.relation.originalKey,
	                type: 'linked',
	                target: this._id
	              }, {
	                nodeid: this._id,
	                originalKey: setting.originalKey,
	                type: 'linked',
	                target: newParentNode.parent._id
	              });
	            }

	            if (newParentNode && oldParentNode && newParentNode.parent === oldParentNode.parent) {
	              // linkchanged
	              needCallJSCQueue.push({
	                nodeid: newParentNode.parent._id,
	                originalKey: newParentNode.relation.originalKey,
	                type: 'linkChanged',
	                target: this._id
	              }, {
	                nodeid: this._id,
	                originalKey: setting.originalKey,
	                type: 'linkChanged',
	                target: newParentNode.parent._id
	              });
	            }
	          }

	          // 发送所有事件
	          if (needCallJSCQueue.length > 0) {
	            tt.publishComponentRelationChange(needCallJSCQueue);
	          }
	        }
	      }, {
	        key: '_renderTree',
	        value: function _renderTree() {
	          var _this8 = this;

	          var vtree = window.__h('div', { id: 'custom-component', style: 'display: inline;' }, this.renderer.call(null, this._data));
	          // ShadyCSS process
	          // 给每一个vnode的classList加上scope
	          if (this.shadyCssScope) {
	            var _walk = function (root) {
	              if (root && root.type === 'VirtualNode') {
	                if (root.properties.className && root.properties.className.indexOf(_this8.shadyCssScope) === -1) {
	                  root.properties.className += ' ' + _this8.shadyCssScope;
	                } else {
	                  root.properties.className = _this8.shadyCssScope;
	                }
	                for (var i = 0, l = root.children.length; i < l; i++) {
	                  _walk(root.children[i]);
	                }
	              }
	            };
	            _walk(vtree);
	          }
	          return vtree;
	        }
	      }, {
	        key: '_render',
	        value: function _render(cb) {

	          if (this.__template__ && !this.__rendered) {

	            var styleId = this.uuid.split('/').join('-') + '-style';
	            var styleTag = document.getElementById(styleId);

	            var shadow = this.attachShadow({ mode: 'open' });

	            if (styleTag) {
	              var template = styleTag.querySelector('template');
	              // polyfill ShadyCSS
	              if (window.ShadyCSS && !window.ShadyCSS.nativeShadow) {
	                var scope = styleId.replace('-style', '');
	                window.ShadyCSS.prepareTemplate(template, scope);
	                this.shadyCssScope = scope;
	              } else {
	                shadow.appendChild(document.importNode(template.content, true));
	              }
	            }

	            this.renderer = this.config.render;
	            this.vtree = this._renderTree();

	            shadow.appendChild(window.__render(this.vtree));

	            this.__rendered = 1;

	            cb && cb();
	          }
	        }
	      }, {
	        key: '_rerender',
	        value: function _rerender(cb) {
	          var root = this.shadowRoot.getElementById('custom-component');

	          if (root) {
	            var newTree = this._renderTree();
	            var patches = window.__diff(this.vtree, newTree);

	            window.__SideEffectFnQueues.push(new SideEffectFnQueue());

	            window.__apply(root, patches);

	            if (window.__SideEffectFnQueues.length > 0) {
	              var queue = window.__SideEffectFnQueues.pop();
	              queue.triggerAll();
	              queue = null;
	            }

	            this.vtree = newTree;
	            document.dispatchEvent(new CustomEvent('pageReRender', {
	              detail: { source: 'componentDataChange' }
	            }));
	          }

	          cb && cb();
	        }
	      }, {
	        key: '_listenComponentDataChange',
	        value: function _listenComponentDataChange() {
	          var _this9 = this;

	          if (this._componentDataChangedListened) {
	            return;
	          }

	          tt.onComponentDataChange(catchError(function (res, cb) {
	            if (!res.nodeid || res.nodeid != _this9._id) {
	              return;
	            }
	            var data = res.data;
	            Object.keys(data).forEach(function (key) {
	              var slcts = parsePath(key);

	              var cached = _this9._data;
	              var cachedParent = {};
	              for (var i = 0, l = slcts.length; i < l; i++) {
	                var slct = slcts[i];

	                if (Number(slct) === slct && slct % 1 === 0) {
	                  if (!Array.isArray(cached)) {
	                    cached = cachedParent[slcts[i - 1]] = [];
	                  }
	                } else if (getType(cached) !== 'object') {
	                  cached = cachedParent[slcts[i - 1]] = {};
	                }

	                if (i + 1 === l) {
	                  cached[slct] = data[key];
	                } else {
	                  clone(cached, slct);

	                  cachedParent = cached;
	                  cached = cached[slct];
	                }
	              }
	            });

	            _this9._rerender(cb);
	          }));

	          this._componentDataChangedListened = 1;
	        }
	      }, {
	        key: '_listenComponentCustomEvents',
	        value: function _listenComponentCustomEvents() {
	          var _this10 = this;

	          if (this._componentCustomEventsListened) {
	            return;
	          }

	          tt.onTriggerComponentEvent(catchError(function (res, cb) {
	            if (!res.nodeid || res.nodeid != _this10._id) {
	              return;
	            }

	            _this10._triggerCustomEvent(res);
	          }));

	          tt.onSelectComponent(catchError(function (res, cb) {
	            if (!res.nodeid || res.nodeid != _this10._id) {
	              return;
	            }

	            var selector = res.selector,
	                single = res.single;


	            if (single) {
	              var node = _this10.shadowRoot.querySelector(selector);

	              cb(isCustomComponent(node) ? node._id : null);
	            } else {
	              var nodes = Array.from(_this10.shadowRoot.querySelectorAll(selector));

	              cb(nodes.reduce(function (prev, next) {
	                if (isCustomComponent(next)) {
	                  prev.push(next._id);
	                }
	                return prev;
	              }, []));
	            }
	          }));

	          tt.onGetRelationNodes(catchError(function (_ref3, cb) {
	            var relation = _ref3.relation,
	                nodeid = _ref3.nodeid;

	            if (!nodeid || nodeid != _this10._id) {
	              return;
	            }

	            var relationsetting = _this10.relations[relation];

	            if (!relationsetting) {
	              return cb(null);
	            }

	            var type = relationsetting.type;

	            if ('parent' !== type && 'ancestor' !== type) {
	              var isChild = 'child' === type;
	              var result = [];

	              travels(_this10, _this10, isChild, relation, result);

	              return cb(result);
	            } else {
	              for (var relations = _this10.relationLinks[type], relationMap = _this10.relationMap[type], i = 0, l = relations.length; i < l; i++) {
	                var relationitem = relations[i];
	                if (relationitem && relationMap[i].originalKey === relation) {
	                  return cb([relationitem.parent._id]);
	                }
	                continue;
	              }
	              return cb([]);
	            }
	          }));

	          this._componentCustomEventsListened = 1;
	        }

	        // this.template may mismatch
	        // cause this.template is a uuid tag name

	      }, {
	        key: '_fetchInitData',
	        value: function _fetchInitData() {
	          var _this11 = this;

	          if (!this.config) {
	            return;
	          }

	          var initContext = this._config.raw;

	          var attrs = this._config.properties;

	          var data = Object.assign({}, initContext ? initContext.data : {});

	          Object.keys(attrs).forEach(function (attr) {
	            if (_this11[attr] !== undefined) {
	              data[attr] = validateData(attr, _this11[attr], attrs);
	            } else {
	              data[attr] = attrs[attr].value;
	            }
	          });

	          return data;
	        }
	      }]);
	      return CustomComponent;
	    }(HTMLElement);

	    window.customElements.define(CustomComponent.is, CustomComponent);
	  }));

	  function _loadConfigs(uuid) {
	    var configs = window.__componentconfig__;
	    var raw = 'object' === typeof configs[uuid] ? configs[uuid] : JSON.parse(configs[uuid]);
	    var properties = raw.properties;

	    return {
	      raw: raw,
	      properties: properties
	    };
	  }

	  function clone(origin, key) {
	    var originData = origin[key];

	    if (Array.isArray(originData)) {
	      origin[key] = Array.from(originData);
	    } else if (typeof originData === 'object') {
	      origin[key] = Object.assign({}, originData);
	    }
	  }

	  // 遍历子节点获取 relation
	  function travels(self, parentnode, isChild, relation) {
	    var result = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

	    var _loop = function (i, nodes, l) {
	      var node = nodes[i];

	      if (isCustomComponent(node)) {
	        if (node.relationLinks) {
	          var relations = isChild ? node.relationLinks.parent : node.relationLinks.ancestor;

	          if (relations) {
	            relations.some(function (relationitem) {
	              if (relationitem && relationitem.parent === parentnode && relationitem.relation.originalKey === relation) {
	                result.push(node._id);
	                return true;
	              }

	              return false;
	            });
	          }
	        }

	        if (!isChild) {
	          travels(node, parentnode, isChild, relation, result);
	        }
	      }
	    };

	    for (var i = 0, nodes = self.childNodes, l = nodes.length; i < l; i++) {
	      _loop(i, nodes, l);
	    }
	  }

	  function validateData(key, value, properties) {
	    var setting = properties[key],
	        settingType = setting.type;

	    // null代表任意类型
	    if (settingType === 'null') {
	      return value;
	    }

	    var type = getType(value);

	    // 如果数据类型和用户设置的类型相同直接返回
	    if (settingType === type) {
	      return value;
	    }

	    // 其他情况返回处理后的值
	    switch (settingType) {
	      case 'string':
	        if (value === null) {
	          return '';
	        }

	        if ('object' === typeof value && !Array.isArray(value)) {
	          return '[object Object]';
	        }

	        return value.toString();
	      case 'number':
	        {
	          var _value = +value;

	          return isNaN(_value) ? 0 : _value;
	        }
	      case 'boolean':
	        return !!value;
	      case 'array':
	        return [];
	      case 'object':
	        if (Array.isArray(value)) {
	          return value;
	        }

	        // map set date reg...
	        if ('object' === typeof value) {
	          return {};
	        }

	        return null;
	    }
	  }

	  // styles

	  function speedReport(key, startTime, endTime, data) {
	    if (!window.Reporter) {
	      return;
	    }

	    Reporter.speedReport({
	      key: key,
	      timeMark: {
	        startTime: startTime,
	        endTime: endTime
	      },
	      force: 'reRenderTime' !== key,
	      data: data
	    });
	  }

	  var scrollFlag = false;
	  var pullupRefreshLock = true;

	  function triggerPullUpRefresh() {
	    if (pullupRefreshLock) {
	      tt.publishPageEvent('onReachBottom', {});

	      pullupRefreshLock = false;

	      setTimeout(function () {
	        pullupRefreshLock = true;
	      }, 350);
	    }
	  }

	  function onPageScrollTo(_ref) {
	    var _ref$duration = _ref.duration,
	        duration = _ref$duration === undefined ? 200 : _ref$duration,
	        scrollTop = _ref.scrollTop;

	    // from https://gist.github.com/andjosh/6764939
	    var scrollTo = function (to, duration) {
	      var element = document.scrollingElement || document.body || document.documentElement;
	      var start = element.scrollTop;
	      var change = to - start;
	      var startDate = +new Date();
	      var easeInOutQuad = function (currentTime, startVal, changeVal, duration) {
	        currentTime /= duration / 2;
	        if (currentTime < 1) {
	          return changeVal / 2 * currentTime * currentTime + startVal;
	        }
	        currentTime--;
	        return -changeVal / 2 * (currentTime * (currentTime - 2) - 1) + startVal;
	      };
	      var animateScroll = function () {
	        var currentDate = +new Date();
	        var currentTime = currentDate - startDate;
	        element.scrollTop = parseInt(easeInOutQuad(currentTime, start, change, duration));
	        if (currentTime < duration) {
	          requestAnimationFrame(animateScroll);
	        } else {
	          element.scrollTop = to;
	        }
	      };
	      animateScroll();
	    };

	    scrollTo(scrollTop, duration);
	  }

	  function enableScroll(_ref2) {
	    var onReachBottomDistance = _ref2.onReachBottomDistance,
	        enablePullUpRefresh = _ref2.enablePullUpRefresh,
	        enablePageScroll = _ref2.enablePageScroll;

	    if (enablePageScroll || enablePullUpRefresh) {
	      window.onscroll = function () {
	        if (enablePageScroll) {
	          tt.publishPageEvent('onPageScroll', {
	            scrollTop: window.pageYOffset
	          });
	        }

	        if (enablePullUpRefresh) {
	          checkScroll(onReachBottomDistance) && triggerPullUpRefresh();
	        }
	      };
	    }

	    if (enablePullUpRefresh) {
	      trackDOMTouches(onReachBottomDistance);
	    }
	  }

	  function getWindowHeight() {
	    return 'CSS1Compat' === document.compatMode ? document.documentElement.clientHeight : document.body.clientHeight;
	  }

	  function getScrollHeight() {
	    var h1 = 0,
	        h2 = 0;

	    if (document.body) {
	      h1 = document.body.scrollHeight;
	    }

	    if (document.documentElement) {
	      h2 = document.documentElement.scrollHeight;
	    }

	    return Math.max(h1, h2);
	  }

	  function checkScroll(onReachBottomDistance) {
	    var windowHeight = getWindowHeight();
	    var scrollHeight = getScrollHeight();
	    var scrollY = window.scrollY;

	    var over = scrollY > 0 && scrollHeight > windowHeight && scrollY + windowHeight + onReachBottomDistance >= scrollHeight;

	    /* eslint-disable no-return-assign */
	    return over && !scrollFlag ? (scrollFlag = true, true) : (!over || !scrollFlag) && (scrollFlag = false, false);
	  }

	  function trackDOMTouches(onReachBottomDistance) {
	    var pageY = 0;

	    window.__DOMTree__.addEventListener('touchstart', function (_ref3) {
	      var touches = _ref3.touches;
	      return pageY = touches[0].pageY;
	    });

	    window.__DOMTree__.addEventListener('touchmove', function (_ref4) {
	      var touches = _ref4.touches;

	      if (touches[0].pageY < pageY) {
	        checkScroll(onReachBottomDistance) && triggerPullUpRefresh();
	      }
	    });
	  }

	  function savePageState(route) {
	    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
	    ttJSBridge.publish('savePageState', { scrollTop: scrollTop, route: route });
	  }

	  function recoverPageState() {
	    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (null !== e.scrollTop) {
	      var t = parseInt(e.scrollTop, 10);

	      document.body.scrollTop = t;
	      document.documentElement.scrollTop = t;
	    }
	  }

	  /**
	   * utils
	   */

	  var isObject = function (obj) {
	    return typeof obj === 'object' && obj !== null;
	  };

	  var isArray = function (obj) {
	    return isObject(obj) && Object.prototype.toString.call(obj) === '[object Array]';
	  };

	  var isBaseComponent = function (node) {
	    return node.hasBehavior && node.hasBehavior('base');
	  };

	  var isVNode = function (obj) {
	    return obj && obj.type === 'VirtualNode';
	  };

	  var isVText = function (obj) {
	    return obj && obj.type === 'VirtualText';
	  };

	  var isVComment = function (obj) {
	    return obj && obj.type === 'VirtualComment';
	  };

	  var isEmpty = function (obj) {
	    return obj === null || obj === undefined;
	  };

	  var isOrigin = function (obj) {
	    return isObject(obj) && obj.hasOwnProperty('__origin');
	  };

	  var makeOrigin = function (origin) {
	    var obj = Object.create({
	      // for safe, but Booleans still have problem
	      toString: function () {
	        return origin + '';
	      },
	      valueOf: function () {
	        return !isEmpty(origin) ? origin.valueOf() : origin;
	      }
	    });

	    Object.defineProperty(obj, '__origin', { value: origin });
	    return obj;
	  };

	  var clone$1 = function (origin, key) {
	    var originData = origin[key];

	    if (isArray(originData)) {
	      origin[key] = Array.from(originData);
	    } else if (isObject(originData)) {
	      origin[key] = Object.assign({}, originData);
	    }
	  };

	  function s4() {
	    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	  }

	  function guid() {
	    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
	  }

	  var noProperties = {};
	  var noChildren = [];

	  function VirtualNode(tagName, properties, children, key) {
	    this.tagName = tagName;
	    this.properties = properties || noProperties;
	    this.children = children || noChildren;
	    this.key = key != null ? String(key) : undefined;

	    var count = children && children.length || 0;
	    var descendants = 0;

	    for (var i = 0; i < count; i++) {
	      var child = children[i];
	      if (isVNode(child)) {
	        descendants += child.count || 0;
	      }
	    }

	    this.count = count + descendants;
	  }

	  VirtualNode.prototype.type = 'VirtualNode';

	  /**
	   * VirtualText
	   */

	  function VirtualText(text) {
	    this.text = String(text);
	  }

	  VirtualText.prototype.type = 'VirtualText';

	  function VirtualComment() {
	    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	    this.text = text;
	  }

	  VirtualComment.prototype.type = 'VirtualComment';

	  /**
	   * 生成vnode的方法
	   */

	  function h$1(tagName, properties) {
	    for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      children[_key - 2] = arguments[_key];
	    }

	    var childNodes = [];
	    var keyCount = {};

	    var addChild = function (children, childNodes) {
	      if (isVNode(children)) {
	        if (children.key) {
	          var childKey = children.key;
	          if (!keyCount.hasOwnProperty(childKey)) {
	            keyCount[childKey] = 1;
	          } else {
	            var logProps = '';
	            if (children.properties.id) {
	              logProps += 'id="' + children.properties.id + '"';
	            }
	            if (children.properties.className) {
	              logProps += 'class="' + children.properties.className + '"';
	            }
	            logger.warn('Duplicated key ' + childKey + ' found on child: <' + children.tagName + ' ' + logProps + '/>. Ignoring the key on this element.' + 'Make sure each tt-for item has a unique key. See also: https://developer.toutiao.com/docs/framework/ttml_list_render.html#tt-key');
	            children.key = undefined;
	          }
	        }

	        childNodes.push(children);
	      } else if (isArray(children)) {
	        for (var i = 0; i < children.length; i++) {
	          var child = children[i];
	          addChild(child, childNodes);
	        }
	      } else if (isVComment(children)) {
	        childNodes.push(children);
	      } else if (children === undefined || children === null) {
	        return;
	      } else {
	        // append as String
	        var text = children.toString().replace(/\\r/g, '').replace(/\\n/g, '\n');
	        childNodes.push(new VirtualText(text));
	      }
	    };

	    addChild(children, childNodes);

	    var key = void 0;
	    if (properties && properties.hasOwnProperty('key')) {
	      key = properties.key;
	      delete properties.key;
	    }

	    return new VirtualNode(tagName, properties, childNodes, key);
	  }

	  /**
	   * 修改文本节点内容的方法
	   */

	  function stringPatch(node, _ref) {
	    var patch = _ref.patch;
	    var text = patch.text;

	    node.parentNode.replaceChild(document.createTextNode(text), node);
	  }

	  /**
	   * 修改注释节点内部文字
	   */
	  function commentPatch(node, _ref2) {
	    var patch = _ref2.patch;
	    var text = patch.text;

	    node.textContent = text;
	  }

	  /**
	   * reorder子元素
	   */

	  function reorderChildren(domNode, moves) {
	    var keyMap = {};

	    var node = void 0;
	    var remove = void 0;
	    var insert = void 0;

	    for (var i = 0; i < moves.removes.length; i++) {
	      remove = moves.removes[i];
	      node = domNode.childNodes[remove.from];
	      if (remove.key) {
	        keyMap[remove.key] = node;
	      }
	      domNode.removeChild(node);
	    }

	    var length = domNode.childNodes.length;
	    for (var j = 0; j < moves.inserts.length; j++) {
	      insert = moves.inserts[j];
	      node = keyMap[insert.key];
	      if (node) {
	        domNode.insertBefore(node, insert.to >= length++ ? null : domNode.childNodes[insert.to]);
	      }
	    }

	    if (moves.inserts2) {
	      var inserts2 = void 0;
	      for (var k = 0; k < moves.inserts2.length; k++) {
	        inserts2 = moves.inserts2[k];
	        node = createElement(inserts2.vnode);
	        domNode.insertBefore(node, domNode.childNodes[inserts2.to]);
	      }
	    }
	  }

	  /**
	   * 删除节点
	   */

	  function removeNode(domNode) {
	    var parentNode = domNode.parentNode;

	    if (parentNode) {
	      parentNode.removeChild(domNode);
	    }
	  }

	  /**
	   * 生成节点
	   */

	  function insertNode(parentNode, vNode) {
	    if (parentNode) {
	      parentNode.appendChild(createElement(vNode));
	    }
	  }

	  /**
	   * 替换节点
	   */

	  function vNodePatch(domNode, vNode) {
	    var parentNode = domNode.parentNode;
	    if (parentNode) {
	      parentNode.replaceChild(createElement(vNode), domNode);
	    }
	  }

	  /**
	   * 修改DOM属性
	   */

	  function getTouches(e) {
	    if (e) {
	      var t = [];
	      for (var n = 0; n < e.length; n++) {
	        var i = e[n];
	        t.push({
	          identifier: i.identifier,
	          pageX: i.pageX,
	          pageY: i.pageY,
	          clientX: i.clientX,
	          clientY: i.clientY,
	          force: i.force || 0
	        });
	      }
	      return t;
	    }
	  }

	  function wrapEvent(node, e, type) {
	    // __eventTargetRef是有些组件在实现一些特殊DOM结构的时候，需要对target做一些篡改，比如tt-text的场景
	    var targetElement = e.target.__eventTargetRef || e.target;
	    var target = {
	      id: targetElement.id || '',
	      offsetLeft: targetElement.offsetLeft || 0,
	      offsetTop: targetElement.offsetTop || 0,
	      dataset: targetElement.$$data || {}
	    };

	    return {
	      type: type,
	      timeStamp: e.timeStamp || performance.now(),
	      target: target,
	      currentTarget: {
	        id: node.id || '',
	        offsetLeft: node.offsetLeft || 0,
	        offsetTop: node.offsetTop || 0,
	        dataset: node.$$data || {}
	      },
	      detail: e.detail || {},
	      touches: getTouches(e.touches),
	      changedTouches: getTouches(e.changedTouches)
	    };
	  }

	  var HAS_NATIVE_TA$2 = typeof document.head.style.touchAction === 'string';
	  var SUPPORTS_PASSIVE$2 = false;

	  (function () {
	    try {
	      var opts = Object.defineProperty({}, 'passive', {
	        // eslint-disable-next-line getter-return
	        get: function () {
	          SUPPORTS_PASSIVE$2 = true;
	        }
	      });
	      window.addEventListener('test', null, opts);
	      window.removeEventListener('test', null, opts);
	    } catch (e) {
	      /* noop */
	    }
	  })();

	  var PRESS_DELAY = 350;
	  var TAP_DISTANCE$1 = 5;

	  var DISABLE_TAP_ELEMENT = ['TT-BUTTON', 'TT-CHECKBOX', 'TT-RADIO'];

	  function addTapEvent(node) {
	    // 模拟合成tap事件和longpress事件，事件名为tt-tap和tt-longpress，以区别于polymer的事件
	    var pressTimer = void 0,
	        pressStart = void 0,
	        ended = void 0,
	        longpressFired = void 0;

	    var ios_version = /iPhone OS (\d{2})/.exec(navigator.userAgent);
	    if (ios_version && parseInt(ios_version[1]) > 10) {
	      // ios有个bug，navigateTo后，DOM无法响应end事件，双击的话第二个tap事件无法合成
	      tt.subscribe('onHide', function (e) {
	        ended = true;
	        clearTimeout(pressTimer);
	      });
	    }

	    var touchstartHandler = function (e) {
	      if (e.__handledTap) {
	        return;
	      }
	      longpressFired = ended = false;
	      pressStart = {
	        x: e.touches[0].pageX,
	        y: e.touches[0].pageY
	      };
	      clearTimeout(pressTimer);
	      pressTimer = setTimeout(function () {
	        // dispatch longpress event
	        var pressEvent = new Event('tt-longpress', { bubbles: true, composed: true });
	        pressEvent.detail = pressStart;
	        node.dispatchEvent(pressEvent);
	        longpressFired = true;
	      }, PRESS_DELAY);
	      e.__handledTap = true;
	    };

	    var touchmoveHandler = function (e) {
	      if (ended || !pressStart) {
	        return;
	      }
	      var dx = Math.abs(e.changedTouches[0].pageX - pressStart.x);
	      var dy = Math.abs(e.changedTouches[0].pageY - pressStart.y);
	      if (dx > TAP_DISTANCE$1 || dy > TAP_DISTANCE$1) {
	        ended = true;
	        clearTimeout(pressTimer);
	      }
	    };

	    if (HAS_NATIVE_TA$2 && SUPPORTS_PASSIVE$2) {
	      node.addEventListener('touchstart', touchstartHandler, { passive: true });
	      node.addEventListener('touchmove', touchmoveHandler, { passive: true });
	    } else {
	      node.addEventListener('touchstart', touchstartHandler);
	      node.addEventListener('touchmove', touchmoveHandler);
	    }

	    node.addEventListener('touchend', function (e) {
	      if (ended || !pressStart) {
	        return;
	      }
	      ended = true;
	      clearTimeout(pressTimer);
	      // 如果没有触发touchmove的判断，这里还要再来一下
	      var dx = Math.abs(e.changedTouches[0].pageX - pressStart.x);
	      var dy = Math.abs(e.changedTouches[0].pageY - pressStart.y);
	      if (dx > TAP_DISTANCE$1 || dy > TAP_DISTANCE$1) {
	        return;
	      }
	      // dispatch tap event
	      if (DISABLE_TAP_ELEMENT.indexOf(node.tagName) !== -1 && node.disabled) {
	        // if element is disabled, 那就不发了
	        return;
	      }
	      var tapEvent = new Event('tt-tap', { bubbles: true, composed: true });

	      tapEvent.detail = {
	        x: e.changedTouches[0].pageX,
	        y: e.changedTouches[0].pageY,
	        sourceEndEvent: e,
	        longpressFired: longpressFired
	      };
	      node.dispatchEvent(tapEvent);
	    });

	    node.addEventListener('touchcancel', function (e) {
	      ended = true;
	      clearTimeout(pressTimer);
	    });
	  }

	  function addListener$1(node, eventType, callback) {
	    switch (eventType) {
	      case 'tap':
	        // listen down and up
	        if (!node.__hasTapEvent) {
	          node.__hasTapEvent = true;
	          addTapEvent(node);
	        }
	        node.addEventListener('tt-tap', function (e) {
	          if (e.detail.longpressFired && node.__hasPressHandler) {
	            return;
	          }

	          return callback.call(node, {
	            touches: e.detail.sourceEndEvent.changedTouches, // touchend没有touches，可以用changedTouches
	            changedTouches: e.detail.sourceEndEvent.changedTouches,
	            detail: {
	              x: e.detail.x,
	              y: e.detail.y
	            },
	            target: e.detail.sourceEndEvent.target,
	            timeStamp: e.timeStamp,
	            preventDefault: function () {
	              return e.detail.sourceEndEvent.preventDefault();
	            },
	            stopPropagation: function () {
	              e.stopPropagation();
	              // 标记一下touchend，表示这个被阻止过
	              e.detail.sourceEndEvent.__catchedTap = true;
	            }
	          });
	        });
	        return;
	      case 'touchstart':
	      case 'touchend':
	      case 'touchmove':
	      case 'touchcancel':
	        node.addEventListener(eventType, function (e) {
	          if (e.__frozenBySwipeBack) return; // ios 触发了滑动返回
	          var detail = {
	            x: e.pageX,
	            y: e.pageY
	          };
	          Object.defineProperty(e, 'detail', {
	            get: function () {
	              return detail;
	            }
	          });
	          return callback.call(node, e);
	        });
	        return;
	      case 'longtap':
	      case 'longpress':
	        // listen down and up
	        if (!node.__hasTapEvent) {
	          node.__hasTapEvent = true;
	          addTapEvent(node);
	        }
	        node.__hasPressHandler = true;
	        node.addEventListener('tt-longpress', callback);
	        return;
	    }

	    node.addEventListener(eventType, callback);
	  }

	  function animationToStyle(action) {
	    var operation = action.text;
	    if (!operation || operation.indexOf('transition') === -1) {
	      return {
	        transformOrigin: '',
	        transform: '',
	        transition: ''
	      };
	    }

	    var option = action.option || {};

	    // parse
	    operation = operation.split(';').map(function (i) {
	      return i.trim();
	    }).filter(function (i) {
	      return '' !== i;
	    }).reduce(function (p, c) {
	      c = c.split(':');
	      if (c[0] === 'transform-origin') ;else if (c[0] === 'transition') ;else if (c[0] === 'transform') {
	        p['transform'] = c[1];
	      } else {
	        if (!p.style) {
	          p.style = {};
	        }
	        p.style[c[0]] = c[1];
	      }

	      return p;
	    }, {});

	    return {
	      style: operation.style,
	      transformOrigin: option.transformOrigin,
	      transform: operation.transform,
	      transitionProperty: ['transform'].concat(Object.keys(operation.style || {})).join(','),
	      transition: option.duration + 'ms ' + option.timingFunction + ' ' + option.delay + 'ms'
	    };
	  }

	  function applyProperties(node, props) {
	    var isCustomComponent = node.tagName.toLowerCase() === 'tt-custom-component';
	    var hasEventTriggeredTag = !!props['event-triggered-by'];
	    var isTriggeredByComponent = hasEventTriggeredTag && props['event-triggered-by'].indexOf('component') > -1;
	    var eventTriggerByTargets = hasEventTriggeredTag ? props['event-triggered-by'].split('__')[1] : '';

	    Object.keys(props).forEach(function (propName) {
	      var propValue = props[propName];
	      var eventHanlderMatch = void 0;
	      var datasetMatch = void 0;

	      if (isOrigin(propValue)) {
	        // restore the origin value of objects generated by `checkDirtyProps` function
	        propValue = propValue.__origin;
	      }

	      if (datasetMatch = /^data-(.+)/.exec(propName)) {
	        // data-*
	        var camelKey = datasetMatch[1].toLowerCase().replace(/-([a-z])/g, function (_, $1) {
	          return $1.toUpperCase();
	        }).replace(/-/g, '');
	        node.$$data[camelKey] = propValue;
	      } else if (eventHanlderMatch = /(bind|catch):?(.+)/.exec(propName)) {
	        // DOM的bind/catch处理
	        // 事件处理
	        var evType = eventHanlderMatch[2];
	        var handleName = propValue;
	        var isCatch = eventHanlderMatch[1] === 'catch';

	        propValue = propValue || '';
	        node.$$eventHandleNames = node.$$eventHandleNames || Object.create(null);

	        if (typeof node.$$eventHandleNames[evType] === 'undefined' && !isCustomComponent) {
	          addListener$1(node, evType, function (e) {
	            // 任何事件，只要用户写了bind:xxx，都会发到app-service，即使有些事件文档上并没开放的内部实现，微信也是
	            var handleName = node.$$eventHandleNames[evType];
	            if (handleName) {
	              var eventData = wrapEvent(node, e, evType);

	              if (hasEventTriggeredTag) {
	                if (!isTriggeredByComponent) {
	                  tt.publishPageEvent(handleName, eventData);
	                } else {
	                  // event popup for custom-component
	                  // should across borders
	                  node.dispatchEvent(new CustomEvent('custom-component-event', {
	                    detail: Object.assign({}, eventData, {
	                      __name: handleName,
	                      __child_method: true,
	                      __trigger_targets: eventTriggerByTargets
	                    }),
	                    bubbles: true,
	                    composed: true
	                  }));
	                }
	              } else {
	                tt.publishPageEvent(handleName, eventData);

	                node.dispatchEvent(new CustomEvent('custom-component-event', {
	                  detail: Object.assign({}, eventData, {
	                    __name: handleName,
	                    __child_method: true
	                  }),
	                  bubbles: true,
	                  composed: true
	                }));
	              }

	              if (isCatch) {
	                e.preventDefault();
	                e.stopPropagation();
	                return false;
	              }
	            }
	          });
	        }

	        node.$$eventHandleNames[evType] = handleName;

	        if (propValue === '') {
	          node.removeAttribute(propName);
	        } else {
	          node.setAttribute(propName, propValue);
	        }
	      } else if (propName === 'animation') {
	        // 处理动画
	        var animationData = null;
	        try {
	          propValue = typeof propValue === 'string' ? propValue : 'null';
	          animationData = JSON.parse(propValue);
	        } catch (e) {
	          !!propValue && logger.warn('Wrong animation property: ' + propValue);
	        }

	        if (!animationData || !animationData.steps || !animationData.steps.length) {
	          return;
	        }

	        var actions = animationData.steps.map(animationToStyle);
	        var i = 0;
	        var l = actions.length;

	        var drain = function () {
	          if (i < l) {
	            var _actions$i = actions[i],
	                transition = _actions$i.transition,
	                transitionProperty = _actions$i.transitionProperty,
	                transform = _actions$i.transform,
	                transformOrigin = _actions$i.transformOrigin,
	                _actions$i$style = _actions$i.style,
	                style = _actions$i$style === undefined ? {} : _actions$i$style;

	            // apply settings

	            node.style.transition = transition;
	            node.style.transitionProperty = transitionProperty;

	            node.animationStyle = {
	              transition: transition,
	              transitionProperty: transitionProperty,
	              transform: transform,
	              transformOrigin: transformOrigin
	            };

	            node.style.transform = transform;
	            node.style.transformOrigin = transformOrigin;

	            for (var key in style) {
	              // '20rpx' => '9px', for tt.transformRpx we must prepend a ':'
	              node.style[key] = tt.transformRpx(':' + style[key]).slice(1);
	            }
	          }
	        };

	        node.removeEventListener('transitionend', node.__transitionEndId);
	        node.__transitionEndId = function () {
	          i += 1;
	          drain();
	        };
	        node.addEventListener('transitionend', node.__transitionEndId);

	        drain();
	      } else if (propName === 'style') {
	        // 处理内联样式
	        if (typeof propValue !== 'string') {
	          if (propValue === true || propValue === undefined) {
	            propValue = '';
	          } else {
	            logger.warn('TypeError when apply style, value is not `String`: ' + propValue);
	            return;
	          }
	        }

	        var animationStyle = node.animationStyle || {};
	        var animationCssText = Object.keys(animationStyle).filter(function (e) {
	          // filter unsafe property
	          return !(/transform|transition/i.test(e) && '' === animationStyle[e] || '' === e.trim() || undefined === animationStyle[e] || '' === animationStyle[e] || !isNaN(parseInt(e)));
	        }).map(function (i) {
	          return i.replace(/([A-Z]{1})/g, function (e) {
	            return '-' + e.toLowerCase();
	          }) + ':' + animationStyle[i];
	        }).join(';');

	        if (animationCssText !== '') {
	          animationCssText += ';';
	        }

	        node.style.cssText = tt.transformRpx(animationCssText + propValue);
	      } else if (propName === 'className') {
	        // 针对className的特殊处理，如果不把true转为字符串，在部分浏览器上会报错
	        if (propValue === true || propValue === undefined || propValue === null) {
	          propValue = '';
	        }
	        node.className = propValue;
	      } else {
	        // 组件属性添加
	        // polymer属性是驼峰
	        propName = propName.replace(/-([a-z])/g, function (_, $1) {
	          return $1.toUpperCase();
	        });
	        if (window.customElements) {
	          var _constructor = window.customElements.get(node.tagName.toLowerCase());
	          if (_constructor && isBaseComponent(node) && !isObject(propValue)) {
	            var property = _constructor.__properties[propName];
	            if (property && property.type) {
	              propValue = node._deserializeValue(propValue, property.type);
	            }
	          }
	        }
	        node[propName] = propValue;
	      }
	    });
	  }

	  /**
	   * 渲染DOM
	   */

	  function renderVNode(vnode) {
	    var props = vnode.properties;
	    var node = document.createElement(vnode.tagName);

	    // generate $$data property
	    Object.defineProperty(node, '$$data', {
	      configurable: true,
	      value: Object.create(null)
	    });
	    if (typeof vnode.key !== 'undefined') {
	      node.setAttribute(':key', vnode.key);
	    }

	    // 为了让 IDE 中能够显示自定义组件真实名字
	    if (props['custom-component-name']) {
	      node.setAttribute('custom-component-name', props['custom-component-name']);
	    }

	    // 为了解决ShadyDOM的name属性或者slot属性为0时不能正常渲染的问题，一个trick
	    if (node.tagName === 'SLOT' && props.hasOwnProperty('name')) {
	      node.setAttribute('name', props.name);
	      delete props.name;
	    }
	    if (props.hasOwnProperty('slot')) {
	      node.setAttribute('slot', props.slot);
	      delete props.slot;
	    }

	    applyProperties(node, props);

	    return node;
	  }

	  function createElement(vnode) {
	    if (isVText(vnode)) {
	      return document.createTextNode(vnode.text);
	    }

	    if (isVComment(vnode)) {
	      return document.createComment(vnode.text);
	    }

	    if (!isVNode(vnode)) {
	      return null;
	    }

	    var node = renderVNode(vnode);

	    var children = vnode.children;
	    var frag = document.createDocumentFragment();

	    for (var i = 0; i < children.length; i++) {
	      var childNode = createElement(children[i]);
	      if (childNode) {
	        frag.appendChild(childNode);
	      }
	    }

	    node.appendChild(frag);

	    return node;
	  }

	  /**
	   * ios 滑动手势补丁
	   */

	  if (/iPhone OS/.test(navigator.userAgent)) {
	    var start = void 0,
	        swipeBack = void 0;
	    document.addEventListener('touchstart', function (e) {
	      swipeBack = false;
	      // 这个43是测出来的一个安全距离。。。
	      start = e.pageX <= 43 && !window.TMAConfig.disableSwipeBack ? e : null;
	    }, true);
	    document.addEventListener('touchmove', function (e) {
	      if (swipeBack) {
	        e.__frozenBySwipeBack = true;
	        return;
	      }
	      if (start && e.pageX - start.pageX > Math.abs(e.pageY - start.pageY)) {
	        e.__frozenBySwipeBack = swipeBack = true;
	      }
	    }, true);
	  }

	  /**
	   * VirtualPatch
	   */

	  function VirtualPatch(type, vNode, patch) {
	    this.type = Number(type);
	    this.vNode = vNode;
	    this.patch = patch;
	  }

	  VirtualPatch.VTEXT = 1;
	  VirtualPatch.VNODE = 2;
	  VirtualPatch.PROPS = 3;
	  VirtualPatch.ORDER = 4;
	  VirtualPatch.INSERT = 5;
	  VirtualPatch.REMOVE = 6;
	  VirtualPatch.COMMENT = 7;

	  function remove$1(arr, index, key) {
	    arr.splice(index, 1);

	    return {
	      from: index,
	      key: key
	    };
	  }

	  function keyIndex(children) {
	    var keys = {};
	    var free = [];
	    var length = children.length;

	    for (var i = 0; i < length; i++) {
	      var child = children[i];

	      if (child.key) {
	        keys[child.key] = i;
	      } else {
	        free.push(i);
	      }
	    }

	    return {
	      keys: keys, // A hash of key name to index
	      free: free // An array of unkeyed item indices
	    };
	  }

	  function appendPatch(apply, patch) {
	    if (apply) {
	      if (isArray(apply)) {
	        apply.push(patch);
	      } else {
	        apply = [apply, patch];
	      }

	      return apply;
	    } else {
	      return patch;
	    }
	  }

	  /**
	   * 把两棵树的差异应用到真实的DOM上
	   */

	  // binary search
	  function indexInRange(indices, left, right) {
	    if (indices.length === 0) {
	      return false;
	    }

	    var minIndex = 0;
	    var maxIndex = indices.length - 1;
	    var currentIndex = void 0;
	    var currentItem = void 0;

	    while (minIndex <= maxIndex) {
	      currentIndex = (maxIndex + minIndex) / 2 >> 0;
	      currentItem = indices[currentIndex];

	      if (minIndex === maxIndex) {
	        return currentItem >= left && currentItem <= right;
	      } else if (currentItem < left) {
	        minIndex = currentIndex + 1;
	      } else if (currentItem > right) {
	        maxIndex = currentIndex - 1;
	      } else {
	        return true;
	      }
	    }

	    return false;
	  }

	  // map indices to dom
	  function nodesByIndices(root, vtree, indices) {
	    var nodes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	    var start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

	    if (indexInRange(indices, start, start)) {
	      nodes[start] = root;
	    }

	    var vChildren = vtree.children;

	    if (vChildren && vChildren.length) {
	      var childNodes = Array.from(root.childNodes);

	      for (var i = 0; i < vChildren.length; i++) {
	        start += 1;
	        var vChild = vChildren[i];
	        var end = start + (vChild.count || 0);

	        if (indexInRange(indices, start, end)) {
	          nodesByIndices(childNodes[i], vChild, indices, nodes, start);
	        }
	        start = end;
	      }
	    }

	    return nodes;
	  }

	  function applyPatchWithSchedule(patch, node) {
	    if (patch.type === VirtualPatch.PROPS) {
	      applyProperties(node, patch.patch, patch.vNode.properties);
	    } else if (patch.type === VirtualPatch.VTEXT) {
	      stringPatch(node, patch);
	    } else if (patch.type === VirtualPatch.ORDER) {
	      reorderChildren(node, patch.patch);
	    } else if (patch.type === VirtualPatch.REMOVE) {
	      removeNode(node);
	    } else if (patch.type === VirtualPatch.INSERT) {
	      insertNode(node, patch.patch);
	    } else if (patch.type === VirtualPatch.VNODE) {
	      vNodePatch(node, patch.patch);
	    } else if (patch.type === VirtualPatch.COMMENT) {
	      commentPatch(node, patch);
	    } else {
	      console.error('TypeError when apply patch with unknown type: ' + patch.type);
	    }
	  }

	  function applyVirtualPatch(rootNode, patches) {
	    var indices = [];

	    for (var key in patches) {
	      if (key !== 'a') {
	        indices.push(Number(key));
	      }
	    }

	    if (indices.length === 0) {
	      return; // noop
	    }

	    var nodes = nodesByIndices(rootNode, patches.a, indices);

	    indices.forEach(function (nodeIndex) {
	      var patchList = [].concat(patches[nodeIndex]);
	      patchList.forEach(function (patch) {
	        applyPatchWithSchedule(patch, nodes[nodeIndex]);
	      });
	    });
	  }

	  /**
	   * diff虚拟树
	   */

	  function diffProps(a, b) {
	    var diff = void 0;

	    for (var aKey in a) {
	      if (!(aKey in b)) {
	        diff = diff || {};
	        diff[aKey] = undefined;
	      }

	      var aValue = a[aKey];
	      var bValue = b[aKey];

	      if (isOrigin(aValue)) {
	        // restore the origin value of objects generated by `checkDirtyProps` function
	        a[aKey] = aValue = aValue.__origin;
	      }

	      if (aValue === bValue) {
	        continue;
	      } else {
	        diff = diff || {};
	        diff[aKey] = bValue;
	      }
	    }

	    for (var bKey in b) {
	      if (!(bKey in a)) {
	        diff = diff || {};
	        diff[bKey] = b[bKey];
	      }
	    }

	    return diff;
	  }

	  // List diff, naive left to right reordering
	  function diffOrder(aChildren, bChildren) {
	    // O(M) time, O(M) memory
	    var bChildIndex = keyIndex(bChildren);
	    var bKeys = bChildIndex.keys;
	    var bFree = bChildIndex.free;

	    if (bFree.length === bChildren.length) {
	      return {
	        children: bChildren,
	        moves: null
	      };
	    }

	    // O(N) time, O(N) memory
	    var aChildIndex = keyIndex(aChildren);
	    var aKeys = aChildIndex.keys;
	    var aFree = aChildIndex.free;

	    if (aFree.length === aChildren.length) {
	      return {
	        children: bChildren,
	        moves: null
	      };
	    }

	    // O(MAX(N, M)) memory
	    var newChildren = [];

	    var freeIndex = 0;
	    var freeCount = bFree.length;
	    var deletedItems = 0;

	    // Iterate through a and match a node in b
	    // O(N) time,
	    for (var i = 0; i < aChildren.length; i++) {
	      var aItem = aChildren[i];
	      var itemIndex = void 0;

	      if (aItem.key) {
	        if (bKeys.hasOwnProperty(aItem.key)) {
	          // Match up the old keys
	          itemIndex = bKeys[aItem.key];
	          newChildren.push(bChildren[itemIndex]);
	        } else {
	          // Remove old keyed items
	          deletedItems++;
	          newChildren.push(null);
	        }
	      } else {
	        // Match the item in a with the next free item in b
	        if (freeIndex < freeCount) {
	          itemIndex = bFree[freeIndex++];
	          newChildren.push(bChildren[itemIndex]);
	        } else {
	          // There are no free items in b to match with
	          // the free items in a, so the extra free nodes
	          // are deleted.
	          deletedItems++;
	          newChildren.push(null);
	        }
	      }
	    }

	    var lastFreeIndex = freeIndex >= bFree.length ? bChildren.length : bFree[freeIndex];

	    // Iterate through b and append any new keys
	    // O(M) time
	    for (var j = 0; j < bChildren.length; j++) {
	      var newItem = bChildren[j];

	      if (newItem.key) {
	        if (!aKeys.hasOwnProperty(newItem.key)) {
	          // Add any new keyed items
	          // We are adding new items to the end and then sorting them
	          // in place. In future we should insert new items in place.
	          newChildren.push(newItem);
	        }
	      } else if (j >= lastFreeIndex) {
	        // Add any leftover non-keyed items
	        newChildren.push(newItem);
	      }
	    }

	    var simulate = newChildren.slice();
	    var simulateIndex = 0;
	    var removes = [];
	    var inserts = [];
	    var simulateItem = void 0;

	    for (var k = 0; k < bChildren.length;) {
	      var wantedItem = bChildren[k];
	      simulateItem = simulate[simulateIndex];

	      // remove items
	      while (simulateItem === null && simulate.length) {
	        removes.push(remove$1(simulate, simulateIndex, null));
	        simulateItem = simulate[simulateIndex];
	      }

	      if (!simulateItem || simulateItem.key !== wantedItem.key) {
	        // if we need a key in this position...
	        if (wantedItem.key) {
	          if (simulateItem && simulateItem.key) {
	            // if an insert doesn't put this key in place, it needs to move
	            if (bKeys[simulateItem.key] !== k + 1) {
	              removes.push(remove$1(simulate, simulateIndex, simulateItem.key));
	              simulateItem = simulate[simulateIndex];
	              // if the remove didn't put the wanted item in place, we need to insert it
	              if (!simulateItem || simulateItem.key !== wantedItem.key) {
	                inserts.push({ key: wantedItem.key, to: k });
	              } else {
	                // items are matching, so skip ahead
	                simulateIndex++;
	              }
	            } else {
	              inserts.push({ key: wantedItem.key, to: k });
	            }
	          } else {
	            inserts.push({ key: wantedItem.key, to: k });
	          }
	          k++;
	        } else if (simulateItem && simulateItem.key) {
	          // a key in simulate has no matching wanted key, remove it
	          removes.push(remove$1(simulate, simulateIndex, simulateItem.key));
	        }
	      } else {
	        simulateIndex++;
	        k++;
	      }
	    }

	    // remove all the remaining nodes from simulate
	    while (simulateIndex < simulate.length) {
	      simulateItem = simulate[simulateIndex];
	      removes.push(remove$1(simulate, simulateIndex, simulateItem && simulateItem.key));
	    }

	    // If the only moves we have are deletes then we can just
	    // let the delete patch remove these items.
	    if (removes.length === deletedItems && !inserts.length) {
	      return {
	        children: newChildren,
	        moves: null
	      };
	    }

	    return {
	      children: newChildren,
	      moves: {
	        removes: removes,
	        inserts: inserts
	      }
	    };
	  }

	  function diffChildren(a, b, patch, apply, index) {
	    var aChildren = a.children;
	    var orderedSet = diffOrder(aChildren, b.children);
	    var bChildren = orderedSet.children;

	    var aLen = aChildren.length;
	    var bLen = bChildren.length;
	    var len = aLen > bLen ? aLen : bLen;

	    var _loop = function (i) {
	      var leftNode = aChildren[i];
	      var rightNode = bChildren[i];

	      index++;

	      if (!leftNode) {
	        if (rightNode) {
	          var needMove = void 0;
	          if (rightNode.key && orderedSet.moves) {
	            needMove = orderedSet.moves.removes.findIndex(function (i) {
	              return i.key === rightNode.key;
	            });
	          }
	          if (needMove >= 0) {
	            orderedSet.moves.removes.splice(needMove, 1);
	            var insert = orderedSet.moves.inserts.findIndex(function (i) {
	              return i.key === rightNode.key;
	            });
	            if (insert !== -1) {
	              var op = orderedSet.moves.inserts.splice(insert, 1);

	              orderedSet.moves.inserts2 = orderedSet.moves.inserts2 || [];
	              orderedSet.moves.inserts2.push({
	                to: op[0].to,
	                vnode: rightNode
	              });
	            }
	          } else {
	            // Excess nodes in b need to be added
	            apply = appendPatch(apply, new VirtualPatch(VirtualPatch.INSERT, null, rightNode));
	          }
	        }
	      } else {
	        walk(leftNode, rightNode, patch, index);
	      }

	      if (isVNode(leftNode) && leftNode.count) {
	        index += leftNode.count;
	      }
	    };

	    for (var i = 0; i < len; i++) {
	      _loop(i);
	    }

	    if (orderedSet.moves) {
	      if (orderedSet.moves.inserts2) {
	        // update the others' position
	        var _len2 = orderedSet.moves.inserts2.length;
	        for (var i = 0; i < orderedSet.moves.inserts.length; i++) {
	          orderedSet.moves.inserts[i].to -= _len2;
	        }
	      }
	      // Reorder nodes last
	      apply = appendPatch(apply, new VirtualPatch(VirtualPatch.ORDER, a, orderedSet.moves));
	    }

	    return apply;
	  }

	  function walk(a, b, patch, index) {
	    if (a === b) {
	      return;
	    }

	    var apply = patch[index];

	    if (b == null) {
	      apply = appendPatch(apply, new VirtualPatch(VirtualPatch.REMOVE, a, b));
	    } else if (isVNode(b)) {
	      if (isVNode(a)) {
	        if (a.tagName === b.tagName && a.key === b.key) {
	          var propsPatch = diffProps(a.properties, b.properties);
	          if (propsPatch) {
	            apply = appendPatch(apply, new VirtualPatch(VirtualPatch.PROPS, a, propsPatch));
	          }
	          apply = diffChildren(a, b, patch, apply, index);
	        } else {
	          apply = appendPatch(apply, new VirtualPatch(VirtualPatch.VNODE, a, b));
	        }
	      } else {
	        apply = appendPatch(apply, new VirtualPatch(VirtualPatch.VNODE, a, b));
	      }
	    } else if (isVText(b)) {
	      if (!isVText(a)) {
	        apply = appendPatch(apply, new VirtualPatch(VirtualPatch.VTEXT, a, b));
	      } else if (a.text !== b.text) {
	        apply = appendPatch(apply, new VirtualPatch(VirtualPatch.VTEXT, a, b));
	      }
	    } else if (isVComment(b)) {
	      if (!isVComment(a)) {
	        apply = appendPatch(apply, new VirtualPatch(VirtualPatch.VNODE, a, b));
	      } else if (a.text !== b.text) {
	        apply = appendPatch(apply, new VirtualPatch(VirtualPatch.COMMENT, a, b));
	      }
	    }

	    if (apply) {
	      patch[index] = apply;
	    }
	  }

	  function diff(a, b) {
	    var patch = { a: a };
	    walk(a, b, patch, 0);
	    return patch;
	  }

	  var diffVirtualTree = diff;

	  // uuid 对应的 observe 长度 eg: uuid: observelist.length
	  var observeIdCache = {};
	  // observe 所有的domitem队列 eg: uuid#index: observer
	  // const observeListCache = {};
	  // 所有计算结果的产物 eg: uuid#index: result
	  var observeResultCache = {};

	  var scheduleIntersectionFlag = false;

	  function _registerIntersection(observelist, relativeInfolist, thresholds, currentRatio, minWidthOrHeight, cb) {
	    var uid = guid();

	    if (!observelist.length || !relativeInfolist.length) {
	      return uid;
	    }

	    observeIdCache[uid] = observelist.length;

	    observelist.forEach(function (observeitem, index) {
	      var uuidindex = uid + '#' + index,
	          result = {
	        targetNode: observeitem,
	        relatives: relativeInfolist,
	        thresholds: thresholds,
	        currentRatio: currentRatio,
	        minWidthOrHeight: minWidthOrHeight,
	        cb: cb
	      };
	      // TODO 创建一个队列，监听元素的 attached detached

	      // TODO 初始化时检测是否相交并触发检测
	      observeResultCache[uuidindex] = result;
	    });

	    return uid;
	  }

	  function _check(result) {
	    var targetNode = result.targetNode,
	        relatives = result.relatives,
	        thresholds = result.thresholds,
	        minWidthOrHeight = result.minWidthOrHeight,
	        cb = result.cb,
	        currentRatio = result.currentRatio;


	    var minRelativeRect = _getMinRelativeRect(relatives);

	    var observeRect = _format(targetNode.getBoundingClientRect());

	    if (observeRect.right - observeRect.left < minWidthOrHeight) {
	      observeRect.right = observeRect.left + minWidthOrHeight;
	      observeRect.width = minWidthOrHeight;
	    }
	    if (observeRect.bottom - observeRect.top < minWidthOrHeight) {
	      observeRect.bottom = observeRect.top + minWidthOrHeight;
	      observeRect.height = minWidthOrHeight;
	    }
	    var intersectionRect = _getIntersection(minRelativeRect, observeRect),
	        observeArea = observeRect.width * observeRect.height,
	        newRatio = observeArea ? intersectionRect.width * intersectionRect.height / observeArea : 0;

	    result.currentRatio = newRatio;

	    var triggerFlag = currentRatio === undefined;

	    if (newRatio !== currentRatio) {
	      thresholds.forEach(function (threshold) {
	        if (triggerFlag) {
	          return false;
	        }
	        if (newRatio <= threshold && threshold <= currentRatio) {
	          triggerFlag = true;
	        } else if (threshold <= newRatio && currentRatio <= threshold) {
	          triggerFlag = true;
	        }
	      });
	    }

	    if (triggerFlag) {
	      cb.call(targetNode, {
	        id: targetNode.id,
	        dataset: targetNode.dataset,
	        time: Date.now(),
	        boundingClientRect: observeRect,
	        intersectionRatio: newRatio,
	        intersectionRect: _format(intersectionRect),
	        relativeRect: minRelativeRect
	      });
	    }
	  }

	  function _getMinRelativeRect(relatives) {
	    var clientWidth = document.documentElement.clientWidth,
	        clientHeight = document.documentElement.clientHeight;
	    var relativeRect = null;

	    for (var i = 0, l = relatives.length; i < l; i++) {
	      var relative = relatives[i],
	          node = relative.node,
	          margins = relative.margins,
	          currentRect = node ? node.getBoundingClientRect() : {
	        left: 0,
	        top: 0,
	        right: clientWidth,
	        bottom: clientHeight,
	        width: clientWidth,
	        height: clientHeight
	      },
	          currentRectMargin = {
	        left: currentRect.left - margins.left,
	        top: currentRect.top - margins.top,
	        right: currentRect.right + margins.right,
	        bottom: currentRect.bottom + margins.bottom
	      };

	      relativeRect = relativeRect ? _getIntersection(relativeRect, currentRectMargin) : currentRectMargin;
	    }

	    return relativeRect;
	  }

	  function _format() {
	    var rect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    return {
	      left: rect.left,
	      top: rect.top,
	      right: rect.right,
	      bottom: rect.bottom,
	      width: rect.width,
	      height: rect.height
	    };
	  }

	  function _getIntersection(e, t) {
	    var intersectionRect = {
	      left: Math.max(e.left, t.left),
	      top: Math.max(e.top, t.top),
	      right: Math.min(e.right, t.right),
	      bottom: Math.min(e.bottom, t.bottom),
	      width: 0,
	      height: 0
	    };
	    if (intersectionRect.right > intersectionRect.left) {
	      intersectionRect.width = intersectionRect.right - intersectionRect.left;
	    } else {
	      intersectionRect.right = intersectionRect.left = intersectionRect.bottom = intersectionRect.top = 0;
	    }

	    if (intersectionRect.bottom > intersectionRect.top) {
	      intersectionRect.height = intersectionRect.bottom - intersectionRect.top;
	    } else {
	      intersectionRect.right = intersectionRect.left = intersectionRect.bottom = intersectionRect.top = 0;
	    }

	    return intersectionRect;
	  }

	  function addIntersectionObserver(rootdom, targetSelector, relativeInfo) {
	    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	    var callback = arguments[4];

	    // 获取 observe 的 dom
	    var observelist = [];

	    if (options.observeAll) {
	      observelist = rootdom.querySelectorAll(targetSelector);
	    } else {
	      var r = rootdom.querySelector(targetSelector);

	      observelist = r ? [r] : [];
	    }

	    if (!observelist.length) {
	      logger.warn('For developer:Node ' + targetSelector + ' is not found. Intersection observer will not trigger.');
	    }

	    // 处理 relativeTo
	    var relativeInfolist = [];

	    relativeInfo.forEach(function (_ref3) {
	      var _ref3$selector = _ref3.selector,
	          selector = _ref3$selector === undefined ? null : _ref3$selector,
	          _ref3$margins = _ref3.margins,
	          margins = _ref3$margins === undefined ? {} : _ref3$margins;
	      var _margins$left = margins.left,
	          left = _margins$left === undefined ? 0 : _margins$left,
	          _margins$top = margins.top,
	          top = _margins$top === undefined ? 0 : _margins$top,
	          _margins$right = margins.right,
	          right = _margins$right === undefined ? 0 : _margins$right,
	          _margins$bottom = margins.bottom,
	          bottom = _margins$bottom === undefined ? 0 : _margins$bottom;

	      var node = selector === null ? null : rootdom.querySelector(selector);

	      if (selector === null || node) {
	        relativeInfolist.push({
	          node: node,
	          margins: {
	            left: left,
	            top: top,
	            right: right,
	            bottom: bottom
	          }
	        });
	      } else {
	        logger.warn('For developer:Node ' + selector + ' is not found. The relative node for intersection observer will be ignored.');
	      }
	    });

	    if (!relativeInfolist.length) {
	      console.warn('For developer:Intersection observer will be ignored because no relative nodes are found.');
	    }

	    _registerIntersection(observelist, relativeInfolist, options.thresholds || [0], options.initialRatio || 0, options.minWidthOrHeight || 0, callback);
	  }
	  function removeIntersectionObserver(observerId) {
	    var length = observeIdCache[observerId];

	    delete observeIdCache[observerId];

	    for (var i = 0; i < length; i++) {
	      var uuidindex = observerId + '#' + i;

	      if (observeResultCache[uuidindex]) {
	        delete observeResultCache[uuidindex];
	      }
	    }
	  }
	  function scheduleIntersectionUpdate() {
	    if (!scheduleIntersectionFlag) {
	      scheduleIntersectionFlag = true;

	      requestAnimationFrame(function () {
	        scheduleIntersectionFlag = false;

	        for (var i in observeResultCache) {
	          _check(observeResultCache[i]);
	        }
	      });
	    }
	  }

	  /**
	   * createVirtualTree第一个参数func是wxml编译生成的render函数
	   * render函数使用window.__h方法生成虚拟节点
	   */

	  function TreeContext(data) {
	    if (!isObject(data) || isArray(data)) {
	      throw new Error('Page data must be a plain object');
	    }

	    var obHash = {};

	    var observable = Object.create({
	      observe: function (key, callback) {
	        obHash[key] = callback;
	      },
	      merge: function (data) {
	        var _this = this;

	        Object.keys(data).forEach(function (key) {
	          // split 'a[0].b[1][2].c' to ['a', '0', 'b', '1', '2', 'c']
	          var dotKey = key.replace(/\[([0-9]+)\]/g, function (_, $1) {
	            return '.' + $1;
	          });
	          var slcts = dotKey.split('.');
	          var cached = _this.data;
	          for (;;) {
	            var slct = slcts.shift();
	            // filter illegal selector
	            // 外层setData已拦截异常情况
	            if (/\[.+\]/.test(slct)) {
	              break;
	            }
	            if (!slcts.length) {
	              if (cached) {
	                var old = cached[slct];
	                cached[slct] = data[key];
	                // execute callback
	                typeof obHash[dotKey] === 'function' && obHash[dotKey](cached[slct], old);
	              }
	              break;
	            } else {
	              // 这里clone是为了如下case
	              // 假如开发者set 'xxxx.yyy' 更新yyy的数据
	              // 属性上又监听了xxx
	              // 假如不进行clone，将会以为没有变化，产生异常
	              clone$1(cached, slct);

	              cached = cached[slct];
	            }
	          }
	        });
	      }
	    });

	    // init data
	    observable.data = {};
	    Object.keys(data).forEach(function (key) {
	      observable.data[key] = data[key];
	    });

	    return observable;
	  }

	  // global observable context
	  var treeContext = void 0;
	  var dirtyCheck = {}; // flags

	  function resetVdomStates() {
	    treeContext = void 0;
	    dirtyCheck = {};
	  }

	  function checkDirtyProps(propVal, deps) {
	    // TODO, 有些key不需要做脏检查，可以在compiler里过滤一下
	    if (isObject(propVal)) {
	      // 所有的Object在diffProps的时候都会产生patch，所以不需要脏检查
	      return propVal;
	    }

	    if (!deps || !deps.length) {
	      return propVal;
	    }

	    var checkId = deps.join('-');

	    if (!dirtyCheck.hasOwnProperty(checkId)) {
	      // add observer to treeContext
	      deps.forEach(function (path) {
	        return treeContext.observe(path, function () {
	          dirtyCheck[checkId] = true;
	        });
	      });
	      dirtyCheck[checkId] = false;
	    }

	    if (dirtyCheck[checkId]) {
	      // reset ditry check flags
	      dirtyCheck[checkId] = false;

	      // cast prop value to a object, since
	      // if the new prop value is object, it must be dirty according to `diffProps` function
	      propVal = makeOrigin(propVal);
	    }

	    return propVal;
	  }

	  function createVirtualTree(func, data) {
	    if (!treeContext) {
	      // this is the first time create the tree
	      treeContext = TreeContext(data);
	    } else {
	      // apply new states to cached data
	      treeContext.merge(data);
	    }
	    return h$1('body', { id: 'app' }, func.render.call(func, treeContext.data));
	  }

	  function createEmptyNode() {
	    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	    return new VirtualComment(text);
	  }

	  var vdom = /*#__PURE__*/Object.freeze({
	    h: h$1,
	    createEmptyNode: createEmptyNode,
	    resetVdomStates: resetVdomStates,
	    checkDirtyProps: checkDirtyProps,
	    createVirtualTree: createVirtualTree,
	    diffVirtualTree: diffVirtualTree,
	    applyVirtualPatch: applyVirtualPatch,
	    addListener: addListener$1,
	    createElement: createElement,
	    addIntersectionObserver: addIntersectionObserver,
	    removeIntersectionObserver: removeIntersectionObserver,
	    scheduleIntersectionUpdate: scheduleIntersectionUpdate
	  });

	  window.__h = h$1;
	  window.__render = createElement;
	  window.__diff = diffVirtualTree;
	  window.__apply = applyVirtualPatch;
	  window.__exprWrapper__ = checkDirtyProps;
	  window.__resetVdomStates__ = resetVdomStates;
	  window.__addListenerToElement = addListener$1;
	  window.__emptyNode = createEmptyNode;
	  window._addIntersectionObserver = addIntersectionObserver;
	  window._removeIntersectionObserver = removeIntersectionObserver;
	  window._scheduleIntersectionUpdate = scheduleIntersectionUpdate;
	  window.__virtualDOM__ = vdom;
	  window.__SideEffectFnQueues = [];
	  window.__DOMTree__ = null;
	  window.__VTree__ = null;

	  var renderStatus = window.renderStatus = {
	    funcReady: false,
	    dataReady: false,
	    firstRendered: false
	  };
	  var timeStamps = {
	    webviewStartTime: Date.now(),
	    funcReadyTs: Date.now()
	  };

	  var statusManager = function () {
	    function statusManager() {
	      classCallCheck(this, statusManager);
	    }

	    createClass(statusManager, null, [{
	      key: 'dataReady',
	      get: function () {
	        return renderStatus.dataReady;
	      },
	      set: function (e) {
	        renderStatus.dataReady = e;
	      }
	    }, {
	      key: 'funcReady',
	      get: function () {
	        return renderStatus.funcReady;
	      },
	      set: function (e) {
	        renderStatus.funcReady = e;
	      }
	    }]);
	    return statusManager;
	  }();

	  var timeStampManager = function () {
	    function timeStampManager() {
	      classCallCheck(this, timeStampManager);
	    }

	    createClass(timeStampManager, null, [{
	      key: 'funcReadyTs',
	      get: function () {
	        return timeStamps.funcReadyTs;
	      },
	      set: function (ts) {
	        timeStamps.funcReadyTs = ts;
	      }
	    }, {
	      key: 'webviewStartTime',
	      get: function () {
	        return timeStamps.webviewStartTime;
	      },
	      set: function (ts) {
	        timeStamps.webviewStartTime = ts;
	      }
	    }]);
	    return timeStampManager;
	  }();

	  function renderPage(res, callback) {
	    if (renderStatus.firstRendered) {
	      // patch renderer
	      // 删除 settimeout，防止用户在 onload 等生命周期 setData，事件较慢
	      var startRenderTs = Date.now();
	      patchRenderer(res);
	      speedReport('reRenderTime', startRenderTs, Date.now());
	      document.dispatchEvent(new CustomEvent('pageReRender', {
	        detail: { source: 'appDataChange' }
	      }));

	      callback(res);
	    } else {
	      // first renderer
	      var ts = Date.now();
	      speedReport('firstGetData', timeStamps.funcReadyTs, Date.now());
	      tt.addTimingDots({
	        pageRenderStart: Date.now()
	      });

	      // make all
	      renderAll(res);

	      speedReport('firstRenderTime', ts, Date.now());

	      renderStatus.firstRendered = true;
	    }
	  }

	  function renderAll(_ref) {
	    var data = _ref.data,
	        ext = _ref.ext;

	    var isPageReloaded = false;
	    var pageScrollTop = void 0;
	    var timingDots = {};
	    if (ext) {
	      var webviewId = ext.webviewId,
	          disableSwipeBack = ext.disableSwipeBack,
	          enablePullUpRefresh = ext.enablePullUpRefresh,
	          onReachBottomDistance = ext.onReachBottomDistance,
	          isPageReload = ext.isPageReload,
	          scene = ext.scene,
	          route = ext.route,
	          lastRoute = ext.lastRoute,
	          _ext$query = ext.query,
	          query = _ext$query === undefined ? {} : _ext$query,
	          _ext$lastQuery = ext.lastQuery,
	          lastQuery = _ext$lastQuery === undefined ? {} : _ext$lastQuery,
	          customComponents = ext.customComponents;

	      pageScrollTop = ext.pageScrollTop;
	      window.__webviewId__ = /iphone/i.test(navigator.userAgent) ? webviewId + 1 : webviewId;
	      window.TMAConfig.disableSwipeBack = disableSwipeBack;

	      if (enablePullUpRefresh) {
	        window.__onReachBottomDistance__ = onReachBottomDistance;
	      }

	      if (customComponents) {
	        window.__componentconfig__ = customComponents;
	      }

	      // app-service 发送过来 customComponents, 发送消息(为了兼容老 r2d2)
	      document.dispatchEvent(new CustomEvent('customComponentsRender', {
	        detail: {}
	      }));

	      if (isPageReload) {
	        isPageReloaded = isPageReload;
	      }

	      if (scene) {
	        window.__scene__ = scene;
	      }

	      window.__route__ = route;
	      window.__lastRoute__ = lastRoute;
	      window.__query__ = query;
	      window.__queryString__ = Object.keys(query).map(function (t) {
	        return t + '=' + query[t];
	      }).join('&');
	      window.__lastQueryString__ = Object.keys(lastQuery).map(function (t) {
	        return t + '=' + lastQuery[t];
	      }).join('&');
	    }
	    timingDots['pageVTreeStart'] = Date.now();
	    window.__VTree__ = createVirtualTree(window.__generateFunc__, data);
	    timingDots['pageDOMTreeStart'] = Date.now();
	    window.__DOMTree__ = createElement(window.__VTree__);
	    timingDots['pageDOMTreeEnd'] = Date.now();
	    tt.addTimingDots(timingDots);

	    document.body.parentNode.replaceChild(window.__DOMTree__, document.body);

	    // trigger onRouteDone
	    window.__onAppRouteDone = true;

	    document.dispatchEvent(new CustomEvent('pageReRender', {}));

	    window.requestAnimationFrame(function () {
	      // firse render event
	      if (!isPageReloaded) {
	        tt.publishPageEvent('__DOMReady', {});
	      }

	      if (ext) {
	        enableScroll(ext);
	      }

	      if (isPageReloaded) {
	        recoverPageState({
	          scrollTop: pageScrollTop
	        });
	      }
	    });
	  }

	  function patchRenderer(_ref2) {
	    var data = _ref2.data;

	    var timingDots = {};

	    timingDots['setDataVTreeStart'] = Date.now();
	    var newTree = createVirtualTree(window.__generateFunc__, data);
	    timingDots['setDataPatchStart'] = Date.now();
	    var patches = diffVirtualTree(window.__VTree__, newTree);
	    timingDots['setDataRenderStart'] = Date.now();

	    window.__SideEffectFnQueues.push(new SideEffectFnQueue());

	    applyVirtualPatch(window.__DOMTree__, patches);

	    timingDots['setDataRenderEnd'] = Date.now();

	    if (data && data.needDataPerformance) {
	      tt.addTimingDots(timingDots);
	      tt.setPerformance();
	    }

	    window.__VTree__ = newTree;

	    if (window.__SideEffectFnQueues.length > 0) {
	      var queue = window.__SideEffectFnQueues.pop();
	      queue.triggerAll();
	      queue = null;
	    }
	  }

	  function initBasicFontSize() {
	    document.addEventListener('DOMContentLoaded', function () {
	      var width = window.innerWidth;
	      var $doc = document.documentElement;
	      $doc.style.fontSize = width / 20 + 'px';
	      var realSize = window.getComputedStyle($doc).fontSize;
	      if ($doc.style.fontSize != realSize) {
	        // 有问题，这个设备比如三星note8，fontSize竟然不准，重新设置一下
	        var r = parseFloat($doc.style.fontSize) / parseFloat(realSize);
	        $doc.style.fontSize = r * width / 20 + 'px';
	      }
	    });
	  }

	  function defineBodyScrollGetter() {
	    // 兼容已经有scrollTop属性报redefine property的错误
	    if (document.body.hasOwnProperty('scrollTop') || document.body.scrollTop !== undefined) {
	      return;
	    }
	    setTimeout(function () {
	      Object.defineProperty(document.body, 'scrollTop', {
	        get: function () {
	          return document.documentElement.scrollTop;
	        },
	        set: function (value) {
	          document.documentElement.scrollTop = value;
	        },

	        configurable: true
	      });
	    }, 100);
	  }

	  var vdom$1 = window.__virtualDOM__;
	  var addIntersectionObserver$1 = vdom$1.addIntersectionObserver;
	  var removeIntersectionObserver$1 = vdom$1.removeIntersectionObserver;

	  function onRequestComponentObserver() {

	    if ('undefined' != typeof window && 'undefined' != typeof document) {
	      document.addEventListener('pageReRender', function () {
	        vdom$1.scheduleIntersectionUpdate();
	      });
	      window.addEventListener('scroll', function () {
	        vdom$1.scheduleIntersectionUpdate();
	      }, {
	        capture: true,
	        passive: true
	      });
	    }

	    tt.onRequestComponentObserver(function (_ref) {
	      var req = _ref.req,
	          reqId = _ref.reqId;

	      if ('addIntersectionObserver' === req.type) {
	        var rootdom = null;
	        var components = getAllComponent();

	        if (req.nodeId) {
	          rootdom = components[req.nodeId];
	        } else {
	          rootdom = window.__DOMTree__;
	        }

	        if (!rootdom) {
	          return;
	        }

	        var observerId = addIntersectionObserver$1(rootdom, req.targetSelector, req.relativeInfo, req.options, function (info) {
	          tt.sendComponentObserver({
	            reqId: reqId,
	            res: {
	              info: info
	            }
	          });
	        });

	        tt.sendComponentObserver({
	          reqId: reqId,
	          res: {
	            observerId: observerId
	          }
	        });
	      } else if ('removeIntersectionObserver' === req.type) {
	        removeIntersectionObserver$1(req.observerId);

	        tt.sendComponentObserver({
	          reqId: reqId,
	          reqEnd: true
	        });
	      }
	    });
	  }

	  var renderList = [];

	  // bootstrap
	  initBasicFontSize();
	  catchWindowError();
	  onRequestComponentInfo();
	  onRequestComponentObserver();

	  // render when data changes
	  tt.onAppDataChange(catchError(function (res, cb) {
	    statusManager.dataReady = true;

	    if (statusManager.funcReady) {
	      renderPage(res, cb);
	    } else {
	      renderList.push({
	        res: res,
	        cb: cb
	      });
	    }
	  }));

	  // listen select component in page
	  tt.onSelectComponentInPage(catchError(function (res, cb) {
	    var selector = res.selector,
	        single = res.single;


	    if (single) {
	      var node = document.querySelector(selector);

	      cb(isCustomComponent(node) ? node._id : null);
	    } else {
	      var nodes = Array.from(document.querySelectorAll(selector));

	      cb(nodes.reduce(function (prev, next) {
	        if (isCustomComponent(next)) {
	          prev.push(next._id);
	        }
	        return prev;
	      }, []));
	    }
	  }));

	  // first renderer
	  document.addEventListener('generateFuncReady', catchError(function (_ref2) {
	    var generateFunc = _ref2.detail.generateFunc;

	    defineBodyScrollGetter();

	    // first renderer ts
	    window.__pageEnterTime__ && (timeStampManager.webviewStartTime = window.__pageEnterTime__);
	    timeStampManager.funcReadyTs = Date.now();

	    // reports
	    speedReport('funcReady', timeStampManager.webviewStartTime, timeStampManager.funcReadyTs);
	    window.__pageFrameStartTime__ && window.__pageFrameEndTime__ && speedReport('pageframe', window.__pageFrameStartTime__, window.__pageFrameEndTime__);
	    window.__WAWebviewStartTime__ && window.__WAWebviewEndTime__ && speedReport('WAWebview', window.__WAWebviewStartTime__, window.__WAWebviewEndTime__);

	    // func cache
	    window.__generateFunc__ = generateFunc;

	    statusManager.funcReady = true;

	    if (statusManager.dataReady) {
	      for (var t in renderList) {
	        renderPage(renderList[t].res, renderList[t].cb);
	      }
	    }
	  }));

	  // errors and panic
	  tt.onPageScrollTo(catchError(onPageScrollTo));

	  tt.onWebViewWillManuallyTerminate(function (e) {
	    return catchError(function () {
	      savePageState();
	      tt.webViewReadyToTerminate();
	    });
	  });

	  // 监听页面上的动画事件，并触发pageReRender
	  !function () {
	    var timer = null;
	    ['animationstart', 'animationiteration', 'animationend', 'transitionend'].forEach(function (eventName) {
	      window.addEventListener(eventName, function () {
	        clearTimeout(timer);
	        timer = setTimeout(function () {
	          return document.dispatchEvent(new CustomEvent('pageReRender', {}));
	        }, 20);
	      }, true);
	    });
	  }();

	  // 解决ios上双击时页面滚动的问题，但是也怕引入其它问题，危险！
	  !function () {
	    var ua = window.navigator.userAgent.toLowerCase();
	    var iLastTouch = null;
	    if (ua.indexOf('iphone') >= 0 || ua.indexOf('ipad') >= 0) {
	      document.addEventListener('touchend', function (e) {
	        var iNow = Date.now();
	        iLastTouch = iLastTouch || iNow + 1;
	        var delta = iNow - iLastTouch;
	        if (delta < 500 && delta > 0) {
	          e.preventDefault();
	          return false;
	        }
	        iLastTouch = iNow;
	      }, false);
	    }
	  }();

	  (function (self) {
	    (function (boot) {
	      if (ttJSBridge) {
	        return boot();
	      }

	      document.addEventListener('ttJSBridgeReady', boot, false);
	    })(function () {

	      ttJSBridge.subscribe('setKeyboardValue', function (e) {
	        // console.log('setKeyboardValue', e)
	        if (e && e.data) {
	          document.dispatchEvent(new CustomEvent('setKeyboardValue', {
	            detail: {
	              value: e.data.value,
	              cursor: e.data.cursor,
	              inputId: e.data.inputId
	            }
	          }));
	        }
	      });

	      // 临时方案，app-service发一个消息过来，in future should be deprecated
	      ttJSBridge.subscribe('disable-scroll', function (e) {
	        ttJSBridge.invoke('disableScrollBounce', {
	          disable: e.data.disable
	        });
	      });

	      ttJSBridge.subscribe('hideKeyboard', function (e) {
	        document.dispatchEvent(new CustomEvent('hideKeyboard', {}));
	      });

	      ttJSBridge.on('onKeyboardComplete', function (e) {
	        // console.log('onKeyboardComplete', e)
	        document.dispatchEvent(new CustomEvent('onKeyboardComplete', {
	          detail: {
	            value: e.value,
	            inputId: e.inputId,
	            cursor: 'number' == typeof e.cursor ? e.cursor : -1
	          }
	        }));
	      });

	      ttJSBridge.on('onKeyboardConfirm', function (e) {
	        // console.log('onKeyboardConfirm', e)
	        document.dispatchEvent(new CustomEvent('onKeyboardConfirm', {
	          detail: {
	            value: e.value,
	            inputId: e.inputId
	          }
	        }));
	      });

	      ttJSBridge.on('onTextAreaHeightChange', function (e) {
	        // console.log('onTextAreaHeightChange', e)
	        document.dispatchEvent(new CustomEvent('onTextAreaHeightChange', {
	          detail: {
	            height: e.height,
	            lineCount: e.lineCount,
	            inputId: e.inputId
	          }
	        }));
	      });

	      ttJSBridge.on('onKeyboardShow', function (e) {
	        // console.log('onKeyboardShow', e)
	        document.dispatchEvent(new CustomEvent('onKeyboardShow', {
	          detail: {
	            inputId: e.inputId,
	            height: e.height
	          }
	        }));
	      });
	    });

	    self.addEventListener('error', function (e) {
	      document.dispatchEvent(new CustomEvent('globalError', {
	        error: e
	      }));
	    }, true);
	  })(window);

	}());

}());
