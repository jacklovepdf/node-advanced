(function($glob$){ $glob$.__JSSDK_VERSION__ = {
    SDKVersion: '',
    SDKUpdateVersion: '',
    CommitHash: ''
  };
var TMGCORE = (function () {
	'use strict';

	
	    var logger = {};
	  ;

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
	});

	var _global$1 = /*#__PURE__*/Object.freeze({
		default: _global,
		__moduleExports: _global
	});

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function _has(it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var _has$1 = /*#__PURE__*/Object.freeze({
		default: _has,
		__moduleExports: _has
	});

	var _fails = function _fails(exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	var _fails$1 = /*#__PURE__*/Object.freeze({
		default: _fails,
		__moduleExports: _fails
	});

	var require$$1 = ( _fails$1 && _fails ) || _fails$1;

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !require$$1(function () {
	  return Object.defineProperty({}, 'a', { get: function get() {
	      return 7;
	    } }).a != 7;
	});

	var _descriptors$1 = /*#__PURE__*/Object.freeze({
		default: _descriptors,
		__moduleExports: _descriptors
	});

	var _core = createCommonjsModule(function (module) {
	  var core = module.exports = { version: '2.5.3' };
	  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _core$1 = /*#__PURE__*/Object.freeze({
		default: _core,
		__moduleExports: _core,
		version: _core_1
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	var inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	var possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	var _isObject = function _isObject(it) {
	  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
	};

	var _isObject$1 = /*#__PURE__*/Object.freeze({
		default: _isObject,
		__moduleExports: _isObject
	});

	var isObject = ( _isObject$1 && _isObject ) || _isObject$1;

	var _anObject = function _anObject(it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _anObject$1 = /*#__PURE__*/Object.freeze({
		default: _anObject,
		__moduleExports: _anObject
	});

	var require$$0 = ( _global$1 && _global ) || _global$1;

	var document$1 = require$$0.document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document$1) && isObject(document$1.createElement);
	var _domCreate = function _domCreate(it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _domCreate$1 = /*#__PURE__*/Object.freeze({
		default: _domCreate,
		__moduleExports: _domCreate
	});

	var require$$0$1 = ( _descriptors$1 && _descriptors ) || _descriptors$1;

	var require$$2 = ( _domCreate$1 && _domCreate ) || _domCreate$1;

	var _ie8DomDefine = !require$$0$1 && !require$$1(function () {
	  return Object.defineProperty(require$$2('div'), 'a', { get: function get() {
	      return 7;
	    } }).a != 7;
	});

	var _ie8DomDefine$1 = /*#__PURE__*/Object.freeze({
		default: _ie8DomDefine,
		__moduleExports: _ie8DomDefine
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function _toPrimitive(it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var _toPrimitive$1 = /*#__PURE__*/Object.freeze({
		default: _toPrimitive,
		__moduleExports: _toPrimitive
	});

	var anObject = ( _anObject$1 && _anObject ) || _anObject$1;

	var IE8_DOM_DEFINE = ( _ie8DomDefine$1 && _ie8DomDefine ) || _ie8DomDefine$1;

	var require$$16 = ( _toPrimitive$1 && _toPrimitive ) || _toPrimitive$1;

	var dP = Object.defineProperty;

	var f = require$$0$1 ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = require$$16(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) {/* empty */}
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var _objectDp = {
	  f: f
	};

	var _objectDp$1 = /*#__PURE__*/Object.freeze({
		default: _objectDp,
		__moduleExports: _objectDp,
		f: f
	});

	var _propertyDesc = function _propertyDesc(bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _propertyDesc$1 = /*#__PURE__*/Object.freeze({
		default: _propertyDesc,
		__moduleExports: _propertyDesc
	});

	var require$$37 = ( _objectDp$1 && _objectDp ) || _objectDp$1;

	var descriptor = ( _propertyDesc$1 && _propertyDesc ) || _propertyDesc$1;

	var _hide = require$$0$1 ? function (object, key, value) {
	  return require$$37.f(object, key, descriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var _hide$1 = /*#__PURE__*/Object.freeze({
		default: _hide,
		__moduleExports: _hide
	});

	var id = 0;
	var px = Math.random();
	var _uid = function _uid(key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _uid$1 = /*#__PURE__*/Object.freeze({
		default: _uid,
		__moduleExports: _uid
	});

	var require$$0$2 = ( _hide$1 && _hide ) || _hide$1;

	var has = ( _has$1 && _has ) || _has$1;

	var uid = ( _uid$1 && _uid ) || _uid$1;

	var require$$1$1 = ( _core$1 && _core ) || _core$1;

	var _redefine = createCommonjsModule(function (module) {
	  var SRC = uid('src');
	  var TO_STRING = 'toString';
	  var $toString = Function[TO_STRING];
	  var TPL = ('' + $toString).split(TO_STRING);

	  require$$1$1.inspectSource = function (it) {
	    return $toString.call(it);
	  };

	  (module.exports = function (O, key, val, safe) {
	    var isFunction = typeof val == 'function';
	    if (isFunction) has(val, 'name') || require$$0$2(val, 'name', key);
	    if (O[key] === val) return;
	    if (isFunction) has(val, SRC) || require$$0$2(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	    if (O === require$$0) {
	      O[key] = val;
	    } else if (!safe) {
	      delete O[key];
	      require$$0$2(O, key, val);
	    } else if (O[key]) {
	      O[key] = val;
	    } else {
	      require$$0$2(O, key, val);
	    }
	    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	  })(Function.prototype, TO_STRING, function toString() {
	    return typeof this == 'function' && this[SRC] || $toString.call(this);
	  });
	});

	var _redefine$1 = /*#__PURE__*/Object.freeze({
		default: _redefine,
		__moduleExports: _redefine
	});

	var _aFunction = function _aFunction(it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	var _aFunction$1 = /*#__PURE__*/Object.freeze({
		default: _aFunction,
		__moduleExports: _aFunction
	});

	var aFunction = ( _aFunction$1 && _aFunction ) || _aFunction$1;

	// optional / simple context binding

	var _ctx = function _ctx(fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1:
	      return function (a) {
	        return fn.call(that, a);
	      };
	    case 2:
	      return function (a, b) {
	        return fn.call(that, a, b);
	      };
	    case 3:
	      return function (a, b, c) {
	        return fn.call(that, a, b, c);
	      };
	  }
	  return function () /* ...args */{
	    return fn.apply(that, arguments);
	  };
	};

	var _ctx$1 = /*#__PURE__*/Object.freeze({
		default: _ctx,
		__moduleExports: _ctx
	});

	var redefine = ( _redefine$1 && _redefine ) || _redefine$1;

	var require$$7 = ( _ctx$1 && _ctx ) || _ctx$1;

	var PROTOTYPE = 'prototype';

	var $export = function $export(type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? require$$0 : IS_STATIC ? require$$0[name] || (require$$0[name] = {}) : (require$$0[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? require$$1$1 : require$$1$1[name] || (require$$1$1[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? require$$7(out, require$$0) : IS_PROTO && typeof out == 'function' ? require$$7(Function.call, out) : out;
	    // extend global
	    if (target) redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) require$$0$2(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	require$$0.core = require$$1$1;
	// type bitmap
	$export.F = 1; // forced
	$export.G = 2; // global
	$export.S = 4; // static
	$export.P = 8; // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	$export.U = 64; // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	var _export$1 = /*#__PURE__*/Object.freeze({
		default: _export,
		__moduleExports: _export
	});

	var _meta = createCommonjsModule(function (module) {
	  var META = uid('meta');

	  var setDesc = require$$37.f;
	  var id = 0;
	  var isExtensible = Object.isExtensible || function () {
	    return true;
	  };
	  var FREEZE = !require$$1(function () {
	    return isExtensible(Object.preventExtensions({}));
	  });
	  var setMeta = function setMeta(it) {
	    setDesc(it, META, { value: {
	        i: 'O' + ++id, // object ID
	        w: {} // weak collections IDs
	      } });
	  };
	  var fastKey = function fastKey(it, create) {
	    // return primitive with prefix
	    if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	    if (!has(it, META)) {
	      // can't set metadata to uncaught frozen object
	      if (!isExtensible(it)) return 'F';
	      // not necessary to add metadata
	      if (!create) return 'E';
	      // add missing metadata
	      setMeta(it);
	      // return object ID
	    }return it[META].i;
	  };
	  var getWeak = function getWeak(it, create) {
	    if (!has(it, META)) {
	      // can't set metadata to uncaught frozen object
	      if (!isExtensible(it)) return true;
	      // not necessary to add metadata
	      if (!create) return false;
	      // add missing metadata
	      setMeta(it);
	      // return hash weak collections IDs
	    }return it[META].w;
	  };
	  // add metadata on freeze-family methods calling
	  var onFreeze = function onFreeze(it) {
	    if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	    return it;
	  };
	  var meta = module.exports = {
	    KEY: META,
	    NEED: false,
	    fastKey: fastKey,
	    getWeak: getWeak,
	    onFreeze: onFreeze
	  };
	});
	var _meta_1 = _meta.KEY;
	var _meta_2 = _meta.NEED;
	var _meta_3 = _meta.fastKey;
	var _meta_4 = _meta.getWeak;
	var _meta_5 = _meta.onFreeze;

	var _meta$1 = /*#__PURE__*/Object.freeze({
		default: _meta,
		__moduleExports: _meta,
		KEY: _meta_1,
		NEED: _meta_2,
		fastKey: _meta_3,
		getWeak: _meta_4,
		onFreeze: _meta_5
	});

	var SHARED = '__core-js_shared__';
	var store = require$$0[SHARED] || (require$$0[SHARED] = {});
	var _shared = function _shared(key) {
	  return store[key] || (store[key] = {});
	};

	var _shared$1 = /*#__PURE__*/Object.freeze({
		default: _shared,
		__moduleExports: _shared
	});

	var require$$0$3 = ( _shared$1 && _shared ) || _shared$1;

	var _wks = createCommonjsModule(function (module) {
	  var store = require$$0$3('wks');

	  var _Symbol = require$$0.Symbol;
	  var USE_SYMBOL = typeof _Symbol == 'function';

	  var $exports = module.exports = function (name) {
	    return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
	  };

	  $exports.store = store;
	});

	var _wks$1 = /*#__PURE__*/Object.freeze({
		default: _wks,
		__moduleExports: _wks
	});

	var require$$0$4 = ( _wks$1 && _wks ) || _wks$1;

	var def = require$$37.f;

	var TAG = require$$0$4('toStringTag');

	var _setToStringTag = function _setToStringTag(it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};

	var _setToStringTag$1 = /*#__PURE__*/Object.freeze({
		default: _setToStringTag,
		__moduleExports: _setToStringTag
	});

	var f$1 = require$$0$4;

	var _wksExt = {
		f: f$1
	};

	var _wksExt$1 = /*#__PURE__*/Object.freeze({
		default: _wksExt,
		__moduleExports: _wksExt,
		f: f$1
	});

	var _library = false;

	var _library$1 = /*#__PURE__*/Object.freeze({
		default: _library,
		__moduleExports: _library
	});

	var require$$1$2 = ( _library$1 && _library ) || _library$1;

	var wksExt = ( _wksExt$1 && _wksExt ) || _wksExt$1;

	var defineProperty$1 = require$$37.f;
	var _wksDefine = function _wksDefine(name) {
	  var $Symbol = require$$1$1.Symbol || (require$$1$1.Symbol = require$$1$2 ? {} : require$$0.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty$1($Symbol, name, { value: wksExt.f(name) });
	};

	var _wksDefine$1 = /*#__PURE__*/Object.freeze({
		default: _wksDefine,
		__moduleExports: _wksDefine
	});

	var toString$1 = {}.toString;

	var _cof = function _cof(it) {
	  return toString$1.call(it).slice(8, -1);
	};

	var _cof$1 = /*#__PURE__*/Object.freeze({
		default: _cof,
		__moduleExports: _cof
	});

	var require$$1$3 = ( _cof$1 && _cof ) || _cof$1;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings

	// eslint-disable-next-line no-prototype-builtins
	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return require$$1$3(it) == 'String' ? it.split('') : Object(it);
	};

	var _iobject$1 = /*#__PURE__*/Object.freeze({
		default: _iobject,
		__moduleExports: _iobject
	});

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function _defined(it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	var _defined$1 = /*#__PURE__*/Object.freeze({
		default: _defined,
		__moduleExports: _defined
	});

	var IObject = ( _iobject$1 && _iobject ) || _iobject$1;

	var defined = ( _defined$1 && _defined ) || _defined$1;

	// to indexed object, toObject with fallback for non-array-like ES3 strings


	var _toIobject = function _toIobject(it) {
	  return IObject(defined(it));
	};

	var _toIobject$1 = /*#__PURE__*/Object.freeze({
		default: _toIobject,
		__moduleExports: _toIobject
	});

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function _toInteger(it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	var _toInteger$1 = /*#__PURE__*/Object.freeze({
		default: _toInteger,
		__moduleExports: _toInteger
	});

	var toInteger = ( _toInteger$1 && _toInteger ) || _toInteger$1;

	// 7.1.15 ToLength

	var min = Math.min;
	var _toLength = function _toLength(it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

	var _toLength$1 = /*#__PURE__*/Object.freeze({
		default: _toLength,
		__moduleExports: _toLength
	});

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	var _toAbsoluteIndex$1 = /*#__PURE__*/Object.freeze({
		default: _toAbsoluteIndex,
		__moduleExports: _toAbsoluteIndex
	});

	var toIObject = ( _toIobject$1 && _toIobject ) || _toIobject$1;

	var toLength = ( _toLength$1 && _toLength ) || _toLength$1;

	var require$$15 = ( _toAbsoluteIndex$1 && _toAbsoluteIndex ) || _toAbsoluteIndex$1;

	// false -> Array#indexOf
	// true  -> Array#includes


	var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this);
	    var length = toLength(O.length);
	    var index = require$$15(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	      // Array#indexOf ignores holes, Array#includes - not
	    } else for (; length > index; index++) {
	      if (IS_INCLUDES || index in O) {
	        if (O[index] === el) return IS_INCLUDES || index || 0;
	      }
	    }return !IS_INCLUDES && -1;
	  };
	};

	var _arrayIncludes$1 = /*#__PURE__*/Object.freeze({
		default: _arrayIncludes,
		__moduleExports: _arrayIncludes
	});

	var shared = require$$0$3('keys');

	var _sharedKey = function _sharedKey(key) {
	  return shared[key] || (shared[key] = uid(key));
	};

	var _sharedKey$1 = /*#__PURE__*/Object.freeze({
		default: _sharedKey,
		__moduleExports: _sharedKey
	});

	var require$$0$5 = ( _arrayIncludes$1 && _arrayIncludes ) || _arrayIncludes$1;

	var require$$1$4 = ( _sharedKey$1 && _sharedKey ) || _sharedKey$1;

	var arrayIndexOf = require$$0$5(false);
	var IE_PROTO = require$$1$4('IE_PROTO');

	var _objectKeysInternal = function _objectKeysInternal(object, names) {
	  var O = toIObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) {
	    if (key != IE_PROTO) has(O, key) && result.push(key);
	  } // Don't enum bug & hidden keys
	  while (names.length > i) {
	    if (has(O, key = names[i++])) {
	      ~arrayIndexOf(result, key) || result.push(key);
	    }
	  }return result;
	};

	var _objectKeysInternal$1 = /*#__PURE__*/Object.freeze({
		default: _objectKeysInternal,
		__moduleExports: _objectKeysInternal
	});

	// IE 8- don't enum bug keys
	var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

	var _enumBugKeys$1 = /*#__PURE__*/Object.freeze({
		default: _enumBugKeys,
		__moduleExports: _enumBugKeys
	});

	var $keys = ( _objectKeysInternal$1 && _objectKeysInternal ) || _objectKeysInternal$1;

	var require$$0$6 = ( _enumBugKeys$1 && _enumBugKeys ) || _enumBugKeys$1;

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)


	var _objectKeys = Object.keys || function keys(O) {
	  return $keys(O, require$$0$6);
	};

	var _objectKeys$1 = /*#__PURE__*/Object.freeze({
		default: _objectKeys,
		__moduleExports: _objectKeys
	});

	var f$2 = Object.getOwnPropertySymbols;

	var _objectGops = {
		f: f$2
	};

	var _objectGops$1 = /*#__PURE__*/Object.freeze({
		default: _objectGops,
		__moduleExports: _objectGops,
		f: f$2
	});

	var f$3 = {}.propertyIsEnumerable;

	var _objectPie = {
		f: f$3
	};

	var _objectPie$1 = /*#__PURE__*/Object.freeze({
		default: _objectPie,
		__moduleExports: _objectPie,
		f: f$3
	});

	var getKeys = ( _objectKeys$1 && _objectKeys ) || _objectKeys$1;

	var gOPS = ( _objectGops$1 && _objectGops ) || _objectGops$1;

	var pIE = ( _objectPie$1 && _objectPie ) || _objectPie$1;

	// all enumerable object keys, includes symbols


	var _enumKeys = function _enumKeys(it) {
	  var result = getKeys(it);
	  var getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = pIE.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) {
	      if (isEnum.call(it, key = symbols[i++])) result.push(key);
	    }
	  }return result;
	};

	var _enumKeys$1 = /*#__PURE__*/Object.freeze({
		default: _enumKeys,
		__moduleExports: _enumKeys
	});

	// 7.2.2 IsArray(argument)

	var _isArray = Array.isArray || function isArray(arg) {
	  return require$$1$3(arg) == 'Array';
	};

	var _isArray$1 = /*#__PURE__*/Object.freeze({
		default: _isArray,
		__moduleExports: _isArray
	});

	var _objectDps = require$$0$1 ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) {
	    require$$37.f(O, P = keys[i++], Properties[P]);
	  }return O;
	};

	var _objectDps$1 = /*#__PURE__*/Object.freeze({
		default: _objectDps,
		__moduleExports: _objectDps
	});

	var document$2 = require$$0.document;
	var _html = document$2 && document$2.documentElement;

	var _html$1 = /*#__PURE__*/Object.freeze({
		default: _html,
		__moduleExports: _html
	});

	var dPs = ( _objectDps$1 && _objectDps ) || _objectDps$1;

	var html = ( _html$1 && _html ) || _html$1;

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


	var IE_PROTO$1 = require$$1$4('IE_PROTO');
	var Empty = function Empty() {/* empty */};
	var PROTOTYPE$1 = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var _createDict = function createDict() {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = require$$2('iframe');
	  var i = require$$0$6.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  _createDict = iframeDocument.F;
	  while (i--) {
	    delete _createDict[PROTOTYPE$1][require$$0$6[i]];
	  }return _createDict();
	};

	var _objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE$1] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE$1] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = _createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

	var _objectCreate$1 = /*#__PURE__*/Object.freeze({
		default: _objectCreate,
		__moduleExports: _objectCreate
	});

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

	var hiddenKeys = require$$0$6.concat('length', 'prototype');

	var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};

	var _objectGopn = {
	  f: f$4
	};

	var _objectGopn$1 = /*#__PURE__*/Object.freeze({
		default: _objectGopn,
		__moduleExports: _objectGopn,
		f: f$4
	});

	var gOPN = ( _objectGopn$1 && _objectGopn ) || _objectGopn$1;

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

	var gOPN$1 = gOPN.f;
	var toString$2 = {}.toString;

	var windowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function getWindowNames(it) {
	  try {
	    return gOPN$1(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$2.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(toIObject(it));
	};

	var _objectGopnExt = {
	  f: f$5
	};

	var _objectGopnExt$1 = /*#__PURE__*/Object.freeze({
		default: _objectGopnExt,
		__moduleExports: _objectGopnExt,
		f: f$5
	});

	var gOPD = Object.getOwnPropertyDescriptor;

	var f$6 = require$$0$1 ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = require$$16(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) {/* empty */}
	  if (has(O, P)) return descriptor(!pIE.f.call(O, P), O[P]);
	};

	var _objectGopd = {
	  f: f$6
	};

	var _objectGopd$1 = /*#__PURE__*/Object.freeze({
		default: _objectGopd,
		__moduleExports: _objectGopd,
		f: f$6
	});

	var require$$4 = ( _export$1 && _export ) || _export$1;

	var require$$0$7 = ( _meta$1 && _meta ) || _meta$1;

	var setToStringTag = ( _setToStringTag$1 && _setToStringTag ) || _setToStringTag$1;

	var wksDefine = ( _wksDefine$1 && _wksDefine ) || _wksDefine$1;

	var enumKeys = ( _enumKeys$1 && _enumKeys ) || _enumKeys$1;

	var isArray = ( _isArray$1 && _isArray ) || _isArray$1;

	var create = ( _objectCreate$1 && _objectCreate ) || _objectCreate$1;

	var require$$1$5 = ( _objectGopnExt$1 && _objectGopnExt ) || _objectGopnExt$1;

	var require$$38 = ( _objectGopd$1 && _objectGopd ) || _objectGopd$1;

	// ECMAScript 6 symbols shim


	var META = require$$0$7.KEY;

	var gOPD$1 = require$$38.f;
	var dP$1 = require$$37.f;
	var gOPN$2 = require$$1$5.f;
	var $Symbol = require$$0.Symbol;
	var $JSON = require$$0.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE$2 = 'prototype';
	var HIDDEN = require$$0$4('_hidden');
	var TO_PRIMITIVE = require$$0$4('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = require$$0$3('symbol-registry');
	var AllSymbols = require$$0$3('symbols');
	var OPSymbols = require$$0$3('op-symbols');
	var ObjectProto = Object[PROTOTYPE$2];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = require$$0.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = require$$0$1 && require$$1(function () {
	  return create(dP$1({}, 'a', {
	    get: function get$$1() {
	      return dP$1(this, 'a', { value: 7 }).a;
	    }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD$1(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP$1(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP$1(ObjectProto, key, protoDesc);
	} : dP$1;

	var wrap = function wrap(tag) {
	  var sym = AllSymbols[tag] = create($Symbol[PROTOTYPE$2]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
	  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty$$1(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = require$$16(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP$1(it, HIDDEN, descriptor(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = create(D, { enumerable: descriptor(0, false) });
	    }return setSymbolDesc(it, key, D);
	  }return dP$1(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) {
	    $defineProperty(it, key = keys[i++], P[key]);
	  }return it;
	};
	var $create = function create$$1(it, P) {
	  return P === undefined ? create(it) : $defineProperties(create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = require$$16(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = require$$16(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD$1(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN$2(toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  }return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN$2(IS_OP ? OPSymbols : toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  }return result;
	};

	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function _Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function $set(value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, descriptor(1, value));
	    };
	    if (require$$0$1 && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
	    return this._k;
	  });

	  require$$38.f = $getOwnPropertyDescriptor;
	  require$$37.f = $defineProperty;
	  gOPN.f = require$$1$5.f = $getOwnPropertyNames;
	  pIE.f = $propertyIsEnumerable;
	  gOPS.f = $getOwnPropertySymbols;

	  if (require$$0$1 && !require$$1$2) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function (name) {
	    return wrap(require$$0$4(name));
	  };
	}

	require$$4(require$$4.G + require$$4.W + require$$4.F * !USE_NATIVE, { Symbol: $Symbol });

	for (var es6Symbols =
	// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
	  require$$0$4(es6Symbols[j++]);
	}for (var wellKnownSymbols = getKeys(require$$0$4.store), k = 0; wellKnownSymbols.length > k;) {
	  wksDefine(wellKnownSymbols[k++]);
	}require$$4(require$$4.S + require$$4.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function _for(key) {
	    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) {
	      if (SymbolRegistry[key] === sym) return key;
	    }
	  },
	  useSetter: function useSetter() {
	    setter = true;
	  },
	  useSimple: function useSimple() {
	    setter = false;
	  }
	});

	require$$4(require$$4.S + require$$4.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && require$$4(require$$4.S + require$$4.F * (!USE_NATIVE || require$$1(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) {
	      args.push(arguments[i++]);
	    }$replacer = replacer = args[1];
	    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!isArray(replacer)) replacer = function replacer(key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || require$$0$2($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(require$$0.JSON, 'JSON', true);

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	require$$4(require$$4.S, 'Object', { create: create });

	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	require$$4(require$$4.S + require$$4.F * !require$$0$1, 'Object', { defineProperty: require$$37.f });

	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	require$$4(require$$4.S + require$$4.F * !require$$0$1, 'Object', { defineProperties: dPs });

	// most Object methods by ES6 should accept primitives


	var _objectSap = function _objectSap(KEY, exec) {
	  var fn = (require$$1$1.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  require$$4(require$$4.S + require$$4.F * require$$1(function () {
	    fn(1);
	  }), 'Object', exp);
	};

	var _objectSap$1 = /*#__PURE__*/Object.freeze({
		default: _objectSap,
		__moduleExports: _objectSap
	});

	var require$$0$8 = ( _objectSap$1 && _objectSap ) || _objectSap$1;

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)

	var $getOwnPropertyDescriptor$1 = require$$38.f;

	require$$0$8('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor$1(toIObject(it), key);
	  };
	});

	// 7.1.13 ToObject(argument)

	var _toObject = function _toObject(it) {
	  return Object(defined(it));
	};

	var _toObject$1 = /*#__PURE__*/Object.freeze({
		default: _toObject,
		__moduleExports: _toObject
	});

	var require$$20 = ( _toObject$1 && _toObject ) || _toObject$1;

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


	var IE_PROTO$2 = require$$1$4('IE_PROTO');
	var ObjectProto$1 = Object.prototype;

	var _objectGpo = Object.getPrototypeOf || function (O) {
	  O = require$$20(O);
	  if (has(O, IE_PROTO$2)) return O[IE_PROTO$2];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  }return O instanceof Object ? ObjectProto$1 : null;
	};

	var _objectGpo$1 = /*#__PURE__*/Object.freeze({
		default: _objectGpo,
		__moduleExports: _objectGpo
	});

	var require$$23 = ( _objectGpo$1 && _objectGpo ) || _objectGpo$1;

	// 19.1.2.9 Object.getPrototypeOf(O)


	require$$0$8('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return require$$23(require$$20(it));
	  };
	});

	// 19.1.2.14 Object.keys(O)


	require$$0$8('keys', function () {
	  return function keys(it) {
	    return getKeys(require$$20(it));
	  };
	});

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	require$$0$8('getOwnPropertyNames', function () {
	  return require$$1$5.f;
	});

	// 19.1.2.5 Object.freeze(O)

	var meta = require$$0$7.onFreeze;

	require$$0$8('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

	// 19.1.2.17 Object.seal(O)

	var meta$1 = require$$0$7.onFreeze;

	require$$0$8('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && isObject(it) ? $seal(meta$1(it)) : it;
	  };
	});

	// 19.1.2.15 Object.preventExtensions(O)

	var meta$2 = require$$0$7.onFreeze;

	require$$0$8('preventExtensions', function ($preventExtensions) {
	  return function preventExtensions(it) {
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta$2(it)) : it;
	  };
	});

	// 19.1.2.12 Object.isFrozen(O)


	require$$0$8('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

	// 19.1.2.13 Object.isSealed(O)


	require$$0$8('isSealed', function ($isSealed) {
	  return function isSealed(it) {
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

	// 19.1.2.11 Object.isExtensible(O)


	require$$0$8('isExtensible', function ($isExtensible) {
	  return function isExtensible(it) {
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

	// 19.1.2.1 Object.assign(target, source, ...)


	var $assign = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	var _objectAssign = !$assign || require$$1(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) {
	    B[k] = k;
	  });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) {
	  // eslint-disable-line no-unused-vars
	  var T = require$$20(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = gOPS.f;
	  var isEnum = pIE.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]);
	    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	    }
	  }return T;
	} : $assign;

	var _objectAssign$1 = /*#__PURE__*/Object.freeze({
		default: _objectAssign,
		__moduleExports: _objectAssign
	});

	var assign = ( _objectAssign$1 && _objectAssign ) || _objectAssign$1;

	// 19.1.3.1 Object.assign(target, source)


	require$$4(require$$4.S + require$$4.F, 'Object', { assign: assign });

	// 7.2.9 SameValue(x, y)
	var _sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	var _sameValue$1 = /*#__PURE__*/Object.freeze({
		default: _sameValue,
		__moduleExports: _sameValue
	});

	var require$$0$9 = ( _sameValue$1 && _sameValue ) || _sameValue$1;

	// 19.1.3.10 Object.is(value1, value2)

	require$$4(require$$4.S, 'Object', { is: require$$0$9 });

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */

	var check = function check(O, proto) {
	  anObject(O);
	  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	var _setProto = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	  function (test, buggy, set) {
	    try {
	      set = require$$7(Function.call, require$$38.f(Object.prototype, '__proto__').set, 2);
	      set(test, []);
	      buggy = !(test instanceof Array);
	    } catch (e) {
	      buggy = true;
	    }
	    return function setPrototypeOf(O, proto) {
	      check(O, proto);
	      if (buggy) O.__proto__ = proto;else set(O, proto);
	      return O;
	    };
	  }({}, false) : undefined),
	  check: check
	};
	var _setProto_1 = _setProto.set;
	var _setProto_2 = _setProto.check;

	var _setProto$1 = /*#__PURE__*/Object.freeze({
		default: _setProto,
		__moduleExports: _setProto,
		set: _setProto_1,
		check: _setProto_2
	});

	var require$$0$10 = ( _setProto$1 && _setProto ) || _setProto$1;

	// 19.1.3.19 Object.setPrototypeOf(O, proto)

	require$$4(require$$4.S, 'Object', { setPrototypeOf: require$$0$10.set });

	// getting tag from 19.1.3.6 Object.prototype.toString()

	var TAG$1 = require$$0$4('toStringTag');
	// ES3 wrong here
	var ARG = require$$1$3(function () {
	  return arguments;
	}()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function tryGet(it, key) {
	  try {
	    return it[key];
	  } catch (e) {/* empty */}
	};

	var _classof = function _classof(it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	  // @@toStringTag case
	  : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
	  // builtinTag case
	  : ARG ? require$$1$3(O)
	  // ES3 arguments fallback
	  : (B = require$$1$3(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

	var _classof$1 = /*#__PURE__*/Object.freeze({
		default: _classof,
		__moduleExports: _classof
	});

	var require$$18 = ( _classof$1 && _classof ) || _classof$1;

	// 19.1.3.6 Object.prototype.toString()

	var test = {};
	test[require$$0$4('toStringTag')] = 'z';
	if (test + '' != '[object z]') {
	  redefine(Object.prototype, 'toString', function toString() {
	    return '[object ' + require$$18(this) + ']';
	  }, true);
	}

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	var _invoke = function _invoke(fn, args, that) {
	                  var un = that === undefined;
	                  switch (args.length) {
	                                    case 0:
	                                                      return un ? fn() : fn.call(that);
	                                    case 1:
	                                                      return un ? fn(args[0]) : fn.call(that, args[0]);
	                                    case 2:
	                                                      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
	                                    case 3:
	                                                      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
	                                    case 4:
	                                                      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
	                  }return fn.apply(that, args);
	};

	var _invoke$1 = /*#__PURE__*/Object.freeze({
		default: _invoke,
		__moduleExports: _invoke
	});

	var invoke = ( _invoke$1 && _invoke ) || _invoke$1;

	var arraySlice = [].slice;
	var factories = {};

	var construct = function construct(F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) {
	      n[i] = 'a[' + i + ']';
	    } // eslint-disable-next-line no-new-func
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  }return factories[len](F, args);
	};

	var _bind = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction(this);
	  var partArgs = arraySlice.call(arguments, 1);
	  var bound = function bound() /* args... */{
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
	  return bound;
	};

	var _bind$1 = /*#__PURE__*/Object.freeze({
		default: _bind,
		__moduleExports: _bind
	});

	var bind = ( _bind$1 && _bind ) || _bind$1;

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)


	require$$4(require$$4.P, 'Function', { bind: bind });

	var dP$2 = require$$37.f;
	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';

	// 19.2.4.2 name
	NAME in FProto || require$$0$1 && dP$2(FProto, NAME, {
	  configurable: true,
	  get: function get() {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});

	var HAS_INSTANCE = require$$0$4('hasInstance');
	var FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if (!(HAS_INSTANCE in FunctionProto)) require$$37.f(FunctionProto, HAS_INSTANCE, { value: function value(O) {
	    if (typeof this != 'function' || !isObject(O)) return false;
	    if (!isObject(this.prototype)) return O instanceof this;
	    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	    while (O = require$$23(O)) {
	      if (this.prototype === O) return true;
	    }return false;
	  } });

	var _stringWs = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var _stringWs$1 = /*#__PURE__*/Object.freeze({
		default: _stringWs,
		__moduleExports: _stringWs
	});

	var spaces = ( _stringWs$1 && _stringWs ) || _stringWs$1;

	var space = '[' + spaces + ']';
	var non = '\u200B\x85';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');

	var exporter = function exporter(KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = require$$1(function () {
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  require$$4(require$$4.P + require$$4.F * FORCE, 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};

	var _stringTrim = exporter;

	var _stringTrim$1 = /*#__PURE__*/Object.freeze({
		default: _stringTrim,
		__moduleExports: _stringTrim
	});

	var require$$1$6 = ( _stringTrim$1 && _stringTrim ) || _stringTrim$1;

	var $parseInt = require$$0.parseInt;
	var $trim = require$$1$6.trim;

	var hex = /^[-+]?0[xX]/;

	var _parseInt = $parseInt(spaces + '08') !== 8 || $parseInt(spaces + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
	} : $parseInt;

	var _parseInt$1 = /*#__PURE__*/Object.freeze({
		default: _parseInt,
		__moduleExports: _parseInt
	});

	var $parseInt$1 = ( _parseInt$1 && _parseInt ) || _parseInt$1;

	// 18.2.5 parseInt(string, radix)
	require$$4(require$$4.G + require$$4.F * (parseInt != $parseInt$1), { parseInt: $parseInt$1 });

	var $parseFloat = require$$0.parseFloat;
	var $trim$1 = require$$1$6.trim;

	var _parseFloat = 1 / $parseFloat(spaces + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim$1(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	var _parseFloat$1 = /*#__PURE__*/Object.freeze({
		default: _parseFloat,
		__moduleExports: _parseFloat
	});

	var $parseFloat$1 = ( _parseFloat$1 && _parseFloat ) || _parseFloat$1;

	// 18.2.4 parseFloat(string)
	require$$4(require$$4.G + require$$4.F * (parseFloat != $parseFloat$1), { parseFloat: $parseFloat$1 });

	var setPrototypeOf = require$$0$10.set;
	var _inheritIfRequired = function _inheritIfRequired(that, target, C) {
	  var S = target.constructor;
	  var P;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  }return that;
	};

	var _inheritIfRequired$1 = /*#__PURE__*/Object.freeze({
		default: _inheritIfRequired,
		__moduleExports: _inheritIfRequired
	});

	var inheritIfRequired = ( _inheritIfRequired$1 && _inheritIfRequired ) || _inheritIfRequired$1;

	var gOPN$3 = gOPN.f;
	var gOPD$2 = require$$38.f;
	var dP$3 = require$$37.f;
	var $trim$2 = require$$1$6.trim;
	var NUMBER = 'Number';
	var $Number = require$$0[NUMBER];
	var Base = $Number;
	var proto = $Number.prototype;
	// Opera ~12 has broken Object#toString
	var BROKEN_COF = require$$1$3(create(proto)) == NUMBER;
	var TRIM = 'trim' in String.prototype;

	// 7.1.3 ToNumber(argument)
	var toNumber = function toNumber(argument) {
	  var it = require$$16(argument, false);
	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim$2(it, 3);
	    var first = it.charCodeAt(0);
	    var third, radix, maxCode;
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66:case 98:
	          radix = 2;maxCode = 49;break; // fast equal /^0b[01]+$/i
	        case 79:case 111:
	          radix = 8;maxCode = 55;break; // fast equal /^0o[0-7]+$/i
	        default:
	          return +it;
	      }
	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      }return parseInt(digits, radix);
	    }
	  }return +it;
	};

	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var that = this;
	    return that instanceof $Number
	    // check on 1..constructor(foo) case
	    && (BROKEN_COF ? require$$1(function () {
	      proto.valueOf.call(that);
	    }) : require$$1$3(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for (var keys = require$$0$1 ? gOPN$3(Base) : (
	  // ES3:
	  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	  // ES6 (in case, if modules with ES6 Number statics required before):
	  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j$1 = 0, key$1; keys.length > j$1; j$1++) {
	    if (has(Base, key$1 = keys[j$1]) && !has($Number, key$1)) {
	      dP$3($Number, key$1, gOPD$2(Base, key$1));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  redefine(require$$0, NUMBER, $Number);
	}

	var _aNumberValue = function _aNumberValue(it, msg) {
	  if (typeof it != 'number' && require$$1$3(it) != 'Number') throw TypeError(msg);
	  return +it;
	};

	var _aNumberValue$1 = /*#__PURE__*/Object.freeze({
		default: _aNumberValue,
		__moduleExports: _aNumberValue
	});

	var _stringRepeat = function repeat(count) {
	  var str = String(defined(this));
	  var res = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
	  for (; n > 0; (n >>>= 1) && (str += str)) {
	    if (n & 1) res += str;
	  }return res;
	};

	var _stringRepeat$1 = /*#__PURE__*/Object.freeze({
		default: _stringRepeat,
		__moduleExports: _stringRepeat
	});

	var aNumberValue = ( _aNumberValue$1 && _aNumberValue ) || _aNumberValue$1;

	var require$$0$11 = ( _stringRepeat$1 && _stringRepeat ) || _stringRepeat$1;

	var $toFixed = 1.0.toFixed;
	var floor$1 = Math.floor;
	var data = [0, 0, 0, 0, 0, 0];
	var ERROR = 'Number.toFixed: incorrect invocation!';
	var ZERO = '0';

	var multiply = function multiply(n, c) {
	  var i = -1;
	  var c2 = c;
	  while (++i < 6) {
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor$1(c2 / 1e7);
	  }
	};
	var divide = function divide(n) {
	  var i = 6;
	  var c = 0;
	  while (--i >= 0) {
	    c += data[i];
	    data[i] = floor$1(c / n);
	    c = c % n * 1e7;
	  }
	};
	var numToString = function numToString() {
	  var i = 6;
	  var s = '';
	  while (--i >= 0) {
	    if (s !== '' || i === 0 || data[i] !== 0) {
	      var t = String(data[i]);
	      s = s === '' ? t : s + require$$0$11.call(ZERO, 7 - t.length) + t;
	    }
	  }return s;
	};
	var pow = function pow(x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function log(x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  }return n;
	};

	require$$4(require$$4.P + require$$4.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !require$$1(function () {
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits) {
	    var x = aNumberValue(this, ERROR);
	    var f = toInteger(fractionDigits);
	    var s = '';
	    var m = ZERO;
	    var e, z, j, k;
	    if (f < 0 || f > 20) throw RangeError(ERROR);
	    // eslint-disable-next-line no-self-compare
	    if (x != x) return 'NaN';
	    if (x <= -1e21 || x >= 1e21) return String(x);
	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }
	    if (x > 1e-21) {
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = f;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + require$$0$11.call(ZERO, f);
	      }
	    }
	    if (f > 0) {
	      k = m.length;
	      m = s + (k <= f ? '0.' + require$$0$11.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    }return m;
	  }
	});

	var $toPrecision = 1.0.toPrecision;

	require$$4(require$$4.P + require$$4.F * (require$$1(function () {
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !require$$1(function () {
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision) {
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
	  }
	});

	// 20.1.2.1 Number.EPSILON


	require$$4(require$$4.S, 'Number', { EPSILON: Math.pow(2, -52) });

	// 20.1.2.2 Number.isFinite(number)

	var _isFinite = require$$0.isFinite;

	require$$4(require$$4.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

	// 20.1.2.3 Number.isInteger(number)

	var floor$2 = Math.floor;
	var _isInteger = function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor$2(it) === it;
	};

	var _isInteger$1 = /*#__PURE__*/Object.freeze({
		default: _isInteger,
		__moduleExports: _isInteger
	});

	var isInteger = ( _isInteger$1 && _isInteger ) || _isInteger$1;

	// 20.1.2.3 Number.isInteger(number)


	require$$4(require$$4.S, 'Number', { isInteger: isInteger });

	// 20.1.2.4 Number.isNaN(number)


	require$$4(require$$4.S, 'Number', {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	// 20.1.2.5 Number.isSafeInteger(number)


	var abs = Math.abs;

	require$$4(require$$4.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

	// 20.1.2.6 Number.MAX_SAFE_INTEGER


	require$$4(require$$4.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

	// 20.1.2.10 Number.MIN_SAFE_INTEGER


	require$$4(require$$4.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

	// 20.1.2.12 Number.parseFloat(string)
	require$$4(require$$4.S + require$$4.F * (Number.parseFloat != $parseFloat$1), 'Number', { parseFloat: $parseFloat$1 });

	// 20.1.2.13 Number.parseInt(string, radix)
	require$$4(require$$4.S + require$$4.F * (Number.parseInt != $parseInt$1), 'Number', { parseInt: $parseInt$1 });

	// 20.2.2.20 Math.log1p(x)
	var _mathLog1p = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

	var _mathLog1p$1 = /*#__PURE__*/Object.freeze({
		default: _mathLog1p,
		__moduleExports: _mathLog1p
	});

	var require$$0$12 = ( _mathLog1p$1 && _mathLog1p ) || _mathLog1p$1;

	// 20.2.2.3 Math.acosh(x)


	var sqrt = Math.sqrt;
	var $acosh = Math.acosh;

	require$$4(require$$4.S + require$$4.F * !($acosh
	// V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	&& Math.floor($acosh(Number.MAX_VALUE)) == 710
	// Tor Browser bug: Math.acosh(Infinity) -> NaN
	&& $acosh(Infinity) == Infinity), 'Math', {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : require$$0$12(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

	// 20.2.2.5 Math.asinh(x)

	var $asinh = Math.asinh;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}

	// Tor Browser bug: Math.asinh(0) -> -0
	require$$4(require$$4.S + require$$4.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

	// 20.2.2.7 Math.atanh(x)

	var $atanh = Math.atanh;

	// Tor Browser bug: Math.atanh(-0) -> 0
	require$$4(require$$4.S + require$$4.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

	// 20.2.2.28 Math.sign(x)
	var _mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	var _mathSign$1 = /*#__PURE__*/Object.freeze({
		default: _mathSign,
		__moduleExports: _mathSign
	});

	var sign = ( _mathSign$1 && _mathSign ) || _mathSign$1;

	// 20.2.2.9 Math.cbrt(x)


	require$$4(require$$4.S, 'Math', {
	  cbrt: function cbrt(x) {
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

	// 20.2.2.11 Math.clz32(x)


	require$$4(require$$4.S, 'Math', {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

	// 20.2.2.12 Math.cosh(x)

	var exp = Math.exp;

	require$$4(require$$4.S, 'Math', {
	  cosh: function cosh(x) {
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	var _mathExpm1 = !$expm1
	// Old FF bug
	|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	// Tor Browser bug
	|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

	var _mathExpm1$1 = /*#__PURE__*/Object.freeze({
		default: _mathExpm1,
		__moduleExports: _mathExpm1
	});

	var expm1 = ( _mathExpm1$1 && _mathExpm1 ) || _mathExpm1$1;

	// 20.2.2.14 Math.expm1(x)


	require$$4(require$$4.S + require$$4.F * (expm1 != Math.expm1), 'Math', { expm1: expm1 });

	// 20.2.2.16 Math.fround(x)

	var pow$1 = Math.pow;
	var EPSILON = pow$1(2, -52);
	var EPSILON32 = pow$1(2, -23);
	var MAX32 = pow$1(2, 127) * (2 - EPSILON32);
	var MIN32 = pow$1(2, -126);

	var roundTiesToEven = function roundTiesToEven(n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	var _mathFround = Math.fround || function fround(x) {
	  var $abs = Math.abs(x);
	  var $sign = sign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};

	var _mathFround$1 = /*#__PURE__*/Object.freeze({
		default: _mathFround,
		__moduleExports: _mathFround
	});

	var require$$0$13 = ( _mathFround$1 && _mathFround ) || _mathFround$1;

	// 20.2.2.16 Math.fround(x)


	require$$4(require$$4.S, 'Math', { fround: require$$0$13 });

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])

	var abs$1 = Math.abs;

	require$$4(require$$4.S, 'Math', {
	  hypot: function hypot(value1, value2) {
	    // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs$1(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

	// 20.2.2.18 Math.imul(x, y)

	var $imul = Math.imul;

	// some WebKit versions fails with big numbers, some has wrong arity
	require$$4(require$$4.S + require$$4.F * require$$1(function () {
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y) {
	    var UINT16 = 0xffff;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

	// 20.2.2.21 Math.log10(x)


	require$$4(require$$4.S, 'Math', {
	  log10: function log10(x) {
	    return Math.log(x) * Math.LOG10E;
	  }
	});

	// 20.2.2.20 Math.log1p(x)


	require$$4(require$$4.S, 'Math', { log1p: require$$0$12 });

	// 20.2.2.22 Math.log2(x)


	require$$4(require$$4.S, 'Math', {
	  log2: function log2(x) {
	    return Math.log(x) / Math.LN2;
	  }
	});

	// 20.2.2.28 Math.sign(x)


	require$$4(require$$4.S, 'Math', { sign: sign });

	// 20.2.2.30 Math.sinh(x)


	var exp$1 = Math.exp;

	// V8 near Chromium 38 has a problem with very small numbers
	require$$4(require$$4.S + require$$4.F * require$$1(function () {
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x) {
	    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (Math.E / 2);
	  }
	});

	// 20.2.2.33 Math.tanh(x)


	var exp$2 = Math.exp;

	require$$4(require$$4.S, 'Math', {
	  tanh: function tanh(x) {
	    var a = expm1(x = +x);
	    var b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
	  }
	});

	// 20.2.2.34 Math.trunc(x)


	require$$4(require$$4.S, 'Math', {
	  trunc: function trunc(it) {
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	require$$4(require$$4.S + require$$4.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) {
	    // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments[i++];
	      if (require$$15(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
	    }return res.join('');
	  }
	});

	require$$4(require$$4.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite) {
	    var tpl = toIObject(callSite.raw);
	    var len = toLength(tpl.length);
	    var aLen = arguments.length;
	    var res = [];
	    var i = 0;
	    while (len > i) {
	      res.push(String(tpl[i++]));
	      if (i < aLen) res.push(String(arguments[i]));
	    }return res.join('');
	  }
	});

	// 21.1.3.25 String.prototype.trim()
	require$$1$6('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});

	// true  -> String#at
	// false -> String#codePointAt
	var _stringAt = function _stringAt(TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that));
	    var i = toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var _stringAt$1 = /*#__PURE__*/Object.freeze({
		default: _stringAt,
		__moduleExports: _stringAt
	});

	var _iterators = {};

	var _iterators$1 = /*#__PURE__*/Object.freeze({
		default: _iterators,
		__moduleExports: _iterators
	});

	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	require$$0$2(IteratorPrototype, require$$0$4('iterator'), function () {
	  return this;
	});

	var _iterCreate = function _iterCreate(Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

	var _iterCreate$1 = /*#__PURE__*/Object.freeze({
		default: _iterCreate,
		__moduleExports: _iterCreate
	});

	var require$$32 = ( _iterators$1 && _iterators ) || _iterators$1;

	var $iterCreate = ( _iterCreate$1 && _iterCreate ) || _iterCreate$1;

	var ITERATOR = require$$0$4('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function returnThis() {
	  return this;
	};

	var _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function getMethod(kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS:
	        return function keys() {
	          return new Constructor(this, kind);
	        };
	      case VALUES:
	        return function values() {
	          return new Constructor(this, kind);
	        };
	    }return function entries() {
	      return new Constructor(this, kind);
	    };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = !BUGGY && $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = require$$23($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!require$$1$2 && !has(IteratorPrototype, ITERATOR)) require$$0$2(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() {
	      return $native.call(this);
	    };
	  }
	  // Define iterator
	  if ((!require$$1$2 || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    require$$0$2(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  require$$32[NAME] = $default;
	  require$$32[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else require$$4(require$$4.P + require$$4.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

	var _iterDefine$1 = /*#__PURE__*/Object.freeze({
		default: _iterDefine,
		__moduleExports: _iterDefine
	});

	var require$$0$14 = ( _stringAt$1 && _stringAt ) || _stringAt$1;

	var $iterDefine = ( _iterDefine$1 && _iterDefine ) || _iterDefine$1;

	var $at = require$$0$14(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	$iterDefine(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0; // next index
	  // 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});

	var $at$1 = require$$0$14(false);
	require$$4(require$$4.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at$1(this, pos);
	  }
	});

	// 7.2.8 IsRegExp(argument)


	var MATCH = require$$0$4('match');
	var _isRegexp = function _isRegexp(it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : require$$1$3(it) == 'RegExp');
	};

	var _isRegexp$1 = /*#__PURE__*/Object.freeze({
		default: _isRegexp,
		__moduleExports: _isRegexp
	});

	var isRegExp = ( _isRegexp$1 && _isRegexp ) || _isRegexp$1;

	// helper for String#{startsWith, endsWith, includes}


	var _stringContext = function _stringContext(that, searchString, NAME) {
	  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

	var _stringContext$1 = /*#__PURE__*/Object.freeze({
		default: _stringContext,
		__moduleExports: _stringContext
	});

	var MATCH$1 = require$$0$4('match');
	var _failsIsRegexp = function _failsIsRegexp(KEY) {
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH$1] = false;
	      return !'/./'[KEY](re);
	    } catch (f) {/* empty */}
	  }return true;
	};

	var _failsIsRegexp$1 = /*#__PURE__*/Object.freeze({
		default: _failsIsRegexp,
		__moduleExports: _failsIsRegexp
	});

	var context = ( _stringContext$1 && _stringContext ) || _stringContext$1;

	var require$$0$15 = ( _failsIsRegexp$1 && _failsIsRegexp ) || _failsIsRegexp$1;

	var ENDS_WITH = 'endsWith';
	var $endsWith = ''[ENDS_WITH];

	require$$4(require$$4.P + require$$4.F * require$$0$15(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = context(this, searchString, ENDS_WITH);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
	    var search = String(searchString);
	    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
	  }
	});

	var INCLUDES = 'includes';

	require$$4(require$$4.P + require$$4.F * require$$0$15(INCLUDES), 'String', {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	require$$4(require$$4.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: require$$0$11
	});

	var STARTS_WITH = 'startsWith';
	var $startsWith = ''[STARTS_WITH];

	require$$4(require$$4.P + require$$4.F * require$$0$15(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = context(this, searchString, STARTS_WITH);
	    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
	  }
	});

	var quot = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function createHTML(string, tag, attribute, value) {
	  var S = String(defined(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	var _stringHtml = function _stringHtml(NAME, exec) {
	  var O = {};
	  O[NAME] = exec(createHTML);
	  require$$4(require$$4.P + require$$4.F * require$$1(function () {
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

	var _stringHtml$1 = /*#__PURE__*/Object.freeze({
		default: _stringHtml,
		__moduleExports: _stringHtml
	});

	var require$$0$16 = ( _stringHtml$1 && _stringHtml ) || _stringHtml$1;

	// B.2.3.2 String.prototype.anchor(name)
	require$$0$16('anchor', function (createHTML) {
	  return function anchor(name) {
	    return createHTML(this, 'a', 'name', name);
	  };
	});

	// B.2.3.3 String.prototype.big()
	require$$0$16('big', function (createHTML) {
	  return function big() {
	    return createHTML(this, 'big', '', '');
	  };
	});

	// B.2.3.4 String.prototype.blink()
	require$$0$16('blink', function (createHTML) {
	  return function blink() {
	    return createHTML(this, 'blink', '', '');
	  };
	});

	// B.2.3.5 String.prototype.bold()
	require$$0$16('bold', function (createHTML) {
	  return function bold() {
	    return createHTML(this, 'b', '', '');
	  };
	});

	// B.2.3.6 String.prototype.fixed()
	require$$0$16('fixed', function (createHTML) {
	  return function fixed() {
	    return createHTML(this, 'tt', '', '');
	  };
	});

	// B.2.3.7 String.prototype.fontcolor(color)
	require$$0$16('fontcolor', function (createHTML) {
	  return function fontcolor(color) {
	    return createHTML(this, 'font', 'color', color);
	  };
	});

	// B.2.3.8 String.prototype.fontsize(size)
	require$$0$16('fontsize', function (createHTML) {
	  return function fontsize(size) {
	    return createHTML(this, 'font', 'size', size);
	  };
	});

	// B.2.3.9 String.prototype.italics()
	require$$0$16('italics', function (createHTML) {
	  return function italics() {
	    return createHTML(this, 'i', '', '');
	  };
	});

	// B.2.3.10 String.prototype.link(url)
	require$$0$16('link', function (createHTML) {
	  return function link(url) {
	    return createHTML(this, 'a', 'href', url);
	  };
	});

	// B.2.3.11 String.prototype.small()
	require$$0$16('small', function (createHTML) {
	  return function small() {
	    return createHTML(this, 'small', '', '');
	  };
	});

	// B.2.3.12 String.prototype.strike()
	require$$0$16('strike', function (createHTML) {
	  return function strike() {
	    return createHTML(this, 'strike', '', '');
	  };
	});

	// B.2.3.13 String.prototype.sub()
	require$$0$16('sub', function (createHTML) {
	  return function sub() {
	    return createHTML(this, 'sub', '', '');
	  };
	});

	// B.2.3.14 String.prototype.sup()
	require$$0$16('sup', function (createHTML) {
	  return function sup() {
	    return createHTML(this, 'sup', '', '');
	  };
	});

	// 20.3.3.1 / 15.9.4.4 Date.now()


	require$$4(require$$4.S, 'Date', { now: function now() {
	    return new Date().getTime();
	  } });

	require$$4(require$$4.P + require$$4.F * require$$1(function () {
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function toISOString() {
	      return 1;
	    } }) !== 1;
	}), 'Date', {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = require$$20(this);
	    var pv = require$$16(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

	var getTime = Date.prototype.getTime;
	var $toISOString = Date.prototype.toISOString;

	var lz = function lz(num) {
	  return num > 9 ? num : '0' + num;
	};

	// PhantomJS / old WebKit has a broken implementations
	var _dateToIsoString = require$$1(function () {
	  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !require$$1(function () {
	  $toISOString.call(new Date(NaN));
	}) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var d = this;
	  var y = d.getUTCFullYear();
	  var m = d.getUTCMilliseconds();
	  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	} : $toISOString;

	var _dateToIsoString$1 = /*#__PURE__*/Object.freeze({
		default: _dateToIsoString,
		__moduleExports: _dateToIsoString
	});

	var toISOString = ( _dateToIsoString$1 && _dateToIsoString ) || _dateToIsoString$1;

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()


	// PhantomJS / old WebKit has a broken implementations
	require$$4(require$$4.P + require$$4.F * (Date.prototype.toISOString !== toISOString), 'Date', {
	  toISOString: toISOString
	});

	var DateProto = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var $toString = DateProto[TO_STRING];
	var getTime$1 = DateProto.getTime;
	if (new Date(NaN) + '' != INVALID_DATE) {
	  redefine(DateProto, TO_STRING, function toString() {
	    var value = getTime$1.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

	var NUMBER$1 = 'number';

	var _dateToPrimitive = function _dateToPrimitive(hint) {
	  if (hint !== 'string' && hint !== NUMBER$1 && hint !== 'default') throw TypeError('Incorrect hint');
	  return require$$16(anObject(this), hint != NUMBER$1);
	};

	var _dateToPrimitive$1 = /*#__PURE__*/Object.freeze({
		default: _dateToPrimitive,
		__moduleExports: _dateToPrimitive
	});

	var require$$2$1 = ( _dateToPrimitive$1 && _dateToPrimitive ) || _dateToPrimitive$1;

	var TO_PRIMITIVE$1 = require$$0$4('toPrimitive');
	var proto$1 = Date.prototype;

	if (!(TO_PRIMITIVE$1 in proto$1)) require$$0$2(proto$1, TO_PRIMITIVE$1, require$$2$1);

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)


	require$$4(require$$4.S, 'Array', { isArray: isArray });

	// call something on iterator step with safe closing on error

	var _iterCall = function _iterCall(iterator, fn, value, entries) {
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	    // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) anObject(ret.call(iterator));
	    throw e;
	  }
	};

	var _iterCall$1 = /*#__PURE__*/Object.freeze({
		default: _iterCall,
		__moduleExports: _iterCall
	});

	// check on default Array iterator

	var ITERATOR$1 = require$$0$4('iterator');
	var ArrayProto = Array.prototype;

	var _isArrayIter = function _isArrayIter(it) {
	  return it !== undefined && (require$$32.Array === it || ArrayProto[ITERATOR$1] === it);
	};

	var _isArrayIter$1 = /*#__PURE__*/Object.freeze({
		default: _isArrayIter,
		__moduleExports: _isArrayIter
	});

	var _createProperty = function _createProperty(object, index, value) {
	  if (index in object) require$$37.f(object, index, descriptor(0, value));else object[index] = value;
	};

	var _createProperty$1 = /*#__PURE__*/Object.freeze({
		default: _createProperty,
		__moduleExports: _createProperty
	});

	var ITERATOR$2 = require$$0$4('iterator');

	var core_getIteratorMethod = require$$1$1.getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || require$$32[require$$18(it)];
	};

	var core_getIteratorMethod$1 = /*#__PURE__*/Object.freeze({
		default: core_getIteratorMethod,
		__moduleExports: core_getIteratorMethod
	});

	var ITERATOR$3 = require$$0$4('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR$3]();
	  riter['return'] = function () {
	    SAFE_CLOSING = true;
	  };
	} catch (e) {/* empty */}

	var _iterDetect = function _iterDetect(exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR$3]();
	    iter.next = function () {
	      return { done: safe = true };
	    };
	    arr[ITERATOR$3] = function () {
	      return iter;
	    };
	    exec(arr);
	  } catch (e) {/* empty */}
	  return safe;
	};

	var _iterDetect$1 = /*#__PURE__*/Object.freeze({
		default: _iterDetect,
		__moduleExports: _iterDetect
	});

	var call = ( _iterCall$1 && _iterCall ) || _iterCall$1;

	var require$$21 = ( _isArrayIter$1 && _isArrayIter ) || _isArrayIter$1;

	var createProperty = ( _createProperty$1 && _createProperty ) || _createProperty$1;

	var require$$25 = ( core_getIteratorMethod$1 && core_getIteratorMethod ) || core_getIteratorMethod$1;

	var require$$33 = ( _iterDetect$1 && _iterDetect ) || _iterDetect$1;

	require$$4(require$$4.S + require$$4.F * !require$$33(function (iter) {
	}), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	    var O = require$$20(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = require$$25(O);
	    var length, result, step, iterator;
	    if (mapping) mapfn = require$$7(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && require$$21(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});

	// WebKit Array.of isn't generic
	require$$4(require$$4.S + require$$4.F * require$$1(function () {
	  function F() {/* empty */}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of() /* ...args */{
	    var index = 0;
	    var aLen = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(aLen);
	    while (aLen > index) {
	      createProperty(result, index, arguments[index++]);
	    }result.length = aLen;
	    return result;
	  }
	});

	var _strictMethod = function _strictMethod(method, arg) {
	  return !!method && require$$1(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () {/* empty */}, 1) : method.call(null);
	  });
	};

	var _strictMethod$1 = /*#__PURE__*/Object.freeze({
		default: _strictMethod,
		__moduleExports: _strictMethod
	});

	var require$$0$17 = ( _strictMethod$1 && _strictMethod ) || _strictMethod$1;

	// 22.1.3.13 Array.prototype.join(separator)


	var arrayJoin = [].join;

	// fallback for not array-like strings
	require$$4(require$$4.P + require$$4.F * (IObject != Object || !require$$0$17(arrayJoin)), 'Array', {
	  join: function join(separator) {
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

	var arraySlice$1 = [].slice;

	// fallback for not array-like ES3 strings and DOM objects
	require$$4(require$$4.P + require$$4.F * require$$1(function () {
	  if (html) arraySlice$1.call(html);
	}), 'Array', {
	  slice: function slice(begin, end) {
	    var len = toLength(this.length);
	    var klass = require$$1$3(this);
	    end = end === undefined ? len : end;
	    if (klass == 'Array') return arraySlice$1.call(this, begin, end);
	    var start = require$$15(begin, len);
	    var upTo = require$$15(end, len);
	    var size = toLength(upTo - start);
	    var cloned = new Array(size);
	    var i = 0;
	    for (; i < size; i++) {
	      cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
	    }return cloned;
	  }
	});

	var $sort = [].sort;
	var test$1 = [1, 2, 3];

	require$$4(require$$4.P + require$$4.F * (require$$1(function () {
	  // IE8-
	  test$1.sort(undefined);
	}) || !require$$1(function () {
	  // V8 bug
	  test$1.sort(null);
	  // Old WebKit
	}) || !require$$0$17($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined ? $sort.call(require$$20(this)) : $sort.call(require$$20(this), aFunction(comparefn));
	  }
	});

	var SPECIES = require$$0$4('species');

	var _arraySpeciesConstructor = function _arraySpeciesConstructor(original) {
	  var C;
	  if (isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  }return C === undefined ? Array : C;
	};

	var _arraySpeciesConstructor$1 = /*#__PURE__*/Object.freeze({
		default: _arraySpeciesConstructor,
		__moduleExports: _arraySpeciesConstructor
	});

	var speciesConstructor = ( _arraySpeciesConstructor$1 && _arraySpeciesConstructor ) || _arraySpeciesConstructor$1;

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


	var _arraySpeciesCreate = function _arraySpeciesCreate(original, length) {
	  return new (speciesConstructor(original))(length);
	};

	var _arraySpeciesCreate$1 = /*#__PURE__*/Object.freeze({
		default: _arraySpeciesCreate,
		__moduleExports: _arraySpeciesCreate
	});

	var asc = ( _arraySpeciesCreate$1 && _arraySpeciesCreate ) || _arraySpeciesCreate$1;

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex


	var _arrayMethods = function _arrayMethods(TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || asc;
	  return function ($this, callbackfn, that) {
	    var O = require$$20($this);
	    var self = IObject(O);
	    var f = require$$7(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (; length > index; index++) {
	      if (NO_HOLES || index in self) {
	        val = self[index];
	        res = f(val, index, O);
	        if (TYPE) {
	          if (IS_MAP) result[index] = res; // map
	          else if (res) switch (TYPE) {
	              case 3:
	                return true; // some
	              case 5:
	                return val; // find
	              case 6:
	                return index; // findIndex
	              case 2:
	                result.push(val); // filter
	            } else if (IS_EVERY) return false; // every
	        }
	      }
	    }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

	var _arrayMethods$1 = /*#__PURE__*/Object.freeze({
		default: _arrayMethods,
		__moduleExports: _arrayMethods
	});

	var require$$28 = ( _arrayMethods$1 && _arrayMethods ) || _arrayMethods$1;

	var $forEach = require$$28(0);
	var STRICT = require$$0$17([].forEach, true);

	require$$4(require$$4.P + require$$4.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

	var $map = require$$28(1);

	require$$4(require$$4.P + require$$4.F * !require$$0$17([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

	var $filter = require$$28(2);

	require$$4(require$$4.P + require$$4.F * !require$$0$17([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

	var $some = require$$28(3);

	require$$4(require$$4.P + require$$4.F * !require$$0$17([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

	var $every = require$$28(4);

	require$$4(require$$4.P + require$$4.F * !require$$0$17([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

	var _arrayReduce = function _arrayReduce(that, callbackfn, aLen, memo, isRight) {
	  aFunction(callbackfn);
	  var O = require$$20(that);
	  var self = IObject(O);
	  var length = toLength(O.length);
	  var index = isRight ? length - 1 : 0;
	  var i = isRight ? -1 : 1;
	  if (aLen < 2) for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for (; isRight ? index >= 0 : length > index; index += i) {
	    if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	  }return memo;
	};

	var _arrayReduce$1 = /*#__PURE__*/Object.freeze({
		default: _arrayReduce,
		__moduleExports: _arrayReduce
	});

	var $reduce = ( _arrayReduce$1 && _arrayReduce ) || _arrayReduce$1;

	require$$4(require$$4.P + require$$4.F * !require$$0$17([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

	require$$4(require$$4.P + require$$4.F * !require$$0$17([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

	var $indexOf = require$$0$5(false);
	var $native = [].indexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

	require$$4(require$$4.P + require$$4.F * (NEGATIVE_ZERO || !require$$0$17($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	    // convert -0 to +0
	    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
	  }
	});

	var $native$1 = [].lastIndexOf;
	var NEGATIVE_ZERO$1 = !!$native$1 && 1 / [1].lastIndexOf(1, -0) < 0;

	require$$4(require$$4.P + require$$4.F * (NEGATIVE_ZERO$1 || !require$$0$17($native$1)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO$1) return $native$1.apply(this, arguments) || 0;
	    var O = toIObject(this);
	    var length = toLength(O.length);
	    var index = length - 1;
	    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
	    if (index < 0) index = length + index;
	    for (; index >= 0; index--) {
	      if (index in O) if (O[index] === searchElement) return index || 0;
	    }return -1;
	  }
	});

	var _arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = require$$20(this);
	  var len = toLength(O.length);
	  var to = require$$15(target, len);
	  var from = require$$15(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = Math.min((end === undefined ? len : require$$15(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];else delete O[to];
	    to += inc;
	    from += inc;
	  }return O;
	};

	var _arrayCopyWithin$1 = /*#__PURE__*/Object.freeze({
		default: _arrayCopyWithin,
		__moduleExports: _arrayCopyWithin
	});

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = require$$0$4('unscopables');
	var ArrayProto$1 = Array.prototype;
	if (ArrayProto$1[UNSCOPABLES] == undefined) require$$0$2(ArrayProto$1, UNSCOPABLES, {});
	var _addToUnscopables = function _addToUnscopables(key) {
	  ArrayProto$1[UNSCOPABLES][key] = true;
	};

	var _addToUnscopables$1 = /*#__PURE__*/Object.freeze({
		default: _addToUnscopables,
		__moduleExports: _addToUnscopables
	});

	var require$$36 = ( _arrayCopyWithin$1 && _arrayCopyWithin ) || _arrayCopyWithin$1;

	var addToUnscopables = ( _addToUnscopables$1 && _addToUnscopables ) || _addToUnscopables$1;

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


	require$$4(require$$4.P, 'Array', { copyWithin: require$$36 });

	addToUnscopables('copyWithin');

	var _arrayFill = function fill(value /* , start = 0, end = @length */) {
	  var O = require$$20(this);
	  var length = toLength(O.length);
	  var aLen = arguments.length;
	  var index = require$$15(aLen > 1 ? arguments[1] : undefined, length);
	  var end = aLen > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : require$$15(end, length);
	  while (endPos > index) {
	    O[index++] = value;
	  }return O;
	};

	var _arrayFill$1 = /*#__PURE__*/Object.freeze({
		default: _arrayFill,
		__moduleExports: _arrayFill
	});

	var require$$35 = ( _arrayFill$1 && _arrayFill ) || _arrayFill$1;

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


	require$$4(require$$4.P, 'Array', { fill: require$$35 });

	addToUnscopables('fill');

	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

	var $find = require$$28(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () {
	  forced = false;
	});
	require$$4(require$$4.P + require$$4.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	addToUnscopables(KEY);

	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

	var $find$1 = require$$28(6);
	var KEY$1 = 'findIndex';
	var forced$1 = true;
	// Shouldn't skip holes
	if (KEY$1 in []) Array(1)[KEY$1](function () {
	  forced$1 = false;
	});
	require$$4(require$$4.P + require$$4.F * forced$1, 'Array', {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	addToUnscopables(KEY$1);

	var SPECIES$1 = require$$0$4('species');

	var _setSpecies = function _setSpecies(KEY) {
	  var C = require$$0[KEY];
	  if (require$$0$1 && C && !C[SPECIES$1]) require$$37.f(C, SPECIES$1, {
	    configurable: true,
	    get: function get() {
	      return this;
	    }
	  });
	};

	var _setSpecies$1 = /*#__PURE__*/Object.freeze({
		default: _setSpecies,
		__moduleExports: _setSpecies
	});

	var require$$34 = ( _setSpecies$1 && _setSpecies ) || _setSpecies$1;

	require$$34('Array');

	var _iterStep = function _iterStep(done, value) {
	  return { value: value, done: !!done };
	};

	var _iterStep$1 = /*#__PURE__*/Object.freeze({
		default: _iterStep,
		__moduleExports: _iterStep
	});

	var step = ( _iterStep$1 && _iterStep ) || _iterStep$1;

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	var es6_array_iterator = $iterDefine(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0; // next index
	  this._k = kind; // kind
	  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	require$$32.Arguments = require$$32.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	var es6_array_iterator$1 = /*#__PURE__*/Object.freeze({
		default: es6_array_iterator,
		__moduleExports: es6_array_iterator
	});

	// 21.2.5.3 get RegExp.prototype.flags

	var _flags = function _flags() {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	var _flags$1 = /*#__PURE__*/Object.freeze({
		default: _flags,
		__moduleExports: _flags
	});

	var require$$2$2 = ( _flags$1 && _flags ) || _flags$1;

	var dP$4 = require$$37.f;
	var gOPN$4 = gOPN.f;

	var $RegExp = require$$0.RegExp;
	var Base$1 = $RegExp;
	var proto$2 = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;
	// "new" creates a new object, old webkit buggy here
	var CORRECT_NEW = new $RegExp(re1) !== re1;

	if (require$$0$1 && (!CORRECT_NEW || require$$1(function () {
	  re2[require$$0$4('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = isRegExp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base$1(piRE && !fiU ? p.source : p, f) : Base$1((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? require$$2$2.call(p) : f), tiRE ? this : proto$2, $RegExp);
	  };
	  var proxy = function proxy(key) {
	    key in $RegExp || dP$4($RegExp, key, {
	      configurable: true,
	      get: function get() {
	        return Base$1[key];
	      },
	      set: function set(it) {
	        Base$1[key] = it;
	      }
	    });
	  };
	  for (var keys$1 = gOPN$4(Base$1), i = 0; keys$1.length > i;) {
	    proxy(keys$1[i++]);
	  }proto$2.constructor = $RegExp;
	  $RegExp.prototype = proto$2;
	  redefine(require$$0, 'RegExp', $RegExp);
	}

	require$$34('RegExp');

	// 21.2.5.3 get RegExp.prototype.flags()
	if (require$$0$1 && /./g.flags != 'g') require$$37.f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: require$$2$2
	});

	var TO_STRING$1 = 'toString';
	var $toString$1 = /./[TO_STRING$1];

	var define = function define(fn) {
	  redefine(RegExp.prototype, TO_STRING$1, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if (require$$1(function () {
	  return $toString$1.call({ source: 'a', flags: 'b' }) != '/a/b';
	})) {
	  define(function toString() {
	    var R = anObject(this);
	    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !require$$0$1 && R instanceof RegExp ? require$$2$2.call(R) : undefined);
	  });
	  // FF44- RegExp#toString has a wrong name
	} else if ($toString$1.name != TO_STRING$1) {
	  define(function toString() {
	    return $toString$1.call(this);
	  });
	}

	var _fixReWks = function _fixReWks(KEY, length, exec) {
	  var SYMBOL = require$$0$4(KEY);
	  var fns = exec(defined, SYMBOL, ''[KEY]);
	  var strfn = fns[0];
	  var rxfn = fns[1];
	  if (require$$1(function () {
	    var O = {};
	    O[SYMBOL] = function () {
	      return 7;
	    };
	    return ''[KEY](O) != 7;
	  })) {
	    redefine(String.prototype, KEY, strfn);
	    require$$0$2(RegExp.prototype, SYMBOL, length == 2
	    // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	    ? function (string, arg) {
	      return rxfn.call(string, this, arg);
	    }
	    // 21.2.5.6 RegExp.prototype[@@match](string)
	    // 21.2.5.9 RegExp.prototype[@@search](string)
	    : function (string) {
	      return rxfn.call(string, this);
	    });
	  }
	};

	var _fixReWks$1 = /*#__PURE__*/Object.freeze({
		default: _fixReWks,
		__moduleExports: _fixReWks
	});

	var require$$0$18 = ( _fixReWks$1 && _fixReWks ) || _fixReWks$1;

	// @@match logic
	require$$0$18('match', 1, function (defined, MATCH, $match) {
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp) {

	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

	// @@replace logic
	require$$0$18('replace', 2, function (defined, REPLACE, $replace) {
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue) {

	    var O = defined(this);
	    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

	// @@search logic
	require$$0$18('search', 1, function (defined, SEARCH, $search) {
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp) {

	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

	// @@split logic
	require$$0$18('split', 2, function (defined, SPLIT, $split) {

	  var isRegExp$$1 = isRegExp;
	  var _split = $split;
	  var $push = [].push;
	  var $SPLIT = 'split';
	  var LENGTH = 'length';
	  var LAST_INDEX = 'lastIndex';
	  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function $split(separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return [];
	      // If `separator` is not a regex, use native split
	      if (!isRegExp$$1(separator)) return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while (match = separatorCopy.exec(string)) {
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          // eslint-disable-next-line no-loop-func
	          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
	            for (i = 1; i < arguments[LENGTH] - 2; i++) {
	              if (arguments[i] === undefined) match[i] = undefined;
	            }
	          });
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }
	        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	    // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    $split = function $split(separator, limit) {
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit) {
	    var O = defined(this);
	    var fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

	var _anInstance = function _anInstance(it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
	    throw TypeError(name + ': incorrect invocation!');
	  }return it;
	};

	var _anInstance$1 = /*#__PURE__*/Object.freeze({
		default: _anInstance,
		__moduleExports: _anInstance
	});

	var _forOf = createCommonjsModule(function (module) {
	  var BREAK = {};
	  var RETURN = {};
	  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	    var iterFn = ITERATOR ? function () {
	      return iterable;
	    } : require$$25(iterable);
	    var f = require$$7(fn, that, entries ? 2 : 1);
	    var index = 0;
	    var length, step, iterator, result;
	    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	    // fast case for arrays with default iterator
	    if (require$$21(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	      result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	      if (result === BREAK || result === RETURN) return result;
	    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	      result = call(iterator, f, step.value, entries);
	      if (result === BREAK || result === RETURN) return result;
	    }
	  };
	  exports.BREAK = BREAK;
	  exports.RETURN = RETURN;
	});

	var _forOf$1 = /*#__PURE__*/Object.freeze({
		default: _forOf,
		__moduleExports: _forOf
	});

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)


	var SPECIES$2 = require$$0$4('species');
	var _speciesConstructor = function _speciesConstructor(O, D) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$2]) == undefined ? D : aFunction(S);
	};

	var _speciesConstructor$1 = /*#__PURE__*/Object.freeze({
		default: _speciesConstructor,
		__moduleExports: _speciesConstructor
	});

	var process$1 = require$$0.process;
	var setTask = require$$0.setImmediate;
	var clearTask = require$$0.clearImmediate;
	var MessageChannel = require$$0.MessageChannel;
	var Dispatch = require$$0.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function run() {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function listener(event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) {
	      args.push(arguments[i++]);
	    }queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (require$$1$3(process$1) == 'process') {
	    defer = function defer(id) {
	      process$1.nextTick(require$$7(run, id, 1));
	    };
	    // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function defer(id) {
	      Dispatch.now(require$$7(run, id, 1));
	    };
	    // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = require$$7(port.postMessage, port, 1);
	    // Browsers with postMessage, skip WebWorkers
	    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (require$$0.addEventListener && typeof postMessage == 'function' && !require$$0.importScripts) {
	    defer = function defer(id) {
	      require$$0.postMessage(id + '', '*');
	    };
	    require$$0.addEventListener('message', listener, false);
	    // IE8-
	  } else if (ONREADYSTATECHANGE in require$$2('script')) {
	    defer = function defer(id) {
	      html.appendChild(require$$2('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	    // Rest old browsers
	  } else {
	    defer = function defer(id) {
	      setTimeout(require$$7(run, id, 1), 0);
	    };
	  }
	}
	var _task = {
	  set: setTask,
	  clear: clearTask
	};
	var _task_1 = _task.set;
	var _task_2 = _task.clear;

	var _task$1 = /*#__PURE__*/Object.freeze({
		default: _task,
		__moduleExports: _task,
		set: _task_1,
		clear: _task_2
	});

	var require$$0$19 = ( _task$1 && _task ) || _task$1;

	var macrotask = require$$0$19.set;
	var Observer = require$$0.MutationObserver || require$$0.WebKitMutationObserver;
	var process$2 = require$$0.process;
	var Promise$1 = require$$0.Promise;
	var isNode = require$$1$3(process$2) == 'process';

	var _microtask = function _microtask() {
	  var head, last, notify;

	  var flush = function flush() {
	    var parent, fn;
	    if (isNode && (parent = process$2.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();else last = undefined;
	        throw e;
	      }
	    }last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (isNode) {
	    notify = function notify() {
	      process$2.nextTick(flush);
	    };
	    // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(require$$0.navigator && require$$0.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function notify() {
	      node.data = toggle = !toggle;
	    };
	    // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    var promise = Promise$1.resolve();
	    notify = function notify() {
	      promise.then(flush);
	    };
	    // for other environments - macrotask based on:
	    // - setImmediate
	    // - MessageChannel
	    // - window.postMessag
	    // - onreadystatechange
	    // - setTimeout
	  } else {
	    notify = function notify() {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(require$$0, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    }last = task;
	  };
	};

	var _microtask$1 = /*#__PURE__*/Object.freeze({
		default: _microtask,
		__moduleExports: _microtask
	});

	// 25.4.1.5 NewPromiseCapability(C)


	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	}

	var f$7 = function f(C) {
	  return new PromiseCapability(C);
	};

	var _newPromiseCapability = {
	  f: f$7
	};

	var _newPromiseCapability$1 = /*#__PURE__*/Object.freeze({
		default: _newPromiseCapability,
		__moduleExports: _newPromiseCapability,
		f: f$7
	});

	var _perform = function _perform(exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};

	var _perform$1 = /*#__PURE__*/Object.freeze({
		default: _perform,
		__moduleExports: _perform
	});

	var newPromiseCapability = ( _newPromiseCapability$1 && _newPromiseCapability ) || _newPromiseCapability$1;

	var _promiseResolve = function _promiseResolve(C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var _promiseResolve$1 = /*#__PURE__*/Object.freeze({
		default: _promiseResolve,
		__moduleExports: _promiseResolve
	});

	var _redefineAll = function _redefineAll(target, src, safe) {
	  for (var key in src) {
	    redefine(target, key, src[key], safe);
	  }return target;
	};

	var _redefineAll$1 = /*#__PURE__*/Object.freeze({
		default: _redefineAll,
		__moduleExports: _redefineAll
	});

	var require$$8 = ( _anInstance$1 && _anInstance ) || _anInstance$1;

	var forOf = ( _forOf$1 && _forOf ) || _forOf$1;

	var require$$30 = ( _speciesConstructor$1 && _speciesConstructor ) || _speciesConstructor$1;

	var require$$1$7 = ( _microtask$1 && _microtask ) || _microtask$1;

	var perform = ( _perform$1 && _perform ) || _perform$1;

	var promiseResolve = ( _promiseResolve$1 && _promiseResolve ) || _promiseResolve$1;

	var require$$11 = ( _redefineAll$1 && _redefineAll ) || _redefineAll$1;

	var task = require$$0$19.set;
	var microtask = require$$1$7();

	var PROMISE = 'Promise';
	var TypeError$1 = require$$0.TypeError;
	var process$3 = require$$0.process;
	var $Promise = require$$0[PROMISE];
	var isNode$1 = require$$18(process$3) == 'process';
	var empty = function empty() {/* empty */};
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability$1 = newGenericPromiseCapability = newPromiseCapability.f;

	var USE_NATIVE$1 = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[require$$0$4('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch (e) {/* empty */}
	}();

	// helpers
	var isThenable = function isThenable(it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function notify(promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function run(reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;else {
	            if (domain) domain.enter();
	            result = handler(value);
	            if (domain) domain.exit();
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        reject(e);
	      }
	    };
	    while (chain.length > i) {
	      run(chain[i++]);
	    } // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function onUnhandled(promise) {
	  task.call(require$$0, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = perform(function () {
	        if (isNode$1) {
	          process$3.emit('unhandledRejection', value, promise);
	        } else if (handler = require$$0.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = require$$0.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
	    }promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function isUnhandled(promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function onHandleUnhandled(promise) {
	  task.call(require$$0, function () {
	    var handler;
	    if (isNode$1) {
	      process$3.emit('rejectionHandled', promise);
	    } else if (handler = require$$0.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function $reject(value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function $resolve(value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, require$$7($resolve, wrapper, 1), require$$7($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE$1) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    require$$8(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(require$$7($resolve, this, 1), require$$7($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = []; // <- awaiting reactions
	    this._a = undefined; // <- checked in isUnhandled reactions
	    this._s = 0; // <- state
	    this._d = false; // <- done
	    this._v = undefined; // <- value
	    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false; // <- notify
	  };
	  Internal.prototype = require$$11($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability$1(require$$30(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode$1 ? process$3.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function _catch(onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function OwnPromiseCapability() {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = require$$7($resolve, promise, 1);
	    this.reject = require$$7($reject, promise, 1);
	  };
	  newPromiseCapability.f = newPromiseCapability$1 = function newPromiseCapability$$1(C) {
	    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
	  };
	}

	require$$4(require$$4.G + require$$4.W + require$$4.F * !USE_NATIVE$1, { Promise: $Promise });
	setToStringTag($Promise, PROMISE);
	require$$34(PROMISE);
	Wrapper = require$$1$1[PROMISE];

	// statics
	require$$4(require$$4.S + require$$4.F * !USE_NATIVE$1, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	require$$4(require$$4.S + require$$4.F * (require$$1$2 || !USE_NATIVE$1), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return promiseResolve(require$$1$2 && this === Wrapper ? $Promise : this, x);
	  }
	});
	require$$4(require$$4.S + require$$4.F * !(USE_NATIVE$1 && require$$33(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});

	var _validateCollection = function _validateCollection(it, TYPE) {
	  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
	  return it;
	};

	var _validateCollection$1 = /*#__PURE__*/Object.freeze({
		default: _validateCollection,
		__moduleExports: _validateCollection
	});

	var validate = ( _validateCollection$1 && _validateCollection ) || _validateCollection$1;

	var dP$5 = require$$37.f;

	var fastKey = require$$0$7.fastKey;

	var SIZE = require$$0$1 ? '_s' : 'size';

	var getEntry = function getEntry(that, key) {
	  // fast case
	  var index = fastKey(key);
	  var entry;
	  if (index !== 'F') return that._i[index];
	  // frozen object case
	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) return entry;
	  }
	};

	var _collectionStrong = {
	  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      require$$8(that, C, NAME, '_i');
	      that._t = NAME; // collection type
	      that._i = create(null); // index
	      that._f = undefined; // first entry
	      that._l = undefined; // last entry
	      that[SIZE] = 0; // size
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    require$$11(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function _delete(key) {
	        var that = validate(this, NAME);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.n;
	          var prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) prev.n = next;
	          if (next) next.p = prev;
	          if (that._f == entry) that._f = next;
	          if (that._l == entry) that._l = prev;
	          that[SIZE]--;
	        }return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        validate(this, NAME);
	        var f = require$$7(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while (entry && entry.r) {
	            entry = entry.p;
	          }
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(validate(this, NAME), key);
	      }
	    });
	    if (require$$0$1) dP$5(C.prototype, 'size', {
	      get: function get() {
	        return validate(this, NAME)[SIZE];
	      }
	    });
	    return C;
	  },
	  def: function def(that, key, value) {
	    var entry = getEntry(that, key);
	    var prev, index;
	    // change existing entry
	    if (entry) {
	      entry.v = value;
	      // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key, // <- key
	        v: value, // <- value
	        p: prev = that._l, // <- previous entry
	        n: undefined, // <- next entry
	        r: false // <- removed
	      };
	      if (!that._f) that._f = entry;
	      if (prev) prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if (index !== 'F') that._i[index] = entry;
	    }return that;
	  },
	  getEntry: getEntry,
	  setStrong: function setStrong(C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function (iterated, kind) {
	      this._t = validate(iterated, NAME); // target
	      this._k = kind; // kind
	      this._l = undefined; // previous
	    }, function () {
	      var that = this;
	      var kind = that._k;
	      var entry = that._l;
	      // revert to the last existing entry
	      while (entry && entry.r) {
	        entry = entry.p;
	      } // get next entry
	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if (kind == 'keys') return step(0, entry.k);
	      if (kind == 'values') return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    require$$34(NAME);
	  }
	};
	var _collectionStrong_1 = _collectionStrong.getConstructor;
	var _collectionStrong_2 = _collectionStrong.def;
	var _collectionStrong_3 = _collectionStrong.getEntry;
	var _collectionStrong_4 = _collectionStrong.setStrong;

	var _collectionStrong$1 = /*#__PURE__*/Object.freeze({
		default: _collectionStrong,
		__moduleExports: _collectionStrong,
		getConstructor: _collectionStrong_1,
		def: _collectionStrong_2,
		getEntry: _collectionStrong_3,
		setStrong: _collectionStrong_4
	});

	var _collection = function _collection(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = require$$0[NAME];
	  var C = Base;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var proto = C && C.prototype;
	  var O = {};
	  var fixMethod = function fixMethod(KEY) {
	    var fn = proto[KEY];
	    redefine(proto, KEY, KEY == 'delete' ? function (a) {
	      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'has' ? function has(a) {
	      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'get' ? function get(a) {
	      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'add' ? function add(a) {
	      fn.call(this, a === 0 ? 0 : a);return this;
	    } : function set(a, b) {
	      fn.call(this, a === 0 ? 0 : a, b);return this;
	    });
	  };
	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !require$$1(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    require$$11(C.prototype, methods);
	    require$$0$7.NEED = true;
	  } else {
	    var instance = new C();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = require$$1(function () {
	      instance.has(1);
	    });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    var ACCEPT_ITERABLES = require$$33(function (iter) {
	      new C(iter);
	    }); // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && require$$1(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C();
	      var index = 5;
	      while (index--) {
	        $instance[ADDER](index, index);
	      }return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        require$$8(target, C, NAME);
	        var that = inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if (IS_WEAK && proto.clear) delete proto.clear;
	  }

	  setToStringTag(C, NAME);

	  O[NAME] = C;
	  require$$4(require$$4.G + require$$4.W + require$$4.F * (C != Base), O);

	  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

	  return C;
	};

	var _collection$1 = /*#__PURE__*/Object.freeze({
		default: _collection,
		__moduleExports: _collection
	});

	var strong = ( _collectionStrong$1 && _collectionStrong ) || _collectionStrong$1;

	var require$$0$20 = ( _collection$1 && _collection ) || _collection$1;

	var MAP = 'Map';

	// 23.1 Map Objects
	var es6_map = require$$0$20(MAP, function (get) {
	  return function Map() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = strong.getEntry(validate(this, MAP), key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
	  }
	}, strong, true);

	var SET = 'Set';

	// 23.2 Set Objects
	var es6_set = require$$0$20(SET, function (get) {
	  return function Set() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
	  }
	}, strong);

	var getWeak = require$$0$7.getWeak;

	var arrayFind = require$$28(5);
	var arrayFindIndex = require$$28(6);
	var id$1 = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function UncaughtFrozenStore() {
	  this.a = [];
	};
	var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function get(key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function has$$1(key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function set(key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;else this.a.push([key, value]);
	  },
	  'delete': function _delete(key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	var _collectionWeak = {
	  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      require$$8(that, C, NAME, '_i');
	      that._t = NAME; // collection type
	      that._i = id$1++; // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    require$$11(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function _delete(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
	        return data && has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has$$1(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
	        return data && has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function def(that, key, value) {
	    var data = getWeak(anObject(key), true);
	    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};
	var _collectionWeak_1 = _collectionWeak.getConstructor;
	var _collectionWeak_2 = _collectionWeak.def;
	var _collectionWeak_3 = _collectionWeak.ufstore;

	var _collectionWeak$1 = /*#__PURE__*/Object.freeze({
		default: _collectionWeak,
		__moduleExports: _collectionWeak,
		getConstructor: _collectionWeak_1,
		def: _collectionWeak_2,
		ufstore: _collectionWeak_3
	});

	var weak = ( _collectionWeak$1 && _collectionWeak ) || _collectionWeak$1;

	var es6_weakMap = createCommonjsModule(function (module) {

	  var each = require$$28(0);

	  var WEAK_MAP = 'WeakMap';
	  var getWeak = require$$0$7.getWeak;
	  var isExtensible = Object.isExtensible;
	  var uncaughtFrozenStore = weak.ufstore;
	  var tmp = {};
	  var InternalMap;

	  var wrapper = function wrapper(get) {
	    return function WeakMap() {
	      return get(this, arguments.length > 0 ? arguments[0] : undefined);
	    };
	  };

	  var methods = {
	    // 23.3.3.3 WeakMap.prototype.get(key)
	    get: function get(key) {
	      if (isObject(key)) {
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
	        return data ? data[this._i] : undefined;
	      }
	    },
	    // 23.3.3.5 WeakMap.prototype.set(key, value)
	    set: function set(key, value) {
	      return weak.def(validate(this, WEAK_MAP), key, value);
	    }
	  };

	  // 23.3 WeakMap Objects
	  var $WeakMap = module.exports = require$$0$20(WEAK_MAP, wrapper, methods, weak, true, true);

	  // IE11 WeakMap frozen keys fix
	  if (require$$1(function () {
	    return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
	  })) {
	    InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
	    assign(InternalMap.prototype, methods);
	    require$$0$7.NEED = true;
	    each(['delete', 'has', 'get', 'set'], function (key) {
	      var proto = $WeakMap.prototype;
	      var method = proto[key];
	      redefine(proto, key, function (a, b) {
	        // store frozen objects on internal weakmap shim
	        if (isObject(a) && !isExtensible(a)) {
	          if (!this._f) this._f = new InternalMap();
	          var result = this._f[key](a, b);
	          return key == 'set' ? this : result;
	          // store all the rest on native weakmap
	        }return method.call(this, a, b);
	      });
	    });
	  }
	});

	var WEAK_SET = 'WeakSet';

	// 23.4 WeakSet Objects
	require$$0$20(WEAK_SET, function (get) {
	  return function WeakSet() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value) {
	    return weak.def(validate(this, WEAK_SET), value, true);
	  }
	}, weak, false, true);

	var TYPED = uid('typed_array');
	var VIEW = uid('view');
	var ABV = !!(require$$0.ArrayBuffer && require$$0.DataView);
	var CONSTR = ABV;
	var i$1 = 0;
	var l = 9;
	var Typed;

	var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

	while (i$1 < l) {
	  if (Typed = require$$0[TypedArrayConstructors[i$1++]]) {
	    require$$0$2(Typed.prototype, TYPED, true);
	    require$$0$2(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}

	var _typed = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};
	var _typed_1 = _typed.ABV;
	var _typed_2 = _typed.CONSTR;
	var _typed_3 = _typed.TYPED;
	var _typed_4 = _typed.VIEW;

	var _typed$1 = /*#__PURE__*/Object.freeze({
		default: _typed,
		__moduleExports: _typed,
		ABV: _typed_1,
		CONSTR: _typed_2,
		TYPED: _typed_3,
		VIEW: _typed_4
	});

	// https://tc39.github.io/ecma262/#sec-toindex


	var _toIndex = function _toIndex(it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length!');
	  return length;
	};

	var _toIndex$1 = /*#__PURE__*/Object.freeze({
		default: _toIndex,
		__moduleExports: _toIndex
	});

	var require$$5 = ( _typed$1 && _typed ) || _typed$1;

	var require$$14 = ( _toIndex$1 && _toIndex ) || _toIndex$1;

	var _typedBuffer = createCommonjsModule(function (module, exports) {

	  var gOPN$$1 = gOPN.f;
	  var dP = require$$37.f;

	  var ARRAY_BUFFER = 'ArrayBuffer';
	  var DATA_VIEW = 'DataView';
	  var PROTOTYPE = 'prototype';
	  var WRONG_LENGTH = 'Wrong length!';
	  var WRONG_INDEX = 'Wrong index!';
	  var $ArrayBuffer = require$$0[ARRAY_BUFFER];
	  var $DataView = require$$0[DATA_VIEW];
	  var Math = require$$0.Math;
	  var RangeError = require$$0.RangeError;
	  // eslint-disable-next-line no-shadow-restricted-names
	  var Infinity = require$$0.Infinity;
	  var BaseBuffer = $ArrayBuffer;
	  var abs = Math.abs;
	  var pow = Math.pow;
	  var floor = Math.floor;
	  var log = Math.log;
	  var LN2 = Math.LN2;
	  var BUFFER = 'buffer';
	  var BYTE_LENGTH = 'byteLength';
	  var BYTE_OFFSET = 'byteOffset';
	  var $BUFFER = require$$0$1 ? '_b' : BUFFER;
	  var $LENGTH = require$$0$1 ? '_l' : BYTE_LENGTH;
	  var $OFFSET = require$$0$1 ? '_o' : BYTE_OFFSET;

	  // IEEE754 conversions based on https://github.com/feross/ieee754
	  function packIEEE754(value, mLen, nBytes) {
	    var buffer = new Array(nBytes);
	    var eLen = nBytes * 8 - mLen - 1;
	    var eMax = (1 << eLen) - 1;
	    var eBias = eMax >> 1;
	    var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
	    var i = 0;
	    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	    var e, m, c;
	    value = abs(value);
	    // eslint-disable-next-line no-self-compare
	    if (value != value || value === Infinity) {
	      // eslint-disable-next-line no-self-compare
	      m = value != value ? 1 : 0;
	      e = eMax;
	    } else {
	      e = floor(log(value) / LN2);
	      if (value * (c = pow(2, -e)) < 1) {
	        e--;
	        c *= 2;
	      }
	      if (e + eBias >= 1) {
	        value += rt / c;
	      } else {
	        value += rt * pow(2, 1 - eBias);
	      }
	      if (value * c >= 2) {
	        e++;
	        c /= 2;
	      }
	      if (e + eBias >= eMax) {
	        m = 0;
	        e = eMax;
	      } else if (e + eBias >= 1) {
	        m = (value * c - 1) * pow(2, mLen);
	        e = e + eBias;
	      } else {
	        m = value * pow(2, eBias - 1) * pow(2, mLen);
	        e = 0;
	      }
	    }
	    for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {}
	    e = e << mLen | m;
	    eLen += mLen;
	    for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {}
	    buffer[--i] |= s * 128;
	    return buffer;
	  }
	  function unpackIEEE754(buffer, mLen, nBytes) {
	    var eLen = nBytes * 8 - mLen - 1;
	    var eMax = (1 << eLen) - 1;
	    var eBias = eMax >> 1;
	    var nBits = eLen - 7;
	    var i = nBytes - 1;
	    var s = buffer[i--];
	    var e = s & 127;
	    var m;
	    s >>= 7;
	    for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {}
	    m = e & (1 << -nBits) - 1;
	    e >>= -nBits;
	    nBits += mLen;
	    for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {}
	    if (e === 0) {
	      e = 1 - eBias;
	    } else if (e === eMax) {
	      return m ? NaN : s ? -Infinity : Infinity;
	    } else {
	      m = m + pow(2, mLen);
	      e = e - eBias;
	    }return (s ? -1 : 1) * m * pow(2, e - mLen);
	  }

	  function unpackI32(bytes) {
	    return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	  }
	  function packI8(it) {
	    return [it & 0xff];
	  }
	  function packI16(it) {
	    return [it & 0xff, it >> 8 & 0xff];
	  }
	  function packI32(it) {
	    return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	  }
	  function packF64(it) {
	    return packIEEE754(it, 52, 8);
	  }
	  function packF32(it) {
	    return packIEEE754(it, 23, 4);
	  }

	  function addGetter(C, key, internal) {
	    dP(C[PROTOTYPE], key, { get: function get() {
	        return this[internal];
	      } });
	  }

	  function get(view, bytes, index, isLittleEndian) {
	    var numIndex = +index;
	    var intIndex = require$$14(numIndex);
	    if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	    var store = view[$BUFFER]._b;
	    var start = intIndex + view[$OFFSET];
	    var pack = store.slice(start, start + bytes);
	    return isLittleEndian ? pack : pack.reverse();
	  }
	  function set(view, bytes, index, conversion, value, isLittleEndian) {
	    var numIndex = +index;
	    var intIndex = require$$14(numIndex);
	    if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	    var store = view[$BUFFER]._b;
	    var start = intIndex + view[$OFFSET];
	    var pack = conversion(+value);
	    for (var i = 0; i < bytes; i++) {
	      store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	    }
	  }

	  if (!require$$5.ABV) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      require$$8(this, $ArrayBuffer, ARRAY_BUFFER);
	      var byteLength = require$$14(length);
	      this._b = require$$35.call(new Array(byteLength), 0);
	      this[$LENGTH] = byteLength;
	    };

	    $DataView = function DataView(buffer, byteOffset, byteLength) {
	      require$$8(this, $DataView, DATA_VIEW);
	      require$$8(buffer, $ArrayBuffer, DATA_VIEW);
	      var bufferLength = buffer[$LENGTH];
	      var offset = toInteger(byteOffset);
	      if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	      byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	      if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	      this[$BUFFER] = buffer;
	      this[$OFFSET] = offset;
	      this[$LENGTH] = byteLength;
	    };

	    if (require$$0$1) {
	      addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	      addGetter($DataView, BUFFER, '_b');
	      addGetter($DataView, BYTE_LENGTH, '_l');
	      addGetter($DataView, BYTE_OFFSET, '_o');
	    }

	    require$$11($DataView[PROTOTYPE], {
	      getInt8: function getInt8(byteOffset) {
	        return get(this, 1, byteOffset)[0] << 24 >> 24;
	      },
	      getUint8: function getUint8(byteOffset) {
	        return get(this, 1, byteOffset)[0];
	      },
	      getInt16: function getInt16(byteOffset /* , littleEndian */) {
	        var bytes = get(this, 2, byteOffset, arguments[1]);
	        return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	      },
	      getUint16: function getUint16(byteOffset /* , littleEndian */) {
	        var bytes = get(this, 2, byteOffset, arguments[1]);
	        return bytes[1] << 8 | bytes[0];
	      },
	      getInt32: function getInt32(byteOffset /* , littleEndian */) {
	        return unpackI32(get(this, 4, byteOffset, arguments[1]));
	      },
	      getUint32: function getUint32(byteOffset /* , littleEndian */) {
	        return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	      },
	      getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	        return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	      },
	      getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	        return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	      },
	      setInt8: function setInt8(byteOffset, value) {
	        set(this, 1, byteOffset, packI8, value);
	      },
	      setUint8: function setUint8(byteOffset, value) {
	        set(this, 1, byteOffset, packI8, value);
	      },
	      setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	        set(this, 2, byteOffset, packI16, value, arguments[2]);
	      },
	      setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	        set(this, 2, byteOffset, packI16, value, arguments[2]);
	      },
	      setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	        set(this, 4, byteOffset, packI32, value, arguments[2]);
	      },
	      setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	        set(this, 4, byteOffset, packI32, value, arguments[2]);
	      },
	      setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	        set(this, 4, byteOffset, packF32, value, arguments[2]);
	      },
	      setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	        set(this, 8, byteOffset, packF64, value, arguments[2]);
	      }
	    });
	  } else {
	    if (!require$$1(function () {
	      $ArrayBuffer(1);
	    }) || !require$$1(function () {
	      new $ArrayBuffer(-1); // eslint-disable-line no-new
	    }) || require$$1(function () {
	      new $ArrayBuffer(); // eslint-disable-line no-new
	      new $ArrayBuffer(1.5); // eslint-disable-line no-new
	      new $ArrayBuffer(NaN); // eslint-disable-line no-new
	      return $ArrayBuffer.name != ARRAY_BUFFER;
	    })) {
	      $ArrayBuffer = function ArrayBuffer(length) {
	        require$$8(this, $ArrayBuffer);
	        return new BaseBuffer(require$$14(length));
	      };
	      var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	      for (var keys = gOPN$$1(BaseBuffer), j = 0, key; keys.length > j;) {
	        if (!((key = keys[j++]) in $ArrayBuffer)) require$$0$2($ArrayBuffer, key, BaseBuffer[key]);
	      }
	      if (!require$$1$2) ArrayBufferProto.constructor = $ArrayBuffer;
	    }
	    // iOS Safari 7.x bug
	    var view = new $DataView(new $ArrayBuffer(2));
	    var $setInt8 = $DataView[PROTOTYPE].setInt8;
	    view.setInt8(0, 2147483648);
	    view.setInt8(1, 2147483649);
	    if (view.getInt8(0) || !view.getInt8(1)) require$$11($DataView[PROTOTYPE], {
	      setInt8: function setInt8(byteOffset, value) {
	        $setInt8.call(this, byteOffset, value << 24 >> 24);
	      },
	      setUint8: function setUint8(byteOffset, value) {
	        $setInt8.call(this, byteOffset, value << 24 >> 24);
	      }
	    }, true);
	  }
	  setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	  setToStringTag($DataView, DATA_VIEW);
	  require$$0$2($DataView[PROTOTYPE], require$$5.VIEW, true);
	  exports[ARRAY_BUFFER] = $ArrayBuffer;
	  exports[DATA_VIEW] = $DataView;
	});

	var _typedBuffer$1 = /*#__PURE__*/Object.freeze({
		default: _typedBuffer,
		__moduleExports: _typedBuffer
	});

	var require$$6 = ( _typedBuffer$1 && _typedBuffer ) || _typedBuffer$1;

	var ArrayBuffer$1 = require$$0.ArrayBuffer;

	var $ArrayBuffer = require$$6.ArrayBuffer;
	var $DataView = require$$6.DataView;
	var $isView = require$$5.ABV && ArrayBuffer$1.isView;
	var $slice = $ArrayBuffer.prototype.slice;
	var VIEW$1 = require$$5.VIEW;
	var ARRAY_BUFFER = 'ArrayBuffer';

	require$$4(require$$4.G + require$$4.W + require$$4.F * (ArrayBuffer$1 !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

	require$$4(require$$4.S + require$$4.F * !require$$5.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it) {
	    return $isView && $isView(it) || isObject(it) && VIEW$1 in it;
	  }
	});

	require$$4(require$$4.P + require$$4.U + require$$4.F * require$$1(function () {
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end) {
	    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
	    var len = anObject(this).byteLength;
	    var first = require$$15(start, len);
	    var final = require$$15(end === undefined ? len : end, len);
	    var result = new (require$$30(this, $ArrayBuffer))(toLength(final - first));
	    var viewS = new $DataView(this);
	    var viewT = new $DataView(result);
	    var index = 0;
	    while (first < final) {
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    }return result;
	  }
	});

	require$$34(ARRAY_BUFFER);

	require$$4(require$$4.G + require$$4.W + require$$4.F * !require$$5.ABV, {
	  DataView: require$$6.DataView
	});

	var require$$31 = ( es6_array_iterator$1 && es6_array_iterator ) || es6_array_iterator$1;

	var _typedArray = createCommonjsModule(function (module) {

	  if (require$$0$1) {
	    var LIBRARY = require$$1$2;
	    var global = require$$0;
	    var fails = require$$1;
	    var $export = require$$4;
	    var $typed = require$$5;
	    var $buffer = require$$6;
	    var ctx = require$$7;
	    var anInstance = require$$8;
	    var propertyDesc = descriptor;
	    var hide = require$$0$2;
	    var redefineAll = require$$11;
	    var toInteger$$1 = toInteger;
	    var toLength$$1 = toLength;
	    var toIndex = require$$14;
	    var toAbsoluteIndex = require$$15;
	    var toPrimitive = require$$16;
	    var has$$1 = has;
	    var classof = require$$18;
	    var isObject$$1 = isObject;
	    var toObject = require$$20;
	    var isArrayIter = require$$21;
	    var create$$1 = create;
	    var getPrototypeOf = require$$23;
	    var gOPN$$1 = gOPN.f;
	    var getIterFn = require$$25;
	    var uid$$1 = uid;
	    var wks = require$$0$4;
	    var createArrayMethod = require$$28;
	    var createArrayIncludes = require$$0$5;
	    var speciesConstructor = require$$30;
	    var ArrayIterators = require$$31;
	    var Iterators = require$$32;
	    var $iterDetect = require$$33;
	    var setSpecies = require$$34;
	    var arrayFill = require$$35;
	    var arrayCopyWithin = require$$36;
	    var $DP = require$$37;
	    var $GOPD = require$$38;
	    var dP = $DP.f;
	    var gOPD = $GOPD.f;
	    var RangeError = global.RangeError;
	    var TypeError = global.TypeError;
	    var Uint8Array = global.Uint8Array;
	    var ARRAY_BUFFER = 'ArrayBuffer';
	    var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
	    var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	    var PROTOTYPE = 'prototype';
	    var ArrayProto = Array[PROTOTYPE];
	    var $ArrayBuffer = $buffer.ArrayBuffer;
	    var $DataView = $buffer.DataView;
	    var arrayForEach = createArrayMethod(0);
	    var arrayFilter = createArrayMethod(2);
	    var arraySome = createArrayMethod(3);
	    var arrayEvery = createArrayMethod(4);
	    var arrayFind = createArrayMethod(5);
	    var arrayFindIndex = createArrayMethod(6);
	    var arrayIncludes = createArrayIncludes(true);
	    var arrayIndexOf = createArrayIncludes(false);
	    var arrayValues = ArrayIterators.values;
	    var arrayKeys = ArrayIterators.keys;
	    var arrayEntries = ArrayIterators.entries;
	    var arrayLastIndexOf = ArrayProto.lastIndexOf;
	    var arrayReduce = ArrayProto.reduce;
	    var arrayReduceRight = ArrayProto.reduceRight;
	    var arrayJoin = ArrayProto.join;
	    var arraySort = ArrayProto.sort;
	    var arraySlice = ArrayProto.slice;
	    var arrayToString = ArrayProto.toString;
	    var arrayToLocaleString = ArrayProto.toLocaleString;
	    var ITERATOR = wks('iterator');
	    var TAG = wks('toStringTag');
	    var TYPED_CONSTRUCTOR = uid$$1('typed_constructor');
	    var DEF_CONSTRUCTOR = uid$$1('def_constructor');
	    var ALL_CONSTRUCTORS = $typed.CONSTR;
	    var TYPED_ARRAY = $typed.TYPED;
	    var VIEW = $typed.VIEW;
	    var WRONG_LENGTH = 'Wrong length!';

	    var $map = createArrayMethod(1, function (O, length) {
	      return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	    });

	    var LITTLE_ENDIAN = fails(function () {
	      // eslint-disable-next-line no-undef
	      return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	    });

	    var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	      new Uint8Array(1).set({});
	    });

	    var toOffset = function toOffset(it, BYTES) {
	      var offset = toInteger$$1(it);
	      if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	      return offset;
	    };

	    var validate = function validate(it) {
	      if (isObject$$1(it) && TYPED_ARRAY in it) return it;
	      throw TypeError(it + ' is not a typed array!');
	    };

	    var allocate = function allocate(C, length) {
	      if (!(isObject$$1(C) && TYPED_CONSTRUCTOR in C)) {
	        throw TypeError('It is not a typed array constructor!');
	      }return new C(length);
	    };

	    var speciesFromList = function speciesFromList(O, list) {
	      return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	    };

	    var fromList = function fromList(C, list) {
	      var index = 0;
	      var length = list.length;
	      var result = allocate(C, length);
	      while (length > index) {
	        result[index] = list[index++];
	      }return result;
	    };

	    var addGetter = function addGetter(it, key, internal) {
	      dP(it, key, { get: function get$$1() {
	          return this._d[internal];
	        } });
	    };

	    var $from = function from(source /* , mapfn, thisArg */) {
	      var O = toObject(source);
	      var aLen = arguments.length;
	      var mapfn = aLen > 1 ? arguments[1] : undefined;
	      var mapping = mapfn !== undefined;
	      var iterFn = getIterFn(O);
	      var i, length, values, result, step, iterator;
	      if (iterFn != undefined && !isArrayIter(iterFn)) {
	        for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	          values.push(step.value);
	        }O = values;
	      }
	      if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
	      for (i = 0, length = toLength$$1(O.length), result = allocate(this, length); length > i; i++) {
	        result[i] = mapping ? mapfn(O[i], i) : O[i];
	      }
	      return result;
	    };

	    var $of = function of() /* ...items */{
	      var index = 0;
	      var length = arguments.length;
	      var result = allocate(this, length);
	      while (length > index) {
	        result[index] = arguments[index++];
	      }return result;
	    };

	    // iOS Safari 6.x fails here
	    var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
	      arrayToLocaleString.call(new Uint8Array(1));
	    });

	    var $toLocaleString = function toLocaleString() {
	      return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	    };

	    var proto = {
	      copyWithin: function copyWithin(target, start /* , end */) {
	        return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	      },
	      every: function every(callbackfn /* , thisArg */) {
	        return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      fill: function fill(value /* , start, end */) {
	        // eslint-disable-line no-unused-vars
	        return arrayFill.apply(validate(this), arguments);
	      },
	      filter: function filter(callbackfn /* , thisArg */) {
	        return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
	      },
	      find: function find(predicate /* , thisArg */) {
	        return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      findIndex: function findIndex(predicate /* , thisArg */) {
	        return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      forEach: function forEach(callbackfn /* , thisArg */) {
	        arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      indexOf: function indexOf(searchElement /* , fromIndex */) {
	        return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      includes: function includes(searchElement /* , fromIndex */) {
	        return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      join: function join(separator) {
	        // eslint-disable-line no-unused-vars
	        return arrayJoin.apply(validate(this), arguments);
	      },
	      lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) {
	        // eslint-disable-line no-unused-vars
	        return arrayLastIndexOf.apply(validate(this), arguments);
	      },
	      map: function map(mapfn /* , thisArg */) {
	        return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      reduce: function reduce(callbackfn /* , initialValue */) {
	        // eslint-disable-line no-unused-vars
	        return arrayReduce.apply(validate(this), arguments);
	      },
	      reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	        // eslint-disable-line no-unused-vars
	        return arrayReduceRight.apply(validate(this), arguments);
	      },
	      reverse: function reverse() {
	        var that = this;
	        var length = validate(that).length;
	        var middle = Math.floor(length / 2);
	        var index = 0;
	        var value;
	        while (index < middle) {
	          value = that[index];
	          that[index++] = that[--length];
	          that[length] = value;
	        }return that;
	      },
	      some: function some(callbackfn /* , thisArg */) {
	        return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      sort: function sort(comparefn) {
	        return arraySort.call(validate(this), comparefn);
	      },
	      subarray: function subarray(begin, end) {
	        var O = validate(this);
	        var length = O.length;
	        var $begin = toAbsoluteIndex(begin, length);
	        return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength$$1((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
	      }
	    };

	    var $slice = function slice(start, end) {
	      return speciesFromList(this, arraySlice.call(validate(this), start, end));
	    };

	    var $set = function set$$1(arrayLike /* , offset */) {
	      validate(this);
	      var offset = toOffset(arguments[1], 1);
	      var length = this.length;
	      var src = toObject(arrayLike);
	      var len = toLength$$1(src.length);
	      var index = 0;
	      if (len + offset > length) throw RangeError(WRONG_LENGTH);
	      while (index < len) {
	        this[offset + index] = src[index++];
	      }
	    };

	    var $iterators = {
	      entries: function entries() {
	        return arrayEntries.call(validate(this));
	      },
	      keys: function keys() {
	        return arrayKeys.call(validate(this));
	      },
	      values: function values() {
	        return arrayValues.call(validate(this));
	      }
	    };

	    var isTAIndex = function isTAIndex(target, key) {
	      return isObject$$1(target) && target[TYPED_ARRAY] && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) != 'symbol' && key in target && String(+key) == String(key);
	    };
	    var $getDesc = function getOwnPropertyDescriptor(target, key) {
	      return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
	    };
	    var $setDesc = function defineProperty$$1(target, key, desc) {
	      if (isTAIndex(target, key = toPrimitive(key, true)) && isObject$$1(desc) && has$$1(desc, 'value') && !has$$1(desc, 'get') && !has$$1(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable && (!has$$1(desc, 'writable') || desc.writable) && (!has$$1(desc, 'enumerable') || desc.enumerable)) {
	        target[key] = desc.value;
	        return target;
	      }return dP(target, key, desc);
	    };

	    if (!ALL_CONSTRUCTORS) {
	      $GOPD.f = $getDesc;
	      $DP.f = $setDesc;
	    }

	    $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	      getOwnPropertyDescriptor: $getDesc,
	      defineProperty: $setDesc
	    });

	    if (fails(function () {
	      arrayToString.call({});
	    })) {
	      arrayToString = arrayToLocaleString = function toString() {
	        return arrayJoin.call(this);
	      };
	    }

	    var $TypedArrayPrototype$ = redefineAll({}, proto);
	    redefineAll($TypedArrayPrototype$, $iterators);
	    hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	    redefineAll($TypedArrayPrototype$, {
	      slice: $slice,
	      set: $set,
	      constructor: function constructor() {/* noop */},
	      toString: arrayToString,
	      toLocaleString: $toLocaleString
	    });
	    addGetter($TypedArrayPrototype$, 'buffer', 'b');
	    addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	    addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	    addGetter($TypedArrayPrototype$, 'length', 'e');
	    dP($TypedArrayPrototype$, TAG, {
	      get: function get$$1() {
	        return this[TYPED_ARRAY];
	      }
	    });

	    // eslint-disable-next-line max-statements
	    module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	      CLAMPED = !!CLAMPED;
	      var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	      var GETTER = 'get' + KEY;
	      var SETTER = 'set' + KEY;
	      var TypedArray = global[NAME];
	      var Base = TypedArray || {};
	      var TAC = TypedArray && getPrototypeOf(TypedArray);
	      var FORCED = !TypedArray || !$typed.ABV;
	      var O = {};
	      var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	      var getter = function getter(that, index) {
	        var data = that._d;
	        return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	      };
	      var setter = function setter(that, index, value) {
	        var data = that._d;
	        if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	        data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	      };
	      var addElement = function addElement(that, index) {
	        dP(that, index, {
	          get: function get$$1() {
	            return getter(this, index);
	          },
	          set: function set$$1(value) {
	            return setter(this, index, value);
	          },
	          enumerable: true
	        });
	      };
	      if (FORCED) {
	        TypedArray = wrapper(function (that, data, $offset, $length) {
	          anInstance(that, TypedArray, NAME, '_d');
	          var index = 0;
	          var offset = 0;
	          var buffer, byteLength, length, klass;
	          if (!isObject$$1(data)) {
	            length = toIndex(data);
	            byteLength = length * BYTES;
	            buffer = new $ArrayBuffer(byteLength);
	          } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	            buffer = data;
	            offset = toOffset($offset, BYTES);
	            var $len = data.byteLength;
	            if ($length === undefined) {
	              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	              byteLength = $len - offset;
	              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	            } else {
	              byteLength = toLength$$1($length) * BYTES;
	              if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
	            }
	            length = byteLength / BYTES;
	          } else if (TYPED_ARRAY in data) {
	            return fromList(TypedArray, data);
	          } else {
	            return $from.call(TypedArray, data);
	          }
	          hide(that, '_d', {
	            b: buffer,
	            o: offset,
	            l: byteLength,
	            e: length,
	            v: new $DataView(buffer)
	          });
	          while (index < length) {
	            addElement(that, index++);
	          }
	        });
	        TypedArrayPrototype = TypedArray[PROTOTYPE] = create$$1($TypedArrayPrototype$);
	        hide(TypedArrayPrototype, 'constructor', TypedArray);
	      } else if (!fails(function () {
	        TypedArray(1);
	      }) || !fails(function () {
	        new TypedArray(-1); // eslint-disable-line no-new
	      }) || !$iterDetect(function (iter) {
	        new TypedArray(); // eslint-disable-line no-new
	        new TypedArray(null); // eslint-disable-line no-new
	        new TypedArray(1.5); // eslint-disable-line no-new
	        new TypedArray(iter); // eslint-disable-line no-new
	      }, true)) {
	        TypedArray = wrapper(function (that, data, $offset, $length) {
	          anInstance(that, TypedArray, NAME);
	          var klass;
	          // `ws` module bug, temporarily remove validation length for Uint8Array
	          // https://github.com/websockets/ws/pull/645
	          if (!isObject$$1(data)) return new Base(toIndex(data));
	          if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	            return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
	          }
	          if (TYPED_ARRAY in data) return fromList(TypedArray, data);
	          return $from.call(TypedArray, data);
	        });
	        arrayForEach(TAC !== Function.prototype ? gOPN$$1(Base).concat(gOPN$$1(TAC)) : gOPN$$1(Base), function (key) {
	          if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
	        });
	        TypedArray[PROTOTYPE] = TypedArrayPrototype;
	        if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	      }
	      var $nativeIterator = TypedArrayPrototype[ITERATOR];
	      var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	      var $iterator = $iterators.values;
	      hide(TypedArray, TYPED_CONSTRUCTOR, true);
	      hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	      hide(TypedArrayPrototype, VIEW, true);
	      hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	      if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	        dP(TypedArrayPrototype, TAG, {
	          get: function get$$1() {
	            return NAME;
	          }
	        });
	      }

	      O[NAME] = TypedArray;

	      $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	      $export($export.S, NAME, {
	        BYTES_PER_ELEMENT: BYTES
	      });

	      $export($export.S + $export.F * fails(function () {
	        Base.of.call(TypedArray, 1);
	      }), NAME, {
	        from: $from,
	        of: $of
	      });

	      if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

	      $export($export.P, NAME, proto);

	      setSpecies(NAME);

	      $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

	      $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	      if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

	      $export($export.P + $export.F * fails(function () {
	        new TypedArray(1).slice();
	      }), NAME, { slice: $slice });

	      $export($export.P + $export.F * (fails(function () {
	        return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	      }) || !fails(function () {
	        TypedArrayPrototype.toLocaleString.call([1, 2]);
	      })), NAME, { toLocaleString: $toLocaleString });

	      Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	      if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
	    };
	  } else module.exports = function () {/* empty */};
	});

	var _typedArray$1 = /*#__PURE__*/Object.freeze({
		default: _typedArray,
		__moduleExports: _typedArray
	});

	var require$$0$21 = ( _typedArray$1 && _typedArray ) || _typedArray$1;

	require$$0$21('Int8', 1, function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$21('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$21('Uint8', 1, function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	require$$0$21('Int16', 2, function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$21('Uint16', 2, function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$21('Int32', 4, function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$21('Uint32', 4, function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$21('Float32', 4, function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$21('Float64', 8, function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)


	var rApply = (require$$0.Reflect || {}).apply;
	var fApply = Function.apply;
	// MS Edge argumentsList argument is optional
	require$$4(require$$4.S + require$$4.F * !require$$1(function () {
	  rApply(function () {/* empty */});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList) {
	    var T = aFunction(target);
	    var L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])


	var rConstruct = (require$$0.Reflect || {}).construct;

	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = require$$1(function () {
	  function F() {/* empty */}
	  return !(rConstruct(function () {/* empty */}, [], F) instanceof F);
	});
	var ARGS_BUG = !require$$1(function () {
	  rConstruct(function () {/* empty */});
	});

	require$$4(require$$4.S + require$$4.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0:
	          return new Target();
	        case 1:
	          return new Target(args[0]);
	        case 2:
	          return new Target(args[0], args[1]);
	        case 3:
	          return new Target(args[0], args[1], args[2]);
	        case 4:
	          return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = create(isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)


	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	require$$4(require$$4.S + require$$4.F * require$$1(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(require$$37.f({}, 1, { value: 1 }), 1, { value: 2 });
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    propertyKey = require$$16(propertyKey, true);
	    anObject(attributes);
	    try {
	      require$$37.f(target, propertyKey, attributes);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)

	var gOPD$3 = require$$38.f;

	require$$4(require$$4.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var desc = gOPD$3(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

	// 26.1.5 Reflect.enumerate(target)


	var Enumerate = function Enumerate(iterated) {
	  this._t = anObject(iterated); // target
	  this._i = 0; // next index
	  var keys = this._k = []; // keys
	  var key;
	  for (key in iterated) {
	    keys.push(key);
	  }
	};
	$iterCreate(Enumerate, 'Object', function () {
	  var that = this;
	  var keys = that._k;
	  var key;
	  do {
	    if (that._i >= keys.length) return { value: undefined, done: true };
	  } while (!((key = keys[that._i++]) in that._t));
	  return { value: key, done: false };
	});

	require$$4(require$$4.S, 'Reflect', {
	  enumerate: function enumerate(target) {
	    return new Enumerate(target);
	  }
	});

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])


	function get$1(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var desc, proto;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (desc = require$$38.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
	  if (isObject(proto = require$$23(target))) return get$1(proto, propertyKey, receiver);
	}

	require$$4(require$$4.S, 'Reflect', { get: get$1 });

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)


	require$$4(require$$4.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return require$$38.f(anObject(target), propertyKey);
	  }
	});

	// 26.1.8 Reflect.getPrototypeOf(target)


	require$$4(require$$4.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return require$$23(anObject(target));
	  }
	});

	// 26.1.9 Reflect.has(target, propertyKey)


	require$$4(require$$4.S, 'Reflect', {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

	// 26.1.10 Reflect.isExtensible(target)


	var $isExtensible = Object.isExtensible;

	require$$4(require$$4.S, 'Reflect', {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

	// all object keys, includes non-enumerable and symbols


	var Reflect$1 = require$$0.Reflect;
	var _ownKeys = Reflect$1 && Reflect$1.ownKeys || function ownKeys(it) {
	  var keys = gOPN.f(anObject(it));
	  var getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

	var _ownKeys$1 = /*#__PURE__*/Object.freeze({
		default: _ownKeys,
		__moduleExports: _ownKeys
	});

	var require$$0$22 = ( _ownKeys$1 && _ownKeys ) || _ownKeys$1;

	// 26.1.11 Reflect.ownKeys(target)


	require$$4(require$$4.S, 'Reflect', { ownKeys: require$$0$22 });

	// 26.1.12 Reflect.preventExtensions(target)


	var $preventExtensions = Object.preventExtensions;

	require$$4(require$$4.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      if ($preventExtensions) $preventExtensions(target);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])


	function set$1(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDesc = require$$38.f(anObject(target), propertyKey);
	  var existingDescriptor, proto;
	  if (!ownDesc) {
	    if (isObject(proto = require$$23(target))) {
	      return set$1(proto, propertyKey, V, receiver);
	    }
	    ownDesc = descriptor(0);
	  }
	  if (has(ownDesc, 'value')) {
	    if (ownDesc.writable === false || !isObject(receiver)) return false;
	    existingDescriptor = require$$38.f(receiver, propertyKey) || descriptor(0);
	    existingDescriptor.value = V;
	    require$$37.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	require$$4(require$$4.S, 'Reflect', { set: set$1 });

	// 26.1.14 Reflect.setPrototypeOf(target, proto)


	if (require$$0$10) require$$4(require$$4.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    require$$0$10.check(target, proto);
	    try {
	      require$$0$10.set(target, proto);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	var _global$2 = new Function('return this;')();
	var __proto = Function.prototype;
	var g = {};

	function _overideFunction() {
	  if (arguments.length > 0 && /^\s*return this\s*;?\s*$/.test(arguments[arguments.length - 1])) {
	    return function () {
	      return g;
	    };
	  }
	  return function () {};
	}

	if (typeof _global$2.webkit === 'undefined') {
	  var _eval = undefined;
	  _global$2.eval = _eval;
	  _overideFunction.prototype = __proto;
	  _overideFunction.prototype.constructor = _overideFunction;
	  // eslint-disable-next-line no-global-assign
	  Function = _overideFunction;
	}

	var ttJSCore = _global$2.ttJSCore;
	var webkit = _global$2.webkit;

	if (_global$2.ttJSCore) {
	  _global$2.ttJSCore = {
	    onDocumentReady: function onDocumentReady() {
	      return ttJSCore.onDocumentReady();
	    }
	  };
	}

	if (_global$2.webkit) {
	  _global$2.webkit = {
	    messageHandlers: {
	      onDocumentReady: {
	        postMessage: function postMessage() {
	          return webkit.messageHandlers.onDocumentReady.postMessage('');
	        }
	      }
	    }
	  };
	}

	// 小程序依赖TMAConfig， 小游戏目前没有这个东东，小游戏引用的公共文件（tt/util.js, request-calss）中用到了TMAConfig 这里兼容一下
	_global$2.TMAConfig = Object.assign(_global$2.TMAConfig || {}, _global$2.nativeTMAConfig, {
	  network: {},
	  onReady: function onReady(fn) {
	    typeof fn === 'function' && fn();
	  },

	  get platform() {
	    if (_global$2.nativeTMAConfig) {
	      return _global$2.nativeTMAConfig.platform;
	    }
	    return 'devtools';
	  }
	});

	var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	var btoa = btoa || function (e) {
	  for (var t, n, r = String(e), o = '', i = 0, a = alphabet; r.charAt(0 | i) || (a = '=', i % 1); o += a.charAt(63 & t >> 8 - i % 1 * 8)) {
	    if ((n = r.charCodeAt(i += 0.75)) > 255) {
	      throw new Error('"btoa" failed');
	    }
	    t = t << 8 | n;
	  }
	  return o;
	};

	var atob = atob || function (e) {
	  var t = String(e).replace(/=+$/, ''),
	      n = '';
	  if (t.length % 4 == 1) {
	    throw new Error('"atob" failed');
	  }
	  for (var r, o, i = 0, a = 0; o = t.charAt(a++), o; ~o && (r = i % 4 ? 64 * r + o : o, i++ % 4) ? n += String.fromCharCode(255 & r >> (-2 * i & 6)) : 0) {
	    o = alphabet.indexOf(o);
	  }
	  return n;
	};

	function encodeToUi8Base64(ab) {
	  var string = '';
	  var ui8aReader = new Uint8Array(ab),
	      len = ui8aReader.byteLength;
	  for (var i = 0; i < len; i++) {
	    string += String.fromCharCode(ui8aReader[i]);
	  }
	  return btoa(string);
	}

	function decodeFromUi8Base64(string) {
	  var base64String = atob(string),
	      len = base64String.length,
	      ui8aReader = new Uint8Array(len);
	  for (var i = 0; i < len; i++) {
	    ui8aReader[i] = base64String.charCodeAt(i);
	  }
	  return ui8aReader.buffer;
	}

	function _new(data) {
	  return {
	    base64: encodeToUi8Base64(data)
	  };
	}

	function _get(data) {
	  if (data != null) {
	    if (data.base64) {
	      return decodeFromUi8Base64(data.base64);
	    } else {
	      return undefined;
	    }
	  }
	}

	function isType(type) {
	  return function (arg) {
	    return Object.prototype.toString.call(arg).toLowerCase() === ('[object ' + type + ']').toLowerCase();
	  };
	}

	function _pack(data) {
	  if (isType('Object')(data) === false) {
	    return data;
	  }

	  // 收集并转换需要编码的字段
	  var needTransAttrs = [];
	  for (var key in data) {
	    var item = data[key];
	    if (item !== undefined && item instanceof ArrayBuffer && item.byteLength !== undefined) {
	      var obj = _new(item);
	      obj.key = key;
	      needTransAttrs.push(obj);
	    }
	  }

	  if (needTransAttrs.length > 0) {
	    // 从原始数据上删除需要转换的字段
	    for (var i = 0; i < needTransAttrs.length; i++) {
	      var tmp = needTransAttrs[i];
	      delete data[tmp.key];
	    }

	    data.__nativeBuffers__ = needTransAttrs;
	  }

	  return data;
	}

	function _unpack(data) {
	  if (isType('Object')(data) === false || null == data.__nativeBuffers__) {
	    return data;
	  }

	  var nbs = data.__nativeBuffers__;
	  delete data.__nativeBuffers__;

	  for (var i = 0; i < nbs.length; i++) {
	    var item = nbs[i];
	    if (null != item) {
	      var tmp = _get(item);
	      if (tmp !== undefined && tmp instanceof ArrayBuffer) {
	        data[item.key] = tmp;
	      }
	    }
	  }

	  return data;
	}

	var NativeBuffer = {
	  new: _new,
	  get: _get,
	  pack: _pack,
	  unpack: _unpack
	};

	/**
	 * 本地修改点：
	 *  1. WeixinJSBridge => ttJSBridge
	 *  2. WeixinJSCore => ttJSCore
	 *  3. invokeCallbackHandler => invokeHandler
	 *  4. invokeHandler 和 subscribeHandler 里加了一层 JSONDecode
	 *  5. 删除了对 webkit 和 ttJSCore 删除的部分
	 */

	var invokeCallbackMap = {};
	var invokeCallbackIdCounter = 0;
	var eventMap = {};
	var customEventMap = {};
	var invokeTaskCache = [];
	var onAppEnterBackground = false;
	var reserveInvokeCallbackIds = [];

	var ACTIONS = {
	  onAppEnterBackground: 'onAppEnterBackground',
	  onAppEnterForeground: 'onAppEnterForeground'
	};

	var backgroundEventManager = {
	  needCache: ['showModal', 'showToast', 'showActionSheet', 'hideToast'],
	  needDisabled: ['onAccelerometerChange', 'onCompassChange']
	};

	// var webkit = global.webkit;
	// var ttJSCore = global.ttJSCore;

	var logSwitchOn = false;

	function _checkSyncInvokeResult(res, callbackId) {
	  if (res !== undefined && typeof invokeCallbackMap[callbackId] == 'function' && res !== '' && res !== null) {
	    try {
	      res = JSON.parse(res);
	      res = NativeBuffer.unpack(res);
	    } catch (t) {
	      res = {};
	    }

	    invokeCallbackMap[callbackId](res);
	    delete invokeCallbackMap[callbackId];
	  }
	}

	function _invoke$2(ev, param, callbackId) {
	  if (logSwitchOn) {
	    logger.log('invoke客户端方法', ev, param, callbackId);
	  }

	  // 进入后台时，缓存调端的 task
	  if (onAppEnterBackground && backgroundEventManager.needCache.find(function (e) {
	    return e === ev;
	  })) {
	    invokeTaskCache.push([ev, param, callbackId]);
	    return;
	  }

	  if (ttJSCore) {
	    var res = ttJSCore.invoke(ev, param, callbackId);
	    _checkSyncInvokeResult(res, callbackId);
	  } else {
	    var wkInvokeParam = {
	      event: ev,
	      paramsString: param,
	      callbackId: callbackId
	    };

	    webkit.messageHandlers.invoke.postMessage(wkInvokeParam);
	  }
	}

	function _publish(ev, paramString, webviewIdsString) {
	  if (logSwitchOn) {
	    logger.log('publish到对岸', ev, paramString, webviewIdsString);
	  }
	  if (ttJSCore) {
	    ttJSCore.publish(ev, paramString, webviewIdsString);
	  } else {
	    webkit.messageHandlers.publish.postMessage({
	      event: ev,
	      paramsString: paramString,
	      webviewIds: webviewIdsString
	    });
	  }
	}

	function _beforeInvoke(ev, data, cb) {
	  data = NativeBuffer.pack(data);
	  var datastring = JSON.stringify(data || {}),
	      _id = ++invokeCallbackIdCounter;
	  invokeCallbackMap[_id] = cb;
	  // trick for openSchema
	  if (ev === 'openSchema') {
	    reserveInvokeCallbackIds.push(_id);
	  }
	  _invoke$2(ev, datastring, _id);
	}

	function _invokeHandler(callbackId, data) {
	  if (logSwitchOn) {
	    logger.log('invokeHandler客户端执行回调', callbackId, data);
	  }
	  // NOTE 这里修改了原有的实现，加了一层 JSON 转码
	  if (typeof data === 'string') {
	    data = JSON.parse(data);
	  }
	  data = NativeBuffer.unpack(data);
	  var _cb = invokeCallbackMap[callbackId];
	  typeof _cb == 'function' && _cb(data);

	  if (reserveInvokeCallbackIds.indexOf(callbackId) === -1) {
	    delete invokeCallbackMap[callbackId];
	  }
	}

	function _on(ev, cb) {
	  eventMap[ev] = cb;
	}

	function _beforePublish(ev, data, webviewIds) {
	  webviewIds = webviewIds || [];
	  webviewIds = JSON.stringify(webviewIds);
	  var custom_ev = 'custom_event_' + ev;
	  var datastring = JSON.stringify(data);

	  _publish(custom_ev, datastring, webviewIds);
	}

	function _subscribe(ev, cb) {
	  customEventMap['custom_event_' + ev] = cb;
	}

	function _subscribeHandler(ev, data, webviewId, r) {
	  if (logSwitchOn) {
	    logger.log('subscribeHandler事件触发', ev, data, webviewId, r);
	  }

	  if (ev === ACTIONS.onAppEnterBackground) {
	    onAppEnterBackground = true;
	  } else if (ev === ACTIONS.onAppEnterForeground) {
	    // 回到前台时，取出缓存的 task
	    onAppEnterBackground = false;
	    while (invokeTaskCache.length) {
	      _invoke$2.apply(null, invokeTaskCache.shift());
	    }
	  }
	  // 处于后台期间需要屏蔽的回调处理
	  if (onAppEnterBackground && backgroundEventManager.needDisabled.find(function (e) {
	    return e === ev;
	  })) {
	    return;
	  }

	  // NOTE 这里修改了原有的实现，加了一层 JSON 转码
	  if (typeof data === 'string') {
	    data = JSON.parse(data);
	  }
	  data = NativeBuffer.unpack(data);
	  var _cb = ev.indexOf('custom_event_') > -1 ? customEventMap[ev] : eventMap[ev];
	  typeof _cb == 'function' && _cb(data, webviewId, r);
	}

	var ttJSBridge = {
	  on: _on,
	  publish: _beforePublish,
	  invoke: _beforeInvoke,
	  subscribe: _subscribe
	};

	// 暴露给端上的
	_global$2.ttJSBridge = {
	  get invokeHandler() {
	    return _invokeHandler;
	  },
	  get subscribeHandler() {
	    return _subscribeHandler;
	  }
	};

	function ext(obj, key, val) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: val,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = val;
	  }

	  return obj;
	}

	var RunType = {
	  APP: 'micro_app',
	  GAME: 'micro_game',
	  DEVTOOLS: 'ide'
	};

	var ThirdScriptErrorKey = {};
	ext(ThirdScriptErrorKey, RunType.APP, 'thirdScriptError');
	ext(ThirdScriptErrorKey, RunType.GAME, 'gameThirdScriptError');

	var APIKeyId = {
	  createRequestTask: 1,
	  operateRequestTask: 2,
	  createUploadTask: 3,
	  operateUploadTask: 4,
	  createDownloadTask: 5,
	  operateDownloadTask: 6,
	  setAudioState: 7,
	  getAudioState: 8,
	  operateAudio: 9,
	  createAudioInstance: 10,
	  destroyAudioInstance: 11,
	  operateRecorder: 12,
	  chooseVideo: 13,
	  saveVideoToPhotosAlbum: 14,
	  saveFile: 15,
	  getStorage: 16,
	  setStorage: 17,
	  removeStorage: 18,
	  removeStorageSync: 19,
	  clearStorage: 20,
	  getStorageInfo: 21,
	  getStorageInfoSync: 22,
	  openLocation: 23,
	  getSystemInfo: 24,
	  getSystemInfoSync: 25,
	  getNetworkType: 26,
	  getConnectedWifi: 27,
	  getClipboardData: 28,
	  setClipboardData: 29,
	  setKeepScreenOn: 30,
	  enableAccelerometer: 31,
	  vibrateShort: 32,
	  vibrateLong: 33,
	  showModal: 34,
	  showToast: 35,
	  hideToast: 36,
	  showActionSheet: 37,
	  redirectTo: 38,
	  reLaunch: 39,
	  navigateTo: 40,
	  switchTab: 41,
	  navigateBack: 42,
	  protocolPathToAbsPath: 43,
	  base64ToTempFilePath: 44,
	  makePhoneCall: 45,
	  login: 46,
	  checkSession: 47,
	  getUserInfo: 48,
	  getUseDuration: 49,
	  dealUserRelation: 50,
	  requestPayment: 51,
	  chooseAddress: 52,
	  setKeyboardValue: 53,
	  hideKeyboard: 54,
	  getCurrentRoute: 55,
	  getPhoneNumber: 56,
	  initReady: 57,
	  showKeyboard: 58,
	  showDatePickerView: 59,
	  insertVideoPlayer: 60,
	  removeVideoPlayer: 61,
	  webViewReadyToTerminate: 62,
	  getFileInfo: 63,
	  getSavedFileList: 64,
	  removeSavedFile: 65,
	  saveFileSync: 66,
	  readFile: 67,
	  readFileSync: 68,
	  writeFileSync: 69,
	  mkdirSync: 70,
	  readdirSync: 71,
	  rmdirSync: 72,
	  accessSync: 73,
	  unlinkSync: 74,
	  statSync: 75,
	  renameSync: 76,
	  copyFile: 77,
	  copyFileSync: 78,
	  unzip: 79,
	  getMenuButtonBoundingClientRect: 80,
	  updateKeyboard: 81,
	  exitMiniProgram: 82,
	  getLaunchOptionsSync: 83,
	  showShareMenu: 84,
	  hideShareMenu: 85,
	  getShareInfo: 86,
	  shareAppMessageDirectly: 87,
	  updateShareMenu: 88,
	  shareVideo: 89,
	  startCompass: 90,
	  stopCompass: 91,
	  startGameRecord: 92,
	  stopGameRecord: 93,
	  chooseImage: 94,
	  previewImage: 95,
	  getImageInfo: 96,
	  saveImageToPhotosAlbum: 97,
	  authorize: 98,
	  insertContainer: 99,
	  updateContainer: 100,
	  removeContainer: 101,
	  updateInput: 102,
	  showPickerView: 104,
	  showMultiPickerView: 105,
	  updateMultiPickerView: 106,
	  disableScrollBounce: 107,
	  removeTextArea: 108,
	  insertTextArea: 109,
	  updateTextArea: 110,
	  insertHTMLWebView: 111,
	  removeHTMLWebView: 112,
	  updateHTMLWebView: 113,
	  createSocketTask: 114,
	  operateSocketTask: 115,
	  getLocation: 116,
	  scanCode: 117,
	  startPullDownRefresh: 118,
	  stopPullDownRefresh: 119,
	  getSetting: 120,
	  openSetting: 121,
	  resumeGameRecord: 122,
	  getCloudStorageByRelation: 123,
	  getUserCloudStorage: 124,
	  removeUserCloudStorage: 125,
	  setUserCloudStorage: 126,
	  openUserProfile: 127,
	  pauseGameRecord: 128,
	  operateVideoAd: 129,
	  createVideoAd: 130,
	  getGeneralInfo: 131,
	  tma_login: 132,
	  openSchema: 133,
	  getVideoManager: 134,
	  createFaceDetector: 135,
	  requestCamera: 136,
	  createOffscreenVideo: 137,
	  reportAnalytics: 138,
	  requestGamePayment: 139,
	  operateScreenRecorder: 140
	};

	// 宿主实现的私有方法
	var HostMethodId = {
	  // 头条
	  tt_checkIsFollowUser: 5000,
	  tt_requestFollowUser: 5001,
	  // 抖音
	  aweme_addFriend: 6000
	};

	var SpeedValueType = {
	  webview2AppService: 1,
	  appService2Webview: 2,
	  funcReady: 3,
	  firstGetData: 4,
	  firstRenderTime: 5,
	  reRenderTime: 6,
	  forceUpdateRenderTime: 7,
	  appRoute2newPage: 8,
	  newPage2pageReady: 9,
	  thirdScriptRunTime: 10,
	  pageframe: 11,
	  WAWebview: 12,
	  WAWidget: 13,
	  widgetCanvasReady: 14,
	  widgetFirstDataPush: 15
	};

	var ErrorType = {
	  appServiceSDKScriptError: 1,
	  webviewSDKScriptError: 2,
	  jsEngineScriptError: 3,
	  thirdScriptError: 4,
	  webviewScriptError: 5,
	  parserScriptError: 6
	};

	// 什么类型的错误需要交给 sentry 处理
	var SENTRY_ERROR = [1, 2, 3, 5, 6];

	function safeBridgeInvoke(callback) {
	  ttJSBridge !== undefined ? callback() : document.addEventListener('ttJSBridgeReady', callback, false);
	}

	function _invoke$3() {
	  var args = arguments;
	  safeBridgeInvoke(function () {
	    ttJSBridge.invoke.apply(ttJSBridge, args);
	  });
	}

	var systemInfo = {};

	function _checkObjectKeys(obj) {
	  var keysArr = [];
	  for (var key in obj) {
	    keysArr.push(key);
	  }
	  return keysArr.length;
	}

	function getSystemInfoSync() {
	  if (!_checkObjectKeys(systemInfo)) {
	    _invoke$3('getSystemInfoSync', {}, function (res) {
	      var isOk = res.errMsg.indexOf('getSystemInfoSync:ok') === 0;
	      if (isOk) {
	        systemInfo = res;
	      }
	    });
	  }

	  return systemInfo;
	}

	function safeBridgeInvoke$1(callback) {
	  ttJSBridge !== undefined ? callback() : document.addEventListener('ttJSBridgeReady', callback, false);
	}

	function _invoke$4() {
	  var args = arguments;
	  safeBridgeInvoke$1(function () {
	    ttJSBridge.invoke.apply(ttJSBridge, args);
	  });
	}

	function _publish$1() {
	  var args = arguments;
	  safeBridgeInvoke$1(function () {
	    ttJSBridge.publish.apply(ttJSBridge, args);
	  });
	}

	// 上报错误信息至 sentry
	// 错误信息指除第三方开发者的错误信息
	function invokeSentryReport(_ref) {
	  var url = _ref.url,
	      method = _ref.method,
	      header = _ref.header,
	      data = _ref.data;

	  _invoke$4('sentryReport', {
	    url: url,
	    method: method,
	    header: header,
	    data: data
	  });
	}

	// 将数据发给客户端，然后使用 APP Log3.0 发送至数据平台
	// 数据上报均基于此接口
	function invokeReportCustom(data) {
	  var _systemInfo = getSystemInfoSync();
	  var logData = {
	    tag: data.tag || '',
	    data: {
	      mp_id: (typeof TMAConfig === 'undefined' ? 'undefined' : _typeof(TMAConfig)) === 'object' && TMAConfig !== null && TMAConfig.appId || '',
	      lib_version: _systemInfo.SDKUpdateVersion || '1.0.0.0',
	      _param_for_special: Reporter.getRunType()
	    }
	  };
	  Object.assign(logData.data, data.data);
	  _invoke$4('systemLog', logData, function () {
	    typeof data.cb === 'function' && data.cb();
	  });
	}

	function surroundTryCatch(func) {
	  return function () {
	    try {
	      return func.apply(func, arguments);
	    } catch (err) {
	      logger.error('reporter error: ' + (err && err.message));
	    }
	  };
	}

	var lastSpeedReportTime = 0;
	var lastWebviewErrorMsg = '';
	var globalRoute = '';
	var globalMethod = '';
	var sentry = null;
	var exeWebviewErrorMsg = function exeWebviewErrorMsg() {};
	var RunType$1 = RunType.APP;

	var Constructor = {
	  // 包装第三方回调
	  surroundThirdByTryCatch: function surroundThirdByTryCatch(func, errTip) {
	    var msg = '';
	    if (globalRoute) {
	      msg = 'at ' + globalRoute + ' ' + globalMethod + ' function;';
	    }

	    return function () {
	      var res;
	      try {
	        var startTime = Date.now();
	        res = func.apply(func, arguments);
	        var cost = Date.now() - startTime;
	        if (cost > 1e3) {
	          // 执行过慢
	          Constructor.slowReport({
	            key: 'apiCallBack',
	            cost: cost,
	            extend: msg + errTip
	          });
	        }
	      } catch (err) {
	        // 第三方错误
	        Constructor.thirdErrorReport({
	          error: err,
	          extend: msg + errTip
	        });
	      }
	      return res;
	    };
	  },
	  // 运行过慢统计上报
	  slowReport: function slowReport(param) {
	    // 第三方执行过慢，缺少可视化工具，暂时不作处理
	    return;
	  },
	  // 速度、性能统计上报
	  speedReport: function speedReport(param) {
	    var key = param.key,
	        data = param.data,
	        timeMark = param.timeMark,
	        force = param.force,
	        eventName = param.eventName;
	    var startTime = timeMark.startTime,
	        endTime = timeMark.endTime;

	    var speedValueType = SpeedValueType && SpeedValueType[key];
	    var now = Date.now();
	    var strLength = 0;

	    if (speedValueType && startTime && endTime && (force || now - lastSpeedReportTime >= 500)) {
	      data && (strLength = JSON.stringify(data).length);
	      lastSpeedReportTime = now;
	      var tag = 'mp_speed_analysis';
	      // 上传至数据平台
	      // 如果是 subscribe/publish, 会有 event_name(绑定的消息)/total_duration(publish => native => subscribe)
	      invokeReportCustom({
	        tag: tag,
	        data: {
	          speed_value_type: key,
	          total_duration: endTime - startTime,
	          param_length: strLength || 0,
	          event_name: eventName || ''
	        }
	      });
	    }
	  },
	  // 第三方错误上报
	  thirdErrorReport: function thirdErrorReport(param) {
	    var error = param.error,
	        extend = param.extend;

	    Constructor.errorReport({
	      key: 'thirdScriptError',
	      error: error,
	      extend: extend
	    });
	  },
	  // 通用上报错误接口
	  errorReport: function errorReport(param) {
	    var key = param.key,
	        error = param.error,
	        extend = param.extend;

	    var errorType = ErrorType && ErrorType[key];
	    if (errorType) {
	      var errorString = extend ? error.message + ';' + extend : error.message;
	      var msg = key + '\n' + errorString + '\n' + error.stack;
	      logger.error(msg);
	      if (typeof window != 'undefined' && window.__webviewId__) {
	        // webview 的 error 发送至 jsCore
	        _publish$1('WEBVIEW_ERROR_MSG', {
	          data: {
	            msg: msg
	          },
	          options: {
	            timestamp: Date.now()
	          }
	        });
	      } else {
	        Constructor.triggerErrorMessage(msg);
	      }

	      if (SENTRY_ERROR.indexOf(errorType) > -1) {
	        if (_global$2.Sentry) {
	          if (!sentry) {
	            sentry = new Sentry({
	              key: 'ed6716196f0742d2bdee626bc665a2fe',
	              project: '325',
	              transportCallback: invokeSentryReport
	            });
	          }
	          var _systemInfo = getSystemInfoSync();
	          sentry.report(error, {
	            error_type: key,
	            mp_id: (typeof TMAConfig === 'undefined' ? 'undefined' : _typeof(TMAConfig)) === 'object' && TMAConfig !== null && TMAConfig.appId || '',
	            lib_version: _systemInfo.SDKUpdateVersion || '1.0.0.0',
	            version_code: _systemInfo.version,
	            run_type: Constructor.getRunType()
	          });
	        } else {
	          logger.error(msg);
	        }
	      } else {
	        return;
	        // 第三方错误暂时不处理
	        // var __id = `${errorType},${error.name},${encodeURIComponent(errorString)},${encodeURIComponent(error.stack)}`;

	        // // TODO 增加反馈错误的条件
	        // Constructor.reportKeyValue({
	        //     key: 'Error',
	        //     value: __id,
	        //     force: true
	        // });
	      }
	    }
	  },
	  registerErrorListener: function registerErrorListener(cb) {
	    if (typeof cb === 'function') {
	      exeWebviewErrorMsg = cb;
	    }
	  },
	  triggerErrorMessage: function triggerErrorMessage(msg) {
	    if (lastWebviewErrorMsg != msg) {
	      lastWebviewErrorMsg = msg;
	      setTimeout(function () {
	        try {
	          exeWebviewErrorMsg(msg);
	        } catch (e) {
	          logger.error(e.message + ' at onError callback function');
	        }
	      }, 0);
	    }
	  },

	  unRegisterErrorListener: function unRegisterErrorListener() {
	    exeWebviewErrorMsg = function exeWebviewErrorMsg() {};
	  },
	  // 个性化上传数据
	  customReport: function customReport() {
	    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref2$tag = _ref2.tag,
	        tag = _ref2$tag === undefined ? '' : _ref2$tag,
	        _ref2$data = _ref2.data,
	        data = _ref2$data === undefined ? {} : _ref2$data,
	        cb = _ref2.cb;

	    invokeReportCustom({ tag: tag, data: data, cb: cb });
	  },
	  setAsGame: function setAsGame() {
	    RunType$1 = RunType.GAME;
	  },
	  saveAsDevtools: function saveAsDevtools() {
	    RunType$1 = RunType.DEVTOOLS;
	  },
	  getRunType: function getRunType() {
	    return RunType$1;
	  }
	};

	var Reporter = {};

	for (var funcName in Constructor) {
	  !function (fn) {
	    Reporter.__defineGetter__(fn, function () {
	      return surroundTryCatch(Constructor[fn]);
	    });
	  }(funcName);
	}

	Reporter.__defineSetter__('__route__', function (val) {
	  globalRoute = val;
	});

	Reporter.__defineSetter__('__method__', function (val) {
	  globalMethod = val;
	});

	typeof window != 'undefined' && (window.Reporter = Reporter);

	typeof window != 'undefined' && (window.onbeforeunload = function () {
	  //    Constructor.submit();
	});

	/**
	 * 主要统计各个 API 的调用成功/失败情况，根据 API、错误信息和调用情况分别进行统计
	 */

	// 上报队列
	var okMap = {};
	var failMap = {};
	var cancelMap = {};
	var lastReportTimestamp = 0;

	function _trans(result, maps) {
	  var res = Object.keys(maps).filter(function (func) {
	    return APIKeyId[func] || HostMethodId[func];
	  }).map(function (func) {
	    return Object.keys(maps[func]).map(function (errMsg) {
	      // 压缩一下
	      var duration = maps[func][errMsg];
	      var count = duration.length;
	      var durationAmount = duration.reduce(function (total, current) {
	        return total + current;
	      }, 0);
	      var averageDuration = durationAmount / count;
	      return (APIKeyId[func] || HostMethodId[func]) + '|' + result + '|' + count + '|' + averageDuration + '|' + errMsg.replace(func, '');
	    });
	  });

	  return [].concat.apply([], res);
	}

	function clear() {
	  okMap = {};
	  failMap = {};
	  cancelMap = {};
	}

	function reportRealtimeAction() {
	  var okarray = _trans(1, okMap);
	  var failarray = _trans(2, failMap);
	  var cancelarray = _trans(3, cancelMap);
	  var dataArray = [].concat(okarray, failarray, cancelarray);

	  if (dataArray.length > 0) {
	    Reporter.customReport({
	      tag: 'mp_api_analysis',
	      data: {
	        api_data_array: dataArray
	      },
	      cb: clear
	    });
	  }
	}

	function reportJSAPI(func, isOk, isFail, isCancel, errMsg, duration) {
	  var evMap = isOk ? okMap : isFail ? failMap : cancelMap;

	  evMap[func] = evMap[func] || {};
	  evMap[func][errMsg] = (evMap[func][errMsg] || []).concat(duration);

	  if (Date.now() - lastReportTimestamp >= 3e4) {
	    lastReportTimestamp = Date.now();
	    setTimeout(reportRealtimeAction, 3e4);
	  }
	}

	function getDataType(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}

	function isObject$1(val) {
	  return getDataType(val) === 'Object';
	}

	function isFn(fn) {
	  return getDataType(fn) === 'Function';
	}

	function paramCheck(input, shouldbe) {
	  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'param';

	  var inputType = getDataType(input);
	  var shouldbeType = getDataType(shouldbe);

	  if (inputType !== shouldbeType) {
	    return name + ' should pass ' + shouldbeType + ', not ' + inputType;
	  }

	  var message = '';
	  switch (shouldbeType) {
	    case 'Object':
	      for (var key in shouldbe) {
	        message += paramCheck(input[key], shouldbe[key], name + '.' + key);
	      }
	      break;
	    case 'Array':
	      if (input.length < shouldbe.length) {
	        return name + ' should have more than ' + shouldbe.length + ' items, not ' + input.length + ' items';
	      }
	      for (var i = 0; i < shouldbe.length; ++i) {
	        message += paramCheck(input[i], shouldbe[i], name + '[' + i + ']');
	      }
	      break;
	    default:
	      break;
	  }

	  return message;
	}
	// equals to path.join()
	function getRealRoute(root, url) {
	  if (url.indexOf('/') === 0) {
	    return url.substr(1);
	  }

	  if (url.indexOf('./') === 0) {
	    return getRealRoute(root, url.substr(2), false);
	  }

	  // 先从 url 里找到 ../ 的个数，将 url 里的 ../ 删掉，同时从 root 的尾部减去相同数量的层级
	  // 问题是，url 中间的 ../ 是无法处理的
	  var urlPathArr = url.split('/'),
	      rootPathArr = root.length > 0 ? root.split('/') : [],
	      twodotCount = 0,
	      len = urlPathArr.length;
	  for (; twodotCount < len && urlPathArr[twodotCount] === '..'; twodotCount++) {}
	  urlPathArr.splice(0, twodotCount);
	  rootPathArr.splice(rootPathArr.length - twodotCount - 1, twodotCount + 1);
	  return rootPathArr.concat(urlPathArr).join('/');
	}

	function getPlatform() {
	  if (isObject$1(TMAConfig)) {
	    return TMAConfig.platform;
	  } else {
	    return '';
	  }
	}

	function urlEncodeFormData(data) {
	  var needEncode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (data === undefined || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
	    return data;
	  }

	  var res = [];
	  for (var key in data) {
	    if (data.hasOwnProperty(key)) {
	      if (needEncode) {
	        try {
	          res.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));
	        } catch (err) {
	          res.push(key + '=' + data[key]);
	        }
	      } else {
	        res.push(key + '=' + data[key]);
	      }
	    }
	  }
	  return res.join('&');
	}

	function addQueryStringToUrl(url, data) {
	  if (typeof url === 'string' && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && Object.keys(data).length > 0) {
	    var ab = url.split('?');
	    var search = ab[1] || '';

	    var urlQueryObj = search.split('&').reduce(function (searchobj, pair) {
	      if (typeof pair === 'string' && pair.length > 0) {
	        var ps = pair.split('=');
	        searchobj[ps[0]] = ps[1];
	      }
	      return searchobj;
	    }, {});

	    var dataObj = Object.keys(data).reduce(function (dataobj, key) {
	      if (_typeof(data[key]) === 'object') {
	        dataobj[encodeURIComponent(key)] = encodeURIComponent(JSON.stringify(data[key]));
	      } else {
	        dataobj[encodeURIComponent(key)] = encodeURIComponent(data[key]);
	      }
	      return dataobj;
	    }, {});

	    return ab[0] + '?' + urlEncodeFormData(assign$1(urlQueryObj, dataObj));
	  }
	  return url;
	}

	function validateUrl(url) {
	  var protocol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http';

	  if (protocol === 'http') {
	    return (/^(http|https):\/\/.*/i.test(url)
	    );
	  } else if (protocol === 'websocket') {
	    return (/^(ws|wss):\/\/.*/i.test(url)
	    );
	  }
	}

	function assign$1() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return args.reduce(function (obj, cur) {
	    for (var key in cur) {
	      obj[key] = cur[key];
	    }
	    return obj;
	  }, {});
	}
	function guid() {
	  return 'xxxxxxxx'.replace(/x/g, function () {
	    return (16 * Math.random() | 0).toString(16);
	  });
	}

	var alphabet$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	var btoa$1 = btoa$1 || function (e) {
	  for (var t, n, r = String(e), o = '', i = 0, a = alphabet$1; r.charAt(0 | i) || (a = '=', i % 1); o += a.charAt(63 & t >> 8 - i % 1 * 8)) {
	    if ((n = r.charCodeAt(i += 0.75)) > 255) {
	      throw new Error('"btoa" failed');
	    }
	    t = t << 8 | n;
	  }
	  return o;
	};

	function arrayBufferToBase64(ab) {
	  var str = '',
	      reader = new Uint8Array(ab),
	      len = reader.byteLength;
	  for (var i = 0; i < len; i++) {
	    str += String.fromCharCode(reader[i]);
	  }
	  return btoa$1(str);
	}

	function convertObjectValueToString(obj) {
	  return Object.keys(obj).reduce(function (ret, key) {
	    if (typeof obj[key] == 'string') {
	      ret[key] = obj[key];
	    } else if (typeof obj[key] == 'number') {
	      ret[key] = obj[key] + '';
	    } else {
	      ret[key] = Object.prototype.toString.apply(obj[key]);
	    }
	    return ret;
	  }, {});
	}

	function surroundByTryCatch(func, msg) {
	  return function () {
	    try {
	      return func.apply(func, arguments);
	    } catch (err) {
	      if (Object.prototype.toString.apply(err) === '[object Error]') {
	        if ('AppServiceSdkKnownError' == err.type) {
	          throw err;
	        }
	        'ThirdScriptError' === err.type ? Reporter.thirdErrorReport({
	          error: err,
	          extend: msg
	        }) : Reporter.errorReport({
	          key: 'appServiceSDKScriptError',
	          error: err,
	          extend: msg
	        });
	      }
	    }
	  };
	}

	// 包装第三方 callback
	function surroundByTryCatchFactory(func, msg) {
	  return Reporter.surroundThirdByTryCatch(func, msg);
	}

	function _anyTypeToString(any) {
	  var protoType = Object.prototype.toString.call(any).split(' ')[1].split(']')[0];

	  if (protoType == 'Array' || protoType == 'Object') {
	    try {
	      any = JSON.stringify(any);
	    } catch (err) {
	      throw err;
	    }
	  } else if (protoType == 'String' || protoType == 'Number' || protoType == 'Boolean') {
	    any = any.toString();
	  } else if (protoType == 'Date') {
	    any = any.getTime().toString();
	  } else if (protoType == 'Undefined') {
	    any = 'undefined';
	  } else if (protoType == 'Null') {
	    any = 'null';
	  } else {
	    any = '';
	  }

	  return {
	    data: any,
	    dataType: protoType
	  };
	}
	var anyTypeToString = surroundByTryCatch(_anyTypeToString, 'anyTypeToString');

	function _stringToAnyType(str, protoType) {
	  switch (protoType) {
	    case 'String':
	      return str;
	    case 'Array':
	    case 'Object':
	      return JSON.parse(str);
	    case 'Number':
	      return parseFloat(str);
	    case 'Boolean':
	      return str == 'true';
	    case 'Date':
	      return new Date(parseInt(str));
	    case 'Undefined':
	      return undefined;
	    case 'Null':
	      return null;
	    default:
	      return '';
	  }
	}
	var stringToAnyType = surroundByTryCatch(_stringToAnyType, 'stringToAnyType');

	// 自定义错误类型
	// 简单分就是两种，需要上报和不需要上报
	// 或者是，sdk的错误 和 开发者的错误

	// sdk 错误, 如调用客户端端失败，手动抛出
	var AppServiceSdkKnownError = function (_Error) {
	  inherits(AppServiceSdkKnownError, _Error);

	  function AppServiceSdkKnownError(msg) {
	    classCallCheck(this, AppServiceSdkKnownError);

	    var _this = possibleConstructorReturn(this, _Error.call(this, 'APP-SERVICE-SDK:' + msg));

	    _this.type = 'AppServiceSdkKnownError';
	    return _this;
	  }

	  return AppServiceSdkKnownError;
	}(Error);

	// 开发者使用中的错误，如使用同步接口时发生的错误
	var ThirdScriptError = function (_Error2) {
	  inherits(ThirdScriptError, _Error2);

	  function ThirdScriptError(msg) {
	    classCallCheck(this, ThirdScriptError);

	    var _this2 = possibleConstructorReturn(this, _Error2.call(this, '' + msg));

	    _this2.type = 'ThirdScriptError';
	    return _this2;
	  }

	  return ThirdScriptError;
	}(Error);

	// 开发者使用中的类型错误，如参数不符合预期，手动抛出
	var ThirdScriptTypeError = function (_TypeError) {
	  inherits(ThirdScriptTypeError, _TypeError);

	  function ThirdScriptTypeError(msg) {
	    classCallCheck(this, ThirdScriptTypeError);

	    var _this3 = possibleConstructorReturn(this, _TypeError.call(this, '' + msg));

	    _this3.type = 'ThirdScriptError';
	    return _this3;
	  }

	  return ThirdScriptTypeError;
	}(TypeError);

	function isString(val) {
	  return getDataType(val) === 'String';
	}

	function deepCopy(obj) {
	  var maps = new Map();
	  function copy(obj) {
	    var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
	    if (obj && type === 'object') {
	      if (maps.has(obj)) {
	        return maps.get(obj);
	      }
	      var ret = void 0;
	      if (obj instanceof Array) {
	        ret = obj.map(deepCopy);
	      } else {
	        ret = {};
	        for (var key in obj) {
	          ret[key] = deepCopy(obj[key]);
	        }
	      }
	      maps.set(obj, ret);
	      return ret;
	    }
	    return obj;
	  }
	  return copy(obj);
	}

	// import Reporter from '../lib/reporter';

	function invoke$1(api, params, callback) {
	  ttJSBridge.invoke.apply(ttJSBridge, arguments);
	}

	function on() {
	  ttJSBridge.on.apply(ttJSBridge, arguments);
	}

	function invokeMethod(api) {
	  var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  var invokeStartTime = Date.now();
	  param = assign$1({}, param);

	  var userUsed = {};
	  for (var i in param) {
	    if ('function' == typeof param[i]) {
	      userUsed[i] = surroundByTryCatchFactory(param[i], 'at api ' + api + ' ' + i + ' callback function');
	      delete param[i];
	    }
	  }

	  var libHooks = {};
	  for (var c in option) {
	    'function' == typeof option[c] && (libHooks[c] = surroundByTryCatchFactory(option[c], 'at api ' + api + ' ' + c + ' callback function'), libHooks[c]._argumentsLength = option[c].length);
	  }

	  // beforeAll
	  // ok:      beforeSuccess - <success> - afterSuccess
	  // cancel:  <fail> - beforeCancel - <!cancel> - afterCancel
	  // fail:    beforeFail - <fail> - afterFail
	  // <complete>
	  // afterAll
	  invoke$1(api, param, function (res) {
	    var invokeEndTime = Date.now();
	    res.errMsg = res.errMsg || api + ':ok';

	    var isOk = res.errMsg.indexOf(api + ':ok') === 0;
	    var isFail = res.errMsg.indexOf(api + ':fail') === 0;
	    var isCancel = res.errMsg.indexOf(api + ':cancel') === 0;

	    typeof libHooks.beforeAll == 'function' && libHooks.beforeAll(res);
	    if (isOk) {
	      var c = function c() {
	        typeof userUsed.success === 'function' && userUsed.success(res);
	        typeof libHooks.afterSuccess === 'function' && libHooks.afterSuccess(res);
	      };

	      if (typeof libHooks.beforeSuccess === 'function') {
	        if (libHooks.beforeSuccess._argumentsLength === 2) {
	          libHooks.beforeSuccess(res, c);
	        } else {
	          libHooks.beforeSuccess(res);
	          c();
	        }
	      } else {
	        c();
	      }
	    } else if (isCancel) {
	      res.errMsg = res.errMsg.replace(api + ':cancel', api + ':fail cancel');
	      typeof userUsed.fail == 'function' && userUsed.fail(res);
	      typeof libHooks.beforeCancel == 'function' && libHooks.beforeCancel(res);
	      typeof userUsed.cancel == 'function' && userUsed.cancel(res);
	      typeof libHooks.afterCancel == 'function' && libHooks.afterCancel(res);
	    } else if (isFail) {
	      typeof libHooks.beforeFail == 'function' && libHooks.beforeFail(res);
	      typeof userUsed.fail == 'function' && userUsed.fail(res);
	      typeof libHooks.afterFail == 'function' && libHooks.afterFail(res);
	    }
	    typeof userUsed.complete == 'function' && userUsed.complete(res);
	    typeof libHooks.afterAll == 'function' && libHooks.afterAll(res);
	    // 统计使用情况
	    // 如果是宿主私有 API，获取真正的 method
	    if ((api === 'callHostMethod' || api === 'callHostMethodSync') && typeof param.method === 'string') {
	      api = param.method;
	    }
	    reportJSAPI(api, isOk, isFail, isCancel, res.errMsg, invokeEndTime - invokeStartTime);
	  });
	}

	function onMethod(event, callback) {
	  on(event, surroundByTryCatchFactory(callback, 'at api ' + event + ' callback function'));
	}

	function noop() {}

	function beforeInvoke(api, param, shouldbe) {
	  var failMessage = paramCheck(param, shouldbe);

	  if (failMessage) {
	    beforeInvokeFail(api, param, failMessage);
	    return false;
	  } else {
	    return true;
	  }
	}

	function beforeInvokeFail(api) {
	  var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var msg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

	  var res = {
	    errMsg: api + ':fail ' + msg
	  };

	  surroundByTryCatchFactory(param.fail || noop, res.errMsg)(res);
	  surroundByTryCatchFactory(param.complete || noop, res.errMsg)(res);
	}

	/* global nativeTMAConfig */

	function doInit() {
	}

	// 由于此次安卓修改v8初始化时机，不修改R2D2，故暂时如下修改。
	// 后续分包加载可以重构此逻辑。

	// 老版本执行这行代码会立即调用，同时由于有debug变量，所以正常执行
	// 新版本执行这行代码会立即调用，但没有debug变量，不会正常执行
	if (typeof TMAConfig.onReady === 'function') {
	  TMAConfig.onReady(doInit);
	}
	// 老版本只会注册，不会执行
	// 新版本客户端会触发ready，导致段代码执行
	if (typeof TMAConfig.onRealReady === 'function') {
	  TMAConfig.onRealReady(doInit);
	}

	var modules = {};

	function define$1(path, factory) {
	  modules[path] = {
	    runed: false,
	    factory: factory
	  };
	}

	var t = function t(path) {
	  var match = path.match(/(.*)\/([^\/]+)?$/);
	  return match && match[1] ? match[1] : './';
	};
	var inRequire = function inRequire(path) {
	  var pwd = t(path);
	  return function (path) {
	    if ('string' != typeof path) {
	      throw new Error('require args must be a string');
	    }

	    for (var t = [], r = (pwd + '/' + path).split('/'), o = 0, i = r.length; o < i; ++o) {
	      var a = r[o];
	      if ('' != a && '.' != a) {
	        if ('..' == a) {
	          if (0 == t.length) {
	            throw new Error('can\'t find module : ' + path);
	          }
	          t.pop();
	        } else {
	          o + 1 < i && '..' == r[o + 1] ? o++ : t.push(a);
	        }
	      }
	    }
	    // try {
	    var c = t.join('/');
	    /* eslint-disable no-return-assign */
	    return (/\.js$/.test(c) || (c += '.js'), require(c)
	    );
	    // } catch (e) {
	    //   throw e;
	    // }
	  };
	};

	function require(path) {
	  if ('string' != typeof path) {
	    throw new Error('require args must be a string');
	  }

	  var module = modules[path];
	  if (!module) {
	    throw new Error('module "' + path + '" is not defined');
	  }

	  if (!module.runed) {
	    var factory = module.factory;
	    var _module = {
	      exports: {}
	    };
	    var res;

	    if (typeof factory === 'function') {
	      // try {
	      res = factory(inRequire(path), _module, _module.exports);
	      // } catch (e) {
	      //   throw e;
	      // }
	    }
	    module.exports = _module.exports || res;
	    module.runed = true;
	  }

	  return module.exports;
	}

	_global$2.define = define$1;
	_global$2.require = require;

	var NativeGlobal = _global$2.NativeGlobal || {
	  Canvas: function Canvas() {},
	  Image: function Image() {},
	  loadFont: function loadFont() {},
	  EventHandler: {},
	  setTimeout: _global$2.setTimeout,
	  clearTimeout: _global$2.clearTimeout,
	  setInterval: _global$2.setInterval,
	  clearInterval: _global$2.clearInterval,
	  requestAnimationFrame: _global$2.requestAnimationFrame,
	  cancelAnimationFrame: _global$2.cancelAnimationFrame,
	  createContext: function createContext() {},

	  Video: function Video() {},
	  Stream: function Stream() {},
	  effect: function effect() {},
	  media: {}
	};

	var Canvas = NativeGlobal.Canvas;
	var Image = NativeGlobal.Image;

	var Video = NativeGlobal.Video;
	var Stream = NativeGlobal.Stream;
	var media = NativeGlobal.media;
	var effect = NativeGlobal.effect;

	var createWorker = NativeGlobal.createWorker;
	var loadFont = NativeGlobal.loadFont;
	var gc = _global$2.gc || function () {};

	var inflate = function inflate(data) {
	  return NativeGlobal.zlib.inflate(data, false);
	};

	var createContext = NativeGlobal.createContext;
	var setTimeout$1 = NativeGlobal.setTimeout;
	var clearTimeout$1 = NativeGlobal.clearTimeout;
	var setInterval$1 = NativeGlobal.setInterval;
	var clearInterval$1 = NativeGlobal.clearInterval;
	var requestAnimationFrame = NativeGlobal.requestAnimationFrame;
	var cancelAnimationFrame = NativeGlobal.cancelAnimationFrame;

	_global$2.GameGlobal = _global$2;

	_global$2.console = _global$2.console || {
	  info: function info() {},
	  log: function log() {},
	  debug: function debug() {},
	  warn: function warn() {},
	  error: function error() {},
	  group: function group() {},
	  groupEnd: function groupEnd() {}
	};

	_global$2.setTimeout = NativeGlobal.setTimeout;
	_global$2.clearTimeout = NativeGlobal.clearTimeout;
	_global$2.setInterval = NativeGlobal.setInterval;
	_global$2.clearInterval = NativeGlobal.clearInterval;
	_global$2.requestAnimationFrame = NativeGlobal.requestAnimationFrame;
	_global$2.cancelAnimationFrame = NativeGlobal.cancelAnimationFrame;
	_global$2.NativeGlobal = undefined;
	_global$2.gc = undefined;

	var _global$__JSSDK_VERSI = _global$2.__JSSDK_VERSION__,
	    SDKVersion = _global$__JSSDK_VERSI.SDKVersion,
	    SDKUpdateVersion = _global$__JSSDK_VERSI.SDKUpdateVersion,
	    CommitHash = _global$__JSSDK_VERSI.CommitHash;

	/**
	 * @function getSystemInfo
	 * @description 获取系统信息
	 * @param {object} param
	 * @param {getSystemInfoSuccessCallback} [param.success] 回调
	 */

	function getSystemInfo(param) {
	  invokeMethod('getSystemInfo', param, {
	    beforeSuccess: function beforeSuccess(res) {
	      res.SDKVersion = SDKVersion;
	      res.SDKUpdateVersion = SDKUpdateVersion;
	      res.platform = res.platform && res.platform.toLocaleLowerCase();
	    }
	  });
	}

	/**
	 * @function getSystemInfoSync
	 * @description 同步获取系统信息
	 * @returns {object}
	 */
	function getSystemInfoSync$1() {

	  var ret = {};
	  invokeMethod('getSystemInfoSync', {}, {
	    beforeSuccess: function beforeSuccess() {
	      var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      res.platform = res.platform && res.platform.toLocaleLowerCase();
	      res.SDKVersion = SDKVersion;
	      res.SDKUpdateVersion = SDKUpdateVersion;
	      res.devicePixelRatio = res.pixelRatio; // 兼容cocos adapter高分屏支持
	      ret = res;
	    }
	  });
	  return ret;
	}

	/**
	 * getSystemInfo success callback
	 * @callback getSystemInfoSuccessCallback
	 * @param {object} response
	 * @param {*} response.data 指定 key 对应的内容
	 * @param {string} response.brand 手机品牌
	 * @param {string} response.model 手机型号
	 * @param {number} response.pixelRatio 设备像素比
	 * @param {number} response.screenWidth 屏幕宽度
	 * @param {number} response.screenHeight 屏幕高度
	 * @param {number} response.windowWidth 可使用窗口宽度
	 * @param {number} response.windowHeight 可使用窗口高度
	 * @param {string} response.version App 版本号
	 * @param {string} response.system 操作系统版本
	 * @param {string} response.platform 客户端平台
	 * @param {string} response.SDKVersion 客户端基础库版本
	 */

	var listeners = [];

	onMethod('onNetworkStatusChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  listeners.forEach(function (cb) {
	    typeof cb === 'function' && cb(res);
	  });
	});

	/**
	 * @function getNetworkType
	 * @description 获取网络类型
	 * @param {object} param
	 * @param {getNetworkTypeSuccessCallback} param.success 执行成功的回调方法
	 * @example
	tt.getNetworkType({
	    success (res) {
	        let network = res.networkType
	    }
	});
	 */
	function getNetworkType() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('getNetworkType', param);
	}

	/**
	 * @function onNetworkStatusChange
	 * @description 监听网络状态变化
	 * @param {onNetworkStatusChangeCallback} callback
	 * @example
	tt.onNetworkStatusChange(function(res) {
	  logger.log(res.isConnected, res.networkType);
	});
	 */
	function onNetworkStatusChange(callback) {
	  listeners.push(surroundByTryCatchFactory(callback, 'onNetworkStatusChange'));
	}

	// TODO 确认返回值准确范围
	/**
	 * getNetworkType success callback
	 * @callback getNetworkTypeSuccessCallback
	 * @param {object} response
	 * @param {string} response.networkType 网络类型，有效值包括 wifi/2g/3g/4g
	 */
	/**
	 * onNetworkStatusChange callback
	 * @callback onNetworkStatusChangeCallback
	 * @param {object} response
	 * @param {boolean} response.isConnected 当前是否有网
	 * @param {string} response.networkType 网络类型，有效值包括 wifi/2g/3g/4g
	 */

	/**
	 * @function getStorage
	 * @description 从本地缓存中异步获取指定 key 对应的内容
	 * @param {object} param
	 * @param {string} param.key 本地缓存中的指定的 key
	 * @param {getStorageSuccessCallback} [param.success] 成功回调
	 */
	var getStorage = function getStorage(param) {
	  if (beforeInvoke('getStorage', param, {
	    key: ''
	  })) {
	    invokeMethod('getStorage', param, {
	      beforeSuccess: function beforeSuccess(res) {
	        res.data = stringToAnyType(res.data, res.dataType);
	        delete res.dataType;
	      },
	      afterFail: function afterFail() {
	        var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        if (res.errMsg && res.errMsg.indexOf('data not found') > 0) {
	          return false;
	        }
	      }
	    });
	  }
	};

	/**
	 * @function getStorageSync
	 * @description 从本地缓存中同步获取指定 key 对应的内容
	 * @param {string} key 本地缓存中的指定的 key
	 * @returns {*} 指定的 key 对应的内容
	 */
	var getStorageSync = function getStorageSync(key) {
	  if (beforeInvoke('getStorageSync', key, '')) {
	    var result;

	    invokeMethod('getStorageSync', {
	      key: key
	    }, {
	      beforeAll: function beforeAll() {
	        var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        result = stringToAnyType(res.data, res.dataType);
	      },
	      afterFail: function afterFail() {
	        var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        if (res.errMsg && res.errMsg.indexOf('data not found') > 0) {
	          return false;
	        }
	      }
	    });

	    return result;
	  }
	};

	/**
	 * @function setStorage
	 * @description 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口
	 * @param {*} param
	 * @param {string} param.key 本地缓存中的指定的 key
	 * @param {object|string} param.data 需要存储的内容
	 */
	var setStorage = function setStorage(param) {
	  if (beforeInvoke('setStorage', param, {
	    key: ''
	  })) {
	    try {
	      var _anyTypeToString = anyTypeToString(param.data),
	          data = _anyTypeToString.data,
	          dataType = _anyTypeToString.dataType;

	      invokeMethod('setStorage', Object.assign(param, {
	        data: data,
	        dataType: dataType
	      }));
	    } catch (ex) {
	      typeof param.fail === 'function' && param.fail({
	        errMsg: 'setStorage:fail ' + ex.message
	      });
	      typeof param.complete === 'function' && param.complete({
	        errMsg: 'setStorage:fail ' + ex.message
	      });
	    }
	  }
	};

	/**
	 * @function setStorageSync
	 * @description 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口
	 * @param {string} key 本地缓存中的指定的 key
	 * @param {object|string} data 需要存储的内容
	 */
	var setStorageSync = function setStorageSync(key) {
	  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

	  if (beforeInvoke('setStorageSync', key, '')) {
	    var tmp = anyTypeToString(data),
	        dataString = tmp.data,
	        dataType = tmp.dataType;
	    var callFailed = false;
	    var errMsg = '';
	    invokeMethod('setStorageSync', {
	      key: key,
	      data: dataString,
	      dataType: dataType,
	      fail: function fail() {
	        var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        errMsg = res.errMsg;
	        callFailed = true;
	      }
	    });

	    if (callFailed) {
	      throw new AppServiceSdkKnownError(errMsg);
	    }
	  }
	};

	/**
	 * @function removeStorage
	 * @description 从本地缓存中异步移除指定 key
	 * @param {object} param
	 * @param {string} param.key 本地缓存中的指定的 key
	 */
	var removeStorage = function removeStorage(param) {
	  if (beforeInvoke('removeStorage', param, {
	    key: ''
	  })) {
	    invokeMethod('removeStorage', param);
	  }
	};

	/**
	 * @function removeStorageSync
	 * @description 从本地缓存中同步移除指定 key
	 * @param {string} key 本地缓存中的指定的 key
	 */
	var removeStorageSync = function removeStorageSync(key) {
	  if (beforeInvoke('removeStorageSync', key, '')) {
	    invokeMethod('removeStorageSync', {
	      key: key
	    });
	  }
	};

	/**
	 * @function clearStorage
	 * @description 清理本地数据缓存
	 */
	var clearStorage = function clearStorage(param) {
	  invokeMethod('clearStorage', param);
	};

	/**
	 * @function clearStorageSync
	 * @description 同步清理本地数据缓存
	 */
	var clearStorageSync = function clearStorageSync() {
	  invokeMethod('clearStorageSync');
	};

	/**
	 * @function getStorageInfo
	 * @description 异步获取当前storage的相关信息
	 * @param {object} param
	 * @param {getStorageInfoSuccessCallback} [param.success] 成功回调
	 */
	var getStorageInfo = function getStorageInfo(param) {
	  invokeMethod('getStorageInfo', param);
	};

	/**
	 * @function getStorageInfoSync
	 * @description 同步获取当前storage的相关信息
	 * @returns {object}
	 * @example
	try {
	  var res = tt.getStorageInfoSync()
	  logger.log(res.keys);
	  logger.log(res.currentSize);
	  logger.log(res.limitSize);
	} catch (error) {
	  // Do something when catch error
	}
	 */
	var getStorageInfoSync = function getStorageInfoSync() {
	  var result;
	  invokeMethod('getStorageInfoSync', {}, {
	    beforeAll: function beforeAll(res) {
	      result = res;
	      delete res.errMsg;
	    }
	  });
	  return result;
	};

	/**
	 * getStorage success callback
	 * @callback getStorageSuccessCallback
	 * @param {object} response
	 * @param {*} response.data 指定 key 对应的内容
	 */

	/**
	 * getStorageInfo success callback
	 * @callback getStorageInfoSuccessCallback
	 * @param {object} response
	 * @param {string[]} response.keys 当前storage中所有的key
	 * @param {number} response.currentSize 当前占用的空间大小, 单位kb
	 * @param {number} response.limitSize 限制的空间大小，单位kb
	 */

	/* !
	* EventEmitter2
	* https://github.com/hij1nx/EventEmitter2
	*
	* Copyright (c) 2013 hij1nx
	* Licensed under the MIT license.
	*/
	var isArray$2 = Array.isArray ? Array.isArray : function _isArray(obj) {
	  return Object.prototype.toString.call(obj) === '[object Array]';
	};
	var defaultMaxListeners = 100;

	function init() {
	  this._events = {};
	  if (this._conf) {
	    configure.call(this, this._conf);
	  }
	}

	function configure(conf) {
	  if (conf) {
	    this._conf = conf;

	    conf.delimiter && (this.delimiter = conf.delimiter);
	    this._maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;

	    conf.wildcard && (this.wildcard = conf.wildcard);
	    conf.newListener && (this._newListener = conf.newListener);
	    conf.removeListener && (this._removeListener = conf.removeListener);
	    conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);

	    if (this.wildcard) {
	      this.listenerTree = {};
	    }
	  } else {
	    this._maxListeners = defaultMaxListeners;
	  }
	}

	function logPossibleMemoryLeak(count, eventName) {
	  var errorMsg = '(node) warning: possible EventEmitter memory ' + 'leak detected. ' + count + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.';

	  if (this.verboseMemoryLeak) {
	    errorMsg += ' Event name: ' + eventName + '.';
	  }

	  if (typeof process !== 'undefined' && process.emitWarning) {
	    var e = new Error(errorMsg);
	    e.name = 'MaxListenersExceededWarning';
	    e.emitter = this;
	    e.count = count;
	    process.emitWarning(e);
	  } else {
	    logger.error(errorMsg);

	    if (logger.trace) {
	      logger.trace();
	    }
	  }
	}

	function EventEmitter(conf) {
	  this._events = {};
	  this._newListener = false;
	  this._removeListener = false;
	  this.verboseMemoryLeak = false;
	  configure.call(this, conf);
	}
	EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

	//
	// Attention, function return type now is array, always !
	// It has zero elements if no any matches found and one or more
	// elements (leafs) if there are matches
	//
	function searchListenerTree(handlers, type, tree, i) {
	  if (!tree) {
	    return [];
	  }
	  var listeners = [],
	      leaf,
	      len,
	      branch,
	      xTree,
	      xxTree,
	      isolatedBranch,
	      endReached,
	      typeLength = type.length,
	      currentType = type[i],
	      nextType = type[i + 1];
	  if (i === typeLength && tree._listeners) {
	    //
	    // If at the end of the event(s) list and the tree has listeners
	    // invoke those listeners.
	    //
	    if (typeof tree._listeners === 'function') {
	      handlers && handlers.push(tree._listeners);
	      return [tree];
	    } else {
	      for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
	        handlers && handlers.push(tree._listeners[leaf]);
	      }
	      return [tree];
	    }
	  }

	  if (currentType === '*' || currentType === '**' || tree[currentType]) {
	    //
	    // If the event emitted is '*' at this part
	    // or there is a concrete match at this patch
	    //
	    if (currentType === '*') {
	      for (branch in tree) {
	        if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
	          listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 1));
	        }
	      }
	      return listeners;
	    } else if (currentType === '**') {
	      endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === '*';
	      if (endReached && tree._listeners) {
	        // The next element has a _listeners, add it to the handlers.
	        listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
	      }

	      for (branch in tree) {
	        if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
	          if (branch === '*' || branch === '**') {
	            if (tree[branch]._listeners && !endReached) {
	              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
	            }
	            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
	          } else if (branch === nextType) {
	            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 2));
	          } else {
	            // No match on this one, shift into the tree but not in the type array.
	            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
	          }
	        }
	      }
	      return listeners;
	    }

	    listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i + 1));
	  }

	  xTree = tree['*'];
	  if (xTree) {
	    //
	    // If the listener tree will allow any match for this part,
	    // then recursively explore all branches of the tree
	    //
	    searchListenerTree(handlers, type, xTree, i + 1);
	  }

	  xxTree = tree['**'];
	  if (xxTree) {
	    if (i < typeLength) {
	      if (xxTree._listeners) {
	        // If we have a listener on a '**', it will catch all, so add its handler.
	        searchListenerTree(handlers, type, xxTree, typeLength);
	      }

	      // Build arrays of matching next branches and others.
	      for (branch in xxTree) {
	        if (branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
	          if (branch === nextType) {
	            // We know the next element will match, so jump twice.
	            searchListenerTree(handlers, type, xxTree[branch], i + 2);
	          } else if (branch === currentType) {
	            // Current node matches, move into the tree.
	            searchListenerTree(handlers, type, xxTree[branch], i + 1);
	          } else {
	            isolatedBranch = {};
	            isolatedBranch[branch] = xxTree[branch];
	            searchListenerTree(handlers, type, { '**': isolatedBranch }, i + 1);
	          }
	        }
	      }
	    } else if (xxTree._listeners) {
	      // We have reached the end and still on a '**'
	      searchListenerTree(handlers, type, xxTree, typeLength);
	    } else if (xxTree['*'] && xxTree['*']._listeners) {
	      searchListenerTree(handlers, type, xxTree['*'], typeLength);
	    }
	  }

	  return listeners;
	}

	function growListenerTree(type, listener) {

	  type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

	  //
	  // Looks for two consecutive '**', if so, don't add the event at all.
	  //
	  for (var i = 0, len = type.length; i + 1 < len; i++) {
	    if (type[i] === '**' && type[i + 1] === '**') {
	      return;
	    }
	  }

	  var tree = this.listenerTree;
	  var name = type.shift();

	  while (name !== undefined) {

	    if (!tree[name]) {
	      tree[name] = {};
	    }

	    tree = tree[name];

	    if (type.length === 0) {

	      if (!tree._listeners) {
	        tree._listeners = listener;
	      } else {
	        if (typeof tree._listeners === 'function') {
	          tree._listeners = [tree._listeners];
	        }

	        tree._listeners.push(listener);

	        if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
	          tree._listeners.warned = true;
	          logPossibleMemoryLeak.call(this, tree._listeners.length, name);
	        }
	      }
	      return true;
	    }
	    name = type.shift();
	  }
	  return true;
	}

	// By default EventEmitters will print a warning if more than
	// 10 listeners are added to it. This is a useful default which
	// helps finding memory leaks.
	//
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.

	EventEmitter.prototype.delimiter = '.';

	EventEmitter.prototype.setMaxListeners = function (n) {
	  if (n !== undefined) {
	    this._maxListeners = n;
	    if (!this._conf) {
	      this._conf = {};
	    }
	    this._conf.maxListeners = n;
	  }
	};

	EventEmitter.prototype.event = '';

	EventEmitter.prototype.once = function (event, fn) {
	  return this._once(event, fn, false);
	};

	EventEmitter.prototype.prependOnceListener = function (event, fn) {
	  return this._once(event, fn, true);
	};

	EventEmitter.prototype._once = function (event, fn, prepend) {
	  this._many(event, 1, fn, prepend);
	  return this;
	};

	EventEmitter.prototype.many = function (event, ttl, fn) {
	  return this._many(event, ttl, fn, false);
	};

	EventEmitter.prototype.prependMany = function (event, ttl, fn) {
	  return this._many(event, ttl, fn, true);
	};

	EventEmitter.prototype._many = function (event, ttl, fn, prepend) {
	  var self = this;

	  if (typeof fn !== 'function') {
	    throw new Error('many only accepts instances of Function');
	  }

	  function listener() {
	    if (--ttl === 0) {
	      self.off(event, listener);
	    }
	    return fn.apply(this, arguments);
	  }

	  listener._origin = fn;

	  this._on(event, listener, prepend);

	  return self;
	};

	EventEmitter.prototype.emit = function () {

	  this._events || init.call(this);

	  var type = arguments[0];

	  if (type === 'newListener' && !this._newListener) {
	    if (!this._events.newListener) {
	      return false;
	    }
	  }

	  var al = arguments.length;
	  var args, l, i, j;
	  var handler;

	  if (this._all && this._all.length) {
	    handler = this._all.slice();
	    if (al > 3) {
	      args = new Array(al);
	      for (j = 0; j < al; j++) {
	        args[j] = arguments[j];
	      }
	    }

	    for (i = 0, l = handler.length; i < l; i++) {
	      this.event = type;
	      switch (al) {
	        case 1:
	          handler[i].call(this, type);
	          break;
	        case 2:
	          handler[i].call(this, type, arguments[1]);
	          break;
	        case 3:
	          handler[i].call(this, type, arguments[1], arguments[2]);
	          break;
	        default:
	          handler[i].apply(this, args);
	      }
	    }
	  }

	  if (this.wildcard) {
	    handler = [];
	    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	    searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
	  } else {
	    handler = this._events[type];
	    if (typeof handler === 'function') {
	      this.event = type;
	      switch (al) {
	        case 1:
	          handler.call(this);
	          break;
	        case 2:
	          handler.call(this, arguments[1]);
	          break;
	        case 3:
	          handler.call(this, arguments[1], arguments[2]);
	          break;
	        default:
	          args = new Array(al - 1);
	          for (j = 1; j < al; j++) {
	            args[j - 1] = arguments[j];
	          }
	          handler.apply(this, args);
	      }
	      return true;
	    } else if (handler) {
	      // need to make copy of handlers because list can change in the middle
	      // of emit call
	      handler = handler.slice();
	    }
	  }

	  if (handler && handler.length) {
	    if (al > 3) {
	      args = new Array(al - 1);
	      for (j = 1; j < al; j++) {
	        args[j - 1] = arguments[j];
	      }
	    }
	    for (i = 0, l = handler.length; i < l; i++) {
	      this.event = type;
	      switch (al) {
	        case 1:
	          handler[i].call(this);
	          break;
	        case 2:
	          handler[i].call(this, arguments[1]);
	          break;
	        case 3:
	          handler[i].call(this, arguments[1], arguments[2]);
	          break;
	        default:
	          handler[i].apply(this, args);
	      }
	    }
	    return true;
	  } else if (!this._all && type === 'error') {
	    if (arguments[1] instanceof Error) {
	      throw arguments[1]; // Unhandled 'error' event
	    } else {
	      throw new Error('Uncaught, unspecified \'error\' event.');
	    }
	  }

	  return !!this._all;
	};

	EventEmitter.prototype.emitAsync = function () {

	  this._events || init.call(this);

	  var type = arguments[0];

	  if (type === 'newListener' && !this._newListener) {
	    if (!this._events.newListener) {
	      return Promise.resolve([false]);
	    }
	  }

	  var promises = [];

	  var al = arguments.length;
	  var args, l, i, j;
	  var handler;

	  if (this._all) {
	    if (al > 3) {
	      args = new Array(al);
	      for (j = 1; j < al; j++) {
	        args[j] = arguments[j];
	      }
	    }
	    for (i = 0, l = this._all.length; i < l; i++) {
	      this.event = type;
	      switch (al) {
	        case 1:
	          promises.push(this._all[i].call(this, type));
	          break;
	        case 2:
	          promises.push(this._all[i].call(this, type, arguments[1]));
	          break;
	        case 3:
	          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
	          break;
	        default:
	          promises.push(this._all[i].apply(this, args));
	      }
	    }
	  }

	  if (this.wildcard) {
	    handler = [];
	    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	    searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
	  } else {
	    handler = this._events[type];
	  }

	  if (typeof handler === 'function') {
	    this.event = type;
	    switch (al) {
	      case 1:
	        promises.push(handler.call(this));
	        break;
	      case 2:
	        promises.push(handler.call(this, arguments[1]));
	        break;
	      case 3:
	        promises.push(handler.call(this, arguments[1], arguments[2]));
	        break;
	      default:
	        args = new Array(al - 1);
	        for (j = 1; j < al; j++) {
	          args[j - 1] = arguments[j];
	        }
	        promises.push(handler.apply(this, args));
	    }
	  } else if (handler && handler.length) {
	    handler = handler.slice();
	    if (al > 3) {
	      args = new Array(al - 1);
	      for (j = 1; j < al; j++) {
	        args[j - 1] = arguments[j];
	      }
	    }
	    for (i = 0, l = handler.length; i < l; i++) {
	      this.event = type;
	      switch (al) {
	        case 1:
	          promises.push(handler[i].call(this));
	          break;
	        case 2:
	          promises.push(handler[i].call(this, arguments[1]));
	          break;
	        case 3:
	          promises.push(handler[i].call(this, arguments[1], arguments[2]));
	          break;
	        default:
	          promises.push(handler[i].apply(this, args));
	      }
	    }
	  } else if (!this._all && type === 'error') {
	    if (arguments[1] instanceof Error) {
	      return Promise.reject(arguments[1]); // Unhandled 'error' event
	    } else {
	      return Promise.reject('Uncaught, unspecified \'error\' event.');
	    }
	  }

	  return Promise.all(promises);
	};

	EventEmitter.prototype.on = function (type, listener) {
	  return this._on(type, listener, false);
	};

	EventEmitter.prototype.prependListener = function (type, listener) {
	  return this._on(type, listener, true);
	};

	EventEmitter.prototype.onAny = function (fn) {
	  return this._onAny(fn, false);
	};

	EventEmitter.prototype.prependAny = function (fn) {
	  return this._onAny(fn, true);
	};

	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	EventEmitter.prototype._onAny = function (fn, prepend) {
	  if (typeof fn !== 'function') {
	    throw new Error('onAny only accepts instances of Function');
	  }

	  if (!this._all) {
	    this._all = [];
	  }

	  // Add the function to the event listener collection.
	  if (prepend) {
	    this._all.unshift(fn);
	  } else {
	    this._all.push(fn);
	  }

	  return this;
	};

	EventEmitter.prototype._on = function (type, listener, prepend) {
	  if (typeof type === 'function') {
	    this._onAny(type, listener);
	    return this;
	  }

	  if (typeof listener !== 'function') {
	    throw new Error('on only accepts instances of Function');
	  }
	  this._events || init.call(this);

	  // To avoid recursion in the case that type == "newListeners"! Before
	  // adding it to the listeners, first emit "newListeners".
	  if (this._newListener) {
	    this.emit('newListener', type, listener);
	  }

	  if (this.wildcard) {
	    growListenerTree.call(this, type, listener);
	    return this;
	  }

	  if (!this._events[type]) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  } else {
	    if (typeof this._events[type] === 'function') {
	      // Change to array.
	      this._events[type] = [this._events[type]];
	    }

	    // If we've already got an array, just add
	    if (prepend) {
	      this._events[type].unshift(listener);
	    } else {
	      this._events[type].push(listener);
	    }

	    // Check for listener leak
	    if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
	      this._events[type].warned = true;
	      logPossibleMemoryLeak.call(this, this._events[type].length, type);
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.off = function (type, listener) {
	  if (typeof listener !== 'function') {
	    throw new Error('removeListener only takes instances of Function');
	  }

	  var handlers,
	      leafs = [];

	  if (this.wildcard) {
	    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	    leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
	  } else {
	    // does not use listeners(), so no side effect of creating _events[type]
	    if (!this._events[type]) {
	      return this;
	    }
	    handlers = this._events[type];
	    leafs.push({ _listeners: handlers });
	  }

	  for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
	    var leaf = leafs[iLeaf];
	    handlers = leaf._listeners;
	    if (isArray$2(handlers)) {

	      var position = -1;

	      for (var i = 0, length = handlers.length; i < length; i++) {
	        if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
	          position = i;
	          break;
	        }
	      }

	      if (position < 0) {
	        continue;
	      }

	      if (this.wildcard) {
	        leaf._listeners.splice(position, 1);
	      } else {
	        this._events[type].splice(position, 1);
	      }

	      if (handlers.length === 0) {
	        if (this.wildcard) {
	          delete leaf._listeners;
	        } else {
	          delete this._events[type];
	        }
	      }
	      if (this._removeListener) {
	        this.emit('removeListener', type, listener);
	      }

	      return this;
	    } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
	      if (this.wildcard) {
	        delete leaf._listeners;
	      } else {
	        delete this._events[type];
	      }
	      if (this._removeListener) {
	        this.emit('removeListener', type, listener);
	      }
	    }
	  }

	  function recursivelyGarbageCollect(root) {
	    if (root === undefined) {
	      return;
	    }
	    var keys = Object.keys(root);
	    for (var i in keys) {
	      var key = keys[i];
	      var obj = root[key];
	      if (obj instanceof Function || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
	        continue;
	      }
	      if (Object.keys(obj).length > 0) {
	        recursivelyGarbageCollect(root[key]);
	      }
	      if (Object.keys(obj).length === 0) {
	        delete root[key];
	      }
	    }
	  }
	  recursivelyGarbageCollect(this.listenerTree);

	  return this;
	};

	EventEmitter.prototype.offAny = function (fn) {
	  var i = 0,
	      l = 0,
	      fns;
	  if (fn && this._all && this._all.length > 0) {
	    fns = this._all;
	    for (i = 0, l = fns.length; i < l; i++) {
	      if (fn === fns[i]) {
	        fns.splice(i, 1);
	        if (this._removeListener) {
	          this.emit('removeListenerAny', fn);
	        }
	        return this;
	      }
	    }
	  } else {
	    fns = this._all;
	    if (this._removeListener) {
	      for (i = 0, l = fns.length; i < l; i++) {
	        this.emit('removeListenerAny', fns[i]);
	      }
	    }
	    this._all = [];
	  }
	  return this;
	};

	EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

	EventEmitter.prototype.removeAllListeners = function (type) {
	  if (type === undefined) {
	    !this._events || init.call(this);
	    return this;
	  }

	  if (this.wildcard) {
	    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	    var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

	    for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
	      var leaf = leafs[iLeaf];
	      leaf._listeners = null;
	    }
	  } else if (this._events) {
	    this._events[type] = null;
	  }
	  return this;
	};

	EventEmitter.prototype.listeners = function (type) {
	  if (this.wildcard) {
	    var handlers = [];
	    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	    searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
	    return handlers;
	  }

	  this._events || init.call(this);

	  if (!this._events[type]) {
	    this._events[type] = [];
	  }
	  if (!isArray$2(this._events[type])) {
	    this._events[type] = [this._events[type]];
	  }
	  return this._events[type];
	};

	EventEmitter.prototype.eventNames = function () {
	  return Object.keys(this._events);
	};

	EventEmitter.prototype.listenerCount = function (type) {
	  return this.listeners(type).length;
	};

	EventEmitter.prototype.listenersAny = function () {

	  if (this._all) {
	    return this._all;
	  } else {
	    return [];
	  }
	};

	function reportNetworkAPI(api, url, result, duration, errMsg) {
	  Reporter.customReport({
	    tag: 'mp_net_request_result',
	    data: {
	      request_type: api,
	      // 不需要上报 query + hash
	      url: url.split('?')[0],
	      result: result,
	      duration: duration,
	      error_msg: result === 'fail' ? errMsg : ''
	    }
	  });
	}

	function createRequestTask() {
	  var that = this;
	  var param = requestParamStore.get(this);
	  var errMsg;

	  requestStatusStore.set(this, 'sending');
	  requestCreateTimeStore.set(this, Date.now());

	  invokeMethod('createRequestTask', {
	    data: param.data,
	    url: param.url,
	    header: param.header,
	    method: param.method,
	    responseType: param.responseType,
	    success: function success(res) {
	      requestTaskIdStore.set(that, res.requestTaskId);
	      concurrentRequestCount += 1;
	      requestInstances[res.requestTaskId] = that;
	    },
	    fail: function fail(res) {
	      errMsg = res.errMsg;
	      var duration = Date.now() - requestCreateTimeStore.get(that);
	      reportNetworkAPI('request', param.url, 'fail', duration, errMsg);
	    },
	    complete: function complete() {
	      requestStatusStore.set(that, 'done');
	    }
	  });

	  if (errMsg) {
	    setTimeout(function () {
	      var res = {
	        errMsg: errMsg.replace('createRequestTask', 'request')
	      };
	      typeof param.fail === 'function' && param.fail(res);
	      typeof param.complete === 'function' && param.complete(res);
	    }, 0);
	  } else {
	    emitter.on(requestTaskIdStore.get(this) + 'success', function (res) {
	      res.errMsg = 'request:ok';
	      if (typeof res.data == 'string' && res.data.charCodeAt(0) === 65279) {
	        res.data = res.data.substr(1);
	      }
	      if (param.dataType === 'json' && typeof res.data === 'string') {
	        try {
	          res.data = JSON.parse(res.data);
	        } catch (e) {}
	      }
	      res.statusCode = parseInt(res.statusCode);
	      if (_typeof(res.header) === 'object') {
	        res.header = Object.keys(res.header).reduce(function (obj, key) {
	          Array.isArray(res.header[key]) ? obj[key] = res.header[key].join(',') : 'string' == typeof res.header[key] && (obj[key] = res.header[key]);
	          return obj;
	        }, {});
	      }
	      'function' == typeof param.success && param.success(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	    emitter.on(requestTaskIdStore.get(this) + 'fail', function (res) {
	      res.errMsg = 'request:fail ' + res.errMsg;
	      'function' == typeof param.fail && param.fail(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	  }
	}

	var MAX_REQUEST_CONCURRENT = 5;
	var requestTaskIdCounter = 0;
	var waitingIdStore = new WeakMap();
	var requestTaskIdStore = new WeakMap();
	var requestStatusStore = new WeakMap();
	var requestParamStore = new WeakMap();
	var requestCreateTimeStore = new WeakMap();
	var concurrentRequestCount = 0;
	var waitingQueue = [];
	var requestInstances = {};
	var emitter = new EventEmitter();

	// 监听客户端派发的状态变化事件
	onMethod('onRequestTaskStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var state = res.state,
	      taskId = res.requestTaskId;
	  delete res.state;
	  delete res.requestTaskId;
	  state !== 'success' && state !== 'fail' || (concurrentRequestCount -= 1, waitingQueue.length > 0 && createRequestTask.call(waitingQueue.shift().item)), emitter.emit('' + taskId + state, res);

	  if (state === 'success' || state === 'fail') {
	    var task = requestInstances[taskId];
	    if (task) {
	      try {
	        var url = requestParamStore.get(task).url;
	        var duration = Date.now() - requestCreateTimeStore.get(task);
	        reportNetworkAPI('request', url, state, duration, res.errMsg);
	      } catch (e) {}

	      delete requestInstances[taskId];
	      emitter.removeAllListeners(taskId + 'success');
	      emitter.removeAllListeners(taskId + 'fail');
	    }
	  }
	});

	/**
	 * @class RequestTask
	 */

	var Request = function () {
	  function Request(param) {
	    classCallCheck(this, Request);

	    var id = requestTaskIdCounter++;
	    waitingIdStore.set(this, id);
	    requestStatusStore.set(this, 'waiting');
	    ['success', 'fail', 'complete'].forEach(function (status) {
	      if (typeof param[status] === 'function') {
	        param[status] = surroundByTryCatchFactory(param[status], 'at api request ' + status + ' callback function');
	      }
	    });
	    requestParamStore.set(this, param);

	    if (concurrentRequestCount >= MAX_REQUEST_CONCURRENT) {
	      return void waitingQueue.push({
	        id: id,
	        item: this
	      });
	    }

	    createRequestTask.call(this);
	  }

	  /**
	     * 结束正在执行的请求，如果请求在等待队列，则直接将其移除
	     * @memberof RequestTask
	     */


	  Request.prototype.abort = function abort() {
	    var that = this;
	    /* eslint-disable valid-typeof */
	    if (typeof requestStatusStore.get(this) == 'waiting') {
	      var idx = waitingQueue.findIndex(function (tmp) {
	        return tmp.id === waitingIdStore.get(that);
	      });
	      if (idx > -1) {
	        waitingQueue.splice(idx, 1);
	        concurrentRequestCount -= 1;
	      }
	      requestStatusStore.set(this, 'done');
	    } else {
	      invokeMethod('operateRequestTask', {
	        requestTaskId: requestTaskIdStore.get(that),
	        operationType: 'abort'
	      });
	    }
	  };

	  return Request;
	}();

	function factory() {

	  return function () {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (beforeInvoke('request', param, { url: '' })) {
	      if (!validateUrl(param.url)) {
	        beforeInvokeFail('request', param, 'invalid url "' + param.url + '"');
	        return;
	      }

	      if ('function' === param.data) {
	        beforeInvokeFail('request', param, 'data should not be Function');
	        return;
	      }

	      var headerDataType = getDataType(param.header);
	      param.header = param.header || {};
	      param.header = convertObjectValueToString(param.header);
	      if (headerDataType !== 'Undefined' && headerDataType !== 'Object') {
	        // console.warn("request: header must be an object");
	        param.header = {};
	      }
	      param.header = Object.keys(param.header).reduce(function (obj, key) {
	        key.toLowerCase() === 'content-type' ? obj[key.toLowerCase()] = param.header[key] : obj[key] = param.header[key];
	        return obj;
	      }, {});
	      var header = param.header || {};

	      var method = 'GET';
	      param.method && (param.method = param.method.toUpperCase());
	      typeof param.method === 'string' && (method = param.method.toUpperCase());

	      var responseType = 'text';
	      param.responseType && (responseType = param.responseType.toLowerCase());

	      var data;
	      param.dataType = param.dataType || 'json';
	      header['content-type'] = header['content-type'] || 'application/json';

	      if (param.data === undefined) {
	        data = '';
	      } else if (typeof param.data === 'string' || param.data instanceof ArrayBuffer) {
	        data = param.data;
	      } else if (header['content-type'].indexOf('application/x-www-form-urlencoded') > -1) {
	        data = urlEncodeFormData(param.data, true);
	      } else if (header['content-type'].indexOf('application/json') > -1) {
	        data = JSON.stringify(param.data);
	      } else if (_typeof(param.data) === 'object') {
	        data = JSON.stringify(param.data);
	      } else {
	        data = param.data.toString();
	      }

	      method == 'GET' && (param.url = addQueryStringToUrl(param.url, param.data));

	      try {
	        return new Request(Object.assign({}, param, {
	          header: header,
	          method: method,
	          responseType: responseType,
	          data: data
	        }));
	      } catch (error) {
	        beforeInvokeFail('request', error, error && error.message);
	      }
	    }
	  };
	}

	/**
	 * @function request
	 * @description
	 *   发起网络请求
	 * @param {object} param
	 * @param {string} param.url 开发者服务器接口地址
	 * @param {object|string|arraybuffer} [param.data] 请求的参数
	 *   注意：最终发给服务器的 data 是字符串
	 * @param {object} param.header 设置请求的 header，header 中不能设置 Referer
	 *   注意：根据 dataType，content-type 字段的值默认为 application/json。
	 * @param {string} [param.method = GET] 请求方法，暂时只支持 POST 和 GET
	 * @param {string} [param.dataType = json] 请求数据类型？
	 * @param {string} [param.responseType = text] 返回数据类型
	 * @param {requestSuccessCallback} param.success
	 * @param {function} param.fail
	 * @param {function} param.complete
	 * @returns {RequestTask}
	 * @example
	var requestTask = tt.request({
	  url: 'http://developer.bytedance.com/getlist',
	  data: {
	    a: '',
	    b: ''
	  },
	  header: {
	    'private-header': 'private/value'
	  },
	  success: function(res) {
	    logger.log(res.data)
	  }
	});
	requestTask.abort(); // 取消请求任务
	 *
	 */
	var request = factory();

	var uploadTaskIdStore = new WeakMap(),
	    uploadTaskParamStore = new WeakMap(),
	    uploadTaskCreateTimeStore = new WeakMap(),
	    uploadInstances = {},
	    emitter$1 = new EventEmitter();
	onMethod('onUploadTaskStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var state = res.state,
	      taskId = res.uploadTaskId;
	  delete res.state;
	  delete res.uploadTaskId;

	  emitter$1.emit('' + taskId + state, res);

	  if ('success' === state || 'fail' === state) {
	    var task = uploadInstances[taskId];
	    if (task) {
	      try {
	        var url = uploadTaskParamStore.get(task).url;
	        var duration = Date.now() - uploadTaskCreateTimeStore.get(task);
	        reportNetworkAPI('uploadFile', url, state, duration, res.errMsg);
	      } catch (e) {}

	      delete uploadInstances[taskId];
	      emitter$1.removeAllListeners(taskId + 'success');
	      emitter$1.removeAllListeners(taskId + 'fail');
	      emitter$1.removeAllListeners(taskId + 'progressUpdate');
	    }
	  }
	});

	/**
	 * @class UploadFileTask
	 */

	var Upload = function () {
	  function Upload(param) {
	    classCallCheck(this, Upload);

	    var that = this;
	    var errMsg;

	    ['success', 'fail', 'complete'].forEach(function (func) {
	      'function' == typeof param[func] && (param[func] = surroundByTryCatchFactory(param[func], 'at api uploadFile ' + func + ' callback function'));
	    });

	    uploadTaskParamStore.set(this, param);
	    uploadTaskCreateTimeStore.set(this, Date.now());

	    invokeMethod('createUploadTask', {
	      url: param.url,
	      header: param.header,
	      filePath: param.filePath,
	      name: param.name,
	      formData: param.formData,
	      success: function success(res) {
	        uploadTaskIdStore.set(that, res.uploadTaskId);
	        uploadInstances[res.uploadTaskId] = that;
	      },
	      fail: function fail(res) {
	        errMsg = res.errMsg;
	        var duration = Date.now() - uploadTaskCreateTimeStore.get(that);
	        reportNetworkAPI('uploadFile', param.url, 'fail', duration, errMsg);
	      },
	      complete: function complete() {}
	    });

	    if (errMsg) {
	      throw new Error(errMsg);
	    }

	    emitter$1.on(uploadTaskIdStore.get(this) + 'success', function (res) {
	      res.errMsg = 'uploadFile:ok';
	      res.statusCode = parseInt(res.statusCode);
	      -1 === [200, 304].indexOf(res.statusCode) && delete res.tempPath;
	      'function' == typeof param.success && param.success(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	    emitter$1.on(uploadTaskIdStore.get(this) + 'fail', function (res) {
	      res.errMsg = 'uploadFile:fail ' + res.errMsg;
	      'function' == typeof param.fail && param.fail(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	  }

	  /**
	     * 中断上传任务
	     * @memberof UploadFileTask
	     */


	  Upload.prototype.abort = function abort() {
	    invokeMethod('operateUploadTask', {
	      uploadTaskId: uploadTaskIdStore.get(this),
	      operationType: 'abort'
	    });
	  };

	  /**
	     * 监听上传进度变化
	     * @memberof UploadFileTask
	     * @param {uploadFileOnProgressUpdateCallback} callback 回调方法
	     */


	  Upload.prototype.onProgressUpdate = function onProgressUpdate(callback) {
	    emitter$1.on(uploadTaskIdStore.get(this) + 'progressUpdate', function (t) {
	      'function' == typeof callback && surroundByTryCatchFactory(callback, 'at UploadTask.onProgressUpdate callback function')(t);
	    });
	  };

	  return Upload;
	}();

	/**
	 * @function uploadFile
	 * @description 将本地资源上传到开发者服务器
	 * @param {object} param
	 * @param {string} param.url 开发者服务器 url
	 * @param {string} param.filePath 要上传文件资源的路径
	 * @param {string} param.name 文件对应的 key , 开发者在服务器端通过这个 key 可以获取到文件二进制内容
	 * @param {object} [param.header] HTTP 请求 Header, header 中不能设置 Referer
	 * @param {object} [param.formData] HTTP 请求中其他额外的 form data
	 * @param {uploadFileSuccessCallback} [param.success] 上传成功的回调方法
	 * @example
	tt.chooseImage({
	  success: function(res) {
	    var tempFilePaths = res.tempFilePaths
	    tt.uploadFile({
	      url: 'https://a.com/upload/', //仅为示例，非真实的接口地址
	      filePath: tempFilePaths[0],
	      name: 'file',
	      formData:{
	        'user': 'test'
	      },
	      success: function(res){
	        var data = res.data
	        //do something
	      }
	    })
	  }
	});
	 * @example
	const uploadTask = tt.uploadFile({
	    url: 'http://a.com/upload', //仅为示例，非真实的接口地址
	    filePath: tempFilePaths[0],
	    name: 'file',
	    formData:{
	        'user': 'test'
	    },
	    success: function(res){
	        var data = res.data
	        //do something
	    }
	})
	uploadTask.onProgressUpdate((res) => {
	    logger.log('上传进度', res.progress)
	    logger.log('已经上传的数据长度', res.totalBytesSent)
	    logger.log('预期需要上传的数据总长度', res.totalBytesExpectedToSend)
	})
	uploadTask.abort() // 取消上传任务
	 * @returns {UploadFileTask}
	 */


	function uploadFile() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('uploadFile', param, {
	    url: '',
	    filePath: '',
	    name: ''
	  })) {
	    if (_typeof(param.header) !== 'object' && param.header !== undefined) {
	      logger.warn('uploadFile: header must be an object');
	      delete param.header;
	    }

	    if (_typeof(param.formData) !== 'object' && param.formData !== undefined) {
	      logger.warn('uploadFile: formData must be an object');
	      delete param.formData;
	    }

	    var headerString = param.header ? convertObjectValueToString(param.header) : {};
	    var formDataString = param.formData ? convertObjectValueToString(param.formData) : {};

	    try {
	      return new Upload(Object.assign({}, param, {
	        header: headerString,
	        formData: formDataString
	      }));
	    } catch (ex) {
	      beforeInvokeFail('uploadFile', param, ex.message);
	    }
	  }
	}

	function createDownloadTask() {
	  var param = downloadTaskParamStore.get(this);

	  downloadTaskStateStore.set(this, 'sending');
	  downloadTaskCreateTimeStore.set(this, Date.now());
	  var that = this;
	  var errMsg;
	  invokeMethod('createDownloadTask', {
	    url: param.url,
	    header: param.header,
	    filePath: param.filePath,
	    success: function success(res) {

	      downloadTaskIdStore.set(that, res.downloadTaskId);
	      concurrentDownload += 1;
	      downloadInstances[res.downloadTaskId] = that;
	    },
	    fail: function fail(res) {
	      errMsg = res.errMsg;
	      var duration = Date.now() - downloadTaskCreateTimeStore.get(that);
	      reportNetworkAPI('downloadFile', param.url, 'fail', duration, errMsg);
	    },
	    complete: function complete() {
	      downloadTaskStateStore.set(this, 'done');
	    }
	  });
	  if (errMsg) {
	    setTimeout(function () {
	      var res = {
	        errMsg: errMsg.replace('createDownloadTask', 'downloadFile')
	      };
	      'function' == typeof param.fail && param.fail(res);
	      'function' == typeof param.complete && param.complete(res);
	    }, 0);
	  } else {

	    emitter$2.on(downloadTaskIdStore.get(this) + 'success', function (res) {

	      res.errMsg = 'downloadFile:ok';
	      res.statusCode = parseInt(res.statusCode);
	      -1 === [200, 304].indexOf(res.statusCode) && delete res.tempPath;
	      delete res.timeInterval;

	      'function' == typeof param.success && param.success(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	    emitter$2.on(downloadTaskIdStore.get(this) + 'fail', function (res) {
	      res.errMsg = 'downloadFile:fail ' + res.errMsg;
	      'function' == typeof param.fail && param.fail(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	  }
	}

	var maxDownloadConcurrent = 5;

	var idCounter = 0,
	    instanceIdStore = new WeakMap(),
	    downloadTaskIdStore = new WeakMap(),
	    downloadTaskStateStore = new WeakMap(),
	    downloadTaskParamStore = new WeakMap(),
	    downloadTaskCreateTimeStore = new WeakMap(),
	    concurrentDownload = 0,
	    waitingQueue$1 = [],
	    downloadInstances = {},
	    emitter$2 = new EventEmitter();

	onMethod('onDownloadTaskStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (typeof res === 'string') {
	    res = JSON.parse(res);
	  }
	  var state = res.state,
	      downloadTaskId = res.downloadTaskId;
	  delete res.state;
	  delete res.downloadTaskId;

	  emitter$2.emit('' + downloadTaskId + state, res);

	  if (state === 'success' || state === 'fail') {
	    concurrentDownload -= 1;
	    waitingQueue$1.length > 0 && createDownloadTask.call(waitingQueue$1.shift().item);

	    var task = downloadInstances[downloadTaskId];

	    if (task) {
	      try {
	        var url = downloadTaskParamStore.get(task).url;
	        var duration = Date.now() - downloadTaskCreateTimeStore.get(task);
	        reportNetworkAPI('downloadFile', url, state, duration, res.errMsg);
	      } catch (e) {}

	      delete downloadInstances[downloadTaskId];

	      emitter$2.removeAllListeners(downloadTaskId + 'success');
	      emitter$2.removeAllListeners(downloadTaskId + 'fail');
	      emitter$2.removeAllListeners(downloadTaskId + 'progressUpdate');
	    }
	  }
	});

	/**
	 * @class downloadFileTask
	 */

	var Download = function () {
	  function Download(param) {
	    classCallCheck(this, Download);

	    var id = idCounter++;
	    instanceIdStore.set(this, id);

	    downloadTaskStateStore.set(this, 'waiting');

	    ['success', 'fail', 'complete'].forEach(function (func) {
	      'function' == typeof param[func] && (param[func] = surroundByTryCatchFactory(param[func], 'at api downloadFile ' + func + ' callback function'));
	    });

	    downloadTaskParamStore.set(this, param);

	    if (concurrentDownload >= maxDownloadConcurrent) {
	      waitingQueue$1.push({
	        id: id,
	        item: this
	      });
	      return;
	    }

	    createDownloadTask.call(this);
	  }

	  /**
	   * 中断下载任务
	   * @memberOf downloadFileTask
	   */


	  Download.prototype.abort = function abort() {
	    invokeMethod('operateDownloadTask', {
	      downloadTaskId: downloadTaskIdStore.get(this),
	      operationType: 'abort'
	    });
	  };

	  /**
	   * 监听下载进度变化
	   * @memberof downloadFileTask
	   * @param {downloadFileOnProgressUpdateCallback} callback 回调方法
	   */


	  Download.prototype.onProgressUpdate = function onProgressUpdate(cb) {
	    emitter$2.on(downloadTaskIdStore.get(this) + 'progressUpdate', function (res) {
	      'function' == typeof cb && surroundByTryCatchFactory(cb, 'at DownloadTask.onProgressUpdate callback function')(res);
	    });
	  };

	  return Download;
	}();

	/**
	 * @function downloadFile
	 * @description 下载文件资源到本地，返回文件的本地临时路径。
	 * @param {*} param
	 * @param {string} param.url 下载资源的 url
	 * @param {object} [param.header] HTTP 请求 Header，header 中不能设置 Referer
	 * @param {downloadFileSuccessCallback} [param.success] 下载成功回调函数
	 * @returns {downloadFileTask}
	 * @example
	 const downloadTask = tt.downloadFile({
	    url: 'http://a.com/sample',
	    success: function(res) {
	        logger.log(res.tempFilePath);
	    }
	})
	 downloadTask.onProgressUpdate((res) => {
	    logger.log('下载进度', res.progress)
	    logger.log('已经下载的数据长度', res.totalBytesWritten)
	    logger.log('预期需要下载的数据总长度', res.totalBytesExpectedToWrite)
	})
	 downloadTask.abort() // 取消下载任务
	 */


	function downloadFile() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('downloadFile', param, {
	    url: ''
	  })) {
	    try {
	      return new Download(param);
	    } catch (ex) {
	      beforeInvokeFail('downloadFile', param, ex.message);
	    }
	  }
	}

	/**
	 * @function showModal
	 * @description 显示模态弹窗
	 * @param {object} param
	 * @param {string} param.title 提示的标题
	 * @param {string} param.content 提示的内容
	 * @param {string} [param.confirmText=确定] 确定按钮的文字，最多 4 个字符
	 * @param {string} [param.confirmColor=#3CC51F] 确定按钮的文字颜色
	 * @param {boolean} [param.showCancel=true] 是否显示取消按钮
	 * @param {string} [param.cancelText=取消] 取消按钮的文字，最多 4 个字符
	 * @param {string} [param.cancelColor=#000000] 取消按钮的文字颜色
	 * @param {showModalSuccessCallback} [param.success] 执行成功的回调方法
	 * @example
	tt.showModal({
	  title: '提示',
	  content: '这是一个模态弹窗',
	  success: function(res) {
	    if (res.confirm) {
	      logger.log('用户点击确定')
	    } else if (res.cancel) {
	      logger.log('用户点击取消')
	    }
	  }
	})
	 */
	function showModal() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var defaultParam = {
	    title: '',
	    content: '',
	    confirmText: '确定',
	    cancelText: '取消',
	    showCancel: true,
	    confirmColor: '#3CC51F',
	    cancelColor: '#000000'
	  };

	  var paramDataType = {
	    title: 'String',
	    content: 'String',
	    confirmText: 'String',
	    cancelText: 'String',
	    confirmColor: 'String',
	    cancelColor: 'String'
	  };

	  // 计算str字节长度
	  var getByteLength = function getByteLength(str) {
	    return str.replace(/[^\u0000-\u00ff]/g, 'aa').length;
	  };

	  param = Object.assign({}, defaultParam, param);

	  if (beforeInvoke('showModal', param, paramDataType)) {
	    if (getByteLength(param.confirmText) > 8) {
	      beforeInvokeFail('showModal', param, 'confirmText length should not larger than 4 Chinese characters');
	    } else if (getByteLength(param.cancelText) > 8) {
	      beforeInvokeFail('showModal', param, 'cancelText length should not larger than 4 Chinese characters');
	    } else {
	      invokeMethod('showModal', param);
	    }
	  }
	}

	/**
	 * @function showToast
	 * @description 显示消息提示
	 * @param {object} param
	 * @param {string} param.title 提示的内容
	 * @param {number} [param.duration=1500] 提示的延迟时间，单位毫秒
	 * @param {string} [param.icon=success] 图标类型，有效值有 success/loading/none。当显示图标时，提示内容最多展示 7 个汉字，无图标时，提示内容可显示 14 个汉字。
	 * @param {string} [param.image] 自定义图标的本地路径，image 的优先级高于 icon
	 * @param {boolean} [param.mask=false] 是否显示透明蒙层，防止触摸穿透
	 * @example
	tt.showToast({
	  title: '举报成功',
	  icon: 'success',
	  duration: 2000
	});
	 */
	function showToast() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var defaultParam = {
	    duration: 1500,
	    title: '',
	    icon: 'success'
	  };

	  var paramDataType = {
	    duration: 1,
	    title: 'String',
	    icon: 'String'
	  };

	  param = Object.assign({}, defaultParam, param);

	  if (['success', 'loading', 'none'].indexOf(param.icon) === -1) {
	    param.icon = 'success';
	  } else if (param.icon === 'none') {
	    param.icon = '';
	  }

	  if (beforeInvoke('showToast', param, paramDataType)) {
	    invokeMethod('showToast', param);
	  }
	}

	/**
	 * @function hideToast
	 * @description 隐藏消息提示框
	 */
	function hideToast() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('hideToast', param);
	}

	/**
	 * @function showLoading
	 * @description 显示 loading 提示框, 需主动调用 hideLoading 才能关闭提示框
	 * @param {object} param
	 * @param {string} param.title 提示的内容
	 */
	function showLoading() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var ONE_DAY_MS = 24 * 60 * 60 * 1000;
	  var coverParam = {
	    icon: 'loading',
	    duration: ONE_DAY_MS
	  };

	  var paramDataType = {
	    title: 'String'
	  };

	  param = Object.assign(param, coverParam);

	  // showLoading的本质是 showToast
	  if (beforeInvoke('showLoading', param, paramDataType)) {
	    invokeMethod('showToast', param, {
	      beforeAll: function beforeAll(res) {
	        res.errMsg = res.errMsg.replace('showToast', 'showLoading');
	      }
	    });
	  }
	}

	/**
	 * @function hideLoading
	 * @description 隐藏 loading 提示框
	 */
	function hideLoading(param) {
	  invokeMethod('hideToast', param, {
	    beforeAll: function beforeAll(res) {
	      res.errMsg = res.errMsg.replace('hideToast', 'hideLoading');
	    }
	  });
	}

	/**
	 * @function showActionSheet
	 * @description 显示操作菜单
	 * @param {object} param
	 * @param {string[]} param.itemList 按钮的文字数组，数组长度最大为6个
	 * @param {string} [param.itemColor=#000000] 按钮的文字颜色
	 * @param {showActionSheetSuccessCallback} [param.success] 接口调用成功的回调函数
	 * @example
	tt.showActionSheet({
	  itemList: ['微信', '微博', '陌陌'],
	  success: function(res) {
	    logger.log(res.tapIndex)
	  }
	});
	 */
	function showActionSheet() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var paramDataType = {
	    itemList: ['String']
	  };

	  if (beforeInvoke('showActionSheet', param, paramDataType)) {
	    if (param.itemList.length < 1) {
	      beforeInvokeFail('showActionSheet', param, 'param.itemList should has at least 1 item');
	    }
	    if (param.itemList.length > 6) {
	      beforeInvokeFail('showActionSheet', param, 'param.itemList should has at most 6 items');
	    } else {
	      invokeMethod('showActionSheet', param);
	    }
	  }
	}

	/**
	 * showModal success callback
	 * @callback showModalSuccessCallback
	 * @param {object} response
	 * @param {boolean} response.confirm 为 true 时，表示用户点击了确定按钮
	 * @param {boolean} response.cancel 为 true 时，表示用户点击了取消（用于 Android 系统区分点击蒙层关闭还是点击取消按钮关闭）
	 */
	/**
	 * showActionSheet success callback
	 * @callback showActionSheetSuccessCallback
	 * @param {object} response
	 * @param {number} response.tapIndex 用户点击的按钮，从上到下的顺序，从0开始
	 */

	var _lifecycleState = {
	  path: '',
	  query: {},
	  scene: 0,
	  subScene: 0,
	  webviewId: -1,
	  __ground: 'foreground'
	};
	var LifecycleState;

	// TODO 其实应该是 内部开发调试时 打开log
	{
	  LifecycleState = new Proxy(_lifecycleState, {
	    set: function set(trapTarget, key, value, receiver) {
	      // logger.log('[发生改变 lifecycle-state]', `key:${key}`, `value:${value}`, trapTarget);
	      return Reflect.set(trapTarget, key, value, receiver);
	    }
	  });
	}

	var LifecycleState$1 = LifecycleState;

	/**
	 * @function chooseImage
	 * @description 从本地相册选择图片或使用相机拍照
	 *
	 * @param {object} param
	 * @param {number} [param.count=9] 最多可以选择的图片张数
	 * @param {string[]} [param.sizeType=['original','compressed']] original 原图，compressed 压缩图
	 * @param {string[]} [param.sourceType=['album', 'camera']] album 从相册选图，camera 使用相机
	 * @param {chooseImageSuccessCallback} [param.success] 成功则返回图片的本地文件路径列表 tempFilePaths
	 * @example
	tt.chooseImage({
	  count: 1, // 默认9
	  sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有
	  sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有
	  success: function (res) {
	    // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片
	    var tempFilePaths = res.tempFilePaths
	  }
	})
	 */
	function chooseImage() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('chooseImage', assign$1({
	    count: 9,
	    sizeType: ['original', 'compressed'],
	    sourceType: ['album', 'camera']
	  }, param), {
	    beforeSuccess: function beforeSuccess(res) {
	      if (res.tempFileSizes) {
	        res.tempFiles = res.tempFilePaths.map(function (path, idx) {
	          return {
	            path: path,
	            size: res.tempFileSizes[idx]
	          };
	        });
	      }
	      delete res.tempFileSizes;
	    }
	  });
	}

	/**
	 * chooseImage success callback
	 * @callback chooseImageSuccessCallback
	 * @param {object} response
	 * @param {string[]} response.tempFilePaths 图片的本地文件路径列表
	 * @param {object[]} response.tempFiles 图片的本地文件列表，每一项是一个 File 对象
	 * @param {string} response.tempFiles[].path 本地文件路径
	 * @param {number} response.tempFiles[].size 本地文件大小，单位：B
	 */

	/**
	 * @function previewImage
	 * @description 预览图片
	 * @param {object} param
	 * @param {string[]} param.urls 需要预览的图片链接列表
	 * @param {string} [param.current] 当前显示图片的链接，不填则默认为 urls 的第一张
	 */
	function previewImage() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('previewImage', param, {
	    urls: ['']
	  })) {
	    if (param.urls) {
	      param.urls = param.urls.map(function (item) {
	        return FakeTempFilePathMap.get(item) || item;
	      });
	    }
	    invokeMethod('previewImage', param);
	  }
	}

	/**
	 * @function getImageInfo
	 * @description 获取图片信息
	 * @param {object} param
	 * @param {string} param.src 图片的路径，可以是相对路径，临时文件路径，存储文件路径，网络图片路径
	 * @param {getImageInfoSuccessCallback} param.success 成功回调
	 */
	function getImageInfo(param) {
	  if (beforeInvoke('getImageInfo', param, {
	    src: ''
	  })) {

	    if (/^(http|https):\/\//.test(param.src)) {
	      downloadFile({
	        url: param.src,
	        success: function success(res) {
	          param.src = res.tempFilePath;
	          invokeMethod('getImageInfo', param, {
	            beforeSuccess: function beforeSuccess(res2) {
	              res2.path = param.src;
	            }
	          });
	        },
	        fail: function fail(res) {
	          beforeInvokeFail('getImageInfo', param, 'download image fail');
	        }
	      });
	    } else if (/^(tt)?file:\/\//.test(param.src)) {
	      invokeMethod('getImageInfo', param, {
	        beforeSuccess: function beforeSuccess(res) {
	          res.path = param.src;
	        }
	      });
	    } else {
	      param.src = getRealRoute(LifecycleState$1.path, param.src, !1);
	      invokeMethod('getImageInfo', param, {
	        beforeSuccess: function beforeSuccess(res) {
	          res.path = param.src;
	        }
	      });
	    }
	  }
	}

	/**
	 * getImageInfo success callback
	 * @callback getImageInfoSuccessCallback
	 * @param {object} response
	 * @param {number} response.width 图片宽度，单位px
	 * @param {number} response.height 图片高度，单位px
	 * @param {string} response.path 返回图片的本地路径
	 */

	/**
	 * @function saveImageToPhotosAlbum
	 * @description 保存图片到系统相册
	 * @param {object} param
	 * @param {string} param.filePath 图片文件路径，可以是临时文件路径也可以是永久文件路径，不支持网络图片路径
	 */
	function saveImageToPhotosAlbum() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  param.filePath = FakeTempFilePathMap.get(param.filePath) || param.filePath;
	  invokeMethod('saveImageToPhotosAlbum', param, {});
	}

	var GlobalEmitter = new EventEmitter();
	var FakeTempFilePathMap = {
	  map: {},
	  set: function set(path) {
	    var id = guid();
	    this.map[id] = path;
	    return id;
	  },
	  get: function get(path) {
	    return this.map[path];
	  }
	};

	/**
	 * @function saveVideoToPhotosAlbum
	 * @description 保存视频到系统相册
	 * @param {object} param
	 * @param {string} param.filePath 视频文件路径，可以是临时文件路径也可以是永久文件路径
	 */
	function saveVideoToPhotosAlbum() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('saveVideoToPhotosAlbum', param, {});
	}

	/**
	 * chooseVideo success callback
	 * @callback chooseVideoSuccessCallback
	 * @param {object} response
	 * @param {string} response.tempFilePath 选定视频的临时文件路径
	 * @param {number} response.duration 选定视频的时间长度
	 * @param {number} response.size 选定视频的数据量大小
	 * @param {number} response.height 返回选定视频的长
	 * @param {number} response.width 返回选定视频的宽
	 */

	var AudioPool = function () {
	  function AudioPool(maxSize, timeout) {
	    classCallCheck(this, AudioPool);

	    this.resourceMap = new Map();
	    this.resourceList = [];
	    this.destroyTimmer = null;
	    this.timeout = timeout;
	    this.maxSize = maxSize;
	    this.destroyHandler = null;
	  }

	  /**
	     * 从缓存池中得到一个资源
	     *
	     * @param key 资源key
	     * @return 资源，如果没有找到，则调用 onCreate 来生成资源
	     */


	  AudioPool.prototype.get = function get$$1(key) {
	    if (this.resourceMap.has(key)) {
	      var list = this.resourceMap.get(key);
	      var len = list.length;
	      if (len > 0) {
	        var entry = list.pop();
	        var index = this.resourceList.lastIndexOf(entry);
	        if (index > -1) {
	          this.resourceList.splice(index, 1);
	        }

	        // console.log(`pool:get [key:${key}]:${entry.payload}`);
	        return entry.payload;
	      }
	    }

	    // console.log(`pool:get [key:${key}]:null`);
	    return this.onCreate(key);
	  };

	  /**
	     * 释放一个资源到缓存池中
	     *
	     * @param key 资源key
	     * @param resource 资源
	     */


	  AudioPool.prototype.release = function release(key, resource) {
	    var _this = this;

	    // console.log(`pool:release [key:${key}, resource:${resource}]`);
	    var now = new Date().getTime();
	    var entry = {
	      expires: now + this.timeout,
	      payload: resource,
	      list: null
	    };

	    if (!this.resourceMap.has(key)) {
	      this.resourceMap.set(key, []);
	    }

	    var list = this.resourceMap.get(key);
	    entry.list = list;
	    list.push(entry);

	    this.resourceList.push(entry);

	    if (this.resourceList.length > this.maxSize) {
	      entry = this.resourceList.shift();
	      destroyEntry.call(this, entry);
	    }

	    if (this.destroyTimmer === null) {
	      this.destroyTimmer = setTimeout(function () {
	        onDestroyTimeout.call(_this);
	      }, this.timeout);
	    }
	  };

	  AudioPool.prototype.onCreate = function onCreate(key) {
	    return null;
	  };

	  AudioPool.prototype.onDestroy = function onDestroy(callback) {
	    this.destroyHandler = callback;
	  };
	  //  onDestroy(resource) {
	  //      console.log(`pool:destroy [resource:${resource}]`);
	  //      return null;
	  //  }


	  return AudioPool;
	}();
	function destroyEntry(entry) {
	  var list = entry.list;
	  var index = list.indexOf(entry);
	  if (index > -1) {
	    list.splice(index, 1);
	  }

	  list = this.resourceList;
	  index = list.indexOf(entry);
	  if (index > -1) {
	    list.splice(index, 1);
	  }

	  if (this.destroyHandler !== null) {
	    this.destroyHandler(entry.payload);
	  }
	  // this.onDestroy(entry.payload);
	}

	/**
	 * 超时销毁资源
	 */
	function onDestroyTimeout() {
	  var _this2 = this;

	  var list = this.resourceList;
	  var now = new Date().getTime();
	  var hasAlive = false;
	  // eslint-disable-next-line no-constant-condition
	  while (true) {
	    if (list.length <= 0) {
	      break;
	    }

	    var entry = list[0];
	    var timeout = entry.expires - now;
	    if (timeout > 0) {
	      hasAlive = true;
	      this.destroyTimmer = setTimeout(function () {
	        onDestroyTimeout.call(_this2);
	      }, timeout);
	      break;
	    } else {
	      entry = list.shift();
	      destroyEntry.call(this, entry);
	    }
	  }

	  if (!hasAlive) {
	    this.destroyTimmer = null;
	  }
	}

	var isRunning = false;
	var nextTickCallbacks = [];

	function nextTick(fn) {
	  nextTickCallbacks.push(fn);
	  if (!isRunning) {
	    isRunning = true;
	    setTimeout(doNextTick, 0);
	  }
	}

	function doNextTick() {
	  var index = 0;
	  var count = nextTickCallbacks.length;

	  while (index < count) {
	    for (; index < count; index++) {
	      try {
	        // FIXME
	        nextTickCallbacks[index].call(null);
	      } catch (e) {
	        logger.error(e);
	      }
	    }
	    count = nextTickCallbacks.length;
	  }

	  nextTickCallbacks = [];
	  isRunning = false;
	}

	var Queue = function () {
	  function Queue(onExecute) {
	    classCallCheck(this, Queue);

	    this.isRunning = false;
	    this.taskList = [];
	    this.onExecute = onExecute;
	  }

	  Queue.prototype.getTaskList = function getTaskList() {
	    return this.taskList;
	  };

	  Queue.prototype.setTaskList = function setTaskList(list) {
	    this.taskList = list;
	    if (list.length > 0 && !this.isRunning) {
	      this.isRunning = true;
	      this.next();
	    }
	  };

	  Queue.prototype.push = function push(task) {
	    var taskLen = this.taskList.push(task);

	    // if (taskLen > 5) {
	    //     console.warn(`task length:${taskLen}`);
	    // }

	    if (!this.isRunning) {
	      this.isRunning = true;
	      this.next();
	    }
	  };

	  Queue.prototype.next = function next() {
	    var _this = this;

	    nextTick(function () {
	      _this.execute();
	    });
	  };

	  Queue.prototype.execute = function execute() {
	    var _this2 = this;

	    if (this.taskList.length <= 0) {
	      this.isRunning = false;
	      return;
	    }
	    try {
	      var task = this.taskList.shift();
	      this.onExecute(task, function () {
	        _this2.next();
	      });
	    } catch (e) {
	      logger.error(e);
	      this.next();
	    }
	  };

	  return Queue;
	}();

	function invokeMethod$1(name, param) {
	  // console.log(`invokeMethod(${JSON.stringify(name)}, ${JSON.stringify(param)})`);
	  return invokeMethod.apply(this, arguments);
	}

	var TASK_CREATE = 0;
	var TASK_DESTROY = 1;
	var TASK_OPERATE = 2;
	var TASK_SETSTATE = 3;
	var TASK_GETSTATE = 4;

	/**
	 * 音频默认属性
	 */
	var DEFAULT_AUDIO_ATTRS = {
	  src: '',
	  startTime: 0,
	  paused: true,
	  currentTime: 0,
	  duration: 0,
	  obeyMuteSwitch: true,
	  volume: 1,
	  autoplay: false,
	  loop: false,
	  buffered: 0
	};

	/**
	 * audioId 到 audio 对象的映射
	 * 用于 onMethod 回调时查找 audio 对象
	 */
	var idAudioStore = new Map();

	/**
	 * 对原生音频的封装，
	 * 屏蔽 Native 调用的异步性
	 * 上层应用可以同步的调用所有方法
	 */
	var NativeAudio = function () {
	  function NativeAudio() {
	    var _this = this;

	    classCallCheck(this, NativeAudio);

	    // console.log(`create native audio`);

	    // 是否来自于本地 audioPool 的复用
	    this.isFromAudioPool = false;

	    /**
	     * 音频 id，在创建真实 native 音频后设置
	     */
	    this.id = null;

	    /**
	     * 是否已经被销毁
	     * 被销毁后会忽略方法调用
	     */
	    this.destroyed = false;

	    /**
	     * 本地状态是否脏
	     */
	    this.isDirty = true;

	    /**
	     * 是否正在从 Native 获取状态
	     */
	    this.isLoadingState = false;

	    /**
	     * 状态改变监听函数
	     */
	    this.stateHandler = null;

	    /**
	     * 设置过的属性
	     */
	    this.settedAttrStore = {};

	    /**
	     * Native 属性，会从 Native 同步
	     */
	    this.audioAttrStore = Object.assign({}, DEFAULT_AUDIO_ATTRS);

	    /**
	     * 任务队列，用于确保前一个操作结束后，再进行下一个操作
	     * 比如音频创建成功后，才能用 audioId 去设置 src 属性
	     */
	    this.taskQueue = new Queue(function (task, next) {
	      task.callback.call(_this, task, next);
	    });

	    this.taskQueue.push({
	      type: TASK_CREATE,
	      callback: this._createTaskHandler
	    });
	  }

	  NativeAudio.prototype._createTaskHandler = function _createTaskHandler(task, next) {
	    var _this2 = this;

	    invokeMethod$1('createAudioInstance', {
	      success: function success(res) {
	        var audioId = res.audioId;
	        _this2.id = audioId;

	        // 在没有被销毁的时候，才会建立引用关系
	        if (!_this2.destroyed) {
	          idAudioStore.set(audioId, _this2);
	        }

	        next();
	      }
	      // TODO 错误处理
	    });
	  };

	  NativeAudio.prototype.destroy = function destroy() {
	    if (this.destroyed) {
	      // console.error('destroyed');
	      return;
	    }

	    // 标记为已被销毁，
	    // 如果已经绑定了id，则解除引用关系
	    // 如果没有绑定id，在create后会判断是否已被销毁，如果被销毁则不会绑定id
	    this.destroyed = true;
	    var audioId = this.id;
	    if (audioId !== null) {
	      idAudioStore.delete(audioId);
	    }

	    this.taskQueue.push({
	      type: TASK_DESTROY,
	      callback: this._destroyTaskHandler
	    });
	  };

	  NativeAudio.prototype._destroyTaskHandler = function _destroyTaskHandler(task, next) {
	    var audioId = this.id;
	    idAudioStore.delete(audioId);
	    invokeMethod$1('destroyAudioInstance', {
	      audioId: audioId
	      // complete: () => {
	      //     next();
	      // }
	    });

	    // if (__audioMap__.hasOwnProperty(audioId)) {
	    //     __audioList__[__audioMap__[audioId]].state = " ";
	    //     __audioList__[__audioMap__[audioId]].destroyed = true;
	    //     treacAudioState();
	    // }

	    next();
	  };

	  NativeAudio.prototype.operate = function operate(op) {
	    if (this.destroyed) {
	      // console.error('destroyed');
	      return;
	    }
	    this.taskQueue.push({
	      type: TASK_OPERATE,
	      operation: Object.assign({}, op),
	      callback: this._operateTaskHandler
	    });
	  };

	  NativeAudio.prototype._operateTaskHandler = function _operateTaskHandler(task, next) {
	    var _this3 = this;

	    var operation = task.operation;

	    // 这里是针对 Cocos 做的优化，Cocos 会 seek 0 然后 pause,
	    // 如果是这种情况我们将两个操作合并为 stop 操g作，
	    // 以便触发 endded 事件
	    if (operation.operationType === 'seek' && operation.currentTime === 0) {
	      var taskList = this.taskQueue.getTaskList();
	      if (taskList.length) {
	        var nextTask = taskList[0];
	        if (nextTask.type === TASK_OPERATE && nextTask.operation.operationType === 'pause') {
	          taskList.shift();
	          operation = {
	            operationType: 'stop'
	          };
	          this.settedAttrStore.paused = true;
	        }
	      }
	    }

	    var audioId = this.id;
	    invokeMethod$1('operateAudio', Object.assign({
	      audioId: audioId,
	      // TODO 错误处理
	      complete: function complete() {
	        // next();
	        if (operation.operationType === 'seek') {
	          _this3._isSeeking = false;
	        }
	      }
	    }, operation));
	    next();
	  };

	  NativeAudio.prototype.setState = function setState(key, value) {
	    if (this.destroyed) {
	      // console.error('destroyed');
	      return;
	    }

	    this.settedAttrStore[key] = value;

	    // FIXME 这个地方的处理好trick
	    // if (key === 'src') {
	    //     this.audioAttrStore.paused = true;
	    // }

	    this.taskQueue.push({
	      type: TASK_SETSTATE,
	      stateKey: key,
	      stateValue: value,
	      callback: this._setStateTaskHandler
	    });
	  };

	  NativeAudio.prototype._setStateTaskHandler = function _setStateTaskHandler(task, next) {
	    var _state,
	        _this4 = this;

	    var taskList = this.taskQueue.getTaskList();
	    var state = (_state = {}, _state[task.stateKey] = task.stateValue, _state);

	    // 合并多次 setState 操作
	    // 这里采用从任务队列中获取之后的任务列表，
	    // 主要是为了保证只 merge 连续的 setState 任务
	    // 因为如果合并 [setState, otherTask, setState] 这种队列中的
	    // 两个 setState 可能造成表现不一致
	    while (taskList.length > 0) {
	      var item = taskList[0];
	      if (item.type !== TASK_SETSTATE) {
	        break;
	      }

	      item = taskList.shift();
	      state[item.stateKey] = item.stateValue;
	    }

	    var audioId = this.id;
	    Object.assign(this.audioAttrStore, state);
	    invokeMethod$1('setAudioState', Object.assign({
	      audioId: audioId,
	      success: function success() {
	        Object.assign(_this4.audioAttrStore, state);
	      },
	      fail: function fail() {
	        _this4.isDirty = true;
	        _this4.getState();
	      }
	      // complete: () => {
	      //     next();
	      // }
	    }, this.audioAttrStore, state));

	    next();
	  };

	  NativeAudio.prototype.getState = function getState(key) {
	    var ret = {};
	    if (key === 'currentTime' && typeof this.id !== 'undefined') {
	      if (this._isSeeking) {
	        return this.settedAttrStore[key];
	      }
	      // currentTime同步获取
	      var time = 0;
	      invokeMethod$1(TMAConfig.platform === 'android' ? 'getAudioStateSync' : 'getAudioState', {
	        audioId: this.id,
	        success: function success(res) {
	          time = (key === 'duration' || key === 'currentTime') && (res[key] / 1000).toFixed(6);
	        },
	        complete: function complete() {}
	      });
	      return time;
	    }
	    // 因为游戏中端的实现全是异步的，所以这里只能同步返回缓存的数据
	    if (this.settedAttrStore.hasOwnProperty(key)) {
	      ret = this.settedAttrStore[key];
	    } else if (this.audioAttrStore.hasOwnProperty(key)) {
	      ret = this.audioAttrStore[key];
	    }
	    if (this.destroyed) {
	      return ret;
	    }
	    if (!this.isLoadingState && this.isDirty) {
	      this.isLoadingState = true;
	      this.taskQueue.push({
	        type: TASK_GETSTATE,
	        callback: this._getStateTaskHandler
	      });
	    }
	    return ret;
	  };

	  NativeAudio.prototype._getStateTaskHandler = function _getStateTaskHandler(task, next) {
	    var _this5 = this;

	    var audioId = this.id;
	    invokeMethod$1('getAudioState', {
	      audioId: audioId,
	      success: function success(res) {
	        // 如果处于 seek 状态，不更新 currentTime
	        _this5._isSeeking || (res.currentTime = (res.currentTime / 1000).toFixed(6));
	        res.duration = (res.duration / 1000).toFixed(6);
	        // FIXME: trick for cocos paused get
	        res.paused = _this5.settedAttrStore.paused;
	        Object.assign(_this5.audioAttrStore, res);
	        Object.assign(_this5.settedAttrStore, res);
	        // this.isDirty = false;
	      },
	      complete: function complete() {
	        _this5.isLoadingState = false;
	        // next();
	      }
	    });

	    next();
	  };

	  NativeAudio.prototype.onStateChange = function onStateChange(callback) {
	    this.stateHandler = callback;
	  };

	  return NativeAudio;
	}();

	/**
	 * 响应音频状态改变事件
	 */

	// let __audioList__ = [];
	// let __audioMap__ = {};

	// function treacAudioState() {
	//     console.log(__audioList__.map(item => {
	//         return item.state[0].toUpperCase();
	//     }));
	//     console.log(__audioList__);
	// }


	onMethod('onAudioStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var state = res.state.toLowerCase();
	  var audioId = res.audioId;

	  // if (!__audioMap__.hasOwnProperty(audioId)) {
	  //     __audioMap__[audioId] = __audioList__.length;
	  //     __audioList__[__audioMap__[audioId]] = {};
	  // }
	  // if (!__audioList__[__audioMap__[audioId]].destroyed) {
	  //     __audioList__[__audioMap__[audioId]] = Object.assign({}, res);
	  // }
	  // treacAudioState();

	  // console.log(`onAudioStateChange(${JSON.stringify(res)})`);

	  delete res.state;
	  delete res.audioId;

	  if (idAudioStore.has(audioId)) {
	    var audio = idAudioStore.get(audioId);
	    if (audio.stateHandler !== null) {
	      audio.stateHandler(state, res);
	    }
	  }
	});

	/**
	 * 音频缓存池
	 * 第一个参数是缓存池大小
	 * 第二个参数是自动销毁时间
	 *
	 * 在超过缓存池大小或者缓存超时时会销毁缓存的对象
	 */
	var audioPool = new AudioPool(10, 3000);
	audioPool.onDestroy(function (audio) {
	  audio.destroy();
	});

	/**
	 * InnerAudio 到 NativeAudio 的映射
	 * 使用 WeakMap 主要是模拟 private，防止暴露 NativeAudio 对象
	 */
	var nativeAudioStore = new WeakMap();

	function hasNativeAudio(audio) {
	  return nativeAudioStore.has(audio);
	}

	function getNativeAudio(audio) {
	  if (hasNativeAudio(audio)) {
	    return nativeAudioStore.get(audio);
	  } else {
	    return null;
	  }
	}

	function unbindNativeAudio(audio) {
	  var nativeAudio = getNativeAudio(audio);
	  if (nativeAudio) {
	    nativeAudio.onStateChange(null);
	  }
	  nativeAudioStore.delete(audio);
	}

	function bindNativeAudio(audio, nativeAudio) {
	  nativeAudio.onStateChange(function (state, res) {
	    nativeAudioStateChangeHandler.call(audio, state, res);
	  });
	  nativeAudioStore.set(audio, nativeAudio);
	}

	function setNativeAudioStateExceptKeys(nativeAudio, state, exceptKeys) {
	  exceptKeys = exceptKeys || [];
	  var keys = Object.keys(state);
	  keys.forEach(function (key) {
	    // 排除的 key 列表中找不到的话，则设置。。有点绕-_-!
	    if (exceptKeys.indexOf(key) < 0) {
	      nativeAudio.setState(key, state[key]);
	    }
	  });
	  return nativeAudio;
	}

	function getState(audio, key) {
	  var nativeAudio = getNativeAudio(audio);
	  if (nativeAudio !== null) {
	    var value = nativeAudio.getState(key);
	    setAttr(audio, key, value);
	    return value;
	  } else {
	    return getAttr(audio, key);
	  }
	}

	function setState(audio, key, value) {
	  setAttr(audio, key, value);
	  var nativeAudio = getNativeAudio(audio);
	  if (nativeAudio !== null) {
	    nativeAudio.setState(key, value);
	  }
	}

	/**
	 * timeUpdate callback
	 */
	var timeupdateFuncStore = new WeakMap();

	/**
	 * 属性缓存
	 */
	var attrStore = new WeakMap();

	/**
	 * 事件处理器缓存
	 */
	var emitterStore = new WeakMap();

	function getAttr(audio, key) {
	  if (arguments.length < 2) {
	    if (attrStore.has(audio)) {
	      return attrStore.get(audio);
	    }
	  } else {
	    if (attrStore.has(audio)) {
	      return attrStore.get(audio)[key];
	    }
	  }
	  return undefined;
	}

	function setAttr(audio, key, value) {
	  if (arguments.length < 3) {
	    attrStore.set(audio, key);
	  } else {
	    if (!attrStore.has(audio)) {
	      attrStore.set(audio, {});
	    }

	    attrStore.get(audio)[key] = value;
	  }
	}

	function loadNativeAudio(audio, src) {
	  // 播放时，检查是否有绑定的NativeAudio，如果没有，
	  // 则从缓存池中获取，如果未获取到，则新建NativeAudio对象
	  var nativeAudio = getNativeAudio(audio);
	  if (nativeAudio === null) {
	    nativeAudio = audioPool.get(src);
	    if (nativeAudio === null) {
	      nativeAudio = new NativeAudio();
	      nativeAudio.setState('src', src);
	    } else {
	      nativeAudio.isFromAudioPool = true;
	    }

	    setNativeAudioStateExceptKeys(nativeAudio, getAttr(audio), ['src']);
	    bindNativeAudio(audio, nativeAudio);
	  }
	  return nativeAudio;
	}

	var InnerAudio = function () {
	  function InnerAudio() {
	    classCallCheck(this, InnerAudio);

	    setAttr(this, Object.assign({}, DEFAULT_AUDIO_ATTRS));
	  }

	  InnerAudio.prototype.play = function play() {
	    var nativeAudio = loadNativeAudio(this, this.src);
	    nativeAudio.operate({
	      operationType: 'play'
	    });
	    // FIXME: trick for cocos paused get
	    nativeAudio.settedAttrStore.paused = false;
	    // nativeAudio._isPlaying = true;
	  };

	  InnerAudio.prototype.pause = function pause() {
	    var nativeAudio = getNativeAudio(this);
	    if (nativeAudio !== null) {
	      nativeAudio.operate({
	        operationType: 'pause'
	      });
	      // FIXME: trick for cocos paused get
	      nativeAudio.settedAttrStore.paused = true;
	      // nativeAudio._isPlaying = false;
	    }
	  };

	  InnerAudio.prototype.stop = function stop() {
	    var nativeAudio = getNativeAudio(this);
	    if (nativeAudio !== null) {
	      nativeAudio.operate({
	        operationType: 'stop'
	      });
	      audioPool.release(this.src, nativeAudio);
	      setState(this, 'paused', true);
	      // FIXME: trick for cocos paused get
	      nativeAudio.settedAttrStore.paused = true;
	      // nativeAudio._isPlaying = false;
	      unbindNativeAudio(this);
	    }
	  };

	  InnerAudio.prototype.seek = function seek(position) {
	    var nativeAudio = getNativeAudio(this);
	    if (nativeAudio !== null) {
	      // seek 操作时手动设置 currentTime
	      nativeAudio.settedAttrStore.currentTime = position.toFixed(6);
	      // seek 是一个异步操作，标记 nativeaudio 处于 seek 状态，用户在 seek 过程中获取 currentTime 为手动设置的 time
	      nativeAudio._isSeeking = true;
	      nativeAudio.operate({
	        operationType: 'seek',
	        currentTime: 1e3 * position
	      });
	    }
	  };

	  InnerAudio.prototype.destroy = function destroy() {
	    var nativeAudio = getNativeAudio(this);
	    if (nativeAudio !== null) {
	      nativeAudio.destroy();
	      var timer = timeupdateFuncStore.get(this);
	      clearInterval(timer);
	      timeupdateFuncStore.set(this, null);
	      // nativeAudio._isPlaying = false;
	      // FIXME: trick for cocos paused get
	      nativeAudio.settedAttrStore.paused = true;
	    }
	  };

	  createClass(InnerAudio, [{
	    key: 'src',
	    set: function set$$1(value) {
	      var origSrc = getState(this, 'src');

	      if (!emitterStore.has(this)) {
	        emitterStore.set(this, new EventEmitter());
	      }

	      var emitter = emitterStore.get(this);

	      // Cocos Creator v2.0.8 版本的audioPool 实现有bug，stop 操作会设置 src 为null，下次复用又不会重新设置src，导致无法播放
	      if (value === '' || !isString(value) || value === origSrc) {
	        return;
	      }

	      // 如果有 NativeAudio，则将之前的 NativeAudio 释放
	      var nativeAudio = getNativeAudio(this);
	      if (nativeAudio !== null) {
	        // 如果已经有了 audio 实例，先暂停之前的 aduio
	        nativeAudio.settedAttrStore.paused = true;
	        nativeAudio.__played__ = false;
	        // setNativeAudioStateExceptKeys(nativeAudio, DEFAULT_AUDIO_ATTRS, ['src']);
	        // audioPool.release(origSrc, nativeAudio);
	        // unbindNativeAudio(this);
	      }

	      setTimeout(function () {
	        return emitter.emit('canplay');
	      }, 0);
	      setState(this, 'src', value);
	      if (this.autoplay) {
	        loadNativeAudio(this, value);
	      }
	    },
	    get: function get$$1() {
	      return getState(this, 'src');
	    }
	  }, {
	    key: 'autoplay',
	    set: function set$$1(value) {
	      value = !!value;
	      setState(this, 'autoplay', value);
	      var src = this.src;
	      if (value && src) {
	        var nativeAudio = loadNativeAudio(this, src);
	        if (nativeAudio.isFromAudioPool) {
	          this.play();
	        }
	      }
	    },
	    get: function get$$1() {
	      return getState(this, 'autoplay');
	    }
	  }, {
	    key: 'loop',
	    set: function set$$1(value) {
	      setState(this, 'loop', value);
	    },
	    get: function get$$1() {
	      return getState(this, 'loop');
	    }
	  }, {
	    key: 'obeyMuteSwitch',
	    set: function set$$1(value) {
	      setState(this, 'obeyMuteSwitch', value);
	    },
	    get: function get$$1() {
	      return getState(this, 'obeyMuteSwitch');
	    }
	  }, {
	    key: 'duration',
	    get: function get$$1() {
	      return getState(this, 'duration');
	    }
	  }, {
	    key: 'currentTime',
	    get: function get$$1() {
	      return getState(this, 'currentTime');
	    }
	  }, {
	    key: 'paused',
	    get: function get$$1() {
	      return getState(this, 'paused');
	    }
	  }, {
	    key: 'buffered',
	    get: function get$$1() {
	      return getState(this, 'buffered');
	    }
	  }, {
	    key: 'volume',
	    set: function set$$1(value) {
	      value = Math.min(1, Math.max(value, 0));
	      !isNaN(value) && setState(this, 'volume', value);
	    },
	    get: function get$$1() {
	      return getState(this, 'volume');
	    }
	  }]);
	  return InnerAudio;
	}();

	['Play', 'Pause', 'Stop', 'Canplay', 'Error', 'Ended', 'Waiting', 'Seeking', 'Seeked', 'TimeUpdate'].forEach(function (event) {
	  var eventName = event.toLowerCase();
	  if (eventName === 'error') {
	    eventName = '_error';
	  }

	  InnerAudio.prototype['on' + event] = function (callback) {
	    var _this = this;

	    if (!emitterStore.has(this)) {
	      emitterStore.set(this, new EventEmitter());
	    }

	    var emitter = emitterStore.get(this);

	    if (event === 'TimeUpdate') {
	      if (!timeupdateFuncStore.get(this)) {
	        var _lastTime = void 0;
	        var timer = setInterval(function () {
	          var nativeAudio = getNativeAudio(_this);
	          if (nativeAudio && !nativeAudio.settedAttrStore.paused) {
	            var ct = getState(_this, 'currentTime');
	            if (ct !== _lastTime) {
	              emitter.emit(eventName);
	            }
	          }
	        }, 250);

	        timeupdateFuncStore.set(this, timer);
	      }

	      emitter.removeAllListeners(eventName);
	    }

	    emitter.on(eventName, callback);
	  };

	  InnerAudio.prototype['off' + event] = function (callback) {
	    if (!emitterStore.has(this)) {
	      return;
	    }
	    var emitter = emitterStore.get(this);
	    if (callback === undefined || callback === null) {
	      emitter.removeAllListeners(eventName);
	    } else {
	      emitter.off(eventName, callback);
	    }
	  };
	});

	function nativeAudioStateChangeHandler(state, props) {
	  var _this2 = this;

	  // 音频播放结束时，将资源放回缓存池
	  switch (state) {
	    case 'play':
	      {
	        // autoplay 时需要手动设置 _isPlaying 属性
	        var nativeAudio = getNativeAudio(this);
	        var autoplay = getAttr(this, 'autoplay');
	        if (autoplay && !nativeAudio.__played__) {
	          // nativeAudio._isPlaying = true;
	          nativeAudio.settedAttrStore.paused = false;
	          nativeAudio.__played__ = true;
	        }
	      }
	      break;
	    case 'ended':
	    case 'stop':
	      {
	        var _nativeAudio = getNativeAudio(this);
	        var src = this.src;
	        if (_nativeAudio == null) {
	          break;
	        }
	        // nativeAudio._isPlaying标记位防止音乐在播放时被释放
	        if (_nativeAudio.settedAttrStore.paused) {
	          audioPool.release(src, _nativeAudio);
	          unbindNativeAudio(this);
	        } else if (state === 'ended') {
	          // nativeAudio._isPlaying = false;
	          setAttr(this, 'paused', true);
	          _nativeAudio.settedAttrStore.paused = true;
	          // 由于端触发为异步回调
	          // 防止此时开发者调用play方法
	          // 此处使用setTimeout 0推后调用
	          setTimeout(function () {
	            // 假如js同步代码中在ended触发后
	            // nativeAudio._isPlaying没有变为true(执行了play操作)
	            // 或资源src被修改
	            // 则释放该音频资源
	            if (_nativeAudio.settedAttrStore.paused && _this2.src === src) {
	              audioPool.release(src, _nativeAudio);
	              unbindNativeAudio(_this2);
	            }
	          }, 0);
	        }
	      }
	      break;

	    case 'error':
	      {
	        logger.error('error');
	        var _nativeAudio2 = getNativeAudio(this);
	        if (_nativeAudio2 !== null) {
	          unbindNativeAudio(this);
	          _nativeAudio2.destroy();
	          // setNativeAudioStateExceptKeys(nativeAudio, DEFAULT_AUDIO_ATTRS, ['src']);
	          // audioPool.release(src, nativeAudio);
	        }
	      }
	      break;
	  }

	  if (emitterStore.has(this)) {
	    var emitter = emitterStore.get(this);
	    if (state === 'error') {
	      state = '_error';
	    }
	    emitter.emit(state, props);
	  }
	}

	function createInnerAudioContext() {
	  return new InnerAudio();
	}

	var isGettingLocation = false;
	var invokeQueue = [];

	/**
	 * @function getLocation
	 * @description 获取当前的地理位置
	 * @param {object} param
	 * @param {getLocationSuccessCallback} [param.success] 成功回调
	 */
	function getLocation() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (isGettingLocation) {
	        invokeQueue.push(param);
	    } else {
	        isGettingLocation = true;
	        invokeMethod("getLocation", param, {
	            beforeAll: function beforeAll() {
	                isGettingLocation = false;
	            },
	            afterAll: function afterAll(res) {
	                invokeQueue.forEach(function (t) {
	                    "function" == typeof t.complete && surroundByTryCatchFactory(t.complete, "at getLocation complete callback function")(res);
	                });
	                invokeQueue = [];
	            },
	            afterSuccess: function afterSuccess(res) {
	                invokeQueue.forEach(function (t) {
	                    "function" == typeof t.success && surroundByTryCatchFactory(t.success, "at getLocation success callback function")(res);
	                });
	            },
	            afterFail: function afterFail(res) {
	                invokeQueue.forEach(function (t) {
	                    "function" == typeof t.fail && surroundByTryCatchFactory(t.fail, "at getLocation fail callback function")(res);
	                });
	            }
	        });
	    }
	}

	/**
	 * @function scanCode
	 * @description 扫描二维码，返回结果
	 * 
	 * @param {object} param
	 * @param {scanCodeSuccessCallback} param.success 成功回调
	 */
	function scanCode() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (beforeInvoke("scanCode", param, {})) {
	        invokeMethod("scanCode", param, {
	            beforeSuccess: function beforeSuccess(res) {
	                "string" == typeof res.path && (res.path = res.path.replace(/\.html$/, ""), res.path = res.path.replace(/\.html\?/, "?"));
	            }
	        });
	    }
	}

	/**
	 * scanCode success callback
	 * @callback scanCodeSuccessCallback
	 * @param {object} response
	 * @param {string} response.result 所扫码的内容
	 */

	/**
	 * @function getClipboardData
	 * @description 获取系统剪贴板内容
	 * @example
	tt.getClipboardData({
	    success: function(res){
	        logger.log(res.data)
	    }
	})
	 */
	function getClipboardData() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('getClipboardData', param);
	}

	/**
	 * @function setClipboardData
	 * @description 设置系统剪贴板的内容
	 * @param {object} param
	 * @param {string} param.data 需要设置的内容
	 * @example
	tt.setClipboardData({
	    data: 'data',
	    success: function(res) {
	        tt.getClipboardData({
	            success: function(res) {
	                logger.log(res.data);
	            }
	        });
	    }
	})
	 */
	var paramDataType = {
	    data: 'String'
	};
	function setClipboardData() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (beforeInvoke('setClipboardData', param, paramDataType)) {
	        invokeMethod('setClipboardData', param);
	    }
	}

	/**
	 * @function vibrateShort
	 * @description 使手机发生较短时间的振动
	 * 只有部分机型生效
	 */
	function vibrateShort() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('vibrateShort', param);
	}

	/**
	 * @function vibrateLong
	 * @description 使手机发生较长时间的振动
	 */
	function vibrateLong() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('vibrateLong', param);
	}

	/**
	 * @function setKeepScreenOn
	 * @description 设置是否保持常亮状态。 仅在当前小功能生效， 离开小功能后设置失效。
	 * @param {object} param
	 * @param {boolean} [param.keepScreenOn=true] 是否保持屏幕常亮
	 * @example
	tt.setKeepScreenOn({
	    keepScreenOn: true
	})
	 */
	function setKeepScreenOn() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (typeof param.keepScreenOn === 'undefined') {
	    param.keepScreenOn = true;
	  }

	  if (beforeInvoke('setKeepScreenOn', param, {
	    keepScreenOn: true
	  })) {
	    invokeMethod('setKeepScreenOn', param);
	  }
	}

	var acounter = 0,
	    counterStore = new WeakMap(),
	    taskIdStore = new WeakMap(),
	    paramStore = new WeakMap();

	var socketTaskMap = {};
	var emitter$3 = new EventEmitter();

	onMethod("onSocketTaskStateChange", function () {
	    var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    var state = res.state,
	        socketTaskId = res.socketTaskId,
	        task = socketTaskMap[socketTaskId],
	        counter = counterStore.get(task);
	    delete res.state;
	    delete res.socketTaskId;
	    if (task) {
	        "open" === state ? task.readyState = task.OPEN : "close" !== state && "error" !== state || (task.readyState = task.CLOSED);
	        // @important!
	        // task 上监听 3close 4message
	        // tt 上监听 onSocketClose
	        emitter$3.emit("" + counter + state, res);
	        emitter$3.emit("onSocket" + (state[0].toUpperCase() + state.substr(1)), res, task);

	        "close" === state && (delete socketTaskMap[socketTaskId], emitter$3.removeAllListeners(counter + "open"), emitter$3.removeAllListeners(counter + "close"), emitter$3.removeAllListeners(counter + "error"), emitter$3.removeAllListeners(counter + "message"));
	    }
	});

	var listeneTaskStateChange = function listeneTaskStateChange(cmd, callback) {
	    counterStore.get(this);
	    emitter$3.on("" + counterStore.get(this) + cmd, surroundByTryCatchFactory(callback, "at socketTask.on" + cmd + " callback function"));
	};

	/**
	 * @class SocketTask
	 */
	var SocketTask = function () {
	    function SocketTask(instanceKey, param) {
	        classCallCheck(this, SocketTask);

	        var instance = this;

	        this.CONNECTING = 0;
	        this.OPEN = 1;
	        this.CLOSING = 2;
	        this.CLOSED = 3;

	        this.readyState = this.CONNECTING;

	        var counter = acounter++;

	        counterStore.set(this, counter);
	        paramStore.set(this, param);

	        Object.defineProperty(this, "__socketInstance__", {
	            value: instanceKey,
	            writable: !1,
	            configurable: !1,
	            enumerable: !1
	        });

	        ["success", "fail", "complete"].forEach(function (e) {
	            "function" == typeof param[e] && (param[e] = surroundByTryCatchFactory(param[e], "at api connectSocket " + e + " callback function"));
	        });

	        var ifFailed;
	        invokeMethod("createSocketTask", param, {
	            beforeAll: function beforeAll(res) {
	                res.errMsg = res.errMsg.replace("createSocketTask", "connectSocket");
	            },
	            beforeSuccess: function beforeSuccess(res) {
	                taskIdStore.set(instance, res.socketTaskId), socketTaskMap[res.socketTaskId] = instance;
	            },
	            beforeFail: function beforeFail(e) {
	                ifFailed = e.errMsg;
	            }
	        });
	        ifFailed && (this.readyState = this.CLOSED, setTimeout(function () {
	            emitter$3.emit(counter + "error", {
	                errMsg: ifFailed
	            });
	        }, 0));
	    }

	    /**
	     * 发送数据
	     * @memberOf SocketTask
	     * @param {object} param 
	     * @param {string|arraybuffer} param.data 要发送的数据
	     */


	    SocketTask.prototype.send = function send(param) {
	        if (this.readyState === this.OPEN) {
	            var copyParam = Object.assign({}, param);
	            "android" === getPlatform() && void 0 !== param.data && param.data instanceof ArrayBuffer && void 0 !== param.data.byteLength && param.data.byteLength > 0 && (copyParam.__nativeBuffers__ = [{
	                key: "data",
	                base64: arrayBufferToBase64(param.data)
	            }], delete copyParam.data);

	            invokeMethod("operateSocketTask", Object.assign({}, copyParam, {
	                operationType: "send",
	                socketTaskId: taskIdStore.get(this)
	            }), {
	                beforeAll: function beforeAll(e) {
	                    e.errMsg = e.errMsg.replace("operateSocketTask", "sendSocketMessage");
	                }
	            });
	        } else {
	            beforeInvokeFail("SocketTask.send", param, "SocketTask.readState is not OPEN");
	        }
	    };

	    /**
	     * 关闭 WebSocket 连接
	     * @memberOf SocketTask
	     * @param {object} param 
	     * @param {number} [param.code=1000] 一个数字值表示关闭连接的状态号，表示连接被关闭的原因。
	     * @param {string} [param.reason] 一个可读的字符串，表示连接被关闭的原因。这个字符串必须是不长于123字节的UTF-8 文本（不是字符）
	     */


	    SocketTask.prototype.close = function close() {
	        var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        invokeMethod("operateSocketTask", Object.assign({}, param, {
	            operationType: "close",
	            code: 1e3,
	            socketTaskId: taskIdStore.get(this)
	        }), {
	            beforeAll: function beforeAll(e) {
	                e.errMsg = e.errMsg.replace("operateSocketTask", "closeSocket");
	            }
	        });
	    };

	    /**
	     * 监听 WebSocket 连接打开事件
	     * @memberOf SocketTask
	     * @param {function} cb 回调方法
	     */


	    SocketTask.prototype.onOpen = function onOpen(cb) {
	        listeneTaskStateChange.call(this, "open", cb);
	    };

	    /**
	     * 监听 WebSocket 连接关闭事件
	     * @memberOf SocketTask
	     * @param {function} cb 回调方法
	     */


	    SocketTask.prototype.onClose = function onClose(cb) {
	        listeneTaskStateChange.call(this, "close", cb);
	    };

	    /**
	     * 监听WebSocket接受到服务器的消息事件
	     * @memberOf SocketTask
	     * @param {function} cb 回调方法
	     */


	    SocketTask.prototype.onMessage = function onMessage(cb) {
	        listeneTaskStateChange.call(this, "message", cb);
	    };

	    /**
	     * 监听 WebSocket 错误
	     * @memberOf SocketTask
	     * @param {function} cb 回调方法
	     */


	    SocketTask.prototype.onError = function onError(cb) {
	        listeneTaskStateChange.call(this, "error", cb);
	    };

	    return SocketTask;
	}();

	function onSocket(instanceKey, cmd) {
	    if (!commandCallbackMap[cmd]) {
	        commandCallbackMap[cmd] = new WeakMap();
	        emitter$3.on("onSocket" + cmd, _check(cmd));
	    }

	    return function (callback) {
	        beforeInvoke("onSocket" + cmd, callback, noop) && commandCallbackMap[cmd].set(instanceKey, callback);
	    };
	}

	function _check(cmd) {
	    return function (res, task) {
	        var instanceKey = task.__socketInstance__,
	            cb = commandCallbackMap[cmd].get(instanceKey),
	            originTask = socketTaskPool.get(instanceKey);
	        cb && task === originTask && surroundByTryCatchFactory(cb, "at onSocket" + cmd + " callback function")(res);
	    };
	}

	var socketTaskPool = new WeakMap();
	var commandCallbackMap = {};
	var factory$1 = function factory() {

	    var instanceKey = {};

	    return {
	        /**
	         * @function connectSocket
	         * @description 创建一个 WebSocket 连接
	         * @param {object} param
	         * @param {string} param.url 开发者服务器接口地址，必须是 wss 协议，且域名必须是后台配置的合法域名
	         * @param {object} [param.header] HTTP Header , header 中不能设置 Referer
	         * @param {string} [param.method=GET] OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT
	         * @param {string[]} [param.protocols] 子协议数组
	         * @returns {SocketTask}
	         */
	        connectSocket: function connectSocket(param) {
	            if (beforeInvoke("connectSocket", param, {
	                url: ""
	            })) {
	                if (!validateUrl(param.url, "websocket")) {
	                    return void beforeInvokeFail("request", param, 'invalid url "' + param.url + '"');
	                }

	                _typeof(param.header) !== 'object' && param.header !== undefined && delete param.header;
	                var headerString = {};
	                param.header && (headerString = convertObjectValueToString(param.header));

	                try {
	                    var oldTask = socketTaskPool.get(instanceKey),
	                        socketTask = new SocketTask(instanceKey, Object.assign({}, param, {
	                        header: headerString
	                    }));
	                    oldTask && oldTask.readyState !== oldTask.CLOSED || socketTaskPool.set(instanceKey, socketTask);
	                    return socketTask;
	                } catch (ex) {
	                    beforeInvokeFail("connectSocket", param, ex.message);
	                }
	            }
	        },
	        closeSocket: function closeSocket(param) {
	            var socketTask = socketTaskPool.get(instanceKey);
	            socketTask && socketTask.readyState !== socketTask.CLOSED ? (socketTask.readyState = socketTask.CLOSED, socketTask.close(param)) : beforeInvokeFail("closeSocket", param, "WebSocket is not connected");
	            for (key in socketTaskMap) {
	                var r = socketTaskMap[key];
	                r.__socketInstance__ === instanceKey && (r.readyState = r.CLOSED, r !== socketTask && r.close());
	            }
	        },
	        sendSocketMessage: function sendSocketMessage(param) {
	            var socketTask = socketTaskPool.get(instanceKey);
	            socketTask && socketTask.readyState === socketTask.OPEN ? socketTask.send(param) : beforeInvokeFail("sendSocketMessage", param, "WebSocket is not connected");
	        },
	        onSocketOpen: onSocket(instanceKey, "Open"),
	        onSocketClose: onSocket(instanceKey, "Close"),
	        onSocketMessage: onSocket(instanceKey, "Message"),
	        onSocketError: onSocket(instanceKey, "Error")
	    };
	};

	var socket = factory$1();

	function login(param) {
	  var newParam = Object.assign({
	    force: true
	  }, param);

	  var loginName = TMAConfig.platform === 'ios' ? 'tma_login' : 'login';
	  invokeMethod(loginName, newParam, {
	    beforeAll: function beforeAll(res) {
	      res.errMsg = res.errMsg.replace('tma_login', 'login');
	    }
	  });
	}

	function checkSession(param) {
	  invokeMethod('checkSession', param);
	}

	var emitter$4 = new EventEmitter();
	var eList = ['start', 'move', 'end', 'cancel'];
	var exports$1 = {};

	var touchCbMap = {};

	eList.forEach(function (e) {

	  NativeGlobal.EventHandler['touch' + e] = function (event) {
	    event.changedTouches.map(function (v) {
	      if (typeof v.screenX === 'undefined') {
	        v.screenX = v.clientX;
	        v.screenY = v.clientY;
	      }
	    });

	    event.touches.map(function (v) {
	      if (typeof v.screenX === 'undefined') {
	        v.screenX = v.clientX;
	        v.screenY = v.clientY;
	      }
	    });
	    var touchEvent = {
	      touches: event.touches,
	      changedTouches: event.changedTouches,
	      timeStamp: Date.now()
	    };
	    emitter$4.emit(e, touchEvent);
	  };

	  var evtName = 'Touch' + (e.charAt(0).toUpperCase() + e.slice(1));
	  exports$1['on' + evtName] = function (cb) {
	    if (!isFn(cb)) {
	      throw new ThirdScriptTypeError('callback must be a function.');
	    }

	    // 不同touch事件不共享同一对象, 防止开放数据域可以传输数据
	    if (!touchCbMap[e]) {
	      touchCbMap[e] = new Map();
	    }

	    if (!touchCbMap[e].get(cb)) {
	      var safeWrapCb = function safeWrapCb(data) {
	        cb(deepCopy(data));
	      };
	      touchCbMap[e].set(cb, safeWrapCb);
	    }

	    emitter$4.on(e, touchCbMap[e].get(cb));
	  };

	  exports$1['off' + evtName] = function (cb) {
	    if (!touchCbMap[e]) {
	      return;
	    }

	    if (cb) {
	      emitter$4.off(e, touchCbMap[e].get(cb));
	      touchCbMap[e].delete(cb);
	    } else {
	      emitter$4.removeAllListeners(e);
	      touchCbMap[e] = null;
	    }
	  };
	});

	/**
	* @function callHostMethod
	* @description 直接调用宿主实现的方法
	*/
	function callHostMethod() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  beforeInvoke('callHostMethod', param, {
	    method: ''
	  }) && invokeMethod('callHostMethod', param);
	}

	/**
	* @function callHostMethod
	* @description 同步调用宿主实现的方法
	*/
	function callHostMethodSync() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var errMsg = void 0,
	      result = void 0;
	  if (beforeInvoke('callHostMethodSync', param, {
	    method: ''
	  })) {
	    invokeMethod('callHostMethodSync', param, {
	      success: function success(res) {
	        result = res;
	      },
	      fail: function fail() {
	        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        errMsg = e.errMsg;
	      }
	    });

	    if (errMsg) {
	      throw new ThirdScriptError(errMsg);
	    }

	    return result;
	  }
	}

	/**
	 * 将当前 Canvas 保存为一个临时文件，并生成相应的临时文件路径。
	 * @param {*} params
	 */
	function toTempFilePath(canvasEncodeFn) {
	  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  var base64Str = _canvasToBase64(params, this, canvasEncodeFn, 'toTempFilePath');
	  invokeMethod('base64ToTempFilePath', Object.assign({
	    base64Data: base64Str
	  }, params), {
	    beforeAll: function beforeAll(res) {
	      res.errMsg = res.errMsg.replace('base64ToTempFilePath', 'toTempFilePath');
	    }
	  });
	}

	/**
	 * toTempFilePath同步版本
	 * @param {*} params
	 */
	function toTempFilePathSync(canvasEncodeFn) {
	  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  var base64Str = _canvasToBase64(params, this, canvasEncodeFn, 'toTempFilePathSync');
	  var tempFilePath = _getRandomPath('png');
	  var errMsg = null;

	  invokeMethod('writeFileSync', {
	    filePath: tempFilePath,
	    data: base64Str,
	    encoding: 'base64',
	    fail: function fail(e) {
	      errMsg = e.errMsg;
	    }
	  });
	  if (errMsg) {
	    throw new Error(_replaceMsg(errMsg, 'writeFileSync', 'toTempFilePathSync'));
	  }
	  return tempFilePath;
	}

	function _replaceMsg(msg, useApi, realApi) {
	  return msg.replace(useApi, realApi);
	}

	function _canvasToBase64(params, canvas, canvasEncodeFn, api) {
	  var defaultParams = {
	    x: 0, // 截取 canvas 的左上角横坐标
	    y: 0, // 截取 canvas 的左上角纵坐标
	    width: +canvas.width, // 截取 canvas 的宽度
	    height: +canvas.height, // 截取 canvas 的高度
	    destWidth: +canvas.width, // 目标文件的宽度，会将截取的部分拉伸或压缩至该数值
	    destHeight: +canvas.height, // 目标文件的高度，会将截取的部分拉伸或压缩至该数值
	    fileType: 'png', // 目前只支持png
	    quality: 1.0 // 目前只支持1.0
	  };
	  params = Object.assign({}, defaultParams, params);
	  if (beforeInvoke(api, params, defaultParams)) {
	    // for type check
	    var _params = params,
	        x = _params.x,
	        y = _params.y,
	        destWidth = _params.destWidth,
	        destHeight = _params.destHeight,
	        width = _params.width,
	        height = _params.height,
	        fileType = _params.fileType,
	        quality = _params.quality;

	    if (canvasEncodeFn) {
	      return canvasEncodeFn.call(canvas, x, y, width, height, destWidth, destHeight, fileType, quality, 'data-url').replace(/.*base64,/, '');
	    } else {
	      // 兼容 IDE
	      var _params2 = params,
	          _x3 = _params2.x,
	          _y = _params2.y,
	          _destWidth = _params2.destWidth,
	          _destHeight = _params2.destHeight,
	          _width = _params2.width,
	          _height = _params2.height;

	      var tmpCanvas = new Canvas();
	      tmpCanvas.width = _destWidth;
	      tmpCanvas.height = _destHeight;
	      var tmpCtx = tmpCanvas.getContext('2d');
	      tmpCtx.drawImage(canvas, _x3, _y, _width, _height, 0, 0, _destWidth, _destHeight);
	      return tmpCanvas.toDataURL().replace(/.*base64,/, ''); // replace DataURL to raw base64
	    }
	  }
	}

	var pathMap = new Map();
	function _getRandomPath() {
	  var ext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'png';

	  var dateNow = Date.now(); // 使用时间戳产生文件名
	  var randomPath = tt.env.USER_DATA_PATH + '/' + dateNow + '.' + ext;
	  while (pathMap.get(randomPath)) {
	    dateNow++;
	    randomPath = tt.env.USER_DATA_PATH + '/' + dateNow + '.' + ext;
	  }
	  pathMap.set(randomPath, true);
	  return randomPath;
	}

	var firstCreate = true;
	var canvasCreateHook = function canvasCreateHook() {};
	var screenCanvas = _createCanvas(true);

	function setCanvasCreateHook(fn) {
	  if (typeof fn === 'function') {
	    canvasCreateHook = fn;
	  }
	}

	function _createCanvas() {
	  var isOnScreenCanvas = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	  var canvas = new Canvas();
	  // helium引擎依赖isSurface上屏/离屏
	  Object.defineProperty(canvas, 'isSurface', {
	    value: isOnScreenCanvas,
	    writable: false,
	    configurable: false
	  });
	  var canvasEncodeFn = canvas.encode;
	  canvas.toTempFilePath = toTempFilePath.bind(canvas, canvasEncodeFn);
	  canvas.toTempFilePathSync = toTempFilePathSync.bind(canvas, canvasEncodeFn);
	  if (canvasEncodeFn) {
	    // IDE 没有 encode 方法
	    canvas.toDataURL = function () {
	      return canvasEncodeFn.call(canvas, 0, 0, canvas.width, canvas.height, canvas.width, canvas.height, 'png', 0, 'data-url');
	    };
	  }
	  canvas.encode = null;
	  !isOnScreenCanvas && canvasCreateHook(canvas); // 主要用于开放数据域拦截getContext使用
	  return canvas;
	}

	function createCanvas() {
	  if (firstCreate) {
	    firstCreate = false;
	    return screenCanvas;
	  }
	  return _createCanvas(false);
	}

	function getScreenCanvas() {
	  return screenCanvas;
	}

	var _handler = function _handler() {};

	function setHandlerForRelationCloudStorage(fn) {
	  if (isFn(fn)) {
	    _handler = fn;
	  }
	}

	/**
	 * @function getCloudStorageByRelation
	 * @description 拉取当前用户所有同玩好友的托管数据。该接口只可在开放数据域下使用
	 * @param {object} param
	 * @param {string} param.type 获取的关系链类型，目前支持的值有 friend(好友)/recommend(可能认识的人)/group(群组)
	 * @param {array} param.keyList 要获取的 key 列表
	 */
	function getCloudStorageByRelation(param) {
	  if (beforeInvoke('getCloudStorageByRelation', param, {
	    type: '',
	    keyList: []
	  })) {
	    invokeMethod('getCloudStorageByRelation', param, {
	      beforeAll: function beforeAll(res) {
	        if (Array.isArray(res.data)) {
	          res.data.forEach(function (v) {
	            _handler(v.avatarUrl);
	          });
	        }
	      }
	    });
	  }
	}

	/**
	 * @function getUserCloudStorage
	 * @description 获取当前用户托管数据当中对应 key 的数据。该接口只可在开放数据域下使用
	 * @param {object} param
	 * @param {array} param.keyList 要获取的 key 列表
	 */
	function getUserCloudStorage(param) {
	  if (beforeInvoke('getUserCloudStorage', param, {
	    keyList: []
	  })) {
	    invokeMethod('getUserCloudStorage', param);
	  }
	}

	/**
	 * @function removeUserCloudStorage
	 * @description 删除用户托管数据当中对应 key 的数据
	 * @param {object} param
	 * @param {array} param.keyList 要获取的 key 列表
	 */
	function removeUserCloudStorage(param) {
	  if (beforeInvoke('removeUserCloudStorage', param, {
	    keyList: []
	  })) {
	    invokeMethod('removeUserCloudStorage', param);
	  }
	}

	/**
	 * @function setUserCloudStorage
	 * @description 对用户托管数据进行写数据操作，允许同时写多组 KV 数据
	 * @param {object} param
	 * @param {array} param.KVDataList 要修改的 KV 数据列表
	 */
	function setUserCloudStorage(param) {
	  if (beforeInvoke('setUserCloudStorage', param, {
	    KVDataList: []
	  })) {
	    invokeMethod('setUserCloudStorage', param);
	  }
	}

	var onTouchStart = exports$1.onTouchStart,
	    offTouchStart = exports$1.offTouchStart,
	    onTouchMove = exports$1.onTouchMove,
	    offTouchMove = exports$1.offTouchMove,
	    onTouchEnd = exports$1.onTouchEnd,
	    offTouchEnd = exports$1.offTouchEnd,
	    onTouchCancel = exports$1.onTouchCancel,
	    offTouchCancel = exports$1.offTouchCancel;

	var openContext = null;
	var openContextURLRule = []; // 用于设置可信 URL 的正则数组
	var openContextTrustedUrlCache = {};

	function setOpenContextTrustedUrlList(url) {
	  if (url && !openContextTrustedUrlCache[url]) {
	    openContextTrustedUrlCache[url] = 1;
	    // url => http://s1.cdn.com/xxx.png?a=123&b=1334
	    // 将 url 中用到的所有 js 正则中的特殊字符加上转义
	    var _url = url.replace(/([\?\.\[\]\\\*\+\:\^\$\(\)\=\|\,\{\}])/g, '\\$1');
	    openContextURLRule.push(new RegExp(_url));
	  }
	}

	setHandlerForRelationCloudStorage(setOpenContextTrustedUrlList);

	var onScreenCanvas = getScreenCanvas();
	var sharedCanvas = null;
	var openContextSharedCanvas = null;

	try {

	  /**
	   * 默认编译出openDataContext.js文件
	   * 此处会提前执行openDataContext.js
	   *
	   * 第一个参数 callback 将在创建 context 后执行
	   *
	   * root 为开放域根对象，可在其上挂载全局对象
	   * sharedCanvas 为开放域共享 canvas
	   * onMessage 为开放域 onMessage 方法
	   * Canvas 为开放域下的Canvas类
	   * Image 为限制了 URL 的 Image 对象
	   * trustedUrlList 为内部信任 URL 的列表，信任则set true
	   *
	   * 第二个参数作为网络请求拦截函数
	   * 引擎内部有几个类型：image / text / arraybuffer / font
	   * 假如通过则返回 true
	   */
	  openContext = createContext && createContext('openDataContext.js', function (root, _ref) {
	    var sharedCanvas = _ref.sharedCanvas,
	        onMessage = _ref.onMessage,
	        Canvas$$1 = _ref.Canvas,
	        Image$$1 = _ref.Image;

	    function _createOpenDataContextCanvas() {
	      var canvas = new Canvas$$1();
	      Object.defineProperty(canvas, 'isSurface', {
	        value: false,
	        writable: false,
	        configurable: false
	      });
	      _wrapGetContext(canvas, {
	        openDataContextDomain: true,
	        subCtxRoot: root
	      });
	      return canvas;
	    }
	    sharedCanvas.getContext('2d'); // 为了获取C++指针
	    openContextSharedCanvas = sharedCanvas;
	    _wrapGetContext(sharedCanvas, {
	      openDataContextDomain: true,
	      isSharedCanvas: true,
	      subCtxRoot: root
	    });
	    function bindFunction(bindFn, bindThis) {
	      var bind = bindFn.bind(bindThis);
	      // 防止通过原型链通信问题
	      bind.__proto__ = root.Function.prototype;
	      return bind;
	    }
	    root.requestAnimationFrame = bindFunction(requestAnimationFrame, root);
	    root.cancelAnimationFrame = bindFunction(cancelAnimationFrame, root);
	    root.setTimeout = bindFunction(setTimeout$1, root);
	    root.clearTimeout = bindFunction(clearTimeout$1, root);
	    root.setInterval = bindFunction(setInterval$1, root);
	    root.clearInterval = bindFunction(clearInterval$1, root);
	    root.console = Object.create(root.Object.prototype);
	    Object.keys(console).forEach(function (fn) {
	      /* eslint-disable no-console */
	      if (typeof console[fn] === 'function') {
	        root.console[fn] = bindFunction(console[fn], root);
	      }
	    });
	    root.wx = root.tt = {
	      getSharedCanvas: function getSharedCanvas() {
	        return sharedCanvas;
	      },

	      onTouchStart: onTouchStart.bind(root.tt),
	      onTouchMove: onTouchMove.bind(root.tt),
	      onTouchEnd: onTouchEnd.bind(root.tt),
	      onTouchCancel: onTouchCancel.bind(root.tt),
	      offTouchStart: offTouchStart.bind(root.tt),
	      offTouchMove: offTouchMove.bind(root.tt),
	      offTouchEnd: offTouchEnd.bind(root.tt),
	      offTouchCancel: offTouchCancel.bind(root.tt),
	      getSystemInfo: getSystemInfo.bind(root.tt),
	      getSystemInfoSync: getSystemInfoSync$1.bind(root.tt),
	      callHostMethod: callHostMethod.bind(root.tt),
	      callHostMethodSync: callHostMethodSync.bind(root.tt),
	      createCanvas: function createCanvas$$1() {
	        return _createOpenDataContextCanvas();
	      },
	      createImage: function createImage() {
	        return new Image$$1();
	      },

	      // get操作只能在开放域下使用
	      getCloudStorageByRelation: getCloudStorageByRelation.bind(root.tt),
	      getUserCloudStorage: getUserCloudStorage.bind(root.tt),
	      setUserCloudStorage: setUserCloudStorage.bind(root.tt),
	      removeUserCloudStorage: removeUserCloudStorage.bind(root.tt),
	      onMessage: onMessage
	    };
	    root.GameGlobal = root;
	    Object.keys(root.tt).forEach(function (key) {
	      if (typeof root.tt[key] === 'function') {
	        // 防止通过原型链通信问题
	        root.tt[key].__proto__ = root.Function.prototype;
	      }
	    });
	  }, function shouldSendRequest(url, type) {
	    // type is one of: image / text / arraybuffer / font
	    return type === 'image' && openContextURLRule.some(function (rule) {
	      return rule.test(url);
	    });
	  });
	} catch (e) {
	  // 当game.json中没有配置openDataContext时
	  // 无法加载到openDataContext.js
	  // 则会报错
	}

	if (openContext) {
	  // 主域中上屏 canvas 以及 sharedCanvas 支持 toTempFilePath / toTempFilePathSync
	  sharedCanvas = openContext.sharedCanvas;
	  var sharedCanvasEncodeFn = openContextSharedCanvas.encode;
	  sharedCanvas.toTempFilePathSync = toTempFilePathSync.bind(sharedCanvas, sharedCanvasEncodeFn);
	  sharedCanvas.toTempFilePath = toTempFilePath.bind(sharedCanvas, sharedCanvasEncodeFn);

	  // 上屏 canvas 不能调用 toDataURL
	  onScreenCanvas.__proto__.toDataURL = onScreenCanvas.toDataURL = function () {
	    console.warn('OnScreenCanvas cannot invoke toDataURL when using openDataContext');
	    return null;
	  };
	  var onScreenCanvasGetCtxFn = onScreenCanvas.getContext;
	  onScreenCanvas.getContext = function (type) {
	    var ctx = onScreenCanvasGetCtxFn.apply(onScreenCanvas, arguments);
	    if (type === '2d') {
	      ctx.getImageData = function () {
	        console.warn('OnScreenCanvas cannot invoke getImageData when using openDataContext');
	        return {
	          data: new Uint8ClampedArray(0),
	          width: 0,
	          height: 0
	        };
	      };
	    }
	    return ctx;
	  };

	  // sharedCanvas 不能调用 toDataURL 和 getContext
	  sharedCanvas.__proto__.toDataURL = sharedCanvas.toDataURL = function () {
	    console.warn('SharedCanvas cannot invoke toDataURL when using openDataContext');
	    return null;
	  };
	  sharedCanvas.getContext = function () {
	    console.warn('SharedCanvas cannot invoke getContext in main domain when using openDataContext');
	    return {};
	  };

	  // 设置canvas创建钩子
	  // 限制主域其他canvas的API
	  setCanvasCreateHook(function (canvas) {
	    _wrapGetContext(canvas);
	  });
	} else {
	  sharedCanvas = _createCanvas();
	}

	/**
	 * 用于包裹 getContext 方法
	 * 限制某些 API 的调用
	 *
	 * 规则如下：
	 * - 不能将上屏 canvas 和 sharedCanvas 以任意形式绘制到其他 canvas 上，
	 *   包括 drawImage、createPattern、texImage2D、texSubImage2D
	 * - sharedCanvas 无法写入除了 onScreenCanvas 的其他 canvas
	 * - onScreenCanvas 无法写入到其他 canvas
	 *
	 * @param {*} canvas
	 */
	function _wrapGetContext(canvas) {
	  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref2$openDataContext = _ref2.openDataContextDomain,
	      openDataContextDomain = _ref2$openDataContext === undefined ? false : _ref2$openDataContext,
	      _ref2$isSharedCanvas = _ref2.isSharedCanvas,
	      isSharedCanvas = _ref2$isSharedCanvas === undefined ? false : _ref2$isSharedCanvas,
	      subCtxRoot = _ref2.subCtxRoot;

	  var getContextFn = canvas.getContext;
	  var ctx = null;
	  var savedType = null;
	  canvas.getContext = function wrapedGetContextFn(type) {
	    if (openDataContextDomain && type !== '2d') {
	      console.error('All canvases in open data domain only support the 2d rendering mode');
	      return {};
	    }
	    if (isSharedCanvas && type !== '2d') {
	      console.error('SharedCanvas only support the 2d rendering mode');
	      return {};
	    }
	    if (type !== '2d' && type !== 'webgl') {
	      console.error('Canvas only support 2d/webgl rendering mode');
	      return {};
	    }
	    if (savedType && type !== savedType) {
	      console.error('Canvas doesnot support multiple different rendering modes');
	      return {};
	    }
	    if (!savedType) {
	      savedType = type;
	    }
	    ctx = ctx ? ctx : getContextFn.apply(canvas, arguments);
	    // 目前引擎内部获取成功后会改写getContext
	    // 这里重新改写一次
	    canvas.getContext = wrapedGetContextFn.bind(canvas);
	    if (subCtxRoot) {
	      canvas.getContext.__proto__ = subCtxRoot.Function.prototype;
	    }
	    if (isSharedCanvas && openDataContextDomain) {
	      return ctx;
	    }
	    var genWarnText = function genWarnText(api) {
	      return console.warn('Can\'t take onScreenCanvas or sharedCanvas as argument of ' + api + ' when using openDataContext');
	    };
	    var isHaveOpenDataCanvas = function isHaveOpenDataCanvas(canvas) {
	      if (openDataContextDomain) {
	        return canvas === openContextSharedCanvas;
	      }
	      return canvas === onScreenCanvas || canvas === openContext.sharedCanvas;
	    };
	    if (type === '2d') {
	      var drawImageFn = ctx.drawImage;
	      var createPatternFn = ctx.createPattern;
	      ctx.drawImage = function (image) {
	        if (isHaveOpenDataCanvas(image)) {
	          genWarnText('drawImage');
	          return;
	        }
	        return drawImageFn.apply(ctx, arguments);
	      };
	      ctx.createPattern = function (image) {
	        if (isHaveOpenDataCanvas(image)) {
	          genWarnText('createPattern');
	          return;
	        }
	        return createPatternFn.apply(ctx, arguments);
	      };
	      if (subCtxRoot) {
	        ctx.drawImage.__proto__ = subCtxRoot.Function.prototype;
	        ctx.createPattern.__proto__ = subCtxRoot.Function.prototype;
	      }
	    }
	    if (type === 'webgl') {
	      var texImage2DFn = ctx.texImage2D;
	      var texSubImage2DFn = ctx.texSubImage2D;
	      ctx.texImage2D = function () {
	        if (arguments.length === 6 && isHaveOpenDataCanvas(arguments[5])) {
	          genWarnText('texImage2D');
	          return;
	        }
	        return texImage2DFn.apply(ctx, arguments);
	      };
	      ctx.texSubImage2D = function () {
	        if (arguments.length === 7 && isHaveOpenDataCanvas(arguments[6])) {
	          genWarnText('texSubImage2D');
	          return;
	        }
	        return texSubImage2DFn.apply(ctx, arguments);
	      };
	      if (subCtxRoot) {
	        ctx.texImage2D.__proto__ = subCtxRoot.Function.prototype;
	        ctx.texSubImage2D.__proto__ = subCtxRoot.Function.prototype;
	      }
	    }
	    return ctx;
	  };
	  if (subCtxRoot) {
	    canvas.getContext.__proto__ = subCtxRoot.Function.prototype;
	  }
	  return canvas.getContext;
	}

	_global$2.sharedCanvas = sharedCanvas;

	function getOpenDataContext() {
	  if (!openContext) {
	    return {
	      canvas: sharedCanvas,
	      postMessage: function postMessage() {}
	    };
	  }
	  return {
	    canvas: openContext.sharedCanvas,
	    postMessage: openContext.postMessage
	  };
	}

	/**
	 * @function getUserInfo
	 * @description 获取用户信息
	 * @param {object} param
	 * @param {getUserInfoSuccessCallback} [param.success] 执行成功的回调方法
	 *
	 */
	function getUserInfo() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('getUserInfo', param, {
	    beforeSuccess: function beforeSuccess(res) {
	      if (res && res.userInfo && res.userInfo.avatarUrl) {
	        setOpenContextTrustedUrlList(res.userInfo.avatarUrl);
	      }
	    }
	  });
	}

	/**
	 * getUserInfo success callback
	 * @callback getUserInfoSuccessCallback
	 * @param {object} response
	 * @param {object} response.userInfo 用户信息对象，不包含 openid 等敏感信息
	 * @param {string} response.rawData 不包括敏感信息的原始数据字符串，用于计算签名。
	 * @param {string} response.signature 使用 sha1( rawData + sessionkey ) 得到字符串
	 * @param {string} response.encryptedData 包括敏感数据在内的完整用户信息的加密数据
	 * @param {string} response.iv 加密算法的初始向量
	 */

	function createImage() {
	    return new Image();
	}

	function getMenuButtonBoundingClientRect() {
	  var ret = {};
	  invokeMethod('getMenuButtonBoundingClientRect', {
	    success: function success(res) {
	      // 适配微信的按钮布局
	      res.top = Math.max(res.top - 8, 0);
	      ret = res;
	    },
	    fail: function fail(err) {
	      throw new Error(err.errMsg);
	    }
	  });
	  return ret;
	}

	function getMenuButtonLayout() {
	  var ret = {};
	  invokeMethod('getMenuButtonBoundingClientRect', {
	    success: function success(res) {
	      ret = res;
	    },
	    fail: function fail(err) {
	      err.errMsg = err.errMsg.replace('BoundingClientRect', 'Layout');
	      throw new Error(err.errMsg);
	    }
	  });
	  return ret;
	}

	function setMenuStyle() {
	  logger.warn('Not support tt.setMenuStyle');
	  return false;
	}

	function setStatusBarStyle() {
	  logger.warn('Not support tt.setStatusBarStyle');
	  return false;
	}

	function setRankData() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (!isFn(param.fail)) {
	    param.fail = function () {};
	  }

	  if (!isFn(param.success)) {
	    param.success = function () {};
	  }

	  invokeMethod('setRankData', _extends({}, param, {
	    success: function success(res) {
	      if (res.result) {
	        try {
	          var response = JSON.parse(res.result);
	          if (response.error === 0) {
	            return param.success(response.data);
	          } else {
	            param.fail(_extends({}, response, { errMsg: 'setRankData:fail' }));
	          }
	        } catch (e) {
	          param.fail(_extends({}, e, { errMsg: 'setRankData:fail' }));
	        }
	      } else {
	        param.fail(_extends({}, res, { errMsg: 'setRankData:fail' }));
	      }
	    },
	    fail: function fail(e) {
	      param.fail(e);
	    }
	  }));
	}

	function getRankData() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (!isFn(param.fail)) {
	    param.fail = function () {};
	  }

	  if (!isFn(param.success)) {
	    param.success = function () {};
	  }

	  invokeMethod('getRankData', _extends({}, param, {
	    success: function success(res) {
	      if (res.result) {
	        try {
	          var response = JSON.parse(res.result);
	          if (response.error === 0) {
	            return param.success(response.data);
	          } else {
	            param.fail(_extends({}, response, { errMsg: 'getRankData:fail' }));
	          }
	        } catch (e) {
	          param.fail(_extends({}, e, { errMsg: 'getRankData:fail' }));
	        }
	      } else {
	        param.fail(_extends({}, res, { errMsg: 'getRankData:fail' }));
	      }
	    },
	    fail: function fail(e) {
	      param.fail(e);
	    }
	  }));
	}

	function FaceDetector() {

	  function range(start, end) {
	    return {
	      map: function map(cb) {
	        var arr = [];
	        for (var i = start; i <= end; i++) {
	          arr[i - start] = cb(i);
	        }
	        return arr;
	      }
	    };
	  }
	  var landmark_points = [{ type: 'face', offsets: range(0, 32) }, { type: 'eyebow', offsets: [33, 34, 35, 36, 37, 64, 65, 66, 67] }, { type: 'eyebow', offsets: [38, 39, 40, 41, 42, 68, 69, 70, 71] }, { type: 'eye', offsets: [52, 53, 54, 55, 56, 57, 72, 73, 74] }, { type: 'eye', offsets: [58, 59, 60, 61, 62, 63, 75, 76, 77] }, { type: 'nose', offsets: [43, 44, 45, 46, 47, 48, 49, 50, 51, 78, 79, 80, 81, 82, 83] }, { type: 'mouth', offsets: range(84, 103) }];

	  this.detect = function (img) {
	    var handle = effect.createFaceHandle();
	    var buf = new ArrayBuffer(2048),
	        f32 = new Float32Array(buf),
	        i32 = new Int32Array(buf);

	    this.detect = function (img) {
	      return new Promise(function (resolve) {
	        return effect.detectFaces(img._ptr, handle, buf, function (faces) {
	          // face: [id, score, action, _padding[7], ...rect, ...points]
	          var arr = [];

	          var _loop = function _loop(i, offset) {
	            var action = i32[offset + 2];
	            arr[i] = {
	              id: i32[offset],
	              score: f32[offset + 1],
	              actions: action && {
	                blink: action >> 1 & 1, // 眨眼
	                mouth_ah: action >> 2 & 1, // 嘴巴大张
	                head_yaw: action >> 3 & 1, // 摇头
	                head_pitch: action >> 4 & 1, // 点头
	                brow_jump: action >> 5 & 1, // 眉毛挑动
	                mouth_pout: action >> 6 & 1 // 嘴巴嘟嘟
	              },
	              boundingBox: {
	                x: i32[offset + 12],
	                y: i32[offset + 13],
	                width: i32[offset + 14] - i32[offset + 12],
	                height: i32[offset + 15] - i32[offset + 13],
	                left: i32[offset + 12],
	                top: i32[offset + 13],
	                right: i32[offset + 14],
	                bottom: i32[offset + 15]
	              },
	              landmarks: landmark_points.map(function (_ref) {
	                var type = _ref.type,
	                    offsets = _ref.offsets;
	                return {
	                  type: type,
	                  locations: offsets.map(function (idx) {
	                    return { x: f32[(idx << 1) + offset + 16], y: f32[(idx << 1) + offset + 17] };
	                  })
	                };
	              })
	            };
	          };

	          for (var i = 0, offset = 0; i < faces; i++, offset += 256) {
	            _loop(i, offset);
	          }
	          resolve(arr);
	        });
	      });
	    };

	    return this.detect(img);
	  };
	}

	function createFaceDetector() {
	  return new FaceDetector();
	}

	var requestCamera = function requestCamera(face, beautify) {
	  return new Promise(function (resolve, reject) {
	    var flags = media.VIDEO | media.EXACT;
	    if (face === 'back') {
	      flags |= media.BACK;
	    } else {
	      flags |= media.FRONT;
	    }

	    if (beautify) {
	      flags |= media.BEAUTIFY;
	    }

	    media.request(flags, function (media$$1) {
	      if (media$$1) {
	        resolve(media$$1);
	      } else {
	        reject(new Error('open camera failed'));
	      }
	    });
	  });
	};

	function createOffscreenVideo() {
	  return new Video();
	}

	// usage:
	// tt.requestCamera().then(media => {
	//     const video = tt.createOffscreenVideo();
	//     video.srcObject = media;
	//     video.play();
	//     const face_detector = tt.createFaceDetector();
	// });

	function requestGamePayment() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  beforeInvoke('requestGamePayment', param, {
	    mode: '',
	    env: 0,
	    currencyType: '',
	    platform: '',
	    buyQuantity: 1
	  }) && invokeMethod('requestGamePayment', param);
	}

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	var ms = function ms(val, options) {
	  options = options || {};
	  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

	createDebug.debug = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = ms;

	/**
	 * Active `debug` instances.
	 */
	createDebug.instances = [];

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	createDebug.names = [];
	createDebug.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */

	createDebug.formatters = {};

	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */

	function selectColor(namespace) {
	  var hash = 0,
	      i;

	  for (i in namespace) {
	    hash = (hash << 5) - hash + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }

	  return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function createDebug(namespace) {

	  var prevTime;

	  function debug() {
	    // disabled?
	    if (!_global$2.__FORCE_LOG__ && !debug.enabled) {
	      return;
	    }

	    var self = debug;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms$$1 = curr - (prevTime || curr);
	    self.diff = ms$$1;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    args[0] = createDebug.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') {
	        return match;
	      }
	      index++;
	      var formatter = createDebug.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    // apply env-specific formatting (colors, etc.)
	    createDebug.formatArgs.call(self, args);

	    var logFn = debug.log || createDebug.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }

	  debug.namespace = namespace;
	  debug.enabled = createDebug.enabled(namespace);
	  debug.useColors = createDebug.useColors();
	  debug.color = selectColor(namespace);
	  debug.destroy = destroy;

	  // env-specific initialization logic for debug instances
	  if ('function' === typeof createDebug.init) {
	    createDebug.init(debug);
	  }

	  createDebug.instances.push(debug);

	  return debug;
	}

	function destroy() {
	  var index = createDebug.instances.indexOf(this);
	  if (index !== -1) {
	    createDebug.instances.splice(index, 1);
	    return true;
	  } else {
	    return false;
	  }
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  createDebug.save(namespaces);

	  createDebug.names = [];
	  createDebug.skips = [];

	  var i;
	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;

	  for (i = 0; i < len; i++) {
	    if (!split[i]) {
	      continue;
	    } // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      createDebug.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }

	  for (i = 0; i < createDebug.instances.length; i++) {
	    var instance = createDebug.instances[i];
	    instance.enabled = createDebug.enabled(instance.namespace);
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  createDebug.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  if (name[name.length - 1] === '*') {
	    return true;
	  }
	  var i, len;
	  for (i = 0, len = createDebug.skips.length; i < len; i++) {
	    if (createDebug.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = createDebug.names.length; i < len; i++) {
	    if (createDebug.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) {
	    return val.stack || val.message;
	  }
	  return val;
	}

	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	createDebug.log = log$1;
	createDebug.formatArgs = formatArgs;
	createDebug.save = save;
	createDebug.load = load;
	createDebug.useColors = useColors;
	createDebug.storage = localstorage();

	/**
	 * Colors.
	 */

	createDebug.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }

	  // Internet Explorer and Edge do not support colors.
	  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	    return false;
	  }

	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table)
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31
	  // double check webkit in userAgent just in case we are in a worker
	  || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	createDebug.formatters.j = function (v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};

	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + createDebug.humanize(this.diff);

	  if (!useColors) {
	    return;
	  }

	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit');

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function (match) {
	    if ('%%' === match) {
	      return;
	    }
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log$1() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      createDebug.storage.debug = '';
	    } else {
	      createDebug.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  return '*TMA*';
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	createDebug.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
	  var g = typeof window === 'undefined' ? _global$2 : window;
	  try {
	    /* eslint-disable no-return-assign */
	    return g.__DEBUG_NAMESPACE ? g.__DEBUG_NAMESPACE : g.__DEBUG_NAMESPACE = {};
	  } catch (e) {}
	}

	var TYPE = 'RUNTIME';
	var app = 'TMA';

	// let debug = debug(`[${app}][DEBUG][${TYPE}]`);
	// let trace = debug(`[${app}][TRACE][${TYPE}]`);
	// let log = debug(`[${app}][LOG][${TYPE}]`);
	// let info = debug(`[${app}][INFO][${TYPE}]`);
	// let warn = debug(`[${app}][WARN][${TYPE}]`);
	// let error = debug(`[${app}][ERROR][${TYPE}]`);

	// const logMethod = ['debug', 'group', 'groupEnd', 'trace', 'log', 'info', 'warn', 'error', 'time', 'timeEnd'];
	var allMethod = [];
	for (var i$2 in console) {
	  allMethod.push(i$2);
	}

	/* eslint-disable no-console */
	var logMethod = allMethod.filter(function (method) {
	  return typeof console[method] === 'function';
	});

	var logger$1 = {};

	logMethod.forEach(function (method) {
	  logger$1[method] = createDebug('[' + app + '][' + method.toUpperCase() + '][' + TYPE + ']');
	  /* eslint-disable no-console */
	  logger$1[method].log = console[method].bind(console);
	});

	// import global from '../global';
	// global.logger = logger;
	logger = logger$1;

	var emitter$5 = new EventEmitter();
	var exports$2 = {};
	var eventTypes = ['input', 'confirm', 'complete'];

	eventTypes.forEach(function (evt) {
	  var _evt = 'onKeyboard' + evt.charAt(0).toUpperCase() + evt.slice(1);

	  onMethod(_evt, surroundByTryCatchFactory(function (e) {
	    emitter$5.emit(evt, e);
	  }, 'at api ' + _evt + ' callback function'));

	  exports$2[_evt] = function (cb) {
	    if (isFn(cb)) {
	      emitter$5.on(evt, cb);
	    } else {
	      throw new ThirdScriptTypeError('callback must be a function');
	    }
	  };

	  exports$2[_evt.replace('on', 'off')] = function (cb) {
	    cb ? emitter$5.off(evt, cb) : emitter$5.removeAllListeners(evt);
	  };
	});

	var ConfirmTypes = ['done', 'next', 'search', 'go', 'send'];

	exports$2.showKeyboard = function () {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('showKeyboard', param, {
	    defaultValue: '',
	    maxLength: 1,
	    multiple: false,
	    confirmHold: false,
	    confirmType: ''
	  })) {
	    var defaultValue = param.defaultValue,
	        maxLength = param.maxLength;

	    if (defaultValue && maxLength) {
	      var len = ~~maxLength;
	      param.defaultValue = defaultValue.slice(0, len);
	    }

	    if (ConfirmTypes.indexOf(param.confirmType) === -1) {
	      beforeInvokeFail('showKeyboard', param, 'invalid confirmType "' + param.confirmType + '"');
	    } else {
	      invokeMethod('showKeyboard', param, {});
	    }
	  }
	};

	exports$2.hideKeyboard = function () {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('hideKeyboard', param, {});
	};

	exports$2.updateKeyboard = function () {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('updateKeyboard', param, {});
	};

	var emitter$6 = new EventEmitter();
	var eList$1 = ['show', 'hide', 'windowResize', 'deviceOrientationChange'];
	var defaultLaunchOptions = {
	  scene: -1,
	  query: ''
	  // isSticky: false,
	  // shareTicket: '',
	  // referrerInfo: {
	  //   appId: '',
	  //   extraData: {},
	  // },
	};

	var exports$3 = {
	  exitMiniProgram: function exitMiniProgram() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('exitMiniProgram', param);
	  },
	  getLaunchOptionsSync: function getLaunchOptionsSync() {
	    var ret = Object.assign({}, defaultLaunchOptions);
	    invokeMethod('getLaunchOptionsSync', {
	      success: function success(res) {
	        // if (res.query && typeof res.query === 'string') {
	        //   try {
	        //     res.query = JSON.parse(decodeURIComponent(res.query));
	        //   } catch (e) {}
	        // }
	        Object.assign(ret, res);
	      },
	      fail: function fail(err) {
	        throw new Error(err.errMsg);
	      }
	    });
	    return ret;
	  }
	};

	onMethod('onAppLaunch', function () {
	  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  Object.assign(defaultLaunchOptions, e);
	});

	onMethod('onAppEnterForeground', surroundByTryCatchFactory(function () {
	  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var res = Object.assign({}, defaultLaunchOptions, e);
	  defaultLaunchOptions.query = '';
	  // if (res.query && typeof res.query === 'string') {
	  //   try {
	  //     res.query = JSON.parse(decodeURIComponent(res.query));
	  //   } catch (e) {}
	  // } else {
	  //   res.query = {};
	  // }
	  emitter$6.emit('show', res);
	}, 'at api onShow callback function'));

	onMethod('onAppEnterBackground', surroundByTryCatchFactory(function () {
	  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  emitter$6.emit('hide', e);
	}, 'at api onHide callback function'));

	// 端上暂未支持
	onMethod('onWindowResize', function () {
	  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  emitter$6.emit('windowResize', e);
	});
	// 端上暂未支持
	onMethod('onDeviceOrientationChange', function () {
	  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  emitter$6.emit('deviceOrientationChange', e);
	});

	eList$1.forEach(function (e) {
	  var m = e.charAt(0).toUpperCase() + e.slice(1);
	  exports$3['on' + m] = function (cb) {
	    if (isFn(cb)) {
	      emitter$6.on(e, cb);
	    } else {
	      throw new ThirdScriptTypeError('callback must be a function');
	    }
	  };

	  exports$3['off' + m] = function (cb) {
	    cb ? emitter$6.off(e, cb) : emitter$6.removeAllListeners(e);
	  };
	});

	// 参考微信暂时使用一个变量存储回调，取消监听时置为null即可
	var noop$1 = function noop$$1() {};
	var onShareAppMessageCallback = noop$1;

	function showShareMenu() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('showShareMenu', param, {});
	}

	function hideShareMenu() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('hideShareMenu', param, {});
	}

	function getShareInfo() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('getShareInfo', param, {});
	}

	function checkShareData(data) {
	  var info = Object.assign({}, data);

	  if (info.query && typeof info.query !== 'string') {
	    throw new ThirdScriptTypeError('query must be a string.');
	  }

	  if (info.query) {
	    var query = {};
	    info.query.split('&').forEach(function (v) {
	      var tmp = v.split('=');
	      query[tmp[0]] = tmp[1];
	    });
	    info.query = encodeURIComponent(JSON.stringify(query));
	  }

	  return info;
	}

	onMethod('onShareAppMessage', function (res) {
	  shareAppMessage(function (originalParam) {
	    var custom = onShareAppMessageCallback(originalParam);

	    if ((typeof custom === 'undefined' ? 'undefined' : _typeof(custom)) !== 'object' || custom === null) {
	      custom = {};
	    }

	    // 保护客户端传递给开发者的channel值不会被修改
	    // 因为checkShareData已经丢失原始参数只能选择在此处处理
	    if ((typeof originalParam === 'undefined' ? 'undefined' : _typeof(originalParam)) === 'object' && originalParam !== null && 'channel' in originalParam) {
	      custom.channel = originalParam.channel;
	    }

	    return custom;
	  }(res));
	});

	function onShareAppMessage(cb) {
	  if (typeof cb !== 'function') {
	    throw new ThirdScriptTypeError('param must be a function.');
	  }
	  onShareAppMessageCallback = cb;
	}

	function offShareAppMessage(cb) {
	  onShareAppMessageCallback = noop$1;
	}

	function shareAppMessage() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('shareAppMessageDirectly', checkShareData(param), {});
	}

	function updateShareMenu() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('updateShareMenu', param);
	}

	function shareVideo() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var info = Object.assign({}, param);

	  if (info.query && typeof info.query !== 'string') {
	    throw new ThirdScriptTypeError('query must be a string.');
	  }

	  if (info.query) {
	    var query = {};
	    info.query.split('&').forEach(function (v) {
	      var tmp = v.split('=');
	      query[tmp[0]] = tmp[1];
	    });
	    info.query = encodeURIComponent(JSON.stringify(query));
	  }

	  if (info.extra) {
	    info.extra.query = info.query;
	    info.extra.title = info.title;
	  }

	  delete info.title;
	  delete info.query;

	  invokeMethod('shareVideo', _extends({}, info));
	}

	var sns = /*#__PURE__*/Object.freeze({
		showShareMenu: showShareMenu,
		hideShareMenu: hideShareMenu,
		getShareInfo: getShareInfo,
		onShareAppMessage: onShareAppMessage,
		offShareAppMessage: offShareAppMessage,
		shareAppMessage: shareAppMessage,
		updateShareMenu: updateShareMenu,
		shareVideo: shareVideo
	});

	var EncodeTypes = ['ascii', 'base64', 'binary', 'hex', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'utf-8', 'utf8', 'latin1'];

	var Stats = function () {
	  function Stats(_ref) {
	    var _ref$mode = _ref.mode,
	        mode = _ref$mode === undefined ? 0 : _ref$mode,
	        _ref$size = _ref.size,
	        size = _ref$size === undefined ? 0 : _ref$size,
	        _ref$lastAccessedTime = _ref.lastAccessedTime,
	        lastAccessedTime = _ref$lastAccessedTime === undefined ? '' : _ref$lastAccessedTime,
	        _ref$lastModifiedTime = _ref.lastModifiedTime,
	        lastModifiedTime = _ref$lastModifiedTime === undefined ? '' : _ref$lastModifiedTime;
	    classCallCheck(this, Stats);

	    this.mode = mode;
	    this.size = size;
	    this.lastAccessedTime = lastAccessedTime;
	    this.lastModifiedTime = lastModifiedTime;
	  }

	  Stats.prototype._checkModeProperty = function _checkModeProperty(type) {
	    return (61440 & this.mode) === type;
	  };

	  Stats.prototype.isFile = function isFile() {
	    return this._checkModeProperty(32768);
	  };

	  Stats.prototype.isDirectory = function isDirectory() {
	    return this._checkModeProperty(16384);
	  };

	  return Stats;
	}();

	var FileSystemManager = function () {
	  function FileSystemManager() {
	    classCallCheck(this, FileSystemManager);
	  }

	  // 获取文件信息
	  FileSystemManager.prototype.getFileInfo = function getFileInfo() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('getFileInfo', param, { filePath: '' }) && invokeMethod('getFileInfo', param);
	  };

	  // 获取本地缓存文件列表


	  FileSystemManager.prototype.getSavedFileList = function getSavedFileList() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('getSavedFileList', param);
	  };

	  // 删除本地缓存文件


	  FileSystemManager.prototype.removeSavedFile = function removeSavedFile() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('removeSavedFile', param, { filePath: '' }) && invokeMethod('removeSavedFile', param);
	  };

	  // 保存临时文件


	  FileSystemManager.prototype.saveFile = function saveFile() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('saveFile', param, {
	      tempFilePath: ''
	    }) && invokeMethod('saveFile', param);
	  };

	  FileSystemManager.prototype.saveFileSync = function saveFileSync(tempFilePath, filePath) {
	    if (!tempFilePath || typeof tempFilePath !== 'string') {
	      throw new TypeError('tempFilePath must be a string');
	    }
	    var errMsg = void 0;
	    var result = void 0;
	    invokeMethod('saveFileSync', {
	      tempFilePath: tempFilePath,
	      filePath: filePath,
	      success: function success(res) {
	        result = res.savedFilePath;
	      },
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	    return result;
	  };

	  // 读文件


	  FileSystemManager.prototype.readFile = function readFile() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('readFile', param, {
	      filePath: ''
	    }) && invokeMethod('readFile', param);
	  };

	  FileSystemManager.prototype.readFileSync = function readFileSync(filePath, encoding) {
	    if (!filePath || typeof filePath !== 'string') {
	      throw new TypeError('filePath must be a string');
	    }
	    if (encoding && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string');
	    }
	    var params = { filePath: filePath };
	    var errMsg = void 0,
	        res = void 0;
	    if (encoding) {
	      params.encoding = encoding;
	    }
	    invokeMethod('readFileSync', _extends({}, params, {
	      success: function success(e) {
	        res = e.data;
	      },
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    }));
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	    return res;
	  };

	  // 写文件


	  FileSystemManager.prototype.writeFile = function writeFile() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


	    if (beforeInvoke('writeFile', param, {
	      filePath: ''
	    })) {
	      param.encoding && EncodeTypes.indexOf(param.encoding) === -1 ? beforeInvokeFail('writeFile', param, 'invalid encoding "' + param.encoding + '"') : invokeMethod('writeFile', param, {});
	    }
	  };

	  FileSystemManager.prototype.writeFileSync = function writeFileSync(filePath, data, encoding) {
	    if (!filePath || typeof filePath !== 'string') {
	      throw new TypeError('filePath must be a string');
	    }
	    if (encoding && EncodeTypes.indexOf(encoding) === -1) {
	      throw new Error('invalid encoding "' + encoding + '"');
	    }
	    var errMsg = void 0;
	    invokeMethod('writeFileSync', {
	      filePath: filePath,
	      data: data,
	      encoding: encoding,
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	  };

	  // 创建目录


	  FileSystemManager.prototype.mkdir = function mkdir() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('mkdir', param, {
	      dirPath: ''
	    }) && invokeMethod('mkdir', param);
	  };

	  FileSystemManager.prototype.mkdirSync = function mkdirSync(dirPath) {
	    if (!dirPath || typeof dirPath !== 'string') {
	      throw new TypeError('dirPath must be a string');
	    }
	    var errMsg = void 0;
	    invokeMethod('mkdirSync', {
	      dirPath: dirPath,
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	  };

	  // 读目录


	  FileSystemManager.prototype.readdir = function readdir() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('readdir', param, {
	      dirPath: ''
	    }) && invokeMethod('readdir', param);
	  };

	  FileSystemManager.prototype.readdirSync = function readdirSync(dirPath) {
	    if (!dirPath || typeof dirPath !== 'string') {
	      throw new TypeError('dirPath must be a string');
	    }
	    var errMsg = void 0,
	        res = void 0;
	    invokeMethod('readdirSync', {
	      dirPath: dirPath,
	      success: function success(e) {
	        res = e.files;
	      },
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	    return res;
	  };

	  // 删除目录


	  FileSystemManager.prototype.rmdir = function rmdir() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { recursive: false };

	    beforeInvoke('rmdir', param, {
	      dirPath: ''
	    }) && invokeMethod('rmdir', param);
	  };

	  FileSystemManager.prototype.rmdirSync = function rmdirSync(dirPath) {
	    var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    if (!dirPath || typeof dirPath !== 'string') {
	      throw new TypeError('dirPath must be a string');
	    }
	    var errMsg = void 0;
	    invokeMethod('rmdirSync', {
	      dirPath: dirPath,
	      recursive: recursive,
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	  };

	  // 判断文件/目录是否存在


	  FileSystemManager.prototype.access = function access() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    var regexp = /^(ttfile|http):\/\/(user|temp)$/;
	    if (regexp.test(param.path)) {
	      param.path += '/';
	    }
	    beforeInvoke('access', param, {
	      path: ''
	    }) && invokeMethod('access', param);
	  };

	  FileSystemManager.prototype.accessSync = function accessSync(path) {
	    if (!path || typeof path !== 'string') {
	      throw new TypeError('path must be a string');
	    }
	    var regexp = /^(ttfile|http):\/\/(user|temp)$/;
	    if (regexp.test(path)) {
	      path += '/';
	    }
	    var errMsg = void 0;
	    invokeMethod('accessSync', {
	      path: path,
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	  };

	  // 删除文件


	  FileSystemManager.prototype.unlink = function unlink() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('unlink', param, {
	      filePath: ''
	    }) && invokeMethod('unlink', param);
	  };

	  FileSystemManager.prototype.unlinkSync = function unlinkSync(filePath) {
	    if (!filePath || typeof filePath !== 'string') {
	      throw new TypeError('filePath must be a string');
	    }
	    var errMsg = void 0;
	    invokeMethod('unlinkSync', {
	      filePath: filePath,
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	  };

	  // 获取文件 Stats 对象


	  FileSystemManager.prototype.stat = function stat() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('stat', param, {
	      path: ''
	    }) && invokeMethod('stat', param, {
	      beforeSuccess: function beforeSuccess(e) {
	        e.stat = new Stats(e.stat);
	        // delete e.mode;
	        // delete e.size;
	        // delete e.lastAccessedTime;
	        // delete e.lastModifiedTime;
	      }
	    });
	  };

	  FileSystemManager.prototype.statSync = function statSync(path) {
	    if (!path || typeof path !== 'string') {
	      throw new TypeError('path must be a string');
	    }
	    var errMsg = void 0,
	        res = void 0;
	    invokeMethod('statSync', {
	      path: path,
	      success: function success(e) {
	        res = new Stats(e.stat);
	      },
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	    return res;
	  };

	  // 重命名文件


	  FileSystemManager.prototype.rename = function rename() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('rename', param, {
	      oldPath: '',
	      newPath: ''
	    }) && invokeMethod('rename', param);
	  };

	  FileSystemManager.prototype.renameSync = function renameSync(oldPath, newPath) {
	    if (!oldPath || typeof oldPath !== 'string') {
	      throw new TypeError('oldPath must be a string');
	    }
	    if (!newPath || typeof newPath !== 'string') {
	      throw new TypeError('newPath must be a string');
	    }
	    var errMsg = void 0;
	    invokeMethod('renameSync', {
	      oldPath: oldPath,
	      newPath: newPath,
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	  };

	  // 复制文件


	  FileSystemManager.prototype.copyFile = function copyFile() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('copyFile', param, {
	      srcPath: '',
	      destPath: ''
	    }) && invokeMethod('copyFile', param);
	  };

	  FileSystemManager.prototype.copyFileSync = function copyFileSync(srcPath, destPath) {
	    if (!srcPath || typeof srcPath !== 'string') {
	      throw new TypeError('srcPath must be a string');
	    }
	    if (!destPath || typeof destPath !== 'string') {
	      throw new TypeError('destPath must be a string');
	    }
	    var errMsg = void 0;
	    invokeMethod('copyFileSync', {
	      srcPath: srcPath,
	      destPath: destPath,
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });
	    if (errMsg) {
	      throw new Error(errMsg);
	    }
	  };

	  // 解压文件


	  FileSystemManager.prototype.unzip = function unzip() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    beforeInvoke('unzip', param, {
	      zipFilePath: '',
	      targetPath: ''
	    }) && invokeMethod('unzip', param, {});
	  };

	  return FileSystemManager;
	}();

	var fs = new FileSystemManager();

	function getFileSystemManager() {
	  return fs;
	}
	var saveFile = fs.saveFile;
	var getFileInfo = fs.getFileInfo;
	var getSavedFileList = fs.getSavedFileList;
	var removeSavedFile = fs.removeSavedFile;

	var enable$1 = false;
	var listeners$1 = [];

	function startAccelerometer() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  enable$1 = true;

	  invokeMethod('enableAccelerometer', _extends({}, param, {
	    enable: enable$1
	  }), {
	    beforeAll: function beforeAll(res) {
	      res.errMsg = res.errMsg.replace('enableAccelerometer', 'startAccelerometer');
	    }
	  });
	}

	function stopAccelerometer() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  enable$1 = false;

	  invokeMethod('enableAccelerometer', _extends({}, param, { enable: enable$1 }), _extends({}, param, {
	    beforeAll: function beforeAll(res) {
	      res.errMsg = res.errMsg.replace('enableAccelerometer', 'stopAccelerometer');
	    }
	  }));
	}

	function onAccelerometerChange(cb) {
	  if (typeof cb !== 'function') {
	    return;
	  }

	  if (!enable$1) {
	    enable$1 = true;

	    invokeMethod('enableAccelerometer', { enable: enable$1 });
	  }

	  listeners$1.push(surroundByTryCatchFactory(cb, 'onAccelerometerChange'));
	}

	onMethod('onAccelerometerChange', function () {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  for (var i in listeners$1) {
	    listeners$1[i](param);
	  }
	});

	var listeners$2 = [];
	var enableCompass = false;

	onMethod('onCompassChange', function () {
	  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  listeners$2.forEach(function (fn) {
	    'function' === typeof fn && fn(e);
	  });
	});

	function onCompassChange(cb) {
	  enableCompass || (invokeMethod('startCompass', {}), enableCompass = true);
	  if ('function' === typeof cb) {
	    listeners$2.push(Reporter.surroundThirdByTryCatch(cb, 'onCompassChange'));
	  }
	}

	function startCompass() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('startCompass', param);
	  enableCompass = true;
	}

	function stopCompass() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('stopCompass', param);
	  enableCompass = false;
	}

	var performance = {
	  now: function now() {
	    // 单位：微妙
	    return NativeGlobal.performanceNow() * 1000;
	  }
	};

	function triggerGC() {
	  gc();
	}

	function getPerformance() {
	  return performance;
	}

	var emitter$7 = new EventEmitter();

	var exports$4 = {};
	var eList$2 = ['audioInterruptionEnd', 'audioInterruptionBegin'];

	eList$2.forEach(function (evt) {
	  onMethod(evt, function () {
	    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    emitter$7.emit(evt, e);
	  });

	  var m = evt.charAt(0).toUpperCase() + evt.slice(1);

	  exports$4['on' + m] = function (cb) {
	    if (isFn(cb)) {
	      emitter$7.on(evt, surroundByTryCatchFactory(cb, 'at on' + m + ' callback function'));
	    } else {
	      throw new ThirdScriptTypeError('callback must be a function');
	    }
	  };

	  exports$4['off' + m] = function (cb) {
	    cb ? emitter$7.off(evt, cb) : emitter$7.removeAllListeners(evt);
	  };
	});

	Reporter.registerErrorListener(function (e) {
	  emitter$7.emit('_error', { message: e, stack: '' });
	});

	if (_global$2.TMAConfig.platform === 'android') {
	  _global$2.__onerror__ = function (e) {
	    Reporter.thirdErrorReport({ error: e, extend: '' });
	  };
	} else {
	  onMethod('_error', function () {
	    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    Reporter.thirdErrorReport({ error: e, extend: '' });
	  });
	}

	exports$4.onError = function (cb) {
	  emitter$7.on('_error', cb);
	};

	exports$4.offError = function (cb) {
	  cb ? emitter$7.off('_error', cb) : emitter$7.removeAllListeners('_error');
	};

	// global console

	var MAX_CONCURRENT = 1;
	var workerMap = new Map();
	// eslint-disable-next-line no-console
	var _console = console;

	var Worker = function () {
	  function Worker(worker, script) {
	    classCallCheck(this, Worker);

	    workerMap.set(this, worker);
	    this.postMessage({
	      __type__: 'requireScript',
	      __content__: script
	    });
	  }

	  Worker.prototype.onMessage = function onMessage(cb) {
	    var _this = this;

	    var _cb = surroundByTryCatchFactory(cb, 'at worker.onMessage');

	    surroundByTryCatch(function () {
	      workerMap.get(_this).onMessage(function (msg) {
	        // console.log('sdk receive: ', msg);
	        var _msg = NativeBuffer.unpack(msg);
	        switch (_msg.__type__) {
	          case 'error':
	            _console.error(_msg.__content__);
	            break;
	          case 'console':
	            _console[_msg.__mtd__] && _console[_msg.__mtd__].apply(_console, _msg.__content__.map(NativeBuffer.unpack));
	            break;
	          default:
	            _cb(_msg);
	            break;
	        }
	      });
	    }, 'worker')();
	  };

	  Worker.prototype.postMessage = function postMessage(msg) {
	    var _this2 = this;

	    surroundByTryCatch(function () {
	      // console.log('sdk post:', msg);
	      if (Object.prototype.toString.call(msg) !== '[object Object]') {
	        throw new ThirdScriptTypeError('param must be a object');
	      }
	      if (msg.__type__) {
	        workerMap.get(_this2).postMessage(msg);
	      } else {
	        // console.log('beforePost', NativeBuffer.pack(msg));
	        workerMap.get(_this2).postMessage({
	          __type__: 'common',
	          __content__: NativeBuffer.pack(msg)
	        });
	      }
	    }, 'at worker.postMessage')();
	  };

	  Worker.prototype.terminate = function terminate() {
	    var _this3 = this;

	    surroundByTryCatch(function () {
	      workerMap.get(_this3).terminate();
	      workerMap.delete(_this3);
	    }, 'worker.terminate')();
	  };

	  return Worker;
	}();

	function createWorker$1(script) {
	  if (workerMap.size >= MAX_CONCURRENT) {
	    throw new ThirdScriptError('createWorker: exceed max concurrent workers limit.');
	  }

	  var worker = createWorker('workers.js');

	  if (worker) {
	    return new Worker(worker, script);
	  }

	  throw new Error('createWorker: Worker "' + script + '" does not exists.');
	}

	var eventEmitter = new EventEmitter();
	var VALID_RATES = {
	  8000: [16000, 48000],
	  11025: [16000, 48000],
	  12000: [24000, 64000],
	  16000: [24000, 96000],
	  22050: [32000, 128000],
	  24000: [32000, 128000],
	  32000: [48000, 192000],
	  44100: [64000, 320000],
	  48000: [64000, 320000]
	};
	var VALID_SAMPLE_RATES = Object.keys(VALID_RATES).map(function (rate) {
	  return parseInt(rate);
	});

	onMethod('onRecorderStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var state = res.state;
	  delete res.state;
	  eventEmitter.emit('onRecorderStateChange_' + state, res);
	});

	function operateRecorder(param) {
	  invokeMethod('operateRecorder', Object.assign({}, param));
	}

	var RecorderManager = {
	  start: function start() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    var invokeParam = Object.assign({
	      format: 'aac',
	      sampleRate: 8000,
	      encodeBitRate: 48000,
	      numberOfChannels: 2,
	      duration: 60000
	    }, param, {
	      operationType: 'start',
	      fail: function fail(e) {
	        eventEmitter.emit('onRecorderStateChange_error', e);
	      }
	    });

	    if (VALID_SAMPLE_RATES.indexOf(invokeParam.sampleRate) === -1) {
	      throw new Error('invalid sampleRate "' + invokeParam.sampleRate + '", sampleRate should be one of ' + JSON.stringify(Object.keys(VALID_RATES)));
	    }

	    if (invokeParam.encodeBitRate > VALID_RATES[invokeParam.sampleRate][1] || invokeParam.encodeBitRate < VALID_RATES[invokeParam.sampleRate][0]) {
	      throw new Error('invalid encodeBitRate "' + invokeParam.encodeBitRate + '", encodeBitRate should be greater than ' + VALID_RATES[invokeParam.sampleRate][0] + ' and less than ' + VALID_RATES[invokeParam.sampleRate][1]);
	    }

	    if (invokeParam.duration > 600000 || invokeParam.duration < 0) {
	      invokeParam.duration = 60000;
	    }

	    operateRecorder(invokeParam);
	  },
	  pause: function pause() {
	    operateRecorder({
	      operationType: 'pause',
	      fail: function fail(err) {
	        eventEmitter.emit('onRecorderStateChange_error', err);
	      }
	    });
	  },
	  resume: function resume() {
	    operateRecorder({
	      operationType: 'resume',
	      success: function success() {
	        eventEmitter.emit('onRecorderStateChange_resume');
	      },
	      fail: function fail(err) {
	        eventEmitter.emit('onRecorderStateChange_error', err);
	      }
	    });
	  },
	  stop: function stop() {
	    operateRecorder({
	      operationType: 'stop',
	      fail: function fail(err) {
	        eventEmitter.emit('onRecorderStateChange_error', err);
	      }
	    });
	  },
	  onStart: function onStart(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_start');
	    eventEmitter.on('onRecorderStateChange_start', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onPause callback function')(res);
	      }
	    });
	  },
	  onResume: function onResume(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_resume');
	    eventEmitter.on('onRecorderStateChange_resume', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onResume callback function')(res);
	      }
	    });
	  },
	  onPause: function onPause(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_pause');
	    eventEmitter.on('onRecorderStateChange_pause', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onPause callback function')(res);
	      }
	    });
	  },
	  onStop: function onStop(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_stop');
	    eventEmitter.on('onRecorderStateChange_stop', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onStop callback function')(res);
	      }
	    });
	  },
	  onFrameRecorded: function onFrameRecorded(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_frameRecorded');
	    eventEmitter.on('onRecorderStateChange_frameRecorded', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onFrameRecorded callback function')(res);
	      }
	    });
	  },
	  onError: function onError(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_error');
	    eventEmitter.on('onRecorderStateChange_error', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onError callback function')(res);
	      }
	    });
	  }
	};

	function getRecorderManager() {
	  return RecorderManager;
	}

	var eventList = ['start', 'stop', 'error', 'pause', 'resume'];
	var emitter$8 = new EventEmitter();
	var MAX_RECORD_TIME = 120;
	var stateHandler = {
	  onStart: null,
	  onPause: null,
	  onStop: null,
	  onResume: null,
	  onInterruptionBegin: null,
	  onInterruptionEnd: null
	};

	onMethod('onGameRecordStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (eventList.indexOf(res.state) > -1) {
	    emitter$8.emit(res.state, res);
	  }
	});

	eventList.forEach(function (v) {
	  var handlerName = v.replace(/\w/, function (c) {
	    return 'on' + c.toUpperCase();
	  });
	  emitter$8.on(v, function (res) {
	    stateHandler[handlerName] && stateHandler[handlerName](res);
	  });
	});

	emitter$8.on('screenRecorderInterruptionBegin', function (res) {
	  var handlerName = 'onInterruptionBegin';
	  stateHandler[handlerName] && stateHandler[handlerName](res);
	});

	emitter$8.on('screenRecorderInterruptionEnd', function (res) {
	  var handlerName = 'onInterruptionEnd';
	  stateHandler[handlerName] && stateHandler[handlerName](res);
	});

	var GameRecorderManager = function () {
	  function GameRecorderManager() {
	    var _this = this;

	    classCallCheck(this, GameRecorderManager);

	    this.init();

	    emitter$8.on('start', function () {
	      _this._st = Date.now();
	      _this._recordTimer = setTimeout(function () {
	        _this.stop();
	      }, _this._duration);
	    });

	    emitter$8.on('pause', function () {
	      _this._remainTime = _this._st + _this._duration - Date.now();
	      clearTimeout(_this._recordTimer);
	    });

	    emitter$8.on('interrupted', function () {
	      _this._recording = false;
	      clearTimeout(_this._recordTimer);
	    });

	    emitter$8.on('resume', function () {
	      if (_this._remainTime > 0) {
	        _this._st = Date.now();
	        _this._duration = _this._remainTime;
	        _this._recordTimer = setTimeout(function () {
	          _this.stop();
	        }, _this._duration);
	      } else {
	        _this.stop();
	      }
	    });

	    emitter$8.on('stop', function () {
	      _this._recording = false;
	      clearTimeout(_this._recordTimer);
	    });
	  }

	  GameRecorderManager.prototype.init = function init() {
	    this._recording = false;
	    this._st = null;
	    this._et = null;
	    this._remainTime = 0;
	    this._duration = 0;
	    this._recordTimer = null;
	    this._hasClip = false;
	    this._range = [];
	  };

	  GameRecorderManager.prototype.start = function start() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


	    // microphoneEnabled 表示是否开启麦克风
	    param = _extends({ microphoneEnabled: false, duration: 10 }, param);

	    if (param.duration && typeof param.duration !== 'number') {
	      throw new TypeError('duration must be a number');
	    }

	    if (typeof param.microphoneEnabled !== 'undefined' && typeof param.microphoneEnabled !== 'boolean') {
	      throw new TypeError('microphoneEnabled must be a boolean');
	    }

	    if (!this._recording) {
	      this.init();
	      this._recording = true;
	      this._remainTime = this._duration = Math.max(Math.min(MAX_RECORD_TIME, param.duration), 0) * 1000;
	      param.microphoneEnabled = param.microphoneEnabled && param.openMicrophoneAuth === true ? 1 : 0;

	      invokeMethod('operateScreenRecorder', {
	        operationType: 'start',
	        microphoneEnabled: 0 // param.microphoneEnabled,
	      });
	    }
	  };

	  GameRecorderManager.prototype.stop = function stop() {
	    this._recording = false;
	    invokeMethod('operateScreenRecorder', { operationType: 'stop' });
	  };

	  // 记录王者时刻,剪裁特别的视频片段，开发者可以在游戏需要特别记录的时候调用该方法


	  GameRecorderManager.prototype.recordClip = function recordClip() {
	    var _this2 = this;

	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref$timeRange = _ref.timeRange,
	        timeRange = _ref$timeRange === undefined ? [] : _ref$timeRange;

	    if (this._recording) {
	      beforeInvoke('operateScreenRecorder', timeRange, []) && invokeMethod('operateScreenRecorder', {
	        operationType: 'getElapseTime',
	        success: function success() {
	          var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	          var elapseTime = res.elapseTime;
	          var _timeRange$ = timeRange[0],
	              beforeTime = _timeRange$ === undefined ? 3 : _timeRange$,
	              _timeRange$2 = timeRange[1],
	              afterTime = _timeRange$2 === undefined ? 3 : _timeRange$2;


	          if (elapseTime) {
	            var startTime = elapseTime - beforeTime * 1000;
	            var endTime = elapseTime + afterTime * 1000;

	            if (startTime < 0) {
	              startTime = 0;
	            }

	            if (endTime > MAX_RECORD_TIME * 1000) {
	              endTime = MAX_RECORD_TIME * 1000;
	            }

	            _this2._range.push([startTime, endTime]);
	          }
	        }
	      });
	    }
	  };

	  // 开始剪辑, 在结束录屏拿到临时文件地址时候调用该方法合成影辑


	  GameRecorderManager.prototype.clipVideo = function clipVideo() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (!this._recording && !this._hasClip) {
	      this._hasClip = true;
	      var range = this._uionClipTime();
	      var _params = params,
	          path = _params.path;

	      params = _extends({
	        operationType: 'trim'
	      }, params, {
	        trimParam: [{
	          videoPath: path,
	          range: range
	        }]
	      });

	      beforeInvoke('operateScreenRecorder', params, { path: '' }) && invokeMethod('operateScreenRecorder', params);
	    }
	  };

	  // 获取剪辑时间的并集部分


	  GameRecorderManager.prototype._uionClipTime = function _uionClipTime() {
	    var range = this._range;

	    var length = range.length;

	    for (var i = 0; i < length; i++) {
	      var item = range[i];
	      var nextIndex = i + 1;
	      var nextItem = range[nextIndex];
	      if (nextItem) {
	        var nextStartTime = nextItem[0];
	        var curentItemEndTime = item[1];

	        // 下一条的开始时间小于前面一条的结束时间，就取并集

	        if (nextStartTime < curentItemEndTime) {
	          item[1] = nextItem[1];
	          range.splice(nextIndex, 1);
	          i--;
	        }
	      }
	    }

	    return range;
	  };

	  GameRecorderManager.prototype.pause = function pause() {
	    invokeMethod('operateScreenRecorder', { operationType: 'pause' });
	  };

	  GameRecorderManager.prototype.resume = function resume() {
	    invokeMethod('operateScreenRecorder', { operationType: 'resume' });
	  };

	  GameRecorderManager.prototype.onStart = function onStart(cb) {
	    if (isFn(cb)) {
	      stateHandler.onStart = surroundByTryCatchFactory(cb, 'GameRecorderManager.onStart');
	    }
	  };

	  GameRecorderManager.prototype.onPause = function onPause(cb) {
	    if (isFn(cb)) {
	      stateHandler.onPause = surroundByTryCatchFactory(cb, 'GameRecorderManager.onPause');
	    }
	  };

	  GameRecorderManager.prototype.onResume = function onResume(cb) {
	    if (isFn(cb)) {
	      stateHandler.onResume = surroundByTryCatchFactory(cb, 'GameRecorderManager.onResume');
	    }
	  };

	  GameRecorderManager.prototype.onStop = function onStop(cb) {
	    if (isFn(cb)) {
	      stateHandler.onStop = surroundByTryCatchFactory(cb, 'GameRecorderManager.onStop');
	    }
	  };

	  GameRecorderManager.prototype.onError = function onError(cb) {
	    if (isFn(cb)) {
	      stateHandler.onError = surroundByTryCatchFactory(cb, 'GameRecorderManager.onError');
	    }
	  };

	  GameRecorderManager.prototype.onInterruptionBegin = function onInterruptionBegin(cb) {
	    if (isFn(cb)) {
	      stateHandler.onInterruptionBegin = surroundByTryCatchFactory(cb, 'GameRecorderManager.onInterruptionBegin');
	    }
	  };

	  GameRecorderManager.prototype.onInterruptionEnd = function onInterruptionEnd(cb) {
	    if (isFn(cb)) {
	      stateHandler.onInterruptionEnd = surroundByTryCatchFactory(cb, 'GameRecorderManager.onInterruptionEnd');
	    }
	  };

	  GameRecorderManager.prototype.onInterrupted = function onInterrupted() {
	    console.warn('GameRecorderManager.onInterrupted 已废弃，请使用 onInterruptionBegin 和 onInterruptionEnd');
	  };

	  return GameRecorderManager;
	}();

	var recorderManager = new GameRecorderManager();

	function getGameRecorderManager() {
	  return recorderManager;
	}

	function authorize() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('authorize', param, { scope: '' })) {
	    invokeMethod('authorize', param);
	  }
	}

	var Settings = function () {
	  function Settings() {
	    classCallCheck(this, Settings);
	  }

	  Settings.prototype.destroy = function destroy() {};

	  Settings.prototype.hide = function hide() {};

	  Settings.prototype.show = function show() {};

	  return Settings;
	}();

	var OpenSettingButton = new Settings();

	function createOpenSettingButton() {
	  return OpenSettingButton;
	}

	function getSetting() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('getSetting', param);
	}

	function openSetting() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('openSetting', param);
	}

	var allBannerAds = {};

	// 建立全局的事件中心，监听native的消息，根据id分发给实例
	onMethod('onBannerAdStateChange', function (res) {
	  logger.info('[b-ad]', 'onBannerAdStateChange', res);
	  var adUnitId = res.adUnitId,
	      state = res.state,
	      data = res.data;


	  if (state === 'resize' && typeof data === 'string') {
	    try {
	      data = JSON.parse(data);
	    } catch (ex) {
	      // do nothing.
	    }
	  }

	  if (allBannerAds[adUnitId] instanceof BannerAd) {
	    allBannerAds[adUnitId]._eventemitter.emit(state, data);
	  }
	});

	var MIN_BANNER_WIDTH = 128;
	var MAX_BANNER_WIDTH = 208;

	var BannerAd = function () {
	  function BannerAd() {
	    var _this = this;

	    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    classCallCheck(this, BannerAd);
	    var adUnitId = option.adUnitId,
	        style = option.style;


	    style = Object.assign({
	      left: 0,
	      top: 0,
	      width: MIN_BANNER_WIDTH
	    }, style);

	    if (style.width < MIN_BANNER_WIDTH) {
	      style.width = MIN_BANNER_WIDTH;
	    } else if (style.width > MAX_BANNER_WIDTH) {
	      style.width = MAX_BANNER_WIDTH;
	    }

	    // 注册一个空方法，防止emit时报错
	    this._eventemitter = new EventEmitter();
	    ['resize', 'error', 'close'].forEach(function (event) {
	      _this._eventemitter.on(event, function () {});
	    });

	    this._destroyed = false;
	    this._destroying = false;
	    this._adUnitId = adUnitId;
	    this.style = {}; // 对外暴露的数据

	    ['left', 'top', 'width' /* , 'realWidth', 'realHeight' */].forEach(function (attribute) {
	      Object.defineProperty(_this.style, attribute, {
	        configurable: true,
	        enumerable: true,
	        get: function get$$1() {
	          return style[attribute];
	        },
	        set: function set$$1(newvalue) {
	          if (['realWidth', 'realHeight'].indexOf(attribute) > -1) {
	            return;
	          }
	          if (!_this._destroyed && newvalue !== style[attribute]) {
	            if (attribute === 'width') {
	              if (newvalue < MIN_BANNER_WIDTH) {
	                newvalue = MIN_BANNER_WIDTH;
	              } else if (newvalue > MAX_BANNER_WIDTH) {
	                newvalue = MAX_BANNER_WIDTH;
	              }
	            }
	            style[attribute] = newvalue;

	            logger.info('[b-ad]', '准备修改size', style);
	            invokeMethod('updateBannerAd', {
	              adUnitId: adUnitId,
	              style: style,
	              success: function success() {
	                logger.info('[b-ad]', 'style' + attribute + '\u4FEE\u6539\u6210\u529F\uFF0C\u7B49\u5F85\u89E6\u53D1resize');
	              },
	              fail: function fail(res) {
	                logger.info('[b-ad]', 'style' + attribute + '\u4FEE\u6539\u5931\u8D25', res);
	              }
	            });
	          }
	        }
	      });
	    });

	    invokeMethod('createBannerAd', {
	      adUnitId: adUnitId,
	      style: style,
	      success: function success(res) {
	        logger.info('[b-ad]', 'createBannerAd success', res);
	      },
	      fail: function fail(res) {
	        logger.info('[b-ad]', 'createBannerAd fail', res);
	      }
	    });
	  }

	  BannerAd.prototype.show = function show() {
	    var _this2 = this;

	    if (this._destroyed && this._destroying) {
	      return Promise.reject({
	        errMsg: 'bannerad destroyed'
	      });
	    } else {
	      return new Promise(function (resolve, reject) {
	        invokeMethod('operateBannerAd', {
	          adUnitId: _this2._adUnitId,
	          type: 'show',
	          success: function success(res) {
	            logger.info('[b-ad]', 'operateBannerAd show success', res);
	            resolve();
	          },
	          fail: function fail(res) {
	            logger.info('[b-ad]', 'operateBannerAd show fail', res);
	            reject(res);
	          }
	        });
	      });
	    }
	  };

	  BannerAd.prototype.hide = function hide() {
	    if (!this._destroyed) {
	      invokeMethod('operateBannerAd', {
	        adUnitId: this._adUnitId,
	        type: 'hide',
	        success: function success(res) {
	          logger.info('[b-ad]', 'operateBannerAd hide success', res);
	        },
	        fail: function fail(res) {
	          logger.info('[b-ad]', 'operateBannerAd hide fail', res);
	        }
	      });
	    }
	  };

	  BannerAd.prototype.destroy = function destroy() {
	    var _this3 = this;

	    this._destroying = true;
	    invokeMethod('operateBannerAd', {
	      adUnitId: this._adUnitId,
	      type: 'destroy',
	      success: function success(res) {
	        logger.info('[b-ad]', 'operateBannerAd destroy success', res);
	        _this3._destroyed = true;
	        _this3._eventemitter.removeAllListeners();
	        _this3._eventemitter = null;
	        // TODO 处理 style 的 getter和setter？

	        allBannerAds[_this3._adUnitId] = null; // 只是把指向删了，能处理事件分发，但外部引用仍然存在
	      },
	      fail: function fail(res) {
	        logger.info('[b-ad]', 'operateBannerAd destroy fail', res);
	      },
	      complete: function complete() {
	        _this3._destroying = false;
	      }
	    });
	  };

	  BannerAd.prototype.onLoad = function onLoad(listener) {
	    if (!this._destroyed) {
	      this._eventemitter.on('loaded', listener);
	    }
	  };

	  BannerAd.prototype.offLoad = function offLoad(listener) {
	    if (!this._destroyed) {
	      this._eventemitter.off('loaded', listener);
	    }
	  };

	  BannerAd.prototype.onResize = function onResize(listener) {
	    if (!this._destroyed) {
	      this._eventemitter.on('resize', listener);
	    }
	  };

	  BannerAd.prototype.offResize = function offResize(listener) {
	    if (!this._destroyed) {
	      this._eventemitter.off('resize', listener);
	    }
	  };

	  BannerAd.prototype.onError = function onError(listener) {
	    if (!this._destroyed) {
	      this._eventemitter.on('error', listener);
	    }
	  };

	  BannerAd.prototype.offError = function offError(listener) {
	    if (!this._destroyed) {
	      this._eventemitter.off('error', listener);
	    }
	  };

	  return BannerAd;
	}();

	function createBannerAd() {
	  var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (!option.adUnitId) {
	    throw 'no adUnitId';
	  }

	  if (!(allBannerAds[option.adUnitId] instanceof BannerAd)) {
	    allBannerAds[option.adUnitId] = new BannerAd(option);
	  } else {
	    logger.log('[b-ad]', 'return from allBannerAds');
	  }

	  return allBannerAds[option.adUnitId];
	}

	// todo

	var globalVideoAdInstance = {};

	// 建立全局的事件中心，监听native的消息，根据id分发给实例
	onMethod('onVideoAdStateChange', function (res) {
	  logger.info('[v-ad]', 'onVideoAdStateChange', res);
	  var adUnitId = res.adUnitId,
	      state = res.state,
	      data = res.data;


	  if (state === 'loaded') {
	    globalVideoAdInstance._loadState = ['loaded'];
	  } else if (state === 'close') {
	    var _data = data,
	        watchedTime = _data.watchedTime,
	        effectiveTime = _data.effectiveTime;


	    data = {
	      isEnded: watchedTime >= 0.98 * effectiveTime
	    };

	    // 通知客户端重新请求一条广告数据
	    // 这个行为和，开发者调用load  有什么区别？
	    // 这个行为，最终看与创建类似，因为都没有处理回调
	    globalVideoAdInstance._loadState = ['loading'];
	    invokeMethod('operateVideoAd', {
	      adUnitId: adUnitId,
	      type: 'load'
	    });
	  } else if (state === 'error') {
	    globalVideoAdInstance._loadState = ['loaderror', data];
	  }

	  globalVideoAdInstance._eventemitter.emit(state, data);
	});

	var VideoAd = function () {
	  function VideoAd() {
	    var _this = this;

	    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    classCallCheck(this, VideoAd);
	    var adUnitId = option.adUnitId;

	    // 注册一个空方法，防止emit时报错

	    this._eventemitter = new EventEmitter();
	    ['loaded', 'error', 'close'].forEach(function (event) {
	      _this._eventemitter.on(event, function () {});
	    });

	    this._adUnitId = adUnitId;
	    this._loadState = ['loading'];

	    invokeMethod('createVideoAd', {
	      adUnitId: adUnitId,
	      success: function success(res) {
	        logger.info('[v-ad]', 'createVideoAd success', res);
	      },
	      fail: function fail(res) {
	        logger.info('[v-ad]', 'createVideoAd fail', res);
	      }
	    });

	    //
	  }

	  VideoAd.prototype._createLoadPromise = function _createLoadPromise() {
	    var _this2 = this;

	    return new Promise(function (resolve, reject) {
	      _this2._eventemitter.on('loaded', function () {
	        resolve();
	        // TODO 应当删除绑定，避免内存泄露
	      });
	      _this2._eventemitter.on('error', function (error) {
	        reject(error);
	        // TODO 应当删除绑定，避免内存泄露
	      });
	    });
	  };

	  /**
	   * 根据当前的load状态：
	   * loading   -- 注册监听方法，成功或失败时相应处理
	   * loaded    -- 调用show方法，处理成功或失败（问题是show的失败是不是会发error？）此处存疑，不知道微信api是何表现。
	   * loaderror -- 已经错误了，直接返回reject
	   */


	  VideoAd.prototype.show = function show() {
	    var _this3 = this;

	    return new Promise(function (resolve, reject) {
	      var _state = _this3._loadState[0];
	      var _sdata = _this3._loadState[1];

	      if (_state === 'loading') {
	        _this3._eventemitter.once('loaded', function () {
	          resolve();
	        });

	        _this3._eventemitter.once('error', function (error) {
	          reject(error);
	        });
	      } else if (_state === 'loaderror') {
	        reject(_sdata);
	      } else if (_state === 'loaded') {
	        invokeMethod('operateVideoAd', {
	          adUnitId: _this3._adUnitId,
	          type: 'show',
	          success: function success(res) {
	            logger.info('[v-ad]', 'operateVideoAd show success', res);
	            resolve();
	          },
	          fail: function fail(res) {
	            logger.info('[v-ad]', 'operateVideoAd show fail', res);
	            reject(res);
	            // 但是没有派发show事件啊
	          }
	        });
	      } else {
	        logger.info('[v-ad]', '未知的广告数据状态 at adinstance.show()', _this3._loadState);
	        reject({
	          errCode: 1001,
	          errMsg: '未知的广告数据状态 at adinstance.show()'
	        });
	      }
	    });
	  };

	  /**
	   * 根据当前的load状态：
	   * loading   -- 注册监听方法，成功或失败时相应处理
	   * loaded    -- 已经加载好了，直接resolve
	   * loaderror -- 调用load方法，处理成功或失败？此处存疑，不知道微信api是否能在错误后无限调用。
	   */


	  VideoAd.prototype.load = function load() {
	    var _this4 = this;

	    return new Promise(function (resolve, reject) {
	      var _state = _this4._loadState[0];
	      var _sdata = _this4._loadState[1];

	      if (_state === 'loading') {
	        _this4._eventemitter.once('loaded', function () {
	          resolve();
	        });

	        _this4._eventemitter.once('error', function (error) {
	          reject(error);
	        });
	      } else if (_state === 'loaderror') {
	        _this4._loadState = ['loading'];
	        invokeMethod('operateVideoAd', {
	          adUnitId: _this4._adUnitId,
	          type: 'load',
	          success: function success(res) {
	            logger.info('[v-ad]', 'operateVideoAd load success', res);
	          },
	          fail: function fail(res) {
	            logger.info('[v-ad]', 'operateVideoAd load fail', res);
	          }
	        });

	        // 通过消息处理
	        _this4._eventemitter.once('loaded', function () {
	          resolve();
	        });
	        _this4._eventemitter.once('error', function (error) {
	          reject(error);
	        });
	      } else if (_state === 'loaded') {
	        resolve();
	      } else {
	        logger.info('[v-ad]', '未知的广告数据状态 at adinstance.load()', _this4._loadState);
	        reject({
	          errCode: 1001,
	          errMsg: '未知的广告数据状态 at adinstance.load()'
	        });
	      }
	    });
	  };

	  VideoAd.prototype.onLoad = function onLoad(listener) {
	    this._eventemitter.on('loaded', listener);
	  };

	  VideoAd.prototype.offLoad = function offLoad(listener) {
	    this._eventemitter.off('loaded', listener);
	  };

	  VideoAd.prototype.onClose = function onClose(listener) {
	    this._eventemitter.on('close', listener);
	  };

	  VideoAd.prototype.offClose = function offClose(listener) {
	    this._eventemitter.off('close', listener);
	  };

	  VideoAd.prototype.onError = function onError(listener) {
	    this._eventemitter.on('error', listener);
	  };

	  VideoAd.prototype.offError = function offError(listener) {
	    this._eventemitter.off('error', listener);
	  };

	  return VideoAd;
	}();

	function createRewardedVideoAd() {
	  var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (!option.adUnitId) {
	    throw 'No RewardedVideoAd adUnitId';
	  }

	  if (!(globalVideoAdInstance instanceof VideoAd)) {
	    globalVideoAdInstance = new VideoAd(option);
	  }

	  return globalVideoAdInstance;
	}

	/**
	 * @function openUserProfile
	 * @description 打开他人主页
	 * @param {object} param
	 * @param {string} param.openid 需要打开的用户的 openid
	 */
	function openUserProfile(param) {
	  if (beforeInvoke('openUserProfile', param, {
	    openid: ''
	  })) {
	    invokeMethod('openUserProfile', param);
	  }
	}

	function invokeBusiness() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (typeof param.__method === 'string') {
	    var method = param.__method;
	    delete param.__method;

	    // console.log('before invoke business', param);
	    invokeMethod(method, param);
	  }
	}

	function openSchema(param) {
	  if (beforeInvoke('openSchema', param, {
	    schema: ''
	  })) {
	    invokeBusiness(_extends({}, param, {
	      __method: 'openSchema'
	    }));
	  }
	}

	var eventEmitter$1 = new EventEmitter();

	onMethod('onCheckForUpdate', function (res) {
	  eventEmitter$1.emit('onCheckForUpdate', res || {});
	});
	onMethod('onUpdateFailed', function (res) {
	  eventEmitter$1.emit('onUpdateFailed', res || {});
	});
	onMethod('onUpdateReady', function (res) {
	  eventEmitter$1.emit('onUpdateReady', res || {});
	});

	var UpdateManager = function () {
	  function UpdateManager() {
	    classCallCheck(this, UpdateManager);
	  }

	  /**
	   * 强制小程序重启并使用新版本
	   * @param {Object} params
	   * @param {Function} params.success 成功回调
	   * @param {Function} params.fail 失败回调
	   * @param {Fucntion} params.complete 不论成功或者失败，都会回调
	   */


	  UpdateManager.prototype.applyUpdate = function applyUpdate() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('applyUpdate', params);
	  };

	  // 监听检查更新结果回调


	  UpdateManager.prototype.onCheckForUpdate = function onCheckForUpdate(cb) {
	    var eventName = 'onCheckForUpdate';
	    eventEmitter$1.removeAllListeners(eventName);
	    eventEmitter$1.on(eventName, function (data) {
	      if (typeof cb === 'function') {
	        surroundByTryCatchFactory(cb, 'at updateManager.onCheckForUpdate callback function')(data);
	      }
	    });
	    return this;
	  };

	  // 监听更新包下载成功回调


	  UpdateManager.prototype.onUpdateReady = function onUpdateReady(cb) {
	    var eventName = 'onUpdateReady';
	    eventEmitter$1.removeAllListeners(eventName);
	    eventEmitter$1.on(eventName, function (data) {
	      if (typeof cb === 'function') {
	        surroundByTryCatchFactory(cb, 'at updateManager.onUpdateReady callback function')(data);
	      }
	    });
	    return this;
	  };

	  // 监听更新包下载失败回调


	  UpdateManager.prototype.onUpdateFailed = function onUpdateFailed(cb) {
	    var eventName = 'onUpdateFailed';
	    eventEmitter$1.removeAllListeners(eventName);
	    eventEmitter$1.on(eventName, function (data) {
	      if (typeof cb === 'function') {
	        surroundByTryCatchFactory(cb, 'at updateManager.onUpdateFailed callback function')(data);
	      }
	    });
	    return this;
	  };

	  return UpdateManager;
	}();

	var updateManager = new UpdateManager();

	function getUpdateManager() {
	  return updateManager;
	}

	var reportAnalytics = function reportAnalytics(eventName, data) {

	  if (!isString(eventName) || !eventName) {
	    throw new ThirdScriptError('eventName must be a string.');
	  }

	  if (eventName.length > 110) {
	    throw new ThirdScriptError('eventName exceeded the maximum length: 110.');
	  }

	  if (!isObject$1(data)) {
	    throw new ThirdScriptError('data must be an object.');
	  }

	  var keys = Object.keys(data);
	  var params = {
	    value: {}
	  };
	  if (keys.length > 256) {
	    throw new ThirdScriptError('data exceeded the maximum number of fields: 256.');
	  }

	  keys.filter(function (v) {
	    return !isObject$1(data[v]);
	  }).forEach(function (key) {
	    if (key.length > 128) {
	      throw new ThirdScriptError(key + ' exceeded the maximum number of bytes: 128.');
	    }

	    if (String(data[key]).length > 1024) {
	      throw new ThirdScriptError('the value of data[' + key + '] exceeded the maximum number of bytes: 1024.');
	    }

	    if (key && key[0] === '_') {
	      throw new ThirdScriptError('the key first char can not be _.');
	    }

	    if (key === 'mp_id' || key === 'mp_name') {
	      throw new ThirdScriptError('the key can not be mp_name or mp_id.');
	    }

	    params['value'][key] = data[key];
	  });

	  invokeMethod('microappLog', _extends({}, params, {
	    event: eventName
	  }));
	};

	var VideoManager = function () {
	  function VideoManager() {
	    classCallCheck(this, VideoManager);

	    this.state = 'init';
	    this.video = createOffscreenVideo();
	    this.screeCanvas = getScreenCanvas();
	  }

	  VideoManager.prototype.play = function play(videoPath) {

	    // 开发者已经调用了就不操作
	    if (this.state === 'playing') {
	      return false;
	    }

	    if (!videoPath) {
	      return false;
	    }

	    this.state = 'playing';

	    if (typeof videoPath === 'string') {
	      this.video.src = videoPath;
	    }

	    if ((typeof videoPath === 'undefined' ? 'undefined' : _typeof(videoPath)) === 'object' && videoPath !== null) {
	      this.video.srcObject = videoPath;
	    }

	    this.video.play();
	  };

	  VideoManager.prototype.paintTo = function paintTo() {
	    var _video;

	    if (this.state !== 'playing') {
	      return false;
	    }

	    for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
	      params[_key] = arguments[_key];
	    }

	    (_video = this.video).paintTo.apply(_video, [this.screeCanvas].concat(params));
	  };

	  VideoManager.getInstance = function getInstance() {

	    return new VideoManager();
	  };

	  VideoManager.prototype.pause = function pause() {
	    this.state = 'pause';
	    this.video.pause();
	  };

	  VideoManager.prototype.resume = function resume() {
	    this.state = 'playing';
	    this.video.play();
	  };

	  VideoManager.prototype.getVideoInfo = function getVideoInfo(key) {
	    return this.video[key];
	  };

	  VideoManager.prototype.getVideo = function getVideo() {
	    return this.video;
	  };

	  VideoManager.prototype.getScalar = function getScalar() {
	    if (this.video) {
	      return this.video.videoWidth / this.video.videoHeight;
	    }
	  };

	  VideoManager.prototype.setVideoSize = function setVideoSize(width, height) {
	    this.video.width = width;
	    this.video.height = height;
	  };

	  return VideoManager;
	}();

	function getVideoManager() {
	  return VideoManager.getInstance();
	}

	// all es6 shim

	var onTouchStart$1 = exports$1.onTouchStart,
	    offTouchStart$1 = exports$1.offTouchStart,
	    onTouchMove$1 = exports$1.onTouchMove,
	    offTouchMove$1 = exports$1.offTouchMove,
	    onTouchEnd$1 = exports$1.onTouchEnd,
	    offTouchEnd$1 = exports$1.offTouchEnd,
	    onTouchCancel$1 = exports$1.onTouchCancel,
	    offTouchCancel$1 = exports$1.offTouchCancel;

	Reporter.setAsGame();

	var ttMethodsMap = _extends({

	  env: {
	    USER_DATA_PATH: 'ttfile://user'
	  },
	  // performance
	  getPerformance: getPerformance,
	  triggerGC: triggerGC,

	  // 网络状态
	  getNetworkType: getNetworkType,
	  onNetworkStatusChange: onNetworkStatusChange,
	  // 设备
	  getSystemInfo: getSystemInfo,
	  getSystemInfoSync: getSystemInfoSync$1,

	  scanCode: scanCode,

	  // 屏幕亮度
	  setKeepScreenOn: setKeepScreenOn,
	  // 罗盘
	  onCompassChange: onCompassChange, startCompass: startCompass, stopCompass: stopCompass,

	  // canIUse,

	  // 界面交互
	  showModal: showModal,
	  showActionSheet: showActionSheet,
	  showToast: showToast,
	  hideToast: hideToast,
	  showLoading: showLoading,
	  hideLoading: hideLoading,

	  // 网络
	  request: request,
	  uploadFile: uploadFile,
	  downloadFile: downloadFile,

	  // websocket
	  connectSocket: socket.connectSocket,
	  //     closeSocket: socket.closeSocket,
	  //     sendSocketMessage: socket.sendSocketMessage,
	  //     onSocketOpen: socket.onSocketOpen,
	  //     onSocketClose: socket.onSocketClose,
	  //     onSocketMessage: socket.onSocketMessage,
	  //     onSocketError: socket.onSocketError,

	  // 图片
	  chooseImage: chooseImage,
	  previewImage: previewImage,
	  getImageInfo: getImageInfo,
	  saveImageToPhotosAlbum: saveImageToPhotosAlbum,

	  createInnerAudioContext: createInnerAudioContext,
	  getRecorderManager: getRecorderManager,

	  // 数据缓存
	  getStorage: getStorage,
	  getStorageSync: getStorageSync,
	  setStorage: setStorage,
	  setStorageSync: setStorageSync,
	  removeStorage: removeStorage,
	  removeStorageSync: removeStorageSync,
	  clearStorage: clearStorage,
	  clearStorageSync: clearStorageSync,
	  getStorageInfo: getStorageInfo,
	  getStorageInfoSync: getStorageInfoSync,

	  // 位置
	  getLocation: getLocation,

	  // 振动
	  vibrateShort: vibrateShort,
	  vibrateLong: vibrateLong,

	  // 剪贴板
	  setClipboardData: setClipboardData,
	  getClipboardData: getClipboardData,

	  login: login,
	  checkSession: checkSession,
	  getUserInfo: getUserInfo,

	  // game
	  // 渲染
	  createCanvas: createCanvas,
	  createImage: createImage,
	  loadFont: loadFont,
	  inflate: inflate, // TODO: delete it

	  // 触摸事件
	  onTouchStart: onTouchStart$1,
	  offTouchStart: offTouchStart$1,
	  onTouchMove: onTouchMove$1,
	  offTouchMove: offTouchMove$1,
	  onTouchEnd: onTouchEnd$1,
	  offTouchEnd: offTouchEnd$1,
	  onTouchCancel: onTouchCancel$1,
	  offTouchCancel: offTouchCancel$1,

	  // 文件
	  getFileSystemManager: getFileSystemManager,
	  saveFile: saveFile,
	  getFileInfo: getFileInfo,
	  getSavedFileList: getSavedFileList,
	  removeSavedFile: removeSavedFile,

	  saveVideoToPhotosAlbum: saveVideoToPhotosAlbum,

	  // 加速度计
	  onAccelerometerChange: onAccelerometerChange,
	  startAccelerometer: startAccelerometer,
	  stopAccelerometer: stopAccelerometer

	}, exports$2, exports$3, sns, exports$4, {

	  createWorker: createWorker$1,
	  getGameRecorderManager: getGameRecorderManager,

	  getMenuButtonLayout: getMenuButtonLayout,
	  getMenuButtonBoundingClientRect: getMenuButtonBoundingClientRect,
	  setMenuStyle: setMenuStyle,
	  setStatusBarStyle: setStatusBarStyle,

	  // 广告
	  createBannerAd: createBannerAd,
	  createRewardedVideoAd: createRewardedVideoAd,

	  getSetting: getSetting, openSetting: openSetting, createOpenSettingButton: createOpenSettingButton,
	  authorize: authorize,

	  getRankData: getRankData,
	  setRankData: setRankData,
	  requestGamePayment: requestGamePayment,

	  // 开放数据域主域方法
	  getOpenDataContext: getOpenDataContext,
	  // 开放数据
	  getCloudStorageByRelation: function getCloudStorageByRelation$$1(e) {
	    console.warn('tt.getCloudStorageByRelation 在主域即将废弃，请参照开放数据域要求使用本接口');
	    getCloudStorageByRelation(e);
	  },
	  getUserCloudStorage: function getUserCloudStorage$$1(e) {
	    console.warn('tt.getUserCloudStorage 在主域即将废弃，请参照开放数据域要求使用本接口');
	    getUserCloudStorage(e);
	  },
	  removeUserCloudStorage: removeUserCloudStorage,
	  setUserCloudStorage: setUserCloudStorage,
	  // setUserGroup,

	  openUserProfile: openUserProfile,
	  createOffscreenVideo: createOffscreenVideo,
	  getVideoManager: getVideoManager,
	  openSchema: openSchema,
	  createFaceDetector: createFaceDetector,
	  requestCamera: requestCamera,
	  reportAnalytics: reportAnalytics,
	  callHostMethod: callHostMethod,
	  callHostMethodSync: callHostMethodSync,
	  getUpdateManager: getUpdateManager,

	  // 兼容wx
	  onMessage: function onMessage() {},
	  postMessage: function postMessage() {}
	});

	var tt$1 = {};

	for (var fn in ttMethodsMap) {
	  if (typeof ttMethodsMap[fn] === 'function') {
	    tt$1[fn] = surroundByTryCatch(ttMethodsMap[fn], 'gameSDKScriptError');
	  } else {
	    tt$1[fn] = ttMethodsMap[fn];
	  }
	}

	var index = {
	  tt: tt$1
	};

	return index;

}());
$glob$.tt = $glob$.wx = TMGCORE.tt; /* 提供对wxAPI支持 */
})(this);
