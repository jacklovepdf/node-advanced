var parentContext = parent.window.parentContext;
var systemInfo = parentContext.getSystemInfo();
var sCanvas = parentContext.shareCanvas;
var canvasContext = sCanvas.getContext;
var toDataURL = sCanvas.toDataURL;
var firstCanvas = false;
const contextMap = new Map();
var _NativeGlobal =  {
    Image: window.Image,
    createElement: window.document.createElement.bind(document)
}

window.subContext = {
    postMessage: function (args) {
        typeof window.subContext['messageHandler'] === "function" && window.subContext['messageHandler'](deepCopy(args));
    },
    sharedCanvas: sCanvas
};


function onMessage(cb) {
    window.subContext['messageHandler'] = cb;
}



function Canvas () {
    var c = _NativeGlobal.createElement('canvas');
    c.width = systemInfo.innerWidth;
    c.height = systemInfo.innerHeight;
    return c;
}

function sharedCanvas() {
    this.width = systemInfo.innerWidth;
    this.height = systemInfo.innerHeight;
    this.tagName = 'CANVAS'

    Object.defineProperty(this, 'width', {
        set: function (val) {
            sCanvas.width = val
        },
        get: function () {
            return sCanvas.width;
        }
    })

    Object.defineProperty(this, 'height', {
        set: function (val) {
            sCanvas.height = val
        },
        get: function () {
            return sCanvas.height;
        }
    })
}

sharedCanvas.prototype.getContext = function (type) {
    if ('2d' === type.toLowerCase()) {
        let context =  canvasContext.call(sCanvas, '2d');

        let proxyFuncs = ['drawImage', 'createPattern'];
        proxyFuncs.forEach(function(item) {
            let fun = context[item].bind(context);
            context[item] = function () {
                let img = arguments[0];
                if (isProxy(img)) {
                    let temImg = contextMap.get(img);
                    arguments[0] = temImg;
                    fun(...arguments);
                } else {
                    fun(...arguments);
                }
            }
        })

        return context;
    }
}

sharedCanvas.prototype.toDataURL = function () {
    return toDataURL.call(sCanvas);
}

sharedCanvas.prototype.width = function(width) {
    sCanvas.width = width;
}

sharedCanvas.prototype.height = function(height) {
    sCanvas.height = height;
}

function deepCopy (obj) {
    const maps = new Map();
    function copy (obj) {
        const type = typeof obj;
        if (obj && type === 'object') {
            if (maps.has(obj)) return maps.get(obj);
            let ret;
            if (obj instanceof Array) {
                ret = obj.map(deepCopy);
            } else {
                ret = {};
                for (let key in obj) {
                    ret[key] = deepCopy(obj[key]);
                }
            }
            maps.set(obj, ret);
            return ret;
        }
        if (type === 'function') return null;
        return obj;
    }
    return copy(obj);
}

const proxies = new WeakSet();
function createProxy(proxy) {
    proxies.add(proxy);
    return proxy;
}
function isProxy(obj) {
    return proxies.has(obj);
}

window.subContext.init = function() {
    let { openContextCb, shouldSendRequest } = parent.window.bytedGame;
    // cb execute setup
    openContextCb(window, {
        sharedCanvas: new sharedCanvas(),
        onMessage,
        Canvas,
        Image: function(){
            let image = new _NativeGlobal.Image();
            // return image;
            var obj = new Proxy(image, {
                get: function (target, key, value) {
                    if (typeof target[key] === 'function') {
                        return target[key].bind(target);
                    }
                    return target[key];
                },
                set: function (target, key, value) {
                    if (key !== 'src') {
                        target[key] = value;
                        return true;
                    }
                    if (/^https?:\/\//.test(value)) {
                        if (shouldSendRequest(value, 'image')) {
                            target[key] = value;
                            return true;
                        } else {
                            console.error("Image url is not trusted: " + value);
                            target[key] = '';
                            return true;
                        }
                    } else if (/^ttfile?:\/\//.test(value)) {
                        target[key] = value;
                        return true;
                    } else{
                        target[key] = value;
                        return true;
                    }
                }
              });

            contextMap.set(obj, image);
            createProxy(obj)
            return obj;
        }
    });

    //'openDataContext.js'
    try {
        openContextUser();
    } catch(e) {
        console.log(e)
    }

};

parentContext.loadTmaCore();

