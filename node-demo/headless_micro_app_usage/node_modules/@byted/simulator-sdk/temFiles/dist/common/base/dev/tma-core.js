(function($glob$){
var TMACORE = (function (exports) {
	'use strict';

	
	    var logger = {};
	  ;$glob$.__JSSDK_VERSION__ = {
	    SDKVersion: '',
	    SDKUpdateVersion: '',
	    CommitHash: ''
	  };

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
	});

	var _global$1 = /*#__PURE__*/Object.freeze({
		default: _global,
		__moduleExports: _global
	});

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function _has(it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var _has$1 = /*#__PURE__*/Object.freeze({
		default: _has,
		__moduleExports: _has
	});

	var _fails = function _fails(exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	var _fails$1 = /*#__PURE__*/Object.freeze({
		default: _fails,
		__moduleExports: _fails
	});

	var require$$1 = ( _fails$1 && _fails ) || _fails$1;

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !require$$1(function () {
	  return Object.defineProperty({}, 'a', { get: function get() {
	      return 7;
	    } }).a != 7;
	});

	var _descriptors$1 = /*#__PURE__*/Object.freeze({
		default: _descriptors,
		__moduleExports: _descriptors
	});

	var _core = createCommonjsModule(function (module) {
	  var core = module.exports = { version: '2.5.3' };
	  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _core$1 = /*#__PURE__*/Object.freeze({
		default: _core,
		__moduleExports: _core,
		version: _core_1
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	var inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	var possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	var _isObject = function _isObject(it) {
	  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
	};

	var _isObject$1 = /*#__PURE__*/Object.freeze({
		default: _isObject,
		__moduleExports: _isObject
	});

	var isObject = ( _isObject$1 && _isObject ) || _isObject$1;

	var _anObject = function _anObject(it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _anObject$1 = /*#__PURE__*/Object.freeze({
		default: _anObject,
		__moduleExports: _anObject
	});

	var require$$2 = ( _global$1 && _global ) || _global$1;

	var document$1 = require$$2.document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document$1) && isObject(document$1.createElement);
	var _domCreate = function _domCreate(it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _domCreate$1 = /*#__PURE__*/Object.freeze({
		default: _domCreate,
		__moduleExports: _domCreate
	});

	var require$$0 = ( _descriptors$1 && _descriptors ) || _descriptors$1;

	var require$$2$1 = ( _domCreate$1 && _domCreate ) || _domCreate$1;

	var _ie8DomDefine = !require$$0 && !require$$1(function () {
	  return Object.defineProperty(require$$2$1('div'), 'a', { get: function get() {
	      return 7;
	    } }).a != 7;
	});

	var _ie8DomDefine$1 = /*#__PURE__*/Object.freeze({
		default: _ie8DomDefine,
		__moduleExports: _ie8DomDefine
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function _toPrimitive(it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var _toPrimitive$1 = /*#__PURE__*/Object.freeze({
		default: _toPrimitive,
		__moduleExports: _toPrimitive
	});

	var anObject = ( _anObject$1 && _anObject ) || _anObject$1;

	var IE8_DOM_DEFINE = ( _ie8DomDefine$1 && _ie8DomDefine ) || _ie8DomDefine$1;

	var require$$16 = ( _toPrimitive$1 && _toPrimitive ) || _toPrimitive$1;

	var dP = Object.defineProperty;

	var f = require$$0 ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = require$$16(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) {/* empty */}
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var _objectDp = {
	  f: f
	};

	var _objectDp$1 = /*#__PURE__*/Object.freeze({
		default: _objectDp,
		__moduleExports: _objectDp,
		f: f
	});

	var _propertyDesc = function _propertyDesc(bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _propertyDesc$1 = /*#__PURE__*/Object.freeze({
		default: _propertyDesc,
		__moduleExports: _propertyDesc
	});

	var require$$37 = ( _objectDp$1 && _objectDp ) || _objectDp$1;

	var descriptor = ( _propertyDesc$1 && _propertyDesc ) || _propertyDesc$1;

	var _hide = require$$0 ? function (object, key, value) {
	  return require$$37.f(object, key, descriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var _hide$1 = /*#__PURE__*/Object.freeze({
		default: _hide,
		__moduleExports: _hide
	});

	var id = 0;
	var px = Math.random();
	var _uid = function _uid(key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _uid$1 = /*#__PURE__*/Object.freeze({
		default: _uid,
		__moduleExports: _uid
	});

	var require$$0$1 = ( _hide$1 && _hide ) || _hide$1;

	var has = ( _has$1 && _has ) || _has$1;

	var uid = ( _uid$1 && _uid ) || _uid$1;

	var require$$1$1 = ( _core$1 && _core ) || _core$1;

	var _redefine = createCommonjsModule(function (module) {
	  var SRC = uid('src');
	  var TO_STRING = 'toString';
	  var $toString = Function[TO_STRING];
	  var TPL = ('' + $toString).split(TO_STRING);

	  require$$1$1.inspectSource = function (it) {
	    return $toString.call(it);
	  };

	  (module.exports = function (O, key, val, safe) {
	    var isFunction = typeof val == 'function';
	    if (isFunction) has(val, 'name') || require$$0$1(val, 'name', key);
	    if (O[key] === val) return;
	    if (isFunction) has(val, SRC) || require$$0$1(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	    if (O === require$$2) {
	      O[key] = val;
	    } else if (!safe) {
	      delete O[key];
	      require$$0$1(O, key, val);
	    } else if (O[key]) {
	      O[key] = val;
	    } else {
	      require$$0$1(O, key, val);
	    }
	    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	  })(Function.prototype, TO_STRING, function toString() {
	    return typeof this == 'function' && this[SRC] || $toString.call(this);
	  });
	});

	var _redefine$1 = /*#__PURE__*/Object.freeze({
		default: _redefine,
		__moduleExports: _redefine
	});

	var _aFunction = function _aFunction(it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	var _aFunction$1 = /*#__PURE__*/Object.freeze({
		default: _aFunction,
		__moduleExports: _aFunction
	});

	var aFunction = ( _aFunction$1 && _aFunction ) || _aFunction$1;

	// optional / simple context binding

	var _ctx = function _ctx(fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1:
	      return function (a) {
	        return fn.call(that, a);
	      };
	    case 2:
	      return function (a, b) {
	        return fn.call(that, a, b);
	      };
	    case 3:
	      return function (a, b, c) {
	        return fn.call(that, a, b, c);
	      };
	  }
	  return function () /* ...args */{
	    return fn.apply(that, arguments);
	  };
	};

	var _ctx$1 = /*#__PURE__*/Object.freeze({
		default: _ctx,
		__moduleExports: _ctx
	});

	var redefine = ( _redefine$1 && _redefine ) || _redefine$1;

	var ctx = ( _ctx$1 && _ctx ) || _ctx$1;

	var PROTOTYPE = 'prototype';

	var $export = function $export(type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? require$$2 : IS_STATIC ? require$$2[name] || (require$$2[name] = {}) : (require$$2[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? require$$1$1 : require$$1$1[name] || (require$$1$1[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, require$$2) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if (target) redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) require$$0$1(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	require$$2.core = require$$1$1;
	// type bitmap
	$export.F = 1; // forced
	$export.G = 2; // global
	$export.S = 4; // static
	$export.P = 8; // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	$export.U = 64; // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	var _export$1 = /*#__PURE__*/Object.freeze({
		default: _export,
		__moduleExports: _export
	});

	var _meta = createCommonjsModule(function (module) {
	  var META = uid('meta');

	  var setDesc = require$$37.f;
	  var id = 0;
	  var isExtensible = Object.isExtensible || function () {
	    return true;
	  };
	  var FREEZE = !require$$1(function () {
	    return isExtensible(Object.preventExtensions({}));
	  });
	  var setMeta = function setMeta(it) {
	    setDesc(it, META, { value: {
	        i: 'O' + ++id, // object ID
	        w: {} // weak collections IDs
	      } });
	  };
	  var fastKey = function fastKey(it, create) {
	    // return primitive with prefix
	    if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	    if (!has(it, META)) {
	      // can't set metadata to uncaught frozen object
	      if (!isExtensible(it)) return 'F';
	      // not necessary to add metadata
	      if (!create) return 'E';
	      // add missing metadata
	      setMeta(it);
	      // return object ID
	    }return it[META].i;
	  };
	  var getWeak = function getWeak(it, create) {
	    if (!has(it, META)) {
	      // can't set metadata to uncaught frozen object
	      if (!isExtensible(it)) return true;
	      // not necessary to add metadata
	      if (!create) return false;
	      // add missing metadata
	      setMeta(it);
	      // return hash weak collections IDs
	    }return it[META].w;
	  };
	  // add metadata on freeze-family methods calling
	  var onFreeze = function onFreeze(it) {
	    if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	    return it;
	  };
	  var meta = module.exports = {
	    KEY: META,
	    NEED: false,
	    fastKey: fastKey,
	    getWeak: getWeak,
	    onFreeze: onFreeze
	  };
	});
	var _meta_1 = _meta.KEY;
	var _meta_2 = _meta.NEED;
	var _meta_3 = _meta.fastKey;
	var _meta_4 = _meta.getWeak;
	var _meta_5 = _meta.onFreeze;

	var _meta$1 = /*#__PURE__*/Object.freeze({
		default: _meta,
		__moduleExports: _meta,
		KEY: _meta_1,
		NEED: _meta_2,
		fastKey: _meta_3,
		getWeak: _meta_4,
		onFreeze: _meta_5
	});

	var SHARED = '__core-js_shared__';
	var store = require$$2[SHARED] || (require$$2[SHARED] = {});
	var _shared = function _shared(key) {
	  return store[key] || (store[key] = {});
	};

	var _shared$1 = /*#__PURE__*/Object.freeze({
		default: _shared,
		__moduleExports: _shared
	});

	var require$$0$2 = ( _shared$1 && _shared ) || _shared$1;

	var _wks = createCommonjsModule(function (module) {
	  var store = require$$0$2('wks');

	  var _Symbol = require$$2.Symbol;
	  var USE_SYMBOL = typeof _Symbol == 'function';

	  var $exports = module.exports = function (name) {
	    return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
	  };

	  $exports.store = store;
	});

	var _wks$1 = /*#__PURE__*/Object.freeze({
		default: _wks,
		__moduleExports: _wks
	});

	var require$$0$3 = ( _wks$1 && _wks ) || _wks$1;

	var def = require$$37.f;

	var TAG = require$$0$3('toStringTag');

	var _setToStringTag = function _setToStringTag(it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};

	var _setToStringTag$1 = /*#__PURE__*/Object.freeze({
		default: _setToStringTag,
		__moduleExports: _setToStringTag
	});

	var f$1 = require$$0$3;

	var _wksExt = {
		f: f$1
	};

	var _wksExt$1 = /*#__PURE__*/Object.freeze({
		default: _wksExt,
		__moduleExports: _wksExt,
		f: f$1
	});

	var _library = false;

	var _library$1 = /*#__PURE__*/Object.freeze({
		default: _library,
		__moduleExports: _library
	});

	var require$$0$4 = ( _library$1 && _library ) || _library$1;

	var wksExt = ( _wksExt$1 && _wksExt ) || _wksExt$1;

	var defineProperty$1 = require$$37.f;
	var _wksDefine = function _wksDefine(name) {
	  var $Symbol = require$$1$1.Symbol || (require$$1$1.Symbol = require$$0$4 ? {} : require$$2.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty$1($Symbol, name, { value: wksExt.f(name) });
	};

	var _wksDefine$1 = /*#__PURE__*/Object.freeze({
		default: _wksDefine,
		__moduleExports: _wksDefine
	});

	var toString$1 = {}.toString;

	var _cof = function _cof(it) {
	  return toString$1.call(it).slice(8, -1);
	};

	var _cof$1 = /*#__PURE__*/Object.freeze({
		default: _cof,
		__moduleExports: _cof
	});

	var require$$1$2 = ( _cof$1 && _cof ) || _cof$1;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings

	// eslint-disable-next-line no-prototype-builtins
	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return require$$1$2(it) == 'String' ? it.split('') : Object(it);
	};

	var _iobject$1 = /*#__PURE__*/Object.freeze({
		default: _iobject,
		__moduleExports: _iobject
	});

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function _defined(it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	var _defined$1 = /*#__PURE__*/Object.freeze({
		default: _defined,
		__moduleExports: _defined
	});

	var IObject = ( _iobject$1 && _iobject ) || _iobject$1;

	var defined = ( _defined$1 && _defined ) || _defined$1;

	// to indexed object, toObject with fallback for non-array-like ES3 strings


	var _toIobject = function _toIobject(it) {
	  return IObject(defined(it));
	};

	var _toIobject$1 = /*#__PURE__*/Object.freeze({
		default: _toIobject,
		__moduleExports: _toIobject
	});

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function _toInteger(it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	var _toInteger$1 = /*#__PURE__*/Object.freeze({
		default: _toInteger,
		__moduleExports: _toInteger
	});

	var toInteger = ( _toInteger$1 && _toInteger ) || _toInteger$1;

	// 7.1.15 ToLength

	var min = Math.min;
	var _toLength = function _toLength(it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

	var _toLength$1 = /*#__PURE__*/Object.freeze({
		default: _toLength,
		__moduleExports: _toLength
	});

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	var _toAbsoluteIndex$1 = /*#__PURE__*/Object.freeze({
		default: _toAbsoluteIndex,
		__moduleExports: _toAbsoluteIndex
	});

	var toIObject = ( _toIobject$1 && _toIobject ) || _toIobject$1;

	var toLength = ( _toLength$1 && _toLength ) || _toLength$1;

	var require$$15 = ( _toAbsoluteIndex$1 && _toAbsoluteIndex ) || _toAbsoluteIndex$1;

	// false -> Array#indexOf
	// true  -> Array#includes


	var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this);
	    var length = toLength(O.length);
	    var index = require$$15(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	      // Array#indexOf ignores holes, Array#includes - not
	    } else for (; length > index; index++) {
	      if (IS_INCLUDES || index in O) {
	        if (O[index] === el) return IS_INCLUDES || index || 0;
	      }
	    }return !IS_INCLUDES && -1;
	  };
	};

	var _arrayIncludes$1 = /*#__PURE__*/Object.freeze({
		default: _arrayIncludes,
		__moduleExports: _arrayIncludes
	});

	var shared = require$$0$2('keys');

	var _sharedKey = function _sharedKey(key) {
	  return shared[key] || (shared[key] = uid(key));
	};

	var _sharedKey$1 = /*#__PURE__*/Object.freeze({
		default: _sharedKey,
		__moduleExports: _sharedKey
	});

	var require$$0$5 = ( _arrayIncludes$1 && _arrayIncludes ) || _arrayIncludes$1;

	var require$$1$3 = ( _sharedKey$1 && _sharedKey ) || _sharedKey$1;

	var arrayIndexOf = require$$0$5(false);
	var IE_PROTO = require$$1$3('IE_PROTO');

	var _objectKeysInternal = function _objectKeysInternal(object, names) {
	  var O = toIObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) {
	    if (key != IE_PROTO) has(O, key) && result.push(key);
	  } // Don't enum bug & hidden keys
	  while (names.length > i) {
	    if (has(O, key = names[i++])) {
	      ~arrayIndexOf(result, key) || result.push(key);
	    }
	  }return result;
	};

	var _objectKeysInternal$1 = /*#__PURE__*/Object.freeze({
		default: _objectKeysInternal,
		__moduleExports: _objectKeysInternal
	});

	// IE 8- don't enum bug keys
	var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

	var _enumBugKeys$1 = /*#__PURE__*/Object.freeze({
		default: _enumBugKeys,
		__moduleExports: _enumBugKeys
	});

	var $keys = ( _objectKeysInternal$1 && _objectKeysInternal ) || _objectKeysInternal$1;

	var require$$0$6 = ( _enumBugKeys$1 && _enumBugKeys ) || _enumBugKeys$1;

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)


	var _objectKeys = Object.keys || function keys(O) {
	  return $keys(O, require$$0$6);
	};

	var _objectKeys$1 = /*#__PURE__*/Object.freeze({
		default: _objectKeys,
		__moduleExports: _objectKeys
	});

	var f$2 = Object.getOwnPropertySymbols;

	var _objectGops = {
		f: f$2
	};

	var _objectGops$1 = /*#__PURE__*/Object.freeze({
		default: _objectGops,
		__moduleExports: _objectGops,
		f: f$2
	});

	var f$3 = {}.propertyIsEnumerable;

	var _objectPie = {
		f: f$3
	};

	var _objectPie$1 = /*#__PURE__*/Object.freeze({
		default: _objectPie,
		__moduleExports: _objectPie,
		f: f$3
	});

	var getKeys = ( _objectKeys$1 && _objectKeys ) || _objectKeys$1;

	var gOPS = ( _objectGops$1 && _objectGops ) || _objectGops$1;

	var require$$0$7 = ( _objectPie$1 && _objectPie ) || _objectPie$1;

	// all enumerable object keys, includes symbols


	var _enumKeys = function _enumKeys(it) {
	  var result = getKeys(it);
	  var getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = require$$0$7.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) {
	      if (isEnum.call(it, key = symbols[i++])) result.push(key);
	    }
	  }return result;
	};

	var _enumKeys$1 = /*#__PURE__*/Object.freeze({
		default: _enumKeys,
		__moduleExports: _enumKeys
	});

	// 7.2.2 IsArray(argument)

	var _isArray = Array.isArray || function isArray(arg) {
	  return require$$1$2(arg) == 'Array';
	};

	var _isArray$1 = /*#__PURE__*/Object.freeze({
		default: _isArray,
		__moduleExports: _isArray
	});

	var _objectDps = require$$0 ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) {
	    require$$37.f(O, P = keys[i++], Properties[P]);
	  }return O;
	};

	var _objectDps$1 = /*#__PURE__*/Object.freeze({
		default: _objectDps,
		__moduleExports: _objectDps
	});

	var document$2 = require$$2.document;
	var _html = document$2 && document$2.documentElement;

	var _html$1 = /*#__PURE__*/Object.freeze({
		default: _html,
		__moduleExports: _html
	});

	var dPs = ( _objectDps$1 && _objectDps ) || _objectDps$1;

	var html = ( _html$1 && _html ) || _html$1;

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


	var IE_PROTO$1 = require$$1$3('IE_PROTO');
	var Empty = function Empty() {/* empty */};
	var PROTOTYPE$1 = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var _createDict = function createDict() {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = require$$2$1('iframe');
	  var i = require$$0$6.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  _createDict = iframeDocument.F;
	  while (i--) {
	    delete _createDict[PROTOTYPE$1][require$$0$6[i]];
	  }return _createDict();
	};

	var _objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE$1] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE$1] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = _createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

	var _objectCreate$1 = /*#__PURE__*/Object.freeze({
		default: _objectCreate,
		__moduleExports: _objectCreate
	});

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

	var hiddenKeys = require$$0$6.concat('length', 'prototype');

	var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};

	var _objectGopn = {
	  f: f$4
	};

	var _objectGopn$1 = /*#__PURE__*/Object.freeze({
		default: _objectGopn,
		__moduleExports: _objectGopn,
		f: f$4
	});

	var gOPN = ( _objectGopn$1 && _objectGopn ) || _objectGopn$1;

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

	var gOPN$1 = gOPN.f;
	var toString$2 = {}.toString;

	var windowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function getWindowNames(it) {
	  try {
	    return gOPN$1(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$2.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(toIObject(it));
	};

	var _objectGopnExt = {
	  f: f$5
	};

	var _objectGopnExt$1 = /*#__PURE__*/Object.freeze({
		default: _objectGopnExt,
		__moduleExports: _objectGopnExt,
		f: f$5
	});

	var gOPD = Object.getOwnPropertyDescriptor;

	var f$6 = require$$0 ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = require$$16(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) {/* empty */}
	  if (has(O, P)) return descriptor(!require$$0$7.f.call(O, P), O[P]);
	};

	var _objectGopd = {
	  f: f$6
	};

	var _objectGopd$1 = /*#__PURE__*/Object.freeze({
		default: _objectGopd,
		__moduleExports: _objectGopd,
		f: f$6
	});

	var $export$1 = ( _export$1 && _export ) || _export$1;

	var require$$0$8 = ( _meta$1 && _meta ) || _meta$1;

	var setToStringTag = ( _setToStringTag$1 && _setToStringTag ) || _setToStringTag$1;

	var require$$0$9 = ( _wksDefine$1 && _wksDefine ) || _wksDefine$1;

	var enumKeys = ( _enumKeys$1 && _enumKeys ) || _enumKeys$1;

	var isArray = ( _isArray$1 && _isArray ) || _isArray$1;

	var create = ( _objectCreate$1 && _objectCreate ) || _objectCreate$1;

	var require$$1$4 = ( _objectGopnExt$1 && _objectGopnExt ) || _objectGopnExt$1;

	var require$$38 = ( _objectGopd$1 && _objectGopd ) || _objectGopd$1;

	// ECMAScript 6 symbols shim


	var META = require$$0$8.KEY;

	var gOPD$1 = require$$38.f;
	var dP$1 = require$$37.f;
	var gOPN$2 = require$$1$4.f;
	var $Symbol = require$$2.Symbol;
	var $JSON = require$$2.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE$2 = 'prototype';
	var HIDDEN = require$$0$3('_hidden');
	var TO_PRIMITIVE = require$$0$3('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = require$$0$2('symbol-registry');
	var AllSymbols = require$$0$2('symbols');
	var OPSymbols = require$$0$2('op-symbols');
	var ObjectProto = Object[PROTOTYPE$2];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = require$$2.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = require$$0 && require$$1(function () {
	  return create(dP$1({}, 'a', {
	    get: function get$$1() {
	      return dP$1(this, 'a', { value: 7 }).a;
	    }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD$1(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP$1(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP$1(ObjectProto, key, protoDesc);
	} : dP$1;

	var wrap = function wrap(tag) {
	  var sym = AllSymbols[tag] = create($Symbol[PROTOTYPE$2]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
	  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty$$1(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = require$$16(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP$1(it, HIDDEN, descriptor(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = create(D, { enumerable: descriptor(0, false) });
	    }return setSymbolDesc(it, key, D);
	  }return dP$1(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) {
	    $defineProperty(it, key = keys[i++], P[key]);
	  }return it;
	};
	var $create = function create$$1(it, P) {
	  return P === undefined ? create(it) : $defineProperties(create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = require$$16(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = require$$16(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD$1(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN$2(toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  }return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN$2(IS_OP ? OPSymbols : toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  }return result;
	};

	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function _Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function $set(value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, descriptor(1, value));
	    };
	    if (require$$0 && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
	    return this._k;
	  });

	  require$$38.f = $getOwnPropertyDescriptor;
	  require$$37.f = $defineProperty;
	  gOPN.f = require$$1$4.f = $getOwnPropertyNames;
	  require$$0$7.f = $propertyIsEnumerable;
	  gOPS.f = $getOwnPropertySymbols;

	  if (require$$0 && !require$$0$4) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function (name) {
	    return wrap(require$$0$3(name));
	  };
	}

	$export$1($export$1.G + $export$1.W + $export$1.F * !USE_NATIVE, { Symbol: $Symbol });

	for (var es6Symbols =
	// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
	  require$$0$3(es6Symbols[j++]);
	}for (var wellKnownSymbols = getKeys(require$$0$3.store), k = 0; wellKnownSymbols.length > k;) {
	  require$$0$9(wellKnownSymbols[k++]);
	}$export$1($export$1.S + $export$1.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function _for(key) {
	    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) {
	      if (SymbolRegistry[key] === sym) return key;
	    }
	  },
	  useSetter: function useSetter() {
	    setter = true;
	  },
	  useSimple: function useSimple() {
	    setter = false;
	  }
	});

	$export$1($export$1.S + $export$1.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export$1($export$1.S + $export$1.F * (!USE_NATIVE || require$$1(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) {
	      args.push(arguments[i++]);
	    }$replacer = replacer = args[1];
	    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!isArray(replacer)) replacer = function replacer(key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || require$$0$1($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(require$$2.JSON, 'JSON', true);

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export$1($export$1.S, 'Object', { create: create });

	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export$1($export$1.S + $export$1.F * !require$$0, 'Object', { defineProperty: require$$37.f });

	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export$1($export$1.S + $export$1.F * !require$$0, 'Object', { defineProperties: dPs });

	// most Object methods by ES6 should accept primitives


	var _objectSap = function _objectSap(KEY, exec) {
	  var fn = (require$$1$1.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  $export$1($export$1.S + $export$1.F * require$$1(function () {
	    fn(1);
	  }), 'Object', exp);
	};

	var _objectSap$1 = /*#__PURE__*/Object.freeze({
		default: _objectSap,
		__moduleExports: _objectSap
	});

	var require$$0$10 = ( _objectSap$1 && _objectSap ) || _objectSap$1;

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)

	var $getOwnPropertyDescriptor$1 = require$$38.f;

	require$$0$10('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor$1(toIObject(it), key);
	  };
	});

	// 7.1.13 ToObject(argument)

	var _toObject = function _toObject(it) {
	  return Object(defined(it));
	};

	var _toObject$1 = /*#__PURE__*/Object.freeze({
		default: _toObject,
		__moduleExports: _toObject
	});

	var require$$20 = ( _toObject$1 && _toObject ) || _toObject$1;

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


	var IE_PROTO$2 = require$$1$3('IE_PROTO');
	var ObjectProto$1 = Object.prototype;

	var _objectGpo = Object.getPrototypeOf || function (O) {
	  O = require$$20(O);
	  if (has(O, IE_PROTO$2)) return O[IE_PROTO$2];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  }return O instanceof Object ? ObjectProto$1 : null;
	};

	var _objectGpo$1 = /*#__PURE__*/Object.freeze({
		default: _objectGpo,
		__moduleExports: _objectGpo
	});

	var require$$23 = ( _objectGpo$1 && _objectGpo ) || _objectGpo$1;

	// 19.1.2.9 Object.getPrototypeOf(O)


	require$$0$10('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return require$$23(require$$20(it));
	  };
	});

	// 19.1.2.14 Object.keys(O)


	require$$0$10('keys', function () {
	  return function keys(it) {
	    return getKeys(require$$20(it));
	  };
	});

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	require$$0$10('getOwnPropertyNames', function () {
	  return require$$1$4.f;
	});

	// 19.1.2.5 Object.freeze(O)

	var meta = require$$0$8.onFreeze;

	require$$0$10('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

	// 19.1.2.17 Object.seal(O)

	var meta$1 = require$$0$8.onFreeze;

	require$$0$10('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && isObject(it) ? $seal(meta$1(it)) : it;
	  };
	});

	// 19.1.2.15 Object.preventExtensions(O)

	var meta$2 = require$$0$8.onFreeze;

	require$$0$10('preventExtensions', function ($preventExtensions) {
	  return function preventExtensions(it) {
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta$2(it)) : it;
	  };
	});

	// 19.1.2.12 Object.isFrozen(O)


	require$$0$10('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

	// 19.1.2.13 Object.isSealed(O)


	require$$0$10('isSealed', function ($isSealed) {
	  return function isSealed(it) {
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

	// 19.1.2.11 Object.isExtensible(O)


	require$$0$10('isExtensible', function ($isExtensible) {
	  return function isExtensible(it) {
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

	// 19.1.2.1 Object.assign(target, source, ...)


	var $assign = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	var _objectAssign = !$assign || require$$1(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) {
	    B[k] = k;
	  });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) {
	  // eslint-disable-line no-unused-vars
	  var T = require$$20(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = gOPS.f;
	  var isEnum = require$$0$7.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]);
	    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	    }
	  }return T;
	} : $assign;

	var _objectAssign$1 = /*#__PURE__*/Object.freeze({
		default: _objectAssign,
		__moduleExports: _objectAssign
	});

	var assign = ( _objectAssign$1 && _objectAssign ) || _objectAssign$1;

	// 19.1.3.1 Object.assign(target, source)


	$export$1($export$1.S + $export$1.F, 'Object', { assign: assign });

	// 7.2.9 SameValue(x, y)
	var _sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	var _sameValue$1 = /*#__PURE__*/Object.freeze({
		default: _sameValue,
		__moduleExports: _sameValue
	});

	var require$$0$11 = ( _sameValue$1 && _sameValue ) || _sameValue$1;

	// 19.1.3.10 Object.is(value1, value2)

	$export$1($export$1.S, 'Object', { is: require$$0$11 });

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */

	var check = function check(O, proto) {
	  anObject(O);
	  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	var _setProto = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	  function (test, buggy, set) {
	    try {
	      set = ctx(Function.call, require$$38.f(Object.prototype, '__proto__').set, 2);
	      set(test, []);
	      buggy = !(test instanceof Array);
	    } catch (e) {
	      buggy = true;
	    }
	    return function setPrototypeOf(O, proto) {
	      check(O, proto);
	      if (buggy) O.__proto__ = proto;else set(O, proto);
	      return O;
	    };
	  }({}, false) : undefined),
	  check: check
	};
	var _setProto_1 = _setProto.set;
	var _setProto_2 = _setProto.check;

	var _setProto$1 = /*#__PURE__*/Object.freeze({
		default: _setProto,
		__moduleExports: _setProto,
		set: _setProto_1,
		check: _setProto_2
	});

	var require$$0$12 = ( _setProto$1 && _setProto ) || _setProto$1;

	// 19.1.3.19 Object.setPrototypeOf(O, proto)

	$export$1($export$1.S, 'Object', { setPrototypeOf: require$$0$12.set });

	// getting tag from 19.1.3.6 Object.prototype.toString()

	var TAG$1 = require$$0$3('toStringTag');
	// ES3 wrong here
	var ARG = require$$1$2(function () {
	  return arguments;
	}()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function tryGet(it, key) {
	  try {
	    return it[key];
	  } catch (e) {/* empty */}
	};

	var _classof = function _classof(it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	  // @@toStringTag case
	  : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
	  // builtinTag case
	  : ARG ? require$$1$2(O)
	  // ES3 arguments fallback
	  : (B = require$$1$2(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

	var _classof$1 = /*#__PURE__*/Object.freeze({
		default: _classof,
		__moduleExports: _classof
	});

	var classof = ( _classof$1 && _classof ) || _classof$1;

	// 19.1.3.6 Object.prototype.toString()

	var test = {};
	test[require$$0$3('toStringTag')] = 'z';
	if (test + '' != '[object z]') {
	  redefine(Object.prototype, 'toString', function toString() {
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	var _invoke = function _invoke(fn, args, that) {
	                  var un = that === undefined;
	                  switch (args.length) {
	                                    case 0:
	                                                      return un ? fn() : fn.call(that);
	                                    case 1:
	                                                      return un ? fn(args[0]) : fn.call(that, args[0]);
	                                    case 2:
	                                                      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
	                                    case 3:
	                                                      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
	                                    case 4:
	                                                      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
	                  }return fn.apply(that, args);
	};

	var _invoke$1 = /*#__PURE__*/Object.freeze({
		default: _invoke,
		__moduleExports: _invoke
	});

	var invoke = ( _invoke$1 && _invoke ) || _invoke$1;

	var arraySlice = [].slice;
	var factories = {};

	var construct = function construct(F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) {
	      n[i] = 'a[' + i + ']';
	    } // eslint-disable-next-line no-new-func
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  }return factories[len](F, args);
	};

	var _bind = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction(this);
	  var partArgs = arraySlice.call(arguments, 1);
	  var bound = function bound() /* args... */{
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
	  return bound;
	};

	var _bind$1 = /*#__PURE__*/Object.freeze({
		default: _bind,
		__moduleExports: _bind
	});

	var bind = ( _bind$1 && _bind ) || _bind$1;

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)


	$export$1($export$1.P, 'Function', { bind: bind });

	var dP$2 = require$$37.f;
	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';

	// 19.2.4.2 name
	NAME in FProto || require$$0 && dP$2(FProto, NAME, {
	  configurable: true,
	  get: function get() {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});

	var HAS_INSTANCE = require$$0$3('hasInstance');
	var FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if (!(HAS_INSTANCE in FunctionProto)) require$$37.f(FunctionProto, HAS_INSTANCE, { value: function value(O) {
	    if (typeof this != 'function' || !isObject(O)) return false;
	    if (!isObject(this.prototype)) return O instanceof this;
	    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	    while (O = require$$23(O)) {
	      if (this.prototype === O) return true;
	    }return false;
	  } });

	var _stringWs = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var _stringWs$1 = /*#__PURE__*/Object.freeze({
		default: _stringWs,
		__moduleExports: _stringWs
	});

	var spaces = ( _stringWs$1 && _stringWs ) || _stringWs$1;

	var space = '[' + spaces + ']';
	var non = '\u200B\x85';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');

	var exporter = function exporter(KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = require$$1(function () {
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  $export$1($export$1.P + $export$1.F * FORCE, 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};

	var _stringTrim = exporter;

	var _stringTrim$1 = /*#__PURE__*/Object.freeze({
		default: _stringTrim,
		__moduleExports: _stringTrim
	});

	var require$$1$5 = ( _stringTrim$1 && _stringTrim ) || _stringTrim$1;

	var $parseInt = require$$2.parseInt;
	var $trim = require$$1$5.trim;

	var hex = /^[-+]?0[xX]/;

	var _parseInt = $parseInt(spaces + '08') !== 8 || $parseInt(spaces + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
	} : $parseInt;

	var _parseInt$1 = /*#__PURE__*/Object.freeze({
		default: _parseInt,
		__moduleExports: _parseInt
	});

	var $parseInt$1 = ( _parseInt$1 && _parseInt ) || _parseInt$1;

	// 18.2.5 parseInt(string, radix)
	$export$1($export$1.G + $export$1.F * (parseInt != $parseInt$1), { parseInt: $parseInt$1 });

	var $parseFloat = require$$2.parseFloat;
	var $trim$1 = require$$1$5.trim;

	var _parseFloat = 1 / $parseFloat(spaces + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim$1(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	var _parseFloat$1 = /*#__PURE__*/Object.freeze({
		default: _parseFloat,
		__moduleExports: _parseFloat
	});

	var $parseFloat$1 = ( _parseFloat$1 && _parseFloat ) || _parseFloat$1;

	// 18.2.4 parseFloat(string)
	$export$1($export$1.G + $export$1.F * (parseFloat != $parseFloat$1), { parseFloat: $parseFloat$1 });

	var setPrototypeOf = require$$0$12.set;
	var _inheritIfRequired = function _inheritIfRequired(that, target, C) {
	  var S = target.constructor;
	  var P;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  }return that;
	};

	var _inheritIfRequired$1 = /*#__PURE__*/Object.freeze({
		default: _inheritIfRequired,
		__moduleExports: _inheritIfRequired
	});

	var inheritIfRequired = ( _inheritIfRequired$1 && _inheritIfRequired ) || _inheritIfRequired$1;

	var gOPN$3 = gOPN.f;
	var gOPD$2 = require$$38.f;
	var dP$3 = require$$37.f;
	var $trim$2 = require$$1$5.trim;
	var NUMBER = 'Number';
	var $Number = require$$2[NUMBER];
	var Base = $Number;
	var proto = $Number.prototype;
	// Opera ~12 has broken Object#toString
	var BROKEN_COF = require$$1$2(create(proto)) == NUMBER;
	var TRIM = 'trim' in String.prototype;

	// 7.1.3 ToNumber(argument)
	var toNumber = function toNumber(argument) {
	  var it = require$$16(argument, false);
	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim$2(it, 3);
	    var first = it.charCodeAt(0);
	    var third, radix, maxCode;
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66:case 98:
	          radix = 2;maxCode = 49;break; // fast equal /^0b[01]+$/i
	        case 79:case 111:
	          radix = 8;maxCode = 55;break; // fast equal /^0o[0-7]+$/i
	        default:
	          return +it;
	      }
	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      }return parseInt(digits, radix);
	    }
	  }return +it;
	};

	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var that = this;
	    return that instanceof $Number
	    // check on 1..constructor(foo) case
	    && (BROKEN_COF ? require$$1(function () {
	      proto.valueOf.call(that);
	    }) : require$$1$2(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for (var keys = require$$0 ? gOPN$3(Base) : (
	  // ES3:
	  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	  // ES6 (in case, if modules with ES6 Number statics required before):
	  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j$1 = 0, key$1; keys.length > j$1; j$1++) {
	    if (has(Base, key$1 = keys[j$1]) && !has($Number, key$1)) {
	      dP$3($Number, key$1, gOPD$2(Base, key$1));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  redefine(require$$2, NUMBER, $Number);
	}

	var _aNumberValue = function _aNumberValue(it, msg) {
	  if (typeof it != 'number' && require$$1$2(it) != 'Number') throw TypeError(msg);
	  return +it;
	};

	var _aNumberValue$1 = /*#__PURE__*/Object.freeze({
		default: _aNumberValue,
		__moduleExports: _aNumberValue
	});

	var _stringRepeat = function repeat(count) {
	  var str = String(defined(this));
	  var res = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
	  for (; n > 0; (n >>>= 1) && (str += str)) {
	    if (n & 1) res += str;
	  }return res;
	};

	var _stringRepeat$1 = /*#__PURE__*/Object.freeze({
		default: _stringRepeat,
		__moduleExports: _stringRepeat
	});

	var aNumberValue = ( _aNumberValue$1 && _aNumberValue ) || _aNumberValue$1;

	var repeat = ( _stringRepeat$1 && _stringRepeat ) || _stringRepeat$1;

	var $toFixed = 1.0.toFixed;
	var floor$1 = Math.floor;
	var data = [0, 0, 0, 0, 0, 0];
	var ERROR = 'Number.toFixed: incorrect invocation!';
	var ZERO = '0';

	var multiply = function multiply(n, c) {
	  var i = -1;
	  var c2 = c;
	  while (++i < 6) {
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor$1(c2 / 1e7);
	  }
	};
	var divide = function divide(n) {
	  var i = 6;
	  var c = 0;
	  while (--i >= 0) {
	    c += data[i];
	    data[i] = floor$1(c / n);
	    c = c % n * 1e7;
	  }
	};
	var numToString = function numToString() {
	  var i = 6;
	  var s = '';
	  while (--i >= 0) {
	    if (s !== '' || i === 0 || data[i] !== 0) {
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  }return s;
	};
	var pow = function pow(x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function log(x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  }return n;
	};

	$export$1($export$1.P + $export$1.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !require$$1(function () {
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits) {
	    var x = aNumberValue(this, ERROR);
	    var f = toInteger(fractionDigits);
	    var s = '';
	    var m = ZERO;
	    var e, z, j, k;
	    if (f < 0 || f > 20) throw RangeError(ERROR);
	    // eslint-disable-next-line no-self-compare
	    if (x != x) return 'NaN';
	    if (x <= -1e21 || x >= 1e21) return String(x);
	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }
	    if (x > 1e-21) {
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = f;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if (f > 0) {
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    }return m;
	  }
	});

	var $toPrecision = 1.0.toPrecision;

	$export$1($export$1.P + $export$1.F * (require$$1(function () {
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !require$$1(function () {
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision) {
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
	  }
	});

	// 20.1.2.1 Number.EPSILON


	$export$1($export$1.S, 'Number', { EPSILON: Math.pow(2, -52) });

	// 20.1.2.2 Number.isFinite(number)

	var _isFinite = require$$2.isFinite;

	$export$1($export$1.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

	// 20.1.2.3 Number.isInteger(number)

	var floor$2 = Math.floor;
	var _isInteger = function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor$2(it) === it;
	};

	var _isInteger$1 = /*#__PURE__*/Object.freeze({
		default: _isInteger,
		__moduleExports: _isInteger
	});

	var isInteger = ( _isInteger$1 && _isInteger ) || _isInteger$1;

	// 20.1.2.3 Number.isInteger(number)


	$export$1($export$1.S, 'Number', { isInteger: isInteger });

	// 20.1.2.4 Number.isNaN(number)


	$export$1($export$1.S, 'Number', {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	// 20.1.2.5 Number.isSafeInteger(number)


	var abs = Math.abs;

	$export$1($export$1.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

	// 20.1.2.6 Number.MAX_SAFE_INTEGER


	$export$1($export$1.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

	// 20.1.2.10 Number.MIN_SAFE_INTEGER


	$export$1($export$1.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

	// 20.1.2.12 Number.parseFloat(string)
	$export$1($export$1.S + $export$1.F * (Number.parseFloat != $parseFloat$1), 'Number', { parseFloat: $parseFloat$1 });

	// 20.1.2.13 Number.parseInt(string, radix)
	$export$1($export$1.S + $export$1.F * (Number.parseInt != $parseInt$1), 'Number', { parseInt: $parseInt$1 });

	// 20.2.2.20 Math.log1p(x)
	var _mathLog1p = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

	var _mathLog1p$1 = /*#__PURE__*/Object.freeze({
		default: _mathLog1p,
		__moduleExports: _mathLog1p
	});

	var require$$0$13 = ( _mathLog1p$1 && _mathLog1p ) || _mathLog1p$1;

	// 20.2.2.3 Math.acosh(x)


	var sqrt = Math.sqrt;
	var $acosh = Math.acosh;

	$export$1($export$1.S + $export$1.F * !($acosh
	// V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	&& Math.floor($acosh(Number.MAX_VALUE)) == 710
	// Tor Browser bug: Math.acosh(Infinity) -> NaN
	&& $acosh(Infinity) == Infinity), 'Math', {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : require$$0$13(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

	// 20.2.2.5 Math.asinh(x)

	var $asinh = Math.asinh;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}

	// Tor Browser bug: Math.asinh(0) -> -0
	$export$1($export$1.S + $export$1.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

	// 20.2.2.7 Math.atanh(x)

	var $atanh = Math.atanh;

	// Tor Browser bug: Math.atanh(-0) -> 0
	$export$1($export$1.S + $export$1.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

	// 20.2.2.28 Math.sign(x)
	var _mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	var _mathSign$1 = /*#__PURE__*/Object.freeze({
		default: _mathSign,
		__moduleExports: _mathSign
	});

	var sign = ( _mathSign$1 && _mathSign ) || _mathSign$1;

	// 20.2.2.9 Math.cbrt(x)


	$export$1($export$1.S, 'Math', {
	  cbrt: function cbrt(x) {
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

	// 20.2.2.11 Math.clz32(x)


	$export$1($export$1.S, 'Math', {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

	// 20.2.2.12 Math.cosh(x)

	var exp = Math.exp;

	$export$1($export$1.S, 'Math', {
	  cosh: function cosh(x) {
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	var _mathExpm1 = !$expm1
	// Old FF bug
	|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	// Tor Browser bug
	|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

	var _mathExpm1$1 = /*#__PURE__*/Object.freeze({
		default: _mathExpm1,
		__moduleExports: _mathExpm1
	});

	var expm1 = ( _mathExpm1$1 && _mathExpm1 ) || _mathExpm1$1;

	// 20.2.2.14 Math.expm1(x)


	$export$1($export$1.S + $export$1.F * (expm1 != Math.expm1), 'Math', { expm1: expm1 });

	// 20.2.2.16 Math.fround(x)

	var pow$1 = Math.pow;
	var EPSILON = pow$1(2, -52);
	var EPSILON32 = pow$1(2, -23);
	var MAX32 = pow$1(2, 127) * (2 - EPSILON32);
	var MIN32 = pow$1(2, -126);

	var roundTiesToEven = function roundTiesToEven(n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	var _mathFround = Math.fround || function fround(x) {
	  var $abs = Math.abs(x);
	  var $sign = sign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};

	var _mathFround$1 = /*#__PURE__*/Object.freeze({
		default: _mathFround,
		__moduleExports: _mathFround
	});

	var fround = ( _mathFround$1 && _mathFround ) || _mathFround$1;

	// 20.2.2.16 Math.fround(x)


	$export$1($export$1.S, 'Math', { fround: fround });

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])

	var abs$1 = Math.abs;

	$export$1($export$1.S, 'Math', {
	  hypot: function hypot(value1, value2) {
	    // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs$1(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

	// 20.2.2.18 Math.imul(x, y)

	var $imul = Math.imul;

	// some WebKit versions fails with big numbers, some has wrong arity
	$export$1($export$1.S + $export$1.F * require$$1(function () {
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y) {
	    var UINT16 = 0xffff;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

	// 20.2.2.21 Math.log10(x)


	$export$1($export$1.S, 'Math', {
	  log10: function log10(x) {
	    return Math.log(x) * Math.LOG10E;
	  }
	});

	// 20.2.2.20 Math.log1p(x)


	$export$1($export$1.S, 'Math', { log1p: require$$0$13 });

	// 20.2.2.22 Math.log2(x)


	$export$1($export$1.S, 'Math', {
	  log2: function log2(x) {
	    return Math.log(x) / Math.LN2;
	  }
	});

	// 20.2.2.28 Math.sign(x)


	$export$1($export$1.S, 'Math', { sign: sign });

	// 20.2.2.30 Math.sinh(x)


	var exp$1 = Math.exp;

	// V8 near Chromium 38 has a problem with very small numbers
	$export$1($export$1.S + $export$1.F * require$$1(function () {
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x) {
	    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (Math.E / 2);
	  }
	});

	// 20.2.2.33 Math.tanh(x)


	var exp$2 = Math.exp;

	$export$1($export$1.S, 'Math', {
	  tanh: function tanh(x) {
	    var a = expm1(x = +x);
	    var b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
	  }
	});

	// 20.2.2.34 Math.trunc(x)


	$export$1($export$1.S, 'Math', {
	  trunc: function trunc(it) {
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	$export$1($export$1.S + $export$1.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) {
	    // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments[i++];
	      if (require$$15(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
	    }return res.join('');
	  }
	});

	$export$1($export$1.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite) {
	    var tpl = toIObject(callSite.raw);
	    var len = toLength(tpl.length);
	    var aLen = arguments.length;
	    var res = [];
	    var i = 0;
	    while (len > i) {
	      res.push(String(tpl[i++]));
	      if (i < aLen) res.push(String(arguments[i]));
	    }return res.join('');
	  }
	});

	// 21.1.3.25 String.prototype.trim()
	require$$1$5('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});

	// true  -> String#at
	// false -> String#codePointAt
	var _stringAt = function _stringAt(TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that));
	    var i = toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var _stringAt$1 = /*#__PURE__*/Object.freeze({
		default: _stringAt,
		__moduleExports: _stringAt
	});

	var _iterators = {};

	var _iterators$1 = /*#__PURE__*/Object.freeze({
		default: _iterators,
		__moduleExports: _iterators
	});

	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	require$$0$1(IteratorPrototype, require$$0$3('iterator'), function () {
	  return this;
	});

	var _iterCreate = function _iterCreate(Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

	var _iterCreate$1 = /*#__PURE__*/Object.freeze({
		default: _iterCreate,
		__moduleExports: _iterCreate
	});

	var require$$32 = ( _iterators$1 && _iterators ) || _iterators$1;

	var $iterCreate = ( _iterCreate$1 && _iterCreate ) || _iterCreate$1;

	var ITERATOR = require$$0$3('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function returnThis() {
	  return this;
	};

	var _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function getMethod(kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS:
	        return function keys() {
	          return new Constructor(this, kind);
	        };
	      case VALUES:
	        return function values() {
	          return new Constructor(this, kind);
	        };
	    }return function entries() {
	      return new Constructor(this, kind);
	    };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = !BUGGY && $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = require$$23($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!require$$0$4 && !has(IteratorPrototype, ITERATOR)) require$$0$1(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() {
	      return $native.call(this);
	    };
	  }
	  // Define iterator
	  if ((!require$$0$4 || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    require$$0$1(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  require$$32[NAME] = $default;
	  require$$32[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else $export$1($export$1.P + $export$1.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

	var _iterDefine$1 = /*#__PURE__*/Object.freeze({
		default: _iterDefine,
		__moduleExports: _iterDefine
	});

	var require$$0$14 = ( _stringAt$1 && _stringAt ) || _stringAt$1;

	var $iterDefine = ( _iterDefine$1 && _iterDefine ) || _iterDefine$1;

	var $at = require$$0$14(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	$iterDefine(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0; // next index
	  // 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});

	var $at$1 = require$$0$14(false);
	$export$1($export$1.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at$1(this, pos);
	  }
	});

	// 7.2.8 IsRegExp(argument)


	var MATCH = require$$0$3('match');
	var _isRegexp = function _isRegexp(it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : require$$1$2(it) == 'RegExp');
	};

	var _isRegexp$1 = /*#__PURE__*/Object.freeze({
		default: _isRegexp,
		__moduleExports: _isRegexp
	});

	var isRegExp = ( _isRegexp$1 && _isRegexp ) || _isRegexp$1;

	// helper for String#{startsWith, endsWith, includes}


	var _stringContext = function _stringContext(that, searchString, NAME) {
	  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

	var _stringContext$1 = /*#__PURE__*/Object.freeze({
		default: _stringContext,
		__moduleExports: _stringContext
	});

	var MATCH$1 = require$$0$3('match');
	var _failsIsRegexp = function _failsIsRegexp(KEY) {
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH$1] = false;
	      return !'/./'[KEY](re);
	    } catch (f) {/* empty */}
	  }return true;
	};

	var _failsIsRegexp$1 = /*#__PURE__*/Object.freeze({
		default: _failsIsRegexp,
		__moduleExports: _failsIsRegexp
	});

	var context = ( _stringContext$1 && _stringContext ) || _stringContext$1;

	var require$$0$15 = ( _failsIsRegexp$1 && _failsIsRegexp ) || _failsIsRegexp$1;

	var ENDS_WITH = 'endsWith';
	var $endsWith = ''[ENDS_WITH];

	$export$1($export$1.P + $export$1.F * require$$0$15(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = context(this, searchString, ENDS_WITH);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
	    var search = String(searchString);
	    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
	  }
	});

	var INCLUDES = 'includes';

	$export$1($export$1.P + $export$1.F * require$$0$15(INCLUDES), 'String', {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	$export$1($export$1.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: repeat
	});

	var STARTS_WITH = 'startsWith';
	var $startsWith = ''[STARTS_WITH];

	$export$1($export$1.P + $export$1.F * require$$0$15(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = context(this, searchString, STARTS_WITH);
	    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
	  }
	});

	var quot = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function createHTML(string, tag, attribute, value) {
	  var S = String(defined(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	var _stringHtml = function _stringHtml(NAME, exec) {
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export$1($export$1.P + $export$1.F * require$$1(function () {
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

	var _stringHtml$1 = /*#__PURE__*/Object.freeze({
		default: _stringHtml,
		__moduleExports: _stringHtml
	});

	var require$$0$16 = ( _stringHtml$1 && _stringHtml ) || _stringHtml$1;

	// B.2.3.2 String.prototype.anchor(name)
	require$$0$16('anchor', function (createHTML) {
	  return function anchor(name) {
	    return createHTML(this, 'a', 'name', name);
	  };
	});

	// B.2.3.3 String.prototype.big()
	require$$0$16('big', function (createHTML) {
	  return function big() {
	    return createHTML(this, 'big', '', '');
	  };
	});

	// B.2.3.4 String.prototype.blink()
	require$$0$16('blink', function (createHTML) {
	  return function blink() {
	    return createHTML(this, 'blink', '', '');
	  };
	});

	// B.2.3.5 String.prototype.bold()
	require$$0$16('bold', function (createHTML) {
	  return function bold() {
	    return createHTML(this, 'b', '', '');
	  };
	});

	// B.2.3.6 String.prototype.fixed()
	require$$0$16('fixed', function (createHTML) {
	  return function fixed() {
	    return createHTML(this, 'tt', '', '');
	  };
	});

	// B.2.3.7 String.prototype.fontcolor(color)
	require$$0$16('fontcolor', function (createHTML) {
	  return function fontcolor(color) {
	    return createHTML(this, 'font', 'color', color);
	  };
	});

	// B.2.3.8 String.prototype.fontsize(size)
	require$$0$16('fontsize', function (createHTML) {
	  return function fontsize(size) {
	    return createHTML(this, 'font', 'size', size);
	  };
	});

	// B.2.3.9 String.prototype.italics()
	require$$0$16('italics', function (createHTML) {
	  return function italics() {
	    return createHTML(this, 'i', '', '');
	  };
	});

	// B.2.3.10 String.prototype.link(url)
	require$$0$16('link', function (createHTML) {
	  return function link(url) {
	    return createHTML(this, 'a', 'href', url);
	  };
	});

	// B.2.3.11 String.prototype.small()
	require$$0$16('small', function (createHTML) {
	  return function small() {
	    return createHTML(this, 'small', '', '');
	  };
	});

	// B.2.3.12 String.prototype.strike()
	require$$0$16('strike', function (createHTML) {
	  return function strike() {
	    return createHTML(this, 'strike', '', '');
	  };
	});

	// B.2.3.13 String.prototype.sub()
	require$$0$16('sub', function (createHTML) {
	  return function sub() {
	    return createHTML(this, 'sub', '', '');
	  };
	});

	// B.2.3.14 String.prototype.sup()
	require$$0$16('sup', function (createHTML) {
	  return function sup() {
	    return createHTML(this, 'sup', '', '');
	  };
	});

	// 20.3.3.1 / 15.9.4.4 Date.now()


	$export$1($export$1.S, 'Date', { now: function now() {
	    return new Date().getTime();
	  } });

	$export$1($export$1.P + $export$1.F * require$$1(function () {
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function toISOString() {
	      return 1;
	    } }) !== 1;
	}), 'Date', {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = require$$20(this);
	    var pv = require$$16(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

	var getTime = Date.prototype.getTime;
	var $toISOString = Date.prototype.toISOString;

	var lz = function lz(num) {
	  return num > 9 ? num : '0' + num;
	};

	// PhantomJS / old WebKit has a broken implementations
	var _dateToIsoString = require$$1(function () {
	  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !require$$1(function () {
	  $toISOString.call(new Date(NaN));
	}) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var d = this;
	  var y = d.getUTCFullYear();
	  var m = d.getUTCMilliseconds();
	  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	} : $toISOString;

	var _dateToIsoString$1 = /*#__PURE__*/Object.freeze({
		default: _dateToIsoString,
		__moduleExports: _dateToIsoString
	});

	var toISOString = ( _dateToIsoString$1 && _dateToIsoString ) || _dateToIsoString$1;

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()


	// PhantomJS / old WebKit has a broken implementations
	$export$1($export$1.P + $export$1.F * (Date.prototype.toISOString !== toISOString), 'Date', {
	  toISOString: toISOString
	});

	var DateProto = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var $toString = DateProto[TO_STRING];
	var getTime$1 = DateProto.getTime;
	if (new Date(NaN) + '' != INVALID_DATE) {
	  redefine(DateProto, TO_STRING, function toString() {
	    var value = getTime$1.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

	var NUMBER$1 = 'number';

	var _dateToPrimitive = function _dateToPrimitive(hint) {
	  if (hint !== 'string' && hint !== NUMBER$1 && hint !== 'default') throw TypeError('Incorrect hint');
	  return require$$16(anObject(this), hint != NUMBER$1);
	};

	var _dateToPrimitive$1 = /*#__PURE__*/Object.freeze({
		default: _dateToPrimitive,
		__moduleExports: _dateToPrimitive
	});

	var require$$2$2 = ( _dateToPrimitive$1 && _dateToPrimitive ) || _dateToPrimitive$1;

	var TO_PRIMITIVE$1 = require$$0$3('toPrimitive');
	var proto$1 = Date.prototype;

	if (!(TO_PRIMITIVE$1 in proto$1)) require$$0$1(proto$1, TO_PRIMITIVE$1, require$$2$2);

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)


	$export$1($export$1.S, 'Array', { isArray: isArray });

	// call something on iterator step with safe closing on error

	var _iterCall = function _iterCall(iterator, fn, value, entries) {
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	    // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) anObject(ret.call(iterator));
	    throw e;
	  }
	};

	var _iterCall$1 = /*#__PURE__*/Object.freeze({
		default: _iterCall,
		__moduleExports: _iterCall
	});

	// check on default Array iterator

	var ITERATOR$1 = require$$0$3('iterator');
	var ArrayProto = Array.prototype;

	var _isArrayIter = function _isArrayIter(it) {
	  return it !== undefined && (require$$32.Array === it || ArrayProto[ITERATOR$1] === it);
	};

	var _isArrayIter$1 = /*#__PURE__*/Object.freeze({
		default: _isArrayIter,
		__moduleExports: _isArrayIter
	});

	var _createProperty = function _createProperty(object, index, value) {
	  if (index in object) require$$37.f(object, index, descriptor(0, value));else object[index] = value;
	};

	var _createProperty$1 = /*#__PURE__*/Object.freeze({
		default: _createProperty,
		__moduleExports: _createProperty
	});

	var ITERATOR$2 = require$$0$3('iterator');

	var core_getIteratorMethod = require$$1$1.getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || require$$32[classof(it)];
	};

	var core_getIteratorMethod$1 = /*#__PURE__*/Object.freeze({
		default: core_getIteratorMethod,
		__moduleExports: core_getIteratorMethod
	});

	var ITERATOR$3 = require$$0$3('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR$3]();
	  riter['return'] = function () {
	    SAFE_CLOSING = true;
	  };
	} catch (e) {/* empty */}

	var _iterDetect = function _iterDetect(exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR$3]();
	    iter.next = function () {
	      return { done: safe = true };
	    };
	    arr[ITERATOR$3] = function () {
	      return iter;
	    };
	    exec(arr);
	  } catch (e) {/* empty */}
	  return safe;
	};

	var _iterDetect$1 = /*#__PURE__*/Object.freeze({
		default: _iterDetect,
		__moduleExports: _iterDetect
	});

	var call = ( _iterCall$1 && _iterCall ) || _iterCall$1;

	var require$$21 = ( _isArrayIter$1 && _isArrayIter ) || _isArrayIter$1;

	var createProperty = ( _createProperty$1 && _createProperty ) || _createProperty$1;

	var require$$25 = ( core_getIteratorMethod$1 && core_getIteratorMethod ) || core_getIteratorMethod$1;

	var require$$33 = ( _iterDetect$1 && _iterDetect ) || _iterDetect$1;

	$export$1($export$1.S + $export$1.F * !require$$33(function (iter) {
	}), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	    var O = require$$20(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = require$$25(O);
	    var length, result, step, iterator;
	    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && require$$21(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});

	// WebKit Array.of isn't generic
	$export$1($export$1.S + $export$1.F * require$$1(function () {
	  function F() {/* empty */}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of() /* ...args */{
	    var index = 0;
	    var aLen = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(aLen);
	    while (aLen > index) {
	      createProperty(result, index, arguments[index++]);
	    }result.length = aLen;
	    return result;
	  }
	});

	var _strictMethod = function _strictMethod(method, arg) {
	  return !!method && require$$1(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () {/* empty */}, 1) : method.call(null);
	  });
	};

	var _strictMethod$1 = /*#__PURE__*/Object.freeze({
		default: _strictMethod,
		__moduleExports: _strictMethod
	});

	var require$$0$17 = ( _strictMethod$1 && _strictMethod ) || _strictMethod$1;

	// 22.1.3.13 Array.prototype.join(separator)


	var arrayJoin = [].join;

	// fallback for not array-like strings
	$export$1($export$1.P + $export$1.F * (IObject != Object || !require$$0$17(arrayJoin)), 'Array', {
	  join: function join(separator) {
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

	var arraySlice$1 = [].slice;

	// fallback for not array-like ES3 strings and DOM objects
	$export$1($export$1.P + $export$1.F * require$$1(function () {
	  if (html) arraySlice$1.call(html);
	}), 'Array', {
	  slice: function slice(begin, end) {
	    var len = toLength(this.length);
	    var klass = require$$1$2(this);
	    end = end === undefined ? len : end;
	    if (klass == 'Array') return arraySlice$1.call(this, begin, end);
	    var start = require$$15(begin, len);
	    var upTo = require$$15(end, len);
	    var size = toLength(upTo - start);
	    var cloned = new Array(size);
	    var i = 0;
	    for (; i < size; i++) {
	      cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
	    }return cloned;
	  }
	});

	var $sort = [].sort;
	var test$1 = [1, 2, 3];

	$export$1($export$1.P + $export$1.F * (require$$1(function () {
	  // IE8-
	  test$1.sort(undefined);
	}) || !require$$1(function () {
	  // V8 bug
	  test$1.sort(null);
	  // Old WebKit
	}) || !require$$0$17($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined ? $sort.call(require$$20(this)) : $sort.call(require$$20(this), aFunction(comparefn));
	  }
	});

	var SPECIES = require$$0$3('species');

	var _arraySpeciesConstructor = function _arraySpeciesConstructor(original) {
	  var C;
	  if (isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  }return C === undefined ? Array : C;
	};

	var _arraySpeciesConstructor$1 = /*#__PURE__*/Object.freeze({
		default: _arraySpeciesConstructor,
		__moduleExports: _arraySpeciesConstructor
	});

	var speciesConstructor = ( _arraySpeciesConstructor$1 && _arraySpeciesConstructor ) || _arraySpeciesConstructor$1;

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


	var _arraySpeciesCreate = function _arraySpeciesCreate(original, length) {
	  return new (speciesConstructor(original))(length);
	};

	var _arraySpeciesCreate$1 = /*#__PURE__*/Object.freeze({
		default: _arraySpeciesCreate,
		__moduleExports: _arraySpeciesCreate
	});

	var asc = ( _arraySpeciesCreate$1 && _arraySpeciesCreate ) || _arraySpeciesCreate$1;

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex


	var _arrayMethods = function _arrayMethods(TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || asc;
	  return function ($this, callbackfn, that) {
	    var O = require$$20($this);
	    var self = IObject(O);
	    var f = ctx(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (; length > index; index++) {
	      if (NO_HOLES || index in self) {
	        val = self[index];
	        res = f(val, index, O);
	        if (TYPE) {
	          if (IS_MAP) result[index] = res; // map
	          else if (res) switch (TYPE) {
	              case 3:
	                return true; // some
	              case 5:
	                return val; // find
	              case 6:
	                return index; // findIndex
	              case 2:
	                result.push(val); // filter
	            } else if (IS_EVERY) return false; // every
	        }
	      }
	    }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

	var _arrayMethods$1 = /*#__PURE__*/Object.freeze({
		default: _arrayMethods,
		__moduleExports: _arrayMethods
	});

	var require$$28 = ( _arrayMethods$1 && _arrayMethods ) || _arrayMethods$1;

	var $forEach = require$$28(0);
	var STRICT = require$$0$17([].forEach, true);

	$export$1($export$1.P + $export$1.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

	var $map = require$$28(1);

	$export$1($export$1.P + $export$1.F * !require$$0$17([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

	var $filter = require$$28(2);

	$export$1($export$1.P + $export$1.F * !require$$0$17([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

	var $some = require$$28(3);

	$export$1($export$1.P + $export$1.F * !require$$0$17([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

	var $every = require$$28(4);

	$export$1($export$1.P + $export$1.F * !require$$0$17([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

	var _arrayReduce = function _arrayReduce(that, callbackfn, aLen, memo, isRight) {
	  aFunction(callbackfn);
	  var O = require$$20(that);
	  var self = IObject(O);
	  var length = toLength(O.length);
	  var index = isRight ? length - 1 : 0;
	  var i = isRight ? -1 : 1;
	  if (aLen < 2) for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for (; isRight ? index >= 0 : length > index; index += i) {
	    if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	  }return memo;
	};

	var _arrayReduce$1 = /*#__PURE__*/Object.freeze({
		default: _arrayReduce,
		__moduleExports: _arrayReduce
	});

	var $reduce = ( _arrayReduce$1 && _arrayReduce ) || _arrayReduce$1;

	$export$1($export$1.P + $export$1.F * !require$$0$17([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

	$export$1($export$1.P + $export$1.F * !require$$0$17([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

	var $indexOf = require$$0$5(false);
	var $native = [].indexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

	$export$1($export$1.P + $export$1.F * (NEGATIVE_ZERO || !require$$0$17($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	    // convert -0 to +0
	    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
	  }
	});

	var $native$1 = [].lastIndexOf;
	var NEGATIVE_ZERO$1 = !!$native$1 && 1 / [1].lastIndexOf(1, -0) < 0;

	$export$1($export$1.P + $export$1.F * (NEGATIVE_ZERO$1 || !require$$0$17($native$1)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO$1) return $native$1.apply(this, arguments) || 0;
	    var O = toIObject(this);
	    var length = toLength(O.length);
	    var index = length - 1;
	    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
	    if (index < 0) index = length + index;
	    for (; index >= 0; index--) {
	      if (index in O) if (O[index] === searchElement) return index || 0;
	    }return -1;
	  }
	});

	var _arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = require$$20(this);
	  var len = toLength(O.length);
	  var to = require$$15(target, len);
	  var from = require$$15(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = Math.min((end === undefined ? len : require$$15(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];else delete O[to];
	    to += inc;
	    from += inc;
	  }return O;
	};

	var _arrayCopyWithin$1 = /*#__PURE__*/Object.freeze({
		default: _arrayCopyWithin,
		__moduleExports: _arrayCopyWithin
	});

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = require$$0$3('unscopables');
	var ArrayProto$1 = Array.prototype;
	if (ArrayProto$1[UNSCOPABLES] == undefined) require$$0$1(ArrayProto$1, UNSCOPABLES, {});
	var _addToUnscopables = function _addToUnscopables(key) {
	  ArrayProto$1[UNSCOPABLES][key] = true;
	};

	var _addToUnscopables$1 = /*#__PURE__*/Object.freeze({
		default: _addToUnscopables,
		__moduleExports: _addToUnscopables
	});

	var require$$36 = ( _arrayCopyWithin$1 && _arrayCopyWithin ) || _arrayCopyWithin$1;

	var require$$0$18 = ( _addToUnscopables$1 && _addToUnscopables ) || _addToUnscopables$1;

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


	$export$1($export$1.P, 'Array', { copyWithin: require$$36 });

	require$$0$18('copyWithin');

	var _arrayFill = function fill(value /* , start = 0, end = @length */) {
	  var O = require$$20(this);
	  var length = toLength(O.length);
	  var aLen = arguments.length;
	  var index = require$$15(aLen > 1 ? arguments[1] : undefined, length);
	  var end = aLen > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : require$$15(end, length);
	  while (endPos > index) {
	    O[index++] = value;
	  }return O;
	};

	var _arrayFill$1 = /*#__PURE__*/Object.freeze({
		default: _arrayFill,
		__moduleExports: _arrayFill
	});

	var require$$35 = ( _arrayFill$1 && _arrayFill ) || _arrayFill$1;

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


	$export$1($export$1.P, 'Array', { fill: require$$35 });

	require$$0$18('fill');

	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

	var $find = require$$28(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () {
	  forced = false;
	});
	$export$1($export$1.P + $export$1.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	require$$0$18(KEY);

	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

	var $find$1 = require$$28(6);
	var KEY$1 = 'findIndex';
	var forced$1 = true;
	// Shouldn't skip holes
	if (KEY$1 in []) Array(1)[KEY$1](function () {
	  forced$1 = false;
	});
	$export$1($export$1.P + $export$1.F * forced$1, 'Array', {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	require$$0$18(KEY$1);

	var SPECIES$1 = require$$0$3('species');

	var _setSpecies = function _setSpecies(KEY) {
	  var C = require$$2[KEY];
	  if (require$$0 && C && !C[SPECIES$1]) require$$37.f(C, SPECIES$1, {
	    configurable: true,
	    get: function get() {
	      return this;
	    }
	  });
	};

	var _setSpecies$1 = /*#__PURE__*/Object.freeze({
		default: _setSpecies,
		__moduleExports: _setSpecies
	});

	var require$$34 = ( _setSpecies$1 && _setSpecies ) || _setSpecies$1;

	require$$34('Array');

	var _iterStep = function _iterStep(done, value) {
	  return { value: value, done: !!done };
	};

	var _iterStep$1 = /*#__PURE__*/Object.freeze({
		default: _iterStep,
		__moduleExports: _iterStep
	});

	var step = ( _iterStep$1 && _iterStep ) || _iterStep$1;

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	var es6_array_iterator = $iterDefine(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0; // next index
	  this._k = kind; // kind
	  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	require$$32.Arguments = require$$32.Array;

	require$$0$18('keys');
	require$$0$18('values');
	require$$0$18('entries');

	var es6_array_iterator$1 = /*#__PURE__*/Object.freeze({
		default: es6_array_iterator,
		__moduleExports: es6_array_iterator
	});

	// 21.2.5.3 get RegExp.prototype.flags

	var _flags = function _flags() {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	var _flags$1 = /*#__PURE__*/Object.freeze({
		default: _flags,
		__moduleExports: _flags
	});

	var getFlags = ( _flags$1 && _flags ) || _flags$1;

	var dP$4 = require$$37.f;
	var gOPN$4 = gOPN.f;

	var $RegExp = require$$2.RegExp;
	var Base$1 = $RegExp;
	var proto$2 = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;
	// "new" creates a new object, old webkit buggy here
	var CORRECT_NEW = new $RegExp(re1) !== re1;

	if (require$$0 && (!CORRECT_NEW || require$$1(function () {
	  re2[require$$0$3('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = isRegExp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base$1(piRE && !fiU ? p.source : p, f) : Base$1((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? getFlags.call(p) : f), tiRE ? this : proto$2, $RegExp);
	  };
	  var proxy = function proxy(key) {
	    key in $RegExp || dP$4($RegExp, key, {
	      configurable: true,
	      get: function get() {
	        return Base$1[key];
	      },
	      set: function set(it) {
	        Base$1[key] = it;
	      }
	    });
	  };
	  for (var keys$1 = gOPN$4(Base$1), i = 0; keys$1.length > i;) {
	    proxy(keys$1[i++]);
	  }proto$2.constructor = $RegExp;
	  $RegExp.prototype = proto$2;
	  redefine(require$$2, 'RegExp', $RegExp);
	}

	require$$34('RegExp');

	// 21.2.5.3 get RegExp.prototype.flags()
	if (require$$0 && /./g.flags != 'g') require$$37.f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: getFlags
	});

	var TO_STRING$1 = 'toString';
	var $toString$1 = /./[TO_STRING$1];

	var define = function define(fn) {
	  redefine(RegExp.prototype, TO_STRING$1, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if (require$$1(function () {
	  return $toString$1.call({ source: 'a', flags: 'b' }) != '/a/b';
	})) {
	  define(function toString() {
	    var R = anObject(this);
	    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !require$$0 && R instanceof RegExp ? getFlags.call(R) : undefined);
	  });
	  // FF44- RegExp#toString has a wrong name
	} else if ($toString$1.name != TO_STRING$1) {
	  define(function toString() {
	    return $toString$1.call(this);
	  });
	}

	var _fixReWks = function _fixReWks(KEY, length, exec) {
	  var SYMBOL = require$$0$3(KEY);
	  var fns = exec(defined, SYMBOL, ''[KEY]);
	  var strfn = fns[0];
	  var rxfn = fns[1];
	  if (require$$1(function () {
	    var O = {};
	    O[SYMBOL] = function () {
	      return 7;
	    };
	    return ''[KEY](O) != 7;
	  })) {
	    redefine(String.prototype, KEY, strfn);
	    require$$0$1(RegExp.prototype, SYMBOL, length == 2
	    // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	    ? function (string, arg) {
	      return rxfn.call(string, this, arg);
	    }
	    // 21.2.5.6 RegExp.prototype[@@match](string)
	    // 21.2.5.9 RegExp.prototype[@@search](string)
	    : function (string) {
	      return rxfn.call(string, this);
	    });
	  }
	};

	var _fixReWks$1 = /*#__PURE__*/Object.freeze({
		default: _fixReWks,
		__moduleExports: _fixReWks
	});

	var require$$0$19 = ( _fixReWks$1 && _fixReWks ) || _fixReWks$1;

	// @@match logic
	require$$0$19('match', 1, function (defined, MATCH, $match) {
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp) {

	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

	// @@replace logic
	require$$0$19('replace', 2, function (defined, REPLACE, $replace) {
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue) {

	    var O = defined(this);
	    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

	// @@search logic
	require$$0$19('search', 1, function (defined, SEARCH, $search) {
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp) {

	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

	// @@split logic
	require$$0$19('split', 2, function (defined, SPLIT, $split) {

	  var isRegExp$$1 = isRegExp;
	  var _split = $split;
	  var $push = [].push;
	  var $SPLIT = 'split';
	  var LENGTH = 'length';
	  var LAST_INDEX = 'lastIndex';
	  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function $split(separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return [];
	      // If `separator` is not a regex, use native split
	      if (!isRegExp$$1(separator)) return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while (match = separatorCopy.exec(string)) {
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          // eslint-disable-next-line no-loop-func
	          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
	            for (i = 1; i < arguments[LENGTH] - 2; i++) {
	              if (arguments[i] === undefined) match[i] = undefined;
	            }
	          });
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }
	        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	    // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    $split = function $split(separator, limit) {
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit) {
	    var O = defined(this);
	    var fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

	var _anInstance = function _anInstance(it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
	    throw TypeError(name + ': incorrect invocation!');
	  }return it;
	};

	var _anInstance$1 = /*#__PURE__*/Object.freeze({
		default: _anInstance,
		__moduleExports: _anInstance
	});

	var _forOf = createCommonjsModule(function (module) {
	  var BREAK = {};
	  var RETURN = {};
	  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	    var iterFn = ITERATOR ? function () {
	      return iterable;
	    } : require$$25(iterable);
	    var f = ctx(fn, that, entries ? 2 : 1);
	    var index = 0;
	    var length, step, iterator, result;
	    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	    // fast case for arrays with default iterator
	    if (require$$21(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	      result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	      if (result === BREAK || result === RETURN) return result;
	    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	      result = call(iterator, f, step.value, entries);
	      if (result === BREAK || result === RETURN) return result;
	    }
	  };
	  exports.BREAK = BREAK;
	  exports.RETURN = RETURN;
	});

	var _forOf$1 = /*#__PURE__*/Object.freeze({
		default: _forOf,
		__moduleExports: _forOf
	});

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)


	var SPECIES$2 = require$$0$3('species');
	var _speciesConstructor = function _speciesConstructor(O, D) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$2]) == undefined ? D : aFunction(S);
	};

	var _speciesConstructor$1 = /*#__PURE__*/Object.freeze({
		default: _speciesConstructor,
		__moduleExports: _speciesConstructor
	});

	var process$1 = require$$2.process;
	var setTask = require$$2.setImmediate;
	var clearTask = require$$2.clearImmediate;
	var MessageChannel = require$$2.MessageChannel;
	var Dispatch = require$$2.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function run() {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function listener(event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) {
	      args.push(arguments[i++]);
	    }queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (require$$1$2(process$1) == 'process') {
	    defer = function defer(id) {
	      process$1.nextTick(ctx(run, id, 1));
	    };
	    // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function defer(id) {
	      Dispatch.now(ctx(run, id, 1));
	    };
	    // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	    // Browsers with postMessage, skip WebWorkers
	    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (require$$2.addEventListener && typeof postMessage == 'function' && !require$$2.importScripts) {
	    defer = function defer(id) {
	      require$$2.postMessage(id + '', '*');
	    };
	    require$$2.addEventListener('message', listener, false);
	    // IE8-
	  } else if (ONREADYSTATECHANGE in require$$2$1('script')) {
	    defer = function defer(id) {
	      html.appendChild(require$$2$1('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	    // Rest old browsers
	  } else {
	    defer = function defer(id) {
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	var _task = {
	  set: setTask,
	  clear: clearTask
	};
	var _task_1 = _task.set;
	var _task_2 = _task.clear;

	var _task$1 = /*#__PURE__*/Object.freeze({
		default: _task,
		__moduleExports: _task,
		set: _task_1,
		clear: _task_2
	});

	var require$$0$20 = ( _task$1 && _task ) || _task$1;

	var macrotask = require$$0$20.set;
	var Observer = require$$2.MutationObserver || require$$2.WebKitMutationObserver;
	var process$2 = require$$2.process;
	var Promise$1 = require$$2.Promise;
	var isNode = require$$1$2(process$2) == 'process';

	var _microtask = function _microtask() {
	  var head, last, notify;

	  var flush = function flush() {
	    var parent, fn;
	    if (isNode && (parent = process$2.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();else last = undefined;
	        throw e;
	      }
	    }last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (isNode) {
	    notify = function notify() {
	      process$2.nextTick(flush);
	    };
	    // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(require$$2.navigator && require$$2.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function notify() {
	      node.data = toggle = !toggle;
	    };
	    // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    var promise = Promise$1.resolve();
	    notify = function notify() {
	      promise.then(flush);
	    };
	    // for other environments - macrotask based on:
	    // - setImmediate
	    // - MessageChannel
	    // - window.postMessag
	    // - onreadystatechange
	    // - setTimeout
	  } else {
	    notify = function notify() {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(require$$2, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    }last = task;
	  };
	};

	var _microtask$1 = /*#__PURE__*/Object.freeze({
		default: _microtask,
		__moduleExports: _microtask
	});

	// 25.4.1.5 NewPromiseCapability(C)


	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	}

	var f$7 = function f(C) {
	  return new PromiseCapability(C);
	};

	var _newPromiseCapability = {
	  f: f$7
	};

	var _newPromiseCapability$1 = /*#__PURE__*/Object.freeze({
		default: _newPromiseCapability,
		__moduleExports: _newPromiseCapability,
		f: f$7
	});

	var _perform = function _perform(exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};

	var _perform$1 = /*#__PURE__*/Object.freeze({
		default: _perform,
		__moduleExports: _perform
	});

	var newPromiseCapability = ( _newPromiseCapability$1 && _newPromiseCapability ) || _newPromiseCapability$1;

	var _promiseResolve = function _promiseResolve(C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var _promiseResolve$1 = /*#__PURE__*/Object.freeze({
		default: _promiseResolve,
		__moduleExports: _promiseResolve
	});

	var _redefineAll = function _redefineAll(target, src, safe) {
	  for (var key in src) {
	    redefine(target, key, src[key], safe);
	  }return target;
	};

	var _redefineAll$1 = /*#__PURE__*/Object.freeze({
		default: _redefineAll,
		__moduleExports: _redefineAll
	});

	var require$$8 = ( _anInstance$1 && _anInstance ) || _anInstance$1;

	var forOf = ( _forOf$1 && _forOf ) || _forOf$1;

	var require$$30 = ( _speciesConstructor$1 && _speciesConstructor ) || _speciesConstructor$1;

	var require$$0$21 = ( _microtask$1 && _microtask ) || _microtask$1;

	var perform = ( _perform$1 && _perform ) || _perform$1;

	var promiseResolve = ( _promiseResolve$1 && _promiseResolve ) || _promiseResolve$1;

	var require$$11 = ( _redefineAll$1 && _redefineAll ) || _redefineAll$1;

	var task = require$$0$20.set;
	var microtask = require$$0$21();

	var PROMISE = 'Promise';
	var TypeError$1 = require$$2.TypeError;
	var process$3 = require$$2.process;
	var $Promise = require$$2[PROMISE];
	var isNode$1 = classof(process$3) == 'process';
	var empty = function empty() {/* empty */};
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability$1 = newGenericPromiseCapability = newPromiseCapability.f;

	var USE_NATIVE$1 = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[require$$0$3('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch (e) {/* empty */}
	}();

	// helpers
	var isThenable = function isThenable(it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function notify(promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function run(reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;else {
	            if (domain) domain.enter();
	            result = handler(value);
	            if (domain) domain.exit();
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        reject(e);
	      }
	    };
	    while (chain.length > i) {
	      run(chain[i++]);
	    } // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function onUnhandled(promise) {
	  task.call(require$$2, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = perform(function () {
	        if (isNode$1) {
	          process$3.emit('unhandledRejection', value, promise);
	        } else if (handler = require$$2.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = require$$2.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
	    }promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function isUnhandled(promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function onHandleUnhandled(promise) {
	  task.call(require$$2, function () {
	    var handler;
	    if (isNode$1) {
	      process$3.emit('rejectionHandled', promise);
	    } else if (handler = require$$2.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function $reject(value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function $resolve(value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE$1) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    require$$8(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = []; // <- awaiting reactions
	    this._a = undefined; // <- checked in isUnhandled reactions
	    this._s = 0; // <- state
	    this._d = false; // <- done
	    this._v = undefined; // <- value
	    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false; // <- notify
	  };
	  Internal.prototype = require$$11($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability$1(require$$30(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode$1 ? process$3.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function _catch(onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function OwnPromiseCapability() {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject = ctx($reject, promise, 1);
	  };
	  newPromiseCapability.f = newPromiseCapability$1 = function newPromiseCapability$$1(C) {
	    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
	  };
	}

	$export$1($export$1.G + $export$1.W + $export$1.F * !USE_NATIVE$1, { Promise: $Promise });
	setToStringTag($Promise, PROMISE);
	require$$34(PROMISE);
	Wrapper = require$$1$1[PROMISE];

	// statics
	$export$1($export$1.S + $export$1.F * !USE_NATIVE$1, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export$1($export$1.S + $export$1.F * (require$$0$4 || !USE_NATIVE$1), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return promiseResolve(require$$0$4 && this === Wrapper ? $Promise : this, x);
	  }
	});
	$export$1($export$1.S + $export$1.F * !(USE_NATIVE$1 && require$$33(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});

	var _validateCollection = function _validateCollection(it, TYPE) {
	  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
	  return it;
	};

	var _validateCollection$1 = /*#__PURE__*/Object.freeze({
		default: _validateCollection,
		__moduleExports: _validateCollection
	});

	var validate = ( _validateCollection$1 && _validateCollection ) || _validateCollection$1;

	var dP$5 = require$$37.f;

	var fastKey = require$$0$8.fastKey;

	var SIZE = require$$0 ? '_s' : 'size';

	var getEntry = function getEntry(that, key) {
	  // fast case
	  var index = fastKey(key);
	  var entry;
	  if (index !== 'F') return that._i[index];
	  // frozen object case
	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) return entry;
	  }
	};

	var _collectionStrong = {
	  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      require$$8(that, C, NAME, '_i');
	      that._t = NAME; // collection type
	      that._i = create(null); // index
	      that._f = undefined; // first entry
	      that._l = undefined; // last entry
	      that[SIZE] = 0; // size
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    require$$11(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function _delete(key) {
	        var that = validate(this, NAME);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.n;
	          var prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) prev.n = next;
	          if (next) next.p = prev;
	          if (that._f == entry) that._f = next;
	          if (that._l == entry) that._l = prev;
	          that[SIZE]--;
	        }return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        validate(this, NAME);
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while (entry && entry.r) {
	            entry = entry.p;
	          }
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(validate(this, NAME), key);
	      }
	    });
	    if (require$$0) dP$5(C.prototype, 'size', {
	      get: function get() {
	        return validate(this, NAME)[SIZE];
	      }
	    });
	    return C;
	  },
	  def: function def(that, key, value) {
	    var entry = getEntry(that, key);
	    var prev, index;
	    // change existing entry
	    if (entry) {
	      entry.v = value;
	      // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key, // <- key
	        v: value, // <- value
	        p: prev = that._l, // <- previous entry
	        n: undefined, // <- next entry
	        r: false // <- removed
	      };
	      if (!that._f) that._f = entry;
	      if (prev) prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if (index !== 'F') that._i[index] = entry;
	    }return that;
	  },
	  getEntry: getEntry,
	  setStrong: function setStrong(C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function (iterated, kind) {
	      this._t = validate(iterated, NAME); // target
	      this._k = kind; // kind
	      this._l = undefined; // previous
	    }, function () {
	      var that = this;
	      var kind = that._k;
	      var entry = that._l;
	      // revert to the last existing entry
	      while (entry && entry.r) {
	        entry = entry.p;
	      } // get next entry
	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if (kind == 'keys') return step(0, entry.k);
	      if (kind == 'values') return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    require$$34(NAME);
	  }
	};
	var _collectionStrong_1 = _collectionStrong.getConstructor;
	var _collectionStrong_2 = _collectionStrong.def;
	var _collectionStrong_3 = _collectionStrong.getEntry;
	var _collectionStrong_4 = _collectionStrong.setStrong;

	var _collectionStrong$1 = /*#__PURE__*/Object.freeze({
		default: _collectionStrong,
		__moduleExports: _collectionStrong,
		getConstructor: _collectionStrong_1,
		def: _collectionStrong_2,
		getEntry: _collectionStrong_3,
		setStrong: _collectionStrong_4
	});

	var _collection = function _collection(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = require$$2[NAME];
	  var C = Base;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var proto = C && C.prototype;
	  var O = {};
	  var fixMethod = function fixMethod(KEY) {
	    var fn = proto[KEY];
	    redefine(proto, KEY, KEY == 'delete' ? function (a) {
	      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'has' ? function has(a) {
	      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'get' ? function get(a) {
	      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'add' ? function add(a) {
	      fn.call(this, a === 0 ? 0 : a);return this;
	    } : function set(a, b) {
	      fn.call(this, a === 0 ? 0 : a, b);return this;
	    });
	  };
	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !require$$1(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    require$$11(C.prototype, methods);
	    require$$0$8.NEED = true;
	  } else {
	    var instance = new C();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = require$$1(function () {
	      instance.has(1);
	    });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    var ACCEPT_ITERABLES = require$$33(function (iter) {
	      new C(iter);
	    }); // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && require$$1(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C();
	      var index = 5;
	      while (index--) {
	        $instance[ADDER](index, index);
	      }return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        require$$8(target, C, NAME);
	        var that = inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if (IS_WEAK && proto.clear) delete proto.clear;
	  }

	  setToStringTag(C, NAME);

	  O[NAME] = C;
	  $export$1($export$1.G + $export$1.W + $export$1.F * (C != Base), O);

	  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

	  return C;
	};

	var _collection$1 = /*#__PURE__*/Object.freeze({
		default: _collection,
		__moduleExports: _collection
	});

	var strong = ( _collectionStrong$1 && _collectionStrong ) || _collectionStrong$1;

	var require$$0$22 = ( _collection$1 && _collection ) || _collection$1;

	var MAP = 'Map';

	// 23.1 Map Objects
	var es6_map = require$$0$22(MAP, function (get) {
	  return function Map() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = strong.getEntry(validate(this, MAP), key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
	  }
	}, strong, true);

	var es6_map$1 = /*#__PURE__*/Object.freeze({
		default: es6_map,
		__moduleExports: es6_map
	});

	var SET = 'Set';

	// 23.2 Set Objects
	var es6_set = require$$0$22(SET, function (get) {
	  return function Set() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
	  }
	}, strong);

	var es6_set$1 = /*#__PURE__*/Object.freeze({
		default: es6_set,
		__moduleExports: es6_set
	});

	var getWeak = require$$0$8.getWeak;

	var arrayFind = require$$28(5);
	var arrayFindIndex = require$$28(6);
	var id$1 = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function UncaughtFrozenStore() {
	  this.a = [];
	};
	var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function get(key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function has$$1(key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function set(key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;else this.a.push([key, value]);
	  },
	  'delete': function _delete(key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	var _collectionWeak = {
	  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      require$$8(that, C, NAME, '_i');
	      that._t = NAME; // collection type
	      that._i = id$1++; // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    require$$11(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function _delete(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
	        return data && has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has$$1(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
	        return data && has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function def(that, key, value) {
	    var data = getWeak(anObject(key), true);
	    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};
	var _collectionWeak_1 = _collectionWeak.getConstructor;
	var _collectionWeak_2 = _collectionWeak.def;
	var _collectionWeak_3 = _collectionWeak.ufstore;

	var _collectionWeak$1 = /*#__PURE__*/Object.freeze({
		default: _collectionWeak,
		__moduleExports: _collectionWeak,
		getConstructor: _collectionWeak_1,
		def: _collectionWeak_2,
		ufstore: _collectionWeak_3
	});

	var weak = ( _collectionWeak$1 && _collectionWeak ) || _collectionWeak$1;

	var es6_weakMap = createCommonjsModule(function (module) {

	  var each = require$$28(0);

	  var WEAK_MAP = 'WeakMap';
	  var getWeak = require$$0$8.getWeak;
	  var isExtensible = Object.isExtensible;
	  var uncaughtFrozenStore = weak.ufstore;
	  var tmp = {};
	  var InternalMap;

	  var wrapper = function wrapper(get) {
	    return function WeakMap() {
	      return get(this, arguments.length > 0 ? arguments[0] : undefined);
	    };
	  };

	  var methods = {
	    // 23.3.3.3 WeakMap.prototype.get(key)
	    get: function get(key) {
	      if (isObject(key)) {
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
	        return data ? data[this._i] : undefined;
	      }
	    },
	    // 23.3.3.5 WeakMap.prototype.set(key, value)
	    set: function set(key, value) {
	      return weak.def(validate(this, WEAK_MAP), key, value);
	    }
	  };

	  // 23.3 WeakMap Objects
	  var $WeakMap = module.exports = require$$0$22(WEAK_MAP, wrapper, methods, weak, true, true);

	  // IE11 WeakMap frozen keys fix
	  if (require$$1(function () {
	    return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
	  })) {
	    InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
	    assign(InternalMap.prototype, methods);
	    require$$0$8.NEED = true;
	    each(['delete', 'has', 'get', 'set'], function (key) {
	      var proto = $WeakMap.prototype;
	      var method = proto[key];
	      redefine(proto, key, function (a, b) {
	        // store frozen objects on internal weakmap shim
	        if (isObject(a) && !isExtensible(a)) {
	          if (!this._f) this._f = new InternalMap();
	          var result = this._f[key](a, b);
	          return key == 'set' ? this : result;
	          // store all the rest on native weakmap
	        }return method.call(this, a, b);
	      });
	    });
	  }
	});

	var es6_weakMap$1 = /*#__PURE__*/Object.freeze({
		default: es6_weakMap,
		__moduleExports: es6_weakMap
	});

	var WEAK_SET = 'WeakSet';

	// 23.4 WeakSet Objects
	require$$0$22(WEAK_SET, function (get) {
	  return function WeakSet() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value) {
	    return weak.def(validate(this, WEAK_SET), value, true);
	  }
	}, weak, false, true);

	var TYPED = uid('typed_array');
	var VIEW = uid('view');
	var ABV = !!(require$$2.ArrayBuffer && require$$2.DataView);
	var CONSTR = ABV;
	var i$1 = 0;
	var l = 9;
	var Typed;

	var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

	while (i$1 < l) {
	  if (Typed = require$$2[TypedArrayConstructors[i$1++]]) {
	    require$$0$1(Typed.prototype, TYPED, true);
	    require$$0$1(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}

	var _typed = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};
	var _typed_1 = _typed.ABV;
	var _typed_2 = _typed.CONSTR;
	var _typed_3 = _typed.TYPED;
	var _typed_4 = _typed.VIEW;

	var _typed$1 = /*#__PURE__*/Object.freeze({
		default: _typed,
		__moduleExports: _typed,
		ABV: _typed_1,
		CONSTR: _typed_2,
		TYPED: _typed_3,
		VIEW: _typed_4
	});

	// https://tc39.github.io/ecma262/#sec-toindex


	var _toIndex = function _toIndex(it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length!');
	  return length;
	};

	var _toIndex$1 = /*#__PURE__*/Object.freeze({
		default: _toIndex,
		__moduleExports: _toIndex
	});

	var require$$5 = ( _typed$1 && _typed ) || _typed$1;

	var require$$14 = ( _toIndex$1 && _toIndex ) || _toIndex$1;

	var _typedBuffer = createCommonjsModule(function (module, exports) {

	  var gOPN$$1 = gOPN.f;
	  var dP = require$$37.f;

	  var ARRAY_BUFFER = 'ArrayBuffer';
	  var DATA_VIEW = 'DataView';
	  var PROTOTYPE = 'prototype';
	  var WRONG_LENGTH = 'Wrong length!';
	  var WRONG_INDEX = 'Wrong index!';
	  var $ArrayBuffer = require$$2[ARRAY_BUFFER];
	  var $DataView = require$$2[DATA_VIEW];
	  var Math = require$$2.Math;
	  var RangeError = require$$2.RangeError;
	  // eslint-disable-next-line no-shadow-restricted-names
	  var Infinity = require$$2.Infinity;
	  var BaseBuffer = $ArrayBuffer;
	  var abs = Math.abs;
	  var pow = Math.pow;
	  var floor = Math.floor;
	  var log = Math.log;
	  var LN2 = Math.LN2;
	  var BUFFER = 'buffer';
	  var BYTE_LENGTH = 'byteLength';
	  var BYTE_OFFSET = 'byteOffset';
	  var $BUFFER = require$$0 ? '_b' : BUFFER;
	  var $LENGTH = require$$0 ? '_l' : BYTE_LENGTH;
	  var $OFFSET = require$$0 ? '_o' : BYTE_OFFSET;

	  // IEEE754 conversions based on https://github.com/feross/ieee754
	  function packIEEE754(value, mLen, nBytes) {
	    var buffer = new Array(nBytes);
	    var eLen = nBytes * 8 - mLen - 1;
	    var eMax = (1 << eLen) - 1;
	    var eBias = eMax >> 1;
	    var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
	    var i = 0;
	    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	    var e, m, c;
	    value = abs(value);
	    // eslint-disable-next-line no-self-compare
	    if (value != value || value === Infinity) {
	      // eslint-disable-next-line no-self-compare
	      m = value != value ? 1 : 0;
	      e = eMax;
	    } else {
	      e = floor(log(value) / LN2);
	      if (value * (c = pow(2, -e)) < 1) {
	        e--;
	        c *= 2;
	      }
	      if (e + eBias >= 1) {
	        value += rt / c;
	      } else {
	        value += rt * pow(2, 1 - eBias);
	      }
	      if (value * c >= 2) {
	        e++;
	        c /= 2;
	      }
	      if (e + eBias >= eMax) {
	        m = 0;
	        e = eMax;
	      } else if (e + eBias >= 1) {
	        m = (value * c - 1) * pow(2, mLen);
	        e = e + eBias;
	      } else {
	        m = value * pow(2, eBias - 1) * pow(2, mLen);
	        e = 0;
	      }
	    }
	    for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {}
	    e = e << mLen | m;
	    eLen += mLen;
	    for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {}
	    buffer[--i] |= s * 128;
	    return buffer;
	  }
	  function unpackIEEE754(buffer, mLen, nBytes) {
	    var eLen = nBytes * 8 - mLen - 1;
	    var eMax = (1 << eLen) - 1;
	    var eBias = eMax >> 1;
	    var nBits = eLen - 7;
	    var i = nBytes - 1;
	    var s = buffer[i--];
	    var e = s & 127;
	    var m;
	    s >>= 7;
	    for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {}
	    m = e & (1 << -nBits) - 1;
	    e >>= -nBits;
	    nBits += mLen;
	    for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {}
	    if (e === 0) {
	      e = 1 - eBias;
	    } else if (e === eMax) {
	      return m ? NaN : s ? -Infinity : Infinity;
	    } else {
	      m = m + pow(2, mLen);
	      e = e - eBias;
	    }return (s ? -1 : 1) * m * pow(2, e - mLen);
	  }

	  function unpackI32(bytes) {
	    return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	  }
	  function packI8(it) {
	    return [it & 0xff];
	  }
	  function packI16(it) {
	    return [it & 0xff, it >> 8 & 0xff];
	  }
	  function packI32(it) {
	    return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	  }
	  function packF64(it) {
	    return packIEEE754(it, 52, 8);
	  }
	  function packF32(it) {
	    return packIEEE754(it, 23, 4);
	  }

	  function addGetter(C, key, internal) {
	    dP(C[PROTOTYPE], key, { get: function get() {
	        return this[internal];
	      } });
	  }

	  function get(view, bytes, index, isLittleEndian) {
	    var numIndex = +index;
	    var intIndex = require$$14(numIndex);
	    if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	    var store = view[$BUFFER]._b;
	    var start = intIndex + view[$OFFSET];
	    var pack = store.slice(start, start + bytes);
	    return isLittleEndian ? pack : pack.reverse();
	  }
	  function set(view, bytes, index, conversion, value, isLittleEndian) {
	    var numIndex = +index;
	    var intIndex = require$$14(numIndex);
	    if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	    var store = view[$BUFFER]._b;
	    var start = intIndex + view[$OFFSET];
	    var pack = conversion(+value);
	    for (var i = 0; i < bytes; i++) {
	      store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	    }
	  }

	  if (!require$$5.ABV) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      require$$8(this, $ArrayBuffer, ARRAY_BUFFER);
	      var byteLength = require$$14(length);
	      this._b = require$$35.call(new Array(byteLength), 0);
	      this[$LENGTH] = byteLength;
	    };

	    $DataView = function DataView(buffer, byteOffset, byteLength) {
	      require$$8(this, $DataView, DATA_VIEW);
	      require$$8(buffer, $ArrayBuffer, DATA_VIEW);
	      var bufferLength = buffer[$LENGTH];
	      var offset = toInteger(byteOffset);
	      if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	      byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	      if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	      this[$BUFFER] = buffer;
	      this[$OFFSET] = offset;
	      this[$LENGTH] = byteLength;
	    };

	    if (require$$0) {
	      addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	      addGetter($DataView, BUFFER, '_b');
	      addGetter($DataView, BYTE_LENGTH, '_l');
	      addGetter($DataView, BYTE_OFFSET, '_o');
	    }

	    require$$11($DataView[PROTOTYPE], {
	      getInt8: function getInt8(byteOffset) {
	        return get(this, 1, byteOffset)[0] << 24 >> 24;
	      },
	      getUint8: function getUint8(byteOffset) {
	        return get(this, 1, byteOffset)[0];
	      },
	      getInt16: function getInt16(byteOffset /* , littleEndian */) {
	        var bytes = get(this, 2, byteOffset, arguments[1]);
	        return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	      },
	      getUint16: function getUint16(byteOffset /* , littleEndian */) {
	        var bytes = get(this, 2, byteOffset, arguments[1]);
	        return bytes[1] << 8 | bytes[0];
	      },
	      getInt32: function getInt32(byteOffset /* , littleEndian */) {
	        return unpackI32(get(this, 4, byteOffset, arguments[1]));
	      },
	      getUint32: function getUint32(byteOffset /* , littleEndian */) {
	        return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	      },
	      getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	        return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	      },
	      getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	        return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	      },
	      setInt8: function setInt8(byteOffset, value) {
	        set(this, 1, byteOffset, packI8, value);
	      },
	      setUint8: function setUint8(byteOffset, value) {
	        set(this, 1, byteOffset, packI8, value);
	      },
	      setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	        set(this, 2, byteOffset, packI16, value, arguments[2]);
	      },
	      setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	        set(this, 2, byteOffset, packI16, value, arguments[2]);
	      },
	      setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	        set(this, 4, byteOffset, packI32, value, arguments[2]);
	      },
	      setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	        set(this, 4, byteOffset, packI32, value, arguments[2]);
	      },
	      setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	        set(this, 4, byteOffset, packF32, value, arguments[2]);
	      },
	      setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	        set(this, 8, byteOffset, packF64, value, arguments[2]);
	      }
	    });
	  } else {
	    if (!require$$1(function () {
	      $ArrayBuffer(1);
	    }) || !require$$1(function () {
	      new $ArrayBuffer(-1); // eslint-disable-line no-new
	    }) || require$$1(function () {
	      new $ArrayBuffer(); // eslint-disable-line no-new
	      new $ArrayBuffer(1.5); // eslint-disable-line no-new
	      new $ArrayBuffer(NaN); // eslint-disable-line no-new
	      return $ArrayBuffer.name != ARRAY_BUFFER;
	    })) {
	      $ArrayBuffer = function ArrayBuffer(length) {
	        require$$8(this, $ArrayBuffer);
	        return new BaseBuffer(require$$14(length));
	      };
	      var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	      for (var keys = gOPN$$1(BaseBuffer), j = 0, key; keys.length > j;) {
	        if (!((key = keys[j++]) in $ArrayBuffer)) require$$0$1($ArrayBuffer, key, BaseBuffer[key]);
	      }
	      if (!require$$0$4) ArrayBufferProto.constructor = $ArrayBuffer;
	    }
	    // iOS Safari 7.x bug
	    var view = new $DataView(new $ArrayBuffer(2));
	    var $setInt8 = $DataView[PROTOTYPE].setInt8;
	    view.setInt8(0, 2147483648);
	    view.setInt8(1, 2147483649);
	    if (view.getInt8(0) || !view.getInt8(1)) require$$11($DataView[PROTOTYPE], {
	      setInt8: function setInt8(byteOffset, value) {
	        $setInt8.call(this, byteOffset, value << 24 >> 24);
	      },
	      setUint8: function setUint8(byteOffset, value) {
	        $setInt8.call(this, byteOffset, value << 24 >> 24);
	      }
	    }, true);
	  }
	  setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	  setToStringTag($DataView, DATA_VIEW);
	  require$$0$1($DataView[PROTOTYPE], require$$5.VIEW, true);
	  exports[ARRAY_BUFFER] = $ArrayBuffer;
	  exports[DATA_VIEW] = $DataView;
	});

	var _typedBuffer$1 = /*#__PURE__*/Object.freeze({
		default: _typedBuffer,
		__moduleExports: _typedBuffer
	});

	var require$$6 = ( _typedBuffer$1 && _typedBuffer ) || _typedBuffer$1;

	var ArrayBuffer$1 = require$$2.ArrayBuffer;

	var $ArrayBuffer = require$$6.ArrayBuffer;
	var $DataView = require$$6.DataView;
	var $isView = require$$5.ABV && ArrayBuffer$1.isView;
	var $slice = $ArrayBuffer.prototype.slice;
	var VIEW$1 = require$$5.VIEW;
	var ARRAY_BUFFER = 'ArrayBuffer';

	$export$1($export$1.G + $export$1.W + $export$1.F * (ArrayBuffer$1 !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

	$export$1($export$1.S + $export$1.F * !require$$5.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it) {
	    return $isView && $isView(it) || isObject(it) && VIEW$1 in it;
	  }
	});

	$export$1($export$1.P + $export$1.U + $export$1.F * require$$1(function () {
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end) {
	    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
	    var len = anObject(this).byteLength;
	    var first = require$$15(start, len);
	    var final = require$$15(end === undefined ? len : end, len);
	    var result = new (require$$30(this, $ArrayBuffer))(toLength(final - first));
	    var viewS = new $DataView(this);
	    var viewT = new $DataView(result);
	    var index = 0;
	    while (first < final) {
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    }return result;
	  }
	});

	require$$34(ARRAY_BUFFER);

	$export$1($export$1.G + $export$1.W + $export$1.F * !require$$5.ABV, {
	  DataView: require$$6.DataView
	});

	var require$$31 = ( es6_array_iterator$1 && es6_array_iterator ) || es6_array_iterator$1;

	var _typedArray = createCommonjsModule(function (module) {

	  if (require$$0) {
	    var LIBRARY = require$$0$4;
	    var global = require$$2;
	    var fails = require$$1;
	    var $export = $export$1;
	    var $typed = require$$5;
	    var $buffer = require$$6;
	    var ctx$$1 = ctx;
	    var anInstance = require$$8;
	    var propertyDesc = descriptor;
	    var hide = require$$0$1;
	    var redefineAll = require$$11;
	    var toInteger$$1 = toInteger;
	    var toLength$$1 = toLength;
	    var toIndex = require$$14;
	    var toAbsoluteIndex = require$$15;
	    var toPrimitive = require$$16;
	    var has$$1 = has;
	    var classof$$1 = classof;
	    var isObject$$1 = isObject;
	    var toObject = require$$20;
	    var isArrayIter = require$$21;
	    var create$$1 = create;
	    var getPrototypeOf = require$$23;
	    var gOPN$$1 = gOPN.f;
	    var getIterFn = require$$25;
	    var uid$$1 = uid;
	    var wks = require$$0$3;
	    var createArrayMethod = require$$28;
	    var createArrayIncludes = require$$0$5;
	    var speciesConstructor = require$$30;
	    var ArrayIterators = require$$31;
	    var Iterators = require$$32;
	    var $iterDetect = require$$33;
	    var setSpecies = require$$34;
	    var arrayFill = require$$35;
	    var arrayCopyWithin = require$$36;
	    var $DP = require$$37;
	    var $GOPD = require$$38;
	    var dP = $DP.f;
	    var gOPD = $GOPD.f;
	    var RangeError = global.RangeError;
	    var TypeError = global.TypeError;
	    var Uint8Array = global.Uint8Array;
	    var ARRAY_BUFFER = 'ArrayBuffer';
	    var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
	    var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	    var PROTOTYPE = 'prototype';
	    var ArrayProto = Array[PROTOTYPE];
	    var $ArrayBuffer = $buffer.ArrayBuffer;
	    var $DataView = $buffer.DataView;
	    var arrayForEach = createArrayMethod(0);
	    var arrayFilter = createArrayMethod(2);
	    var arraySome = createArrayMethod(3);
	    var arrayEvery = createArrayMethod(4);
	    var arrayFind = createArrayMethod(5);
	    var arrayFindIndex = createArrayMethod(6);
	    var arrayIncludes = createArrayIncludes(true);
	    var arrayIndexOf = createArrayIncludes(false);
	    var arrayValues = ArrayIterators.values;
	    var arrayKeys = ArrayIterators.keys;
	    var arrayEntries = ArrayIterators.entries;
	    var arrayLastIndexOf = ArrayProto.lastIndexOf;
	    var arrayReduce = ArrayProto.reduce;
	    var arrayReduceRight = ArrayProto.reduceRight;
	    var arrayJoin = ArrayProto.join;
	    var arraySort = ArrayProto.sort;
	    var arraySlice = ArrayProto.slice;
	    var arrayToString = ArrayProto.toString;
	    var arrayToLocaleString = ArrayProto.toLocaleString;
	    var ITERATOR = wks('iterator');
	    var TAG = wks('toStringTag');
	    var TYPED_CONSTRUCTOR = uid$$1('typed_constructor');
	    var DEF_CONSTRUCTOR = uid$$1('def_constructor');
	    var ALL_CONSTRUCTORS = $typed.CONSTR;
	    var TYPED_ARRAY = $typed.TYPED;
	    var VIEW = $typed.VIEW;
	    var WRONG_LENGTH = 'Wrong length!';

	    var $map = createArrayMethod(1, function (O, length) {
	      return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	    });

	    var LITTLE_ENDIAN = fails(function () {
	      // eslint-disable-next-line no-undef
	      return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	    });

	    var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	      new Uint8Array(1).set({});
	    });

	    var toOffset = function toOffset(it, BYTES) {
	      var offset = toInteger$$1(it);
	      if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	      return offset;
	    };

	    var validate = function validate(it) {
	      if (isObject$$1(it) && TYPED_ARRAY in it) return it;
	      throw TypeError(it + ' is not a typed array!');
	    };

	    var allocate = function allocate(C, length) {
	      if (!(isObject$$1(C) && TYPED_CONSTRUCTOR in C)) {
	        throw TypeError('It is not a typed array constructor!');
	      }return new C(length);
	    };

	    var speciesFromList = function speciesFromList(O, list) {
	      return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	    };

	    var fromList = function fromList(C, list) {
	      var index = 0;
	      var length = list.length;
	      var result = allocate(C, length);
	      while (length > index) {
	        result[index] = list[index++];
	      }return result;
	    };

	    var addGetter = function addGetter(it, key, internal) {
	      dP(it, key, { get: function get$$1() {
	          return this._d[internal];
	        } });
	    };

	    var $from = function from(source /* , mapfn, thisArg */) {
	      var O = toObject(source);
	      var aLen = arguments.length;
	      var mapfn = aLen > 1 ? arguments[1] : undefined;
	      var mapping = mapfn !== undefined;
	      var iterFn = getIterFn(O);
	      var i, length, values, result, step, iterator;
	      if (iterFn != undefined && !isArrayIter(iterFn)) {
	        for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	          values.push(step.value);
	        }O = values;
	      }
	      if (mapping && aLen > 2) mapfn = ctx$$1(mapfn, arguments[2], 2);
	      for (i = 0, length = toLength$$1(O.length), result = allocate(this, length); length > i; i++) {
	        result[i] = mapping ? mapfn(O[i], i) : O[i];
	      }
	      return result;
	    };

	    var $of = function of() /* ...items */{
	      var index = 0;
	      var length = arguments.length;
	      var result = allocate(this, length);
	      while (length > index) {
	        result[index] = arguments[index++];
	      }return result;
	    };

	    // iOS Safari 6.x fails here
	    var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
	      arrayToLocaleString.call(new Uint8Array(1));
	    });

	    var $toLocaleString = function toLocaleString() {
	      return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	    };

	    var proto = {
	      copyWithin: function copyWithin(target, start /* , end */) {
	        return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	      },
	      every: function every(callbackfn /* , thisArg */) {
	        return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      fill: function fill(value /* , start, end */) {
	        // eslint-disable-line no-unused-vars
	        return arrayFill.apply(validate(this), arguments);
	      },
	      filter: function filter(callbackfn /* , thisArg */) {
	        return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
	      },
	      find: function find(predicate /* , thisArg */) {
	        return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      findIndex: function findIndex(predicate /* , thisArg */) {
	        return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      forEach: function forEach(callbackfn /* , thisArg */) {
	        arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      indexOf: function indexOf(searchElement /* , fromIndex */) {
	        return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      includes: function includes(searchElement /* , fromIndex */) {
	        return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      join: function join(separator) {
	        // eslint-disable-line no-unused-vars
	        return arrayJoin.apply(validate(this), arguments);
	      },
	      lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) {
	        // eslint-disable-line no-unused-vars
	        return arrayLastIndexOf.apply(validate(this), arguments);
	      },
	      map: function map(mapfn /* , thisArg */) {
	        return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      reduce: function reduce(callbackfn /* , initialValue */) {
	        // eslint-disable-line no-unused-vars
	        return arrayReduce.apply(validate(this), arguments);
	      },
	      reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	        // eslint-disable-line no-unused-vars
	        return arrayReduceRight.apply(validate(this), arguments);
	      },
	      reverse: function reverse() {
	        var that = this;
	        var length = validate(that).length;
	        var middle = Math.floor(length / 2);
	        var index = 0;
	        var value;
	        while (index < middle) {
	          value = that[index];
	          that[index++] = that[--length];
	          that[length] = value;
	        }return that;
	      },
	      some: function some(callbackfn /* , thisArg */) {
	        return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	      },
	      sort: function sort(comparefn) {
	        return arraySort.call(validate(this), comparefn);
	      },
	      subarray: function subarray(begin, end) {
	        var O = validate(this);
	        var length = O.length;
	        var $begin = toAbsoluteIndex(begin, length);
	        return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength$$1((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
	      }
	    };

	    var $slice = function slice(start, end) {
	      return speciesFromList(this, arraySlice.call(validate(this), start, end));
	    };

	    var $set = function set$$1(arrayLike /* , offset */) {
	      validate(this);
	      var offset = toOffset(arguments[1], 1);
	      var length = this.length;
	      var src = toObject(arrayLike);
	      var len = toLength$$1(src.length);
	      var index = 0;
	      if (len + offset > length) throw RangeError(WRONG_LENGTH);
	      while (index < len) {
	        this[offset + index] = src[index++];
	      }
	    };

	    var $iterators = {
	      entries: function entries() {
	        return arrayEntries.call(validate(this));
	      },
	      keys: function keys() {
	        return arrayKeys.call(validate(this));
	      },
	      values: function values() {
	        return arrayValues.call(validate(this));
	      }
	    };

	    var isTAIndex = function isTAIndex(target, key) {
	      return isObject$$1(target) && target[TYPED_ARRAY] && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) != 'symbol' && key in target && String(+key) == String(key);
	    };
	    var $getDesc = function getOwnPropertyDescriptor(target, key) {
	      return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
	    };
	    var $setDesc = function defineProperty$$1(target, key, desc) {
	      if (isTAIndex(target, key = toPrimitive(key, true)) && isObject$$1(desc) && has$$1(desc, 'value') && !has$$1(desc, 'get') && !has$$1(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable && (!has$$1(desc, 'writable') || desc.writable) && (!has$$1(desc, 'enumerable') || desc.enumerable)) {
	        target[key] = desc.value;
	        return target;
	      }return dP(target, key, desc);
	    };

	    if (!ALL_CONSTRUCTORS) {
	      $GOPD.f = $getDesc;
	      $DP.f = $setDesc;
	    }

	    $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	      getOwnPropertyDescriptor: $getDesc,
	      defineProperty: $setDesc
	    });

	    if (fails(function () {
	      arrayToString.call({});
	    })) {
	      arrayToString = arrayToLocaleString = function toString() {
	        return arrayJoin.call(this);
	      };
	    }

	    var $TypedArrayPrototype$ = redefineAll({}, proto);
	    redefineAll($TypedArrayPrototype$, $iterators);
	    hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	    redefineAll($TypedArrayPrototype$, {
	      slice: $slice,
	      set: $set,
	      constructor: function constructor() {/* noop */},
	      toString: arrayToString,
	      toLocaleString: $toLocaleString
	    });
	    addGetter($TypedArrayPrototype$, 'buffer', 'b');
	    addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	    addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	    addGetter($TypedArrayPrototype$, 'length', 'e');
	    dP($TypedArrayPrototype$, TAG, {
	      get: function get$$1() {
	        return this[TYPED_ARRAY];
	      }
	    });

	    // eslint-disable-next-line max-statements
	    module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	      CLAMPED = !!CLAMPED;
	      var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	      var GETTER = 'get' + KEY;
	      var SETTER = 'set' + KEY;
	      var TypedArray = global[NAME];
	      var Base = TypedArray || {};
	      var TAC = TypedArray && getPrototypeOf(TypedArray);
	      var FORCED = !TypedArray || !$typed.ABV;
	      var O = {};
	      var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	      var getter = function getter(that, index) {
	        var data = that._d;
	        return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	      };
	      var setter = function setter(that, index, value) {
	        var data = that._d;
	        if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	        data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	      };
	      var addElement = function addElement(that, index) {
	        dP(that, index, {
	          get: function get$$1() {
	            return getter(this, index);
	          },
	          set: function set$$1(value) {
	            return setter(this, index, value);
	          },
	          enumerable: true
	        });
	      };
	      if (FORCED) {
	        TypedArray = wrapper(function (that, data, $offset, $length) {
	          anInstance(that, TypedArray, NAME, '_d');
	          var index = 0;
	          var offset = 0;
	          var buffer, byteLength, length, klass;
	          if (!isObject$$1(data)) {
	            length = toIndex(data);
	            byteLength = length * BYTES;
	            buffer = new $ArrayBuffer(byteLength);
	          } else if (data instanceof $ArrayBuffer || (klass = classof$$1(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	            buffer = data;
	            offset = toOffset($offset, BYTES);
	            var $len = data.byteLength;
	            if ($length === undefined) {
	              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	              byteLength = $len - offset;
	              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	            } else {
	              byteLength = toLength$$1($length) * BYTES;
	              if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
	            }
	            length = byteLength / BYTES;
	          } else if (TYPED_ARRAY in data) {
	            return fromList(TypedArray, data);
	          } else {
	            return $from.call(TypedArray, data);
	          }
	          hide(that, '_d', {
	            b: buffer,
	            o: offset,
	            l: byteLength,
	            e: length,
	            v: new $DataView(buffer)
	          });
	          while (index < length) {
	            addElement(that, index++);
	          }
	        });
	        TypedArrayPrototype = TypedArray[PROTOTYPE] = create$$1($TypedArrayPrototype$);
	        hide(TypedArrayPrototype, 'constructor', TypedArray);
	      } else if (!fails(function () {
	        TypedArray(1);
	      }) || !fails(function () {
	        new TypedArray(-1); // eslint-disable-line no-new
	      }) || !$iterDetect(function (iter) {
	        new TypedArray(); // eslint-disable-line no-new
	        new TypedArray(null); // eslint-disable-line no-new
	        new TypedArray(1.5); // eslint-disable-line no-new
	        new TypedArray(iter); // eslint-disable-line no-new
	      }, true)) {
	        TypedArray = wrapper(function (that, data, $offset, $length) {
	          anInstance(that, TypedArray, NAME);
	          var klass;
	          // `ws` module bug, temporarily remove validation length for Uint8Array
	          // https://github.com/websockets/ws/pull/645
	          if (!isObject$$1(data)) return new Base(toIndex(data));
	          if (data instanceof $ArrayBuffer || (klass = classof$$1(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	            return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
	          }
	          if (TYPED_ARRAY in data) return fromList(TypedArray, data);
	          return $from.call(TypedArray, data);
	        });
	        arrayForEach(TAC !== Function.prototype ? gOPN$$1(Base).concat(gOPN$$1(TAC)) : gOPN$$1(Base), function (key) {
	          if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
	        });
	        TypedArray[PROTOTYPE] = TypedArrayPrototype;
	        if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	      }
	      var $nativeIterator = TypedArrayPrototype[ITERATOR];
	      var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	      var $iterator = $iterators.values;
	      hide(TypedArray, TYPED_CONSTRUCTOR, true);
	      hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	      hide(TypedArrayPrototype, VIEW, true);
	      hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	      if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	        dP(TypedArrayPrototype, TAG, {
	          get: function get$$1() {
	            return NAME;
	          }
	        });
	      }

	      O[NAME] = TypedArray;

	      $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	      $export($export.S, NAME, {
	        BYTES_PER_ELEMENT: BYTES
	      });

	      $export($export.S + $export.F * fails(function () {
	        Base.of.call(TypedArray, 1);
	      }), NAME, {
	        from: $from,
	        of: $of
	      });

	      if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

	      $export($export.P, NAME, proto);

	      setSpecies(NAME);

	      $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

	      $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	      if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

	      $export($export.P + $export.F * fails(function () {
	        new TypedArray(1).slice();
	      }), NAME, { slice: $slice });

	      $export($export.P + $export.F * (fails(function () {
	        return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	      }) || !fails(function () {
	        TypedArrayPrototype.toLocaleString.call([1, 2]);
	      })), NAME, { toLocaleString: $toLocaleString });

	      Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	      if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
	    };
	  } else module.exports = function () {/* empty */};
	});

	var _typedArray$1 = /*#__PURE__*/Object.freeze({
		default: _typedArray,
		__moduleExports: _typedArray
	});

	var require$$0$23 = ( _typedArray$1 && _typedArray ) || _typedArray$1;

	require$$0$23('Int8', 1, function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Uint8', 1, function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	require$$0$23('Int16', 2, function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Uint16', 2, function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Int32', 4, function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Uint32', 4, function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Float32', 4, function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	require$$0$23('Float64', 8, function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)


	var rApply = (require$$2.Reflect || {}).apply;
	var fApply = Function.apply;
	// MS Edge argumentsList argument is optional
	$export$1($export$1.S + $export$1.F * !require$$1(function () {
	  rApply(function () {/* empty */});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList) {
	    var T = aFunction(target);
	    var L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])


	var rConstruct = (require$$2.Reflect || {}).construct;

	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = require$$1(function () {
	  function F() {/* empty */}
	  return !(rConstruct(function () {/* empty */}, [], F) instanceof F);
	});
	var ARGS_BUG = !require$$1(function () {
	  rConstruct(function () {/* empty */});
	});

	$export$1($export$1.S + $export$1.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0:
	          return new Target();
	        case 1:
	          return new Target(args[0]);
	        case 2:
	          return new Target(args[0], args[1]);
	        case 3:
	          return new Target(args[0], args[1], args[2]);
	        case 4:
	          return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = create(isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)


	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export$1($export$1.S + $export$1.F * require$$1(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(require$$37.f({}, 1, { value: 1 }), 1, { value: 2 });
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    propertyKey = require$$16(propertyKey, true);
	    anObject(attributes);
	    try {
	      require$$37.f(target, propertyKey, attributes);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)

	var gOPD$3 = require$$38.f;

	$export$1($export$1.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var desc = gOPD$3(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

	// 26.1.5 Reflect.enumerate(target)


	var Enumerate = function Enumerate(iterated) {
	  this._t = anObject(iterated); // target
	  this._i = 0; // next index
	  var keys = this._k = []; // keys
	  var key;
	  for (key in iterated) {
	    keys.push(key);
	  }
	};
	$iterCreate(Enumerate, 'Object', function () {
	  var that = this;
	  var keys = that._k;
	  var key;
	  do {
	    if (that._i >= keys.length) return { value: undefined, done: true };
	  } while (!((key = keys[that._i++]) in that._t));
	  return { value: key, done: false };
	});

	$export$1($export$1.S, 'Reflect', {
	  enumerate: function enumerate(target) {
	    return new Enumerate(target);
	  }
	});

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])


	function get$1(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var desc, proto;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (desc = require$$38.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
	  if (isObject(proto = require$$23(target))) return get$1(proto, propertyKey, receiver);
	}

	$export$1($export$1.S, 'Reflect', { get: get$1 });

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)


	$export$1($export$1.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return require$$38.f(anObject(target), propertyKey);
	  }
	});

	// 26.1.8 Reflect.getPrototypeOf(target)


	$export$1($export$1.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return require$$23(anObject(target));
	  }
	});

	// 26.1.9 Reflect.has(target, propertyKey)


	$export$1($export$1.S, 'Reflect', {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

	// 26.1.10 Reflect.isExtensible(target)


	var $isExtensible = Object.isExtensible;

	$export$1($export$1.S, 'Reflect', {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

	// all object keys, includes non-enumerable and symbols


	var Reflect$1 = require$$2.Reflect;
	var _ownKeys = Reflect$1 && Reflect$1.ownKeys || function ownKeys(it) {
	  var keys = gOPN.f(anObject(it));
	  var getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

	var _ownKeys$1 = /*#__PURE__*/Object.freeze({
		default: _ownKeys,
		__moduleExports: _ownKeys
	});

	var ownKeys = ( _ownKeys$1 && _ownKeys ) || _ownKeys$1;

	// 26.1.11 Reflect.ownKeys(target)


	$export$1($export$1.S, 'Reflect', { ownKeys: ownKeys });

	// 26.1.12 Reflect.preventExtensions(target)


	var $preventExtensions = Object.preventExtensions;

	$export$1($export$1.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      if ($preventExtensions) $preventExtensions(target);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])


	function set$1(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDesc = require$$38.f(anObject(target), propertyKey);
	  var existingDescriptor, proto;
	  if (!ownDesc) {
	    if (isObject(proto = require$$23(target))) {
	      return set$1(proto, propertyKey, V, receiver);
	    }
	    ownDesc = descriptor(0);
	  }
	  if (has(ownDesc, 'value')) {
	    if (ownDesc.writable === false || !isObject(receiver)) return false;
	    existingDescriptor = require$$38.f(receiver, propertyKey) || descriptor(0);
	    existingDescriptor.value = V;
	    require$$37.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	$export$1($export$1.S, 'Reflect', { set: set$1 });

	// 26.1.14 Reflect.setPrototypeOf(target, proto)


	if (require$$0$12) $export$1($export$1.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    require$$0$12.check(target, proto);
	    try {
	      require$$0$12.set(target, proto);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	var Map$1 = ( es6_map$1 && es6_map ) || es6_map$1;

	var Set$1 = ( es6_set$1 && es6_set ) || es6_set$1;

	var require$$1$6 = ( es6_weakMap$1 && es6_weakMap ) || es6_weakMap$1;

	// https://github.com/tc39/Array.prototype.includes

	var $includes = require$$0$5(true);

	$export$1($export$1.P, 'Array', {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	require$$0$18('includes');

	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray


	var IS_CONCAT_SPREADABLE = require$$0$3('isConcatSpreadable');

	function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
	  var element, spreadable;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

	      spreadable = false;
	      if (isObject(element)) {
	        spreadable = element[IS_CONCAT_SPREADABLE];
	        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
	      }

	      if (spreadable && depth > 0) {
	        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	}

	var _flattenIntoArray = flattenIntoArray;

	var _flattenIntoArray$1 = /*#__PURE__*/Object.freeze({
		default: _flattenIntoArray,
		__moduleExports: _flattenIntoArray
	});

	var flattenIntoArray$1 = ( _flattenIntoArray$1 && _flattenIntoArray ) || _flattenIntoArray$1;

	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap


	$export$1($export$1.P, 'Array', {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = require$$20(this);
	    var sourceLen, A;
	    aFunction(callbackfn);
	    sourceLen = toLength(O.length);
	    A = asc(O, 0);
	    flattenIntoArray$1(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
	    return A;
	  }
	});

	require$$0$18('flatMap');

	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten


	$export$1($export$1.P, 'Array', {
	  flatten: function flatten() /* depthArg = 1 */{
	    var depthArg = arguments[0];
	    var O = require$$20(this);
	    var sourceLen = toLength(O.length);
	    var A = asc(O, 0);
	    flattenIntoArray$1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
	    return A;
	  }
	});

	require$$0$18('flatten');

	// https://github.com/mathiasbynens/String.prototype.at

	var $at$2 = require$$0$14(true);

	$export$1($export$1.P, 'String', {
	  at: function at(pos) {
	    return $at$2(this, pos);
	  }
	});

	// https://github.com/tc39/proposal-string-pad-start-end


	var _stringPad = function _stringPad(that, maxLength, fillString, left) {
	  var S = String(defined(that));
	  var stringLength = S.length;
	  var fillStr = fillString === undefined ? ' ' : String(fillString);
	  var intMaxLength = toLength(maxLength);
	  if (intMaxLength <= stringLength || fillStr == '') return S;
	  var fillLen = intMaxLength - stringLength;
	  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};

	var _stringPad$1 = /*#__PURE__*/Object.freeze({
		default: _stringPad,
		__moduleExports: _stringPad
	});

	var navigator$1 = require$$2.navigator;

	var _userAgent = navigator$1 && navigator$1.userAgent || '';

	var _userAgent$1 = /*#__PURE__*/Object.freeze({
		default: _userAgent,
		__moduleExports: _userAgent
	});

	var $pad = ( _stringPad$1 && _stringPad ) || _stringPad$1;

	var userAgent = ( _userAgent$1 && _userAgent ) || _userAgent$1;

	// https://github.com/tc39/proposal-string-pad-start-end


	// https://github.com/zloirock/core-js/issues/280
	$export$1($export$1.P + $export$1.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

	// https://github.com/tc39/proposal-string-pad-start-end


	// https://github.com/zloirock/core-js/issues/280
	$export$1($export$1.P + $export$1.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	require$$1$5('trimLeft', function ($trim) {
	  return function trimLeft() {
	    return $trim(this, 1);
	  };
	}, 'trimStart');

	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	require$$1$5('trimRight', function ($trim) {
	  return function trimRight() {
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

	// https://tc39.github.io/String.prototype.matchAll/


	var RegExpProto = RegExp.prototype;

	var $RegExpStringIterator = function $RegExpStringIterator(regexp, string) {
	  this._r = regexp;
	  this._s = string;
	};

	$iterCreate($RegExpStringIterator, 'RegExp String', function next() {
	  var match = this._r.exec(this._s);
	  return { value: match, done: match === null };
	});

	$export$1($export$1.P, 'String', {
	  matchAll: function matchAll(regexp) {
	    defined(this);
	    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
	    var S = String(this);
	    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
	    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

	require$$0$9('asyncIterator');

	require$$0$9('observable');

	// https://github.com/tc39/proposal-object-getownpropertydescriptors


	$export$1($export$1.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIObject(object);
	    var getDesc = require$$38.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var i = 0;
	    var key, desc;
	    while (keys.length > i) {
	      desc = getDesc(O, key = keys[i++]);
	      if (desc !== undefined) createProperty(result, key, desc);
	    }
	    return result;
	  }
	});

	var isEnum$1 = require$$0$7.f;
	var _objectToArray = function _objectToArray(isEntries) {
	  return function (it) {
	    var O = toIObject(it);
	    var keys = getKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      if (isEnum$1.call(O, key = keys[i++])) {
	        result.push(isEntries ? [key, O[key]] : O[key]);
	      }
	    }return result;
	  };
	};

	var _objectToArray$1 = /*#__PURE__*/Object.freeze({
		default: _objectToArray,
		__moduleExports: _objectToArray
	});

	var require$$0$24 = ( _objectToArray$1 && _objectToArray ) || _objectToArray$1;

	// https://github.com/tc39/proposal-object-values-entries

	var $values = require$$0$24(false);

	$export$1($export$1.S, 'Object', {
	  values: function values(it) {
	    return $values(it);
	  }
	});

	// https://github.com/tc39/proposal-object-values-entries

	var $entries = require$$0$24(true);

	$export$1($export$1.S, 'Object', {
	  entries: function entries(it) {
	    return $entries(it);
	  }
	});

	// Forced replacement prototype accessors methods
	var _objectForcedPam = require$$0$4 || !require$$1(function () {
	  var K = Math.random();
	  // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call
	  __defineSetter__.call(null, K, function () {/* empty */});
	  delete require$$2[K];
	});

	var _objectForcedPam$1 = /*#__PURE__*/Object.freeze({
		default: _objectForcedPam,
		__moduleExports: _objectForcedPam
	});

	var require$$2$3 = ( _objectForcedPam$1 && _objectForcedPam ) || _objectForcedPam$1;

	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	require$$0 && $export$1($export$1.P + require$$2$3, 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter) {
	    require$$37.f(require$$20(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
	  }
	});

	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	require$$0 && $export$1($export$1.P + require$$2$3, 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter) {
	    require$$37.f(require$$20(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
	  }
	});

	var getOwnPropertyDescriptor = require$$38.f;

	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	require$$0 && $export$1($export$1.P + require$$2$3, 'Object', {
	  __lookupGetter__: function __lookupGetter__(P) {
	    var O = require$$20(this);
	    var K = require$$16(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
	    } while (O = require$$23(O));
	  }
	});

	var getOwnPropertyDescriptor$1 = require$$38.f;

	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	require$$0 && $export$1($export$1.P + require$$2$3, 'Object', {
	  __lookupSetter__: function __lookupSetter__(P) {
	    var O = require$$20(this);
	    var K = require$$16(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor$1(O, K)) return D.set;
	    } while (O = require$$23(O));
	  }
	});

	var _arrayFromIterable = function _arrayFromIterable(iter, ITERATOR) {
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};

	var _arrayFromIterable$1 = /*#__PURE__*/Object.freeze({
		default: _arrayFromIterable,
		__moduleExports: _arrayFromIterable
	});

	var from = ( _arrayFromIterable$1 && _arrayFromIterable ) || _arrayFromIterable$1;

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON


	var _collectionToJson = function _collectionToJson(NAME) {
	  return function toJSON() {
	    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

	var _collectionToJson$1 = /*#__PURE__*/Object.freeze({
		default: _collectionToJson,
		__moduleExports: _collectionToJson
	});

	var require$$0$25 = ( _collectionToJson$1 && _collectionToJson ) || _collectionToJson$1;

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON


	$export$1($export$1.P + $export$1.R, 'Map', { toJSON: require$$0$25('Map') });

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON


	$export$1($export$1.P + $export$1.R, 'Set', { toJSON: require$$0$25('Set') });

	// https://tc39.github.io/proposal-setmap-offrom/


	var _setCollectionOf = function _setCollectionOf(COLLECTION) {
	  $export$1($export$1.S, COLLECTION, { of: function of() {
	      var length = arguments.length;
	      var A = new Array(length);
	      while (length--) {
	        A[length] = arguments[length];
	      }return new this(A);
	    } });
	};

	var _setCollectionOf$1 = /*#__PURE__*/Object.freeze({
		default: _setCollectionOf,
		__moduleExports: _setCollectionOf
	});

	var require$$0$26 = ( _setCollectionOf$1 && _setCollectionOf ) || _setCollectionOf$1;

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	require$$0$26('Map');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
	require$$0$26('Set');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
	require$$0$26('WeakMap');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
	require$$0$26('WeakSet');

	// https://tc39.github.io/proposal-setmap-offrom/


	var _setCollectionFrom = function _setCollectionFrom(COLLECTION) {
	  $export$1($export$1.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
	      var mapFn = arguments[1];
	      var mapping, A, n, cb;
	      aFunction(this);
	      mapping = mapFn !== undefined;
	      if (mapping) aFunction(mapFn);
	      if (source == undefined) return new this();
	      A = [];
	      if (mapping) {
	        n = 0;
	        cb = ctx(mapFn, arguments[2], 2);
	        forOf(source, false, function (nextItem) {
	          A.push(cb(nextItem, n++));
	        });
	      } else {
	        forOf(source, false, A.push, A);
	      }
	      return new this(A);
	    } });
	};

	var _setCollectionFrom$1 = /*#__PURE__*/Object.freeze({
		default: _setCollectionFrom,
		__moduleExports: _setCollectionFrom
	});

	var require$$0$27 = ( _setCollectionFrom$1 && _setCollectionFrom ) || _setCollectionFrom$1;

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	require$$0$27('Map');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
	require$$0$27('Set');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
	require$$0$27('WeakMap');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
	require$$0$27('WeakSet');

	// https://github.com/tc39/proposal-global


	$export$1($export$1.G, { global: require$$2 });

	// https://github.com/tc39/proposal-global


	$export$1($export$1.S, 'System', { global: require$$2 });

	// https://github.com/ljharb/proposal-is-error


	$export$1($export$1.S, 'Error', {
	  isError: function isError(it) {
	    return require$$1$2(it) === 'Error';
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	$export$1($export$1.S, 'Math', {
	  clamp: function clamp(x, lower, upper) {
	    return Math.min(upper, Math.max(lower, x));
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	$export$1($export$1.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

	// https://rwaldron.github.io/proposal-math-extensions/

	var RAD_PER_DEG = 180 / Math.PI;

	$export$1($export$1.S, 'Math', {
	  degrees: function degrees(radians) {
	    return radians * RAD_PER_DEG;
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/
	var _mathScale = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
	  if (arguments.length === 0
	  // eslint-disable-next-line no-self-compare
	  || x != x
	  // eslint-disable-next-line no-self-compare
	  || inLow != inLow
	  // eslint-disable-next-line no-self-compare
	  || inHigh != inHigh
	  // eslint-disable-next-line no-self-compare
	  || outLow != outLow
	  // eslint-disable-next-line no-self-compare
	  || outHigh != outHigh) return NaN;
	  if (x === Infinity || x === -Infinity) return x;
	  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
	};

	var _mathScale$1 = /*#__PURE__*/Object.freeze({
		default: _mathScale,
		__moduleExports: _mathScale
	});

	var require$$0$28 = ( _mathScale$1 && _mathScale ) || _mathScale$1;

	// https://rwaldron.github.io/proposal-math-extensions/


	$export$1($export$1.S, 'Math', {
	  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
	    return fround(require$$0$28(x, inLow, inHigh, outLow, outHigh));
	  }
	});

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	$export$1($export$1.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	$export$1($export$1.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	$export$1($export$1.S, 'Math', {
	  imulh: function imulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >> 16;
	    var v1 = $v >> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	$export$1($export$1.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

	// https://rwaldron.github.io/proposal-math-extensions/

	var DEG_PER_RAD = Math.PI / 180;

	$export$1($export$1.S, 'Math', {
	  radians: function radians(degrees) {
	    return degrees * DEG_PER_RAD;
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	$export$1($export$1.S, 'Math', { scale: require$$0$28 });

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	$export$1($export$1.S, 'Math', {
	  umulh: function umulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >>> 16;
	    var v1 = $v >>> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

	// http://jfbastien.github.io/papers/Math.signbit.html


	$export$1($export$1.S, 'Math', { signbit: function signbit(x) {
	    // eslint-disable-next-line no-self-compare
	    return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
	  } });

	// https://github.com/tc39/proposal-promise-try


	$export$1($export$1.S, 'Promise', { 'try': function _try(callbackfn) {
	    var promiseCapability = newPromiseCapability.f(this);
	    var result = perform(callbackfn);
	    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	    return promiseCapability.promise;
	  } });

	var shared$1 = require$$0$2('metadata');
	var store$1 = shared$1.store || (shared$1.store = new require$$1$6());

	var getOrCreateMetadataMap = function getOrCreateMetadataMap(target, targetKey, create) {
	  var targetMetadata = store$1.get(target);
	  if (!targetMetadata) {
	    if (!create) return undefined;
	    store$1.set(target, targetMetadata = new Map$1());
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if (!keyMetadata) {
	    if (!create) return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map$1());
	  }return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function ordinaryHasOwnMetadata(MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function ordinaryGetOwnMetadata(MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function ordinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function ordinaryOwnMetadataKeys(target, targetKey) {
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
	  var keys = [];
	  if (metadataMap) metadataMap.forEach(function (_, key) {
	    keys.push(key);
	  });
	  return keys;
	};
	var toMetaKey = function toMetaKey(it) {
	  return it === undefined || (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : String(it);
	};
	var exp$3 = function exp(O) {
	  $export$1($export$1.S, 'Reflect', O);
	};

	var _metadata = {
	  store: store$1,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp$3
	};
	var _metadata_1 = _metadata.store;
	var _metadata_2 = _metadata.map;
	var _metadata_3 = _metadata.has;
	var _metadata_4 = _metadata.get;
	var _metadata_5 = _metadata.set;
	var _metadata_6 = _metadata.keys;
	var _metadata_7 = _metadata.key;
	var _metadata_8 = _metadata.exp;

	var _metadata$1 = /*#__PURE__*/Object.freeze({
		default: _metadata,
		__moduleExports: _metadata,
		store: _metadata_1,
		map: _metadata_2,
		has: _metadata_3,
		get: _metadata_4,
		set: _metadata_5,
		keys: _metadata_6,
		key: _metadata_7,
		exp: _metadata_8
	});

	var $metadata = ( _metadata$1 && _metadata ) || _metadata$1;

	var toMetaKey$1 = $metadata.key;
	var ordinaryDefineOwnMetadata$1 = $metadata.set;

	$metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
	    ordinaryDefineOwnMetadata$1(metadataKey, metadataValue, anObject(target), toMetaKey$1(targetKey));
	  } });

	var toMetaKey$2 = $metadata.key;
	var getOrCreateMetadataMap$1 = $metadata.map;
	var store$2 = $metadata.store;

	$metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetaKey$2(arguments[2]);
	    var metadataMap = getOrCreateMetadataMap$1(anObject(target), targetKey, false);
	    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
	    if (metadataMap.size) return true;
	    var targetMetadata = store$2.get(target);
	    targetMetadata['delete'](targetKey);
	    return !!targetMetadata.size || store$2['delete'](target);
	  } });

	var ordinaryHasOwnMetadata$1 = $metadata.has;
	var ordinaryGetOwnMetadata$1 = $metadata.get;
	var toMetaKey$3 = $metadata.key;

	var ordinaryGetMetadata = function ordinaryGetMetadata(MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata$1(MetadataKey, O, P);
	  if (hasOwn) return ordinaryGetOwnMetadata$1(MetadataKey, O, P);
	  var parent = require$$23(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};

	$metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
	    return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey$3(arguments[2]));
	  } });

	var ordinaryOwnMetadataKeys$1 = $metadata.keys;
	var toMetaKey$4 = $metadata.key;

	var ordinaryMetadataKeys = function ordinaryMetadataKeys(O, P) {
	  var oKeys = ordinaryOwnMetadataKeys$1(O, P);
	  var parent = require$$23(O);
	  if (parent === null) return oKeys;
	  var pKeys = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set$1(oKeys.concat(pKeys))) : pKeys : oKeys;
	};

	$metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
	    return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey$4(arguments[1]));
	  } });

	var ordinaryGetOwnMetadata$2 = $metadata.get;
	var toMetaKey$5 = $metadata.key;

	$metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
	    return ordinaryGetOwnMetadata$2(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey$5(arguments[2]));
	  } });

	var ordinaryOwnMetadataKeys$2 = $metadata.keys;
	var toMetaKey$6 = $metadata.key;

	$metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
	    return ordinaryOwnMetadataKeys$2(anObject(target), arguments.length < 2 ? undefined : toMetaKey$6(arguments[1]));
	  } });

	var ordinaryHasOwnMetadata$2 = $metadata.has;
	var toMetaKey$7 = $metadata.key;

	var ordinaryHasMetadata = function ordinaryHasMetadata(MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata$2(MetadataKey, O, P);
	  if (hasOwn) return true;
	  var parent = require$$23(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};

	$metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
	    return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey$7(arguments[2]));
	  } });

	var ordinaryHasOwnMetadata$3 = $metadata.has;
	var toMetaKey$8 = $metadata.key;

	$metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
	    return ordinaryHasOwnMetadata$3(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey$8(arguments[2]));
	  } });

	var toMetaKey$9 = $metadata.key;
	var ordinaryDefineOwnMetadata$2 = $metadata.set;

	$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
	    return function decorator(target, targetKey) {
	      ordinaryDefineOwnMetadata$2(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey$9(targetKey));
	    };
	  } });

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask

	var microtask$1 = require$$0$21();
	var process$4 = require$$2.process;
	var isNode$2 = require$$1$2(process$4) == 'process';

	$export$1($export$1.G, {
	  asap: function asap(fn) {
	    var domain = isNode$2 && process$4.domain;
	    microtask$1(domain ? domain.bind(fn) : fn);
	  }
	});

	// https://github.com/zenparsing/es-observable


	var microtask$2 = require$$0$21();
	var OBSERVABLE = require$$0$3('observable');

	var RETURN = forOf.RETURN;

	var getMethod = function getMethod(fn) {
	  return fn == null ? undefined : aFunction(fn);
	};

	var cleanupSubscription = function cleanupSubscription(subscription) {
	  var cleanup = subscription._c;
	  if (cleanup) {
	    subscription._c = undefined;
	    cleanup();
	  }
	};

	var subscriptionClosed = function subscriptionClosed(subscription) {
	  return subscription._o === undefined;
	};

	var closeSubscription = function closeSubscription(subscription) {
	  if (!subscriptionClosed(subscription)) {
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};

	var Subscription = function Subscription(observer, subscriber) {
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup = subscriber(observer);
	    var subscription = cleanup;
	    if (cleanup != null) {
	      if (typeof cleanup.unsubscribe === 'function') cleanup = function cleanup() {
	        subscription.unsubscribe();
	      };else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch (e) {
	    observer.error(e);
	    return;
	  }if (subscriptionClosed(this)) cleanupSubscription(this);
	};

	Subscription.prototype = require$$11({}, {
	  unsubscribe: function unsubscribe() {
	    closeSubscription(this);
	  }
	});

	var SubscriptionObserver = function SubscriptionObserver(subscription) {
	  this._s = subscription;
	};

	SubscriptionObserver.prototype = require$$11({}, {
	  next: function next(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if (m) return m.call(observer, value);
	      } catch (e) {
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value) {
	    var subscription = this._s;
	    if (subscriptionClosed(subscription)) throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if (!m) throw value;
	      value = m.call(observer, value);
	    } catch (e) {
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    }cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch (e) {
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});

	var $Observable = function Observable(subscriber) {
	  require$$8(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};

	require$$11($Observable.prototype, {
	  subscribe: function subscribe(observer) {
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn) {
	    var that = this;
	    return new (require$$1$1.Promise || require$$2.Promise)(function (resolve, reject) {
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next: function next(value) {
	          try {
	            return fn(value);
	          } catch (e) {
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});

	require$$11($Observable, {
	  from: function from(x) {
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if (method) {
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function (observer) {
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function (observer) {
	      var done = false;
	      microtask$2(function () {
	        if (!done) {
	          try {
	            if (forOf(x, false, function (it) {
	              observer.next(it);
	              if (done) return RETURN;
	            }) === RETURN) return;
	          } catch (e) {
	            if (done) throw e;
	            observer.error(e);
	            return;
	          }observer.complete();
	        }
	      });
	      return function () {
	        done = true;
	      };
	    });
	  },
	  of: function of() {
	    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) {
	      items[i] = arguments[i++];
	    }return new (typeof this === 'function' ? this : $Observable)(function (observer) {
	      var done = false;
	      microtask$2(function () {
	        if (!done) {
	          for (var j = 0; j < items.length; ++j) {
	            observer.next(items[j]);
	            if (done) return;
	          }observer.complete();
	        }
	      });
	      return function () {
	        done = true;
	      };
	    });
	  }
	});

	require$$0$1($Observable.prototype, OBSERVABLE, function () {
	  return this;
	});

	$export$1($export$1.G, { Observable: $Observable });

	require$$34('Observable');

	var _global$2 = new Function('return this;')();
	var __proto = Function.prototype;
	var g = {};

	function _overideFunction() {
	  if (arguments.length > 0 && /^\s*return this\s*;?\s*$/.test(arguments[arguments.length - 1])) {
	    return function () {
	      return g;
	    };
	  }
	  return function () {};
	}

	if (typeof _global$2.webkit === 'undefined') {
	  var _eval = undefined;
	  _global$2.eval = _eval;
	  _overideFunction.prototype = __proto;
	  _overideFunction.prototype.constructor = _overideFunction;
	  // eslint-disable-next-line no-global-assign
	  Function = _overideFunction;
	}

	var ttJSCore = _global$2.ttJSCore;
	var webkit = _global$2.webkit;

	if (_global$2.ttJSCore) {
	  _global$2.ttJSCore = {
	    onDocumentReady: function onDocumentReady() {
	      return ttJSCore.onDocumentReady();
	    }
	  };
	}

	if (_global$2.webkit) {
	  _global$2.webkit = {
	    messageHandlers: {
	      onDocumentReady: {
	        postMessage: function postMessage() {
	          return webkit.messageHandlers.onDocumentReady.postMessage('');
	        }
	      }
	    }
	  };
	}

	var readyQueue = [];
	if (_typeof(_global$2.TMAConfig) === 'object' && _global$2.TMAConfig !== null) {
	  _global$2.TMAConfig.onReady = function (cb) {
	    cb(_global$2.TMAConfig);
	  };

	  _global$2.TMAConfig.onRealReady = function (cb) {
	    if (typeof cb === 'function') {
	      readyQueue.push(cb);
	    }
	  };

	  _global$2.TMAConfig.ready = function () {
	    readyQueue.forEach(function (cb) {
	      cb(_global$2.TMAConfig);
	    });
	  };
	}

	var modules = {};

	function define$1(path, factory) {
	    modules[path] = {
	        runed: false,
	        factory: factory
	    };
	}
	var t = function t(path) {
	    var match = path.match(/(.*)\/([^\/]+)?$/);
	    return match && match[1] ? match[1] : "./";
	};
	var inRequire = function inRequire(path) {
	    var pwd = t(path);
	    return function (path) {
	        if ("string" != typeof path) {
	            throw new Error("require args must be a string");
	        }

	        for (var t = [], r = (pwd + "/" + path).split("/"), o = 0, i = r.length; o < i; ++o) {
	            var a = r[o];
	            if ("" != a && "." != a) if (".." == a) {
	                if (0 == t.length) throw new Error("can't find module : " + path);
	                t.pop();
	            } else o + 1 < i && ".." == r[o + 1] ? o++ : t.push(a);
	        }
	        try {
	            var c = t.join("/");
	            return (/\.js$/.test(c) || (c += ".js"), require(c)
	            );
	        } catch (e) {
	            throw e;
	        }
	    };
	};

	function require(path) {
	    if ("string" != typeof path) {
	        throw new Error("require args must be a string");
	    }

	    var module = modules[path];
	    if (!module) {
	        throw new Error('module "' + path + '" is not defined');
	    }

	    if (!module.runed) {
	        var factory = module.factory;
	        var _module = {
	            exports: {}
	        };
	        var res;

	        if (typeof factory === 'function') {
	            res = factory(inRequire(path), _module, _module.exports);
	        }
	        module.exports = _module.exports || res;
	        module.runed = true;
	    }

	    return module.exports;
	}

	_global$2.define = define$1;
	_global$2.require = require;

	/* global $glob$ */

	var timerFnIdCounter = 1;
	var timerFnMap = {};

	var _setTimer = function _setTimer(type, fn, ms) {
	  timerFnMap[timerFnIdCounter] = fn;
	  if (typeof ms !== 'number') {
	    ms = 0;
	  }
	  ttJSCore.setTimer(type, timerFnIdCounter, ms);
	  return timerFnIdCounter++;
	};

	var _clearTimer = function _clearTimer(type, id) {
	  if (typeof timerFnMap[id] === 'function') {
	    timerFnMap[id] = undefined;
	    ttJSCore.clearTimer(type, id);
	  }
	};

	$glob$.nativeInvokeTimer = function (type, id) {
	  if (typeof timerFnMap[id] === 'function') {
	    timerFnMap[id].call($glob$);
	  }
	  if (type === 'Timeout') {
	    timerFnMap[id] = undefined;
	  }
	};

	if (typeof setTimeout === 'undefined') {
	  $glob$.setTimeout = _setTimer.bind($glob$, 'Timeout');
	  $glob$.clearTimeout = _clearTimer.bind($glob$, 'Timeout');
	  $glob$.setInterval = _setTimer.bind($glob$, 'Interval');
	  $glob$.clearInterval = _clearTimer.bind($glob$, 'Interval');
	}

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	var ms = function ms(val, options) {
	  options = options || {};
	  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

	createDebug.debug = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = ms;

	/**
	 * Active `debug` instances.
	 */
	createDebug.instances = [];

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	createDebug.names = [];
	createDebug.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */

	createDebug.formatters = {};

	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */

	function selectColor(namespace) {
	  var hash = 0,
	      i;

	  for (i in namespace) {
	    hash = (hash << 5) - hash + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }

	  return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function createDebug(namespace) {

	  var prevTime;

	  function debug() {
	    // disabled?
	    if (!_global$2.__FORCE_LOG__ && !debug.enabled) {
	      return;
	    }

	    var self = debug;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms$$1 = curr - (prevTime || curr);
	    self.diff = ms$$1;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    args[0] = createDebug.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') {
	        return match;
	      }
	      index++;
	      var formatter = createDebug.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    // apply env-specific formatting (colors, etc.)
	    createDebug.formatArgs.call(self, args);

	    var logFn = debug.log || createDebug.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }

	  debug.namespace = namespace;
	  debug.enabled = createDebug.enabled(namespace);
	  debug.useColors = createDebug.useColors();
	  debug.color = selectColor(namespace);
	  debug.destroy = destroy;

	  // env-specific initialization logic for debug instances
	  if ('function' === typeof createDebug.init) {
	    createDebug.init(debug);
	  }

	  createDebug.instances.push(debug);

	  return debug;
	}

	function destroy() {
	  var index = createDebug.instances.indexOf(this);
	  if (index !== -1) {
	    createDebug.instances.splice(index, 1);
	    return true;
	  } else {
	    return false;
	  }
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  createDebug.save(namespaces);

	  createDebug.names = [];
	  createDebug.skips = [];

	  var i;
	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;

	  for (i = 0; i < len; i++) {
	    if (!split[i]) {
	      continue;
	    } // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      createDebug.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }

	  for (i = 0; i < createDebug.instances.length; i++) {
	    var instance = createDebug.instances[i];
	    instance.enabled = createDebug.enabled(instance.namespace);
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  createDebug.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  if (name[name.length - 1] === '*') {
	    return true;
	  }
	  var i, len;
	  for (i = 0, len = createDebug.skips.length; i < len; i++) {
	    if (createDebug.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = createDebug.names.length; i < len; i++) {
	    if (createDebug.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) {
	    return val.stack || val.message;
	  }
	  return val;
	}

	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	createDebug.log = log$1;
	createDebug.formatArgs = formatArgs;
	createDebug.save = save;
	createDebug.load = load;
	createDebug.useColors = useColors;
	createDebug.storage = localstorage();

	/**
	 * Colors.
	 */

	createDebug.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }

	  // Internet Explorer and Edge do not support colors.
	  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	    return false;
	  }

	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table)
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31
	  // double check webkit in userAgent just in case we are in a worker
	  || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	createDebug.formatters.j = function (v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};

	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + createDebug.humanize(this.diff);

	  if (!useColors) {
	    return;
	  }

	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit');

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function (match) {
	    if ('%%' === match) {
	      return;
	    }
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log$1() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      createDebug.storage.debug = '';
	    } else {
	      createDebug.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  return '*TMA*';
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	createDebug.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
	  var g = typeof window === 'undefined' ? _global$2 : window;
	  try {
	    /* eslint-disable no-return-assign */
	    return g.__DEBUG_NAMESPACE ? g.__DEBUG_NAMESPACE : g.__DEBUG_NAMESPACE = {};
	  } catch (e) {}
	}

	var TYPE = 'RUNTIME';
	var app = 'TMA';

	// let debug = debug(`[${app}][DEBUG][${TYPE}]`);
	// let trace = debug(`[${app}][TRACE][${TYPE}]`);
	// let log = debug(`[${app}][LOG][${TYPE}]`);
	// let info = debug(`[${app}][INFO][${TYPE}]`);
	// let warn = debug(`[${app}][WARN][${TYPE}]`);
	// let error = debug(`[${app}][ERROR][${TYPE}]`);

	// const logMethod = ['debug', 'group', 'groupEnd', 'trace', 'log', 'info', 'warn', 'error', 'time', 'timeEnd'];
	var allMethod = [];
	for (var i$2 in console) {
	  allMethod.push(i$2);
	}

	/* eslint-disable no-console */
	var logMethod = allMethod.filter(function (method) {
	  return typeof console[method] === 'function';
	});

	var logger$1 = {};

	logMethod.forEach(function (method) {
	  logger$1[method] = createDebug('[' + app + '][' + method.toUpperCase() + '][' + TYPE + ']');
	  /* eslint-disable no-console */
	  logger$1[method].log = console[method].bind(console);
	});

	// import global from '../global';
	// global.logger = logger;
	logger = logger$1;

	var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	var btoa = btoa || function (e) {
	  for (var t, n, r = String(e), o = '', i = 0, a = alphabet; r.charAt(0 | i) || (a = '=', i % 1); o += a.charAt(63 & t >> 8 - i % 1 * 8)) {
	    if ((n = r.charCodeAt(i += 0.75)) > 255) {
	      throw new Error('"btoa" failed');
	    }
	    t = t << 8 | n;
	  }
	  return o;
	};

	var atob = atob || function (e) {
	  var t = String(e).replace(/=+$/, ''),
	      n = '';
	  if (t.length % 4 == 1) {
	    throw new Error('"atob" failed');
	  }
	  for (var r, o, i = 0, a = 0; o = t.charAt(a++), o; ~o && (r = i % 4 ? 64 * r + o : o, i++ % 4) ? n += String.fromCharCode(255 & r >> (-2 * i & 6)) : 0) {
	    o = alphabet.indexOf(o);
	  }
	  return n;
	};

	function encodeToUi8Base64(ab) {
	  var string = '';
	  var ui8aReader = new Uint8Array(ab),
	      len = ui8aReader.byteLength;
	  for (var i = 0; i < len; i++) {
	    string += String.fromCharCode(ui8aReader[i]);
	  }
	  return btoa(string);
	}

	function decodeFromUi8Base64(string) {
	  var base64String = atob(string),
	      len = base64String.length,
	      ui8aReader = new Uint8Array(len);
	  for (var i = 0; i < len; i++) {
	    ui8aReader[i] = base64String.charCodeAt(i);
	  }
	  return ui8aReader.buffer;
	}

	function _new(data) {
	  return {
	    base64: encodeToUi8Base64(data)
	  };
	}

	function _get(data) {
	  if (data != null) {
	    if (data.base64) {
	      return decodeFromUi8Base64(data.base64);
	    } else {
	      return undefined;
	    }
	  }
	}

	function isType(type) {
	  return function (arg) {
	    return Object.prototype.toString.call(arg).toLowerCase() === ('[object ' + type + ']').toLowerCase();
	  };
	}

	function _pack(data) {
	  if (isType('Object')(data) === false) {
	    return data;
	  }

	  // 收集并转换需要编码的字段
	  var needTransAttrs = [];
	  for (var key in data) {
	    var item = data[key];
	    if (item !== undefined && item instanceof ArrayBuffer && item.byteLength !== undefined) {
	      var obj = _new(item);
	      obj.key = key;
	      needTransAttrs.push(obj);
	    }
	  }

	  if (needTransAttrs.length > 0) {
	    // 从原始数据上删除需要转换的字段
	    for (var i = 0; i < needTransAttrs.length; i++) {
	      var tmp = needTransAttrs[i];
	      delete data[tmp.key];
	    }

	    data.__nativeBuffers__ = needTransAttrs;
	  }

	  return data;
	}

	function _unpack(data) {
	  if (isType('Object')(data) === false || null == data.__nativeBuffers__) {
	    return data;
	  }

	  var nbs = data.__nativeBuffers__;
	  delete data.__nativeBuffers__;

	  for (var i = 0; i < nbs.length; i++) {
	    var item = nbs[i];
	    if (null != item) {
	      var tmp = _get(item);
	      if (tmp !== undefined && tmp instanceof ArrayBuffer) {
	        data[item.key] = tmp;
	      }
	    }
	  }

	  return data;
	}

	var NativeBuffer = {
	  new: _new,
	  get: _get,
	  pack: _pack,
	  unpack: _unpack
	};

	/**
	 * 本地修改点：
	 *  1. WeixinJSBridge => ttJSBridge
	 *  2. WeixinJSCore => ttJSCore
	 *  3. invokeCallbackHandler => invokeHandler
	 *  4. invokeHandler 和 subscribeHandler 里加了一层 JSONDecode
	 *  5. 删除了对 webkit 和 ttJSCore 删除的部分
	 */

	var invokeCallbackMap = {};
	var invokeCallbackIdCounter = 0;
	var eventMap = {};
	var customEventMap = {};
	var invokeTaskCache = [];
	var onAppEnterBackground = false;
	var reserveInvokeCallbackIds = [];

	var ACTIONS = {
	  onAppEnterBackground: 'onAppEnterBackground',
	  onAppEnterForeground: 'onAppEnterForeground'
	};

	var backgroundEventManager = {
	  needCache: ['showModal', 'showToast', 'showActionSheet', 'hideToast'],
	  needDisabled: ['onAccelerometerChange', 'onCompassChange']
	};

	// var webkit = global.webkit;
	// var ttJSCore = global.ttJSCore;

	var logSwitchOn = false;

	function _checkSyncInvokeResult(res, callbackId) {
	  if (res !== undefined && typeof invokeCallbackMap[callbackId] == 'function' && res !== '' && res !== null) {
	    try {
	      res = JSON.parse(res);
	      res = NativeBuffer.unpack(res);
	    } catch (t) {
	      res = {};
	    }

	    invokeCallbackMap[callbackId](res);
	    delete invokeCallbackMap[callbackId];
	  }
	}

	function _invoke$2(ev, param, callbackId) {
	  if (logSwitchOn) {
	    logger.log('invoke客户端方法', ev, param, callbackId);
	  }

	  // 进入后台时，缓存调端的 task
	  if (onAppEnterBackground && backgroundEventManager.needCache.find(function (e) {
	    return e === ev;
	  })) {
	    invokeTaskCache.push([ev, param, callbackId]);
	    return;
	  }

	  if (ttJSCore) {
	    var res = ttJSCore.invoke(ev, param, callbackId);
	    _checkSyncInvokeResult(res, callbackId);
	  } else {
	    var wkInvokeParam = {
	      event: ev,
	      paramsString: param,
	      callbackId: callbackId
	    };

	    webkit.messageHandlers.invoke.postMessage(wkInvokeParam);
	  }
	}

	function _publish(ev, paramString, webviewIdsString) {
	  if (logSwitchOn) {
	    logger.log('publish到对岸', ev, paramString, webviewIdsString);
	  }
	  if (ttJSCore) {
	    ttJSCore.publish(ev, paramString, webviewIdsString);
	  } else {
	    webkit.messageHandlers.publish.postMessage({
	      event: ev,
	      paramsString: paramString,
	      webviewIds: webviewIdsString
	    });
	  }
	}

	function _beforeInvoke(ev, data, cb) {
	  data = NativeBuffer.pack(data);
	  var datastring = JSON.stringify(data || {}),
	      _id = ++invokeCallbackIdCounter;
	  invokeCallbackMap[_id] = cb;
	  // trick for openSchema
	  if (ev === 'openSchema') {
	    reserveInvokeCallbackIds.push(_id);
	  }
	  _invoke$2(ev, datastring, _id);
	}

	function _invokeHandler(callbackId, data) {
	  if (logSwitchOn) {
	    logger.log('invokeHandler客户端执行回调', callbackId, data);
	  }
	  // NOTE 这里修改了原有的实现，加了一层 JSON 转码
	  if (typeof data === 'string') {
	    data = JSON.parse(data);
	  }
	  data = NativeBuffer.unpack(data);
	  var _cb = invokeCallbackMap[callbackId];
	  typeof _cb == 'function' && _cb(data);

	  if (reserveInvokeCallbackIds.indexOf(callbackId) === -1) {
	    delete invokeCallbackMap[callbackId];
	  }
	}

	function _on(ev, cb) {
	  eventMap[ev] = cb;
	}

	function _beforePublish(ev, data, webviewIds) {
	  webviewIds = webviewIds || [];
	  webviewIds = JSON.stringify(webviewIds);
	  var custom_ev = 'custom_event_' + ev;
	  var datastring = JSON.stringify(data);

	  _publish(custom_ev, datastring, webviewIds);
	}

	function _subscribe(ev, cb) {
	  customEventMap['custom_event_' + ev] = cb;
	}

	function _subscribeHandler(ev, data, webviewId, r) {
	  if (logSwitchOn) {
	    logger.log('subscribeHandler事件触发', ev, data, webviewId, r);
	  }

	  if (ev === ACTIONS.onAppEnterBackground) {
	    onAppEnterBackground = true;
	  } else if (ev === ACTIONS.onAppEnterForeground) {
	    // 回到前台时，取出缓存的 task
	    onAppEnterBackground = false;
	    while (invokeTaskCache.length) {
	      _invoke$2.apply(null, invokeTaskCache.shift());
	    }
	  }
	  // 处于后台期间需要屏蔽的回调处理
	  if (onAppEnterBackground && backgroundEventManager.needDisabled.find(function (e) {
	    return e === ev;
	  })) {
	    return;
	  }

	  // NOTE 这里修改了原有的实现，加了一层 JSON 转码
	  if (typeof data === 'string') {
	    data = JSON.parse(data);
	  }
	  data = NativeBuffer.unpack(data);
	  var _cb = ev.indexOf('custom_event_') > -1 ? customEventMap[ev] : eventMap[ev];
	  typeof _cb == 'function' && _cb(data, webviewId, r);
	}

	var ttJSBridge = {
	  on: _on,
	  publish: _beforePublish,
	  invoke: _beforeInvoke,
	  subscribe: _subscribe
	};

	// 暴露给端上的
	_global$2.ttJSBridge = {
	  get invokeHandler() {
	    return _invokeHandler;
	  },
	  get subscribeHandler() {
	    return _subscribeHandler;
	  }
	};

	function ext(obj, key, val) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: val,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = val;
	  }

	  return obj;
	}

	var RunType = {
	  APP: 'micro_app',
	  GAME: 'micro_game',
	  DEVTOOLS: 'ide'
	};

	var ThirdScriptErrorKey = {};
	ext(ThirdScriptErrorKey, RunType.APP, 'thirdScriptError');
	ext(ThirdScriptErrorKey, RunType.GAME, 'gameThirdScriptError');

	var APIKeyId = {
	  createRequestTask: 1,
	  operateRequestTask: 2,
	  createUploadTask: 3,
	  operateUploadTask: 4,
	  createDownloadTask: 5,
	  operateDownloadTask: 6,
	  setAudioState: 7,
	  getAudioState: 8,
	  operateAudio: 9,
	  createAudioInstance: 10,
	  destroyAudioInstance: 11,
	  operateRecorder: 12,
	  chooseVideo: 13,
	  saveVideoToPhotosAlbum: 14,
	  saveFile: 15,
	  getStorage: 16,
	  setStorage: 17,
	  removeStorage: 18,
	  removeStorageSync: 19,
	  clearStorage: 20,
	  getStorageInfo: 21,
	  getStorageInfoSync: 22,
	  openLocation: 23,
	  getSystemInfo: 24,
	  getSystemInfoSync: 25,
	  getNetworkType: 26,
	  getConnectedWifi: 27,
	  getClipboardData: 28,
	  setClipboardData: 29,
	  setKeepScreenOn: 30,
	  enableAccelerometer: 31,
	  vibrateShort: 32,
	  vibrateLong: 33,
	  showModal: 34,
	  showToast: 35,
	  hideToast: 36,
	  showActionSheet: 37,
	  redirectTo: 38,
	  reLaunch: 39,
	  navigateTo: 40,
	  switchTab: 41,
	  navigateBack: 42,
	  protocolPathToAbsPath: 43,
	  base64ToTempFilePath: 44,
	  makePhoneCall: 45,
	  login: 46,
	  checkSession: 47,
	  getUserInfo: 48,
	  getUseDuration: 49,
	  dealUserRelation: 50,
	  requestPayment: 51,
	  chooseAddress: 52,
	  setKeyboardValue: 53,
	  hideKeyboard: 54,
	  getCurrentRoute: 55,
	  getPhoneNumber: 56,
	  initReady: 57,
	  showKeyboard: 58,
	  showDatePickerView: 59,
	  insertVideoPlayer: 60,
	  removeVideoPlayer: 61,
	  webViewReadyToTerminate: 62,
	  getFileInfo: 63,
	  getSavedFileList: 64,
	  removeSavedFile: 65,
	  saveFileSync: 66,
	  readFile: 67,
	  readFileSync: 68,
	  writeFileSync: 69,
	  mkdirSync: 70,
	  readdirSync: 71,
	  rmdirSync: 72,
	  accessSync: 73,
	  unlinkSync: 74,
	  statSync: 75,
	  renameSync: 76,
	  copyFile: 77,
	  copyFileSync: 78,
	  unzip: 79,
	  getMenuButtonBoundingClientRect: 80,
	  updateKeyboard: 81,
	  exitMiniProgram: 82,
	  getLaunchOptionsSync: 83,
	  showShareMenu: 84,
	  hideShareMenu: 85,
	  getShareInfo: 86,
	  shareAppMessageDirectly: 87,
	  updateShareMenu: 88,
	  shareVideo: 89,
	  startCompass: 90,
	  stopCompass: 91,
	  startGameRecord: 92,
	  stopGameRecord: 93,
	  chooseImage: 94,
	  previewImage: 95,
	  getImageInfo: 96,
	  saveImageToPhotosAlbum: 97,
	  authorize: 98,
	  insertContainer: 99,
	  updateContainer: 100,
	  removeContainer: 101,
	  updateInput: 102,
	  showPickerView: 104,
	  showMultiPickerView: 105,
	  updateMultiPickerView: 106,
	  disableScrollBounce: 107,
	  removeTextArea: 108,
	  insertTextArea: 109,
	  updateTextArea: 110,
	  insertHTMLWebView: 111,
	  removeHTMLWebView: 112,
	  updateHTMLWebView: 113,
	  createSocketTask: 114,
	  operateSocketTask: 115,
	  getLocation: 116,
	  scanCode: 117,
	  startPullDownRefresh: 118,
	  stopPullDownRefresh: 119,
	  getSetting: 120,
	  openSetting: 121,
	  resumeGameRecord: 122,
	  getCloudStorageByRelation: 123,
	  getUserCloudStorage: 124,
	  removeUserCloudStorage: 125,
	  setUserCloudStorage: 126,
	  openUserProfile: 127,
	  pauseGameRecord: 128,
	  operateVideoAd: 129,
	  createVideoAd: 130,
	  getGeneralInfo: 131,
	  tma_login: 132,
	  openSchema: 133,
	  getVideoManager: 134,
	  createFaceDetector: 135,
	  requestCamera: 136,
	  createOffscreenVideo: 137,
	  reportAnalytics: 138,
	  requestGamePayment: 139,
	  operateScreenRecorder: 140
	};

	// 宿主实现的私有方法
	var HostMethodId = {
	  // 头条
	  tt_checkIsFollowUser: 5000,
	  tt_requestFollowUser: 5001,
	  // 抖音
	  aweme_addFriend: 6000
	};

	var SpeedValueType = {
	  webview2AppService: 1,
	  appService2Webview: 2,
	  funcReady: 3,
	  firstGetData: 4,
	  firstRenderTime: 5,
	  reRenderTime: 6,
	  forceUpdateRenderTime: 7,
	  appRoute2newPage: 8,
	  newPage2pageReady: 9,
	  thirdScriptRunTime: 10,
	  pageframe: 11,
	  WAWebview: 12,
	  WAWidget: 13,
	  widgetCanvasReady: 14,
	  widgetFirstDataPush: 15
	};

	var ErrorType = {
	  appServiceSDKScriptError: 1,
	  webviewSDKScriptError: 2,
	  jsEngineScriptError: 3,
	  thirdScriptError: 4,
	  webviewScriptError: 5,
	  parserScriptError: 6
	};

	// 什么类型的错误需要交给 sentry 处理
	var SENTRY_ERROR = [1, 2, 3, 5, 6];

	function safeBridgeInvoke(callback) {
	  ttJSBridge !== undefined ? callback() : document.addEventListener('ttJSBridgeReady', callback, false);
	}

	function _invoke$3() {
	  var args = arguments;
	  safeBridgeInvoke(function () {
	    ttJSBridge.invoke.apply(ttJSBridge, args);
	  });
	}

	var systemInfo = {};

	function _checkObjectKeys(obj) {
	  var keysArr = [];
	  for (var key in obj) {
	    keysArr.push(key);
	  }
	  return keysArr.length;
	}

	function getSystemInfoSync() {
	  if (!_checkObjectKeys(systemInfo)) {
	    _invoke$3('getSystemInfoSync', {}, function (res) {
	      var isOk = res.errMsg.indexOf('getSystemInfoSync:ok') === 0;
	      if (isOk) {
	        systemInfo = res;
	      }
	    });
	  }

	  return systemInfo;
	}

	function safeBridgeInvoke$1(callback) {
	  ttJSBridge !== undefined ? callback() : document.addEventListener('ttJSBridgeReady', callback, false);
	}

	function _invoke$4() {
	  var args = arguments;
	  safeBridgeInvoke$1(function () {
	    ttJSBridge.invoke.apply(ttJSBridge, args);
	  });
	}

	function _publish$1() {
	  var args = arguments;
	  safeBridgeInvoke$1(function () {
	    ttJSBridge.publish.apply(ttJSBridge, args);
	  });
	}

	// 上报错误信息至 sentry
	// 错误信息指除第三方开发者的错误信息
	function invokeSentryReport(_ref) {
	  var url = _ref.url,
	      method = _ref.method,
	      header = _ref.header,
	      data = _ref.data;

	  _invoke$4('sentryReport', {
	    url: url,
	    method: method,
	    header: header,
	    data: data
	  });
	}

	// 将数据发给客户端，然后使用 APP Log3.0 发送至数据平台
	// 数据上报均基于此接口
	function invokeReportCustom(data) {
	  var _systemInfo = getSystemInfoSync();
	  var logData = {
	    tag: data.tag || '',
	    data: {
	      mp_id: (typeof TMAConfig === 'undefined' ? 'undefined' : _typeof(TMAConfig)) === 'object' && TMAConfig !== null && TMAConfig.appId || '',
	      lib_version: _systemInfo.SDKUpdateVersion || '1.0.0.0',
	      _param_for_special: Reporter.getRunType()
	    }
	  };
	  Object.assign(logData.data, data.data);
	  _invoke$4('systemLog', logData, function () {
	    typeof data.cb === 'function' && data.cb();
	  });
	}

	function surroundTryCatch(func) {
	  return function () {
	    try {
	      return func.apply(func, arguments);
	    } catch (err) {
	      logger.error('reporter error: ' + (err && err.message));
	    }
	  };
	}

	var lastSpeedReportTime = 0;
	var lastWebviewErrorMsg = '';
	var globalRoute = '';
	var globalMethod = '';
	var sentry = null;
	var exeWebviewErrorMsg = function exeWebviewErrorMsg() {};
	var RunType$1 = RunType.APP;

	var Constructor = {
	  // 包装第三方回调
	  surroundThirdByTryCatch: function surroundThirdByTryCatch(func, errTip) {
	    var msg = '';
	    if (globalRoute) {
	      msg = 'at ' + globalRoute + ' ' + globalMethod + ' function;';
	    }

	    return function () {
	      var res;
	      try {
	        var startTime = Date.now();
	        res = func.apply(func, arguments);
	        var cost = Date.now() - startTime;
	        if (cost > 1e3) {
	          // 执行过慢
	          Constructor.slowReport({
	            key: 'apiCallBack',
	            cost: cost,
	            extend: msg + errTip
	          });
	        }
	      } catch (err) {
	        // 第三方错误
	        Constructor.thirdErrorReport({
	          error: err,
	          extend: msg + errTip
	        });
	      }
	      return res;
	    };
	  },
	  // 运行过慢统计上报
	  slowReport: function slowReport(param) {
	    // 第三方执行过慢，缺少可视化工具，暂时不作处理
	    return;
	  },
	  // 速度、性能统计上报
	  speedReport: function speedReport(param) {
	    var key = param.key,
	        data = param.data,
	        timeMark = param.timeMark,
	        force = param.force,
	        eventName = param.eventName;
	    var startTime = timeMark.startTime,
	        endTime = timeMark.endTime;

	    var speedValueType = SpeedValueType && SpeedValueType[key];
	    var now = Date.now();
	    var strLength = 0;

	    if (speedValueType && startTime && endTime && (force || now - lastSpeedReportTime >= 500)) {
	      data && (strLength = JSON.stringify(data).length);
	      lastSpeedReportTime = now;
	      var tag = 'mp_speed_analysis';
	      // 上传至数据平台
	      // 如果是 subscribe/publish, 会有 event_name(绑定的消息)/total_duration(publish => native => subscribe)
	      invokeReportCustom({
	        tag: tag,
	        data: {
	          speed_value_type: key,
	          total_duration: endTime - startTime,
	          param_length: strLength || 0,
	          event_name: eventName || ''
	        }
	      });
	    }
	  },
	  // 第三方错误上报
	  thirdErrorReport: function thirdErrorReport(param) {
	    var error = param.error,
	        extend = param.extend;

	    Constructor.errorReport({
	      key: 'thirdScriptError',
	      error: error,
	      extend: extend
	    });
	  },
	  // 通用上报错误接口
	  errorReport: function errorReport(param) {
	    var key = param.key,
	        error = param.error,
	        extend = param.extend;

	    var errorType = ErrorType && ErrorType[key];
	    if (errorType) {
	      var errorString = extend ? error.message + ';' + extend : error.message;
	      var msg = key + '\n' + errorString + '\n' + error.stack;
	      logger.error(msg);
	      if (typeof window != 'undefined' && window.__webviewId__) {
	        // webview 的 error 发送至 jsCore
	        _publish$1('WEBVIEW_ERROR_MSG', {
	          data: {
	            msg: msg
	          },
	          options: {
	            timestamp: Date.now()
	          }
	        });
	      } else {
	        Constructor.triggerErrorMessage(msg);
	      }

	      if (SENTRY_ERROR.indexOf(errorType) > -1) {
	        if (_global$2.Sentry) {
	          if (!sentry) {
	            sentry = new Sentry({
	              key: 'ed6716196f0742d2bdee626bc665a2fe',
	              project: '325',
	              transportCallback: invokeSentryReport
	            });
	          }
	          var _systemInfo = getSystemInfoSync();
	          sentry.report(error, {
	            error_type: key,
	            mp_id: (typeof TMAConfig === 'undefined' ? 'undefined' : _typeof(TMAConfig)) === 'object' && TMAConfig !== null && TMAConfig.appId || '',
	            lib_version: _systemInfo.SDKUpdateVersion || '1.0.0.0',
	            version_code: _systemInfo.version,
	            run_type: Constructor.getRunType()
	          });
	        } else {
	          logger.error(msg);
	        }
	      } else {
	        return;
	        // 第三方错误暂时不处理
	        // var __id = `${errorType},${error.name},${encodeURIComponent(errorString)},${encodeURIComponent(error.stack)}`;

	        // // TODO 增加反馈错误的条件
	        // Constructor.reportKeyValue({
	        //     key: 'Error',
	        //     value: __id,
	        //     force: true
	        // });
	      }
	    }
	  },
	  registerErrorListener: function registerErrorListener(cb) {
	    if (typeof cb === 'function') {
	      exeWebviewErrorMsg = cb;
	    }
	  },
	  triggerErrorMessage: function triggerErrorMessage(msg) {
	    if (lastWebviewErrorMsg != msg) {
	      lastWebviewErrorMsg = msg;
	      setTimeout(function () {
	        try {
	          exeWebviewErrorMsg(msg);
	        } catch (e) {
	          logger.error(e.message + ' at onError callback function');
	        }
	      }, 0);
	    }
	  },

	  unRegisterErrorListener: function unRegisterErrorListener() {
	    exeWebviewErrorMsg = function exeWebviewErrorMsg() {};
	  },
	  // 个性化上传数据
	  customReport: function customReport() {
	    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref2$tag = _ref2.tag,
	        tag = _ref2$tag === undefined ? '' : _ref2$tag,
	        _ref2$data = _ref2.data,
	        data = _ref2$data === undefined ? {} : _ref2$data,
	        cb = _ref2.cb;

	    invokeReportCustom({ tag: tag, data: data, cb: cb });
	  },
	  setAsGame: function setAsGame() {
	    RunType$1 = RunType.GAME;
	  },
	  saveAsDevtools: function saveAsDevtools() {
	    RunType$1 = RunType.DEVTOOLS;
	  },
	  getRunType: function getRunType() {
	    return RunType$1;
	  }
	};

	var Reporter = {};

	for (var funcName in Constructor) {
	  !function (fn) {
	    Reporter.__defineGetter__(fn, function () {
	      return surroundTryCatch(Constructor[fn]);
	    });
	  }(funcName);
	}

	Reporter.__defineSetter__('__route__', function (val) {
	  globalRoute = val;
	});

	Reporter.__defineSetter__('__method__', function (val) {
	  globalMethod = val;
	});

	typeof window != 'undefined' && (window.Reporter = Reporter);

	typeof window != 'undefined' && (window.onbeforeunload = function () {
	  //    Constructor.submit();
	});

	/**
	 * 主要统计各个 API 的调用成功/失败情况，根据 API、错误信息和调用情况分别进行统计
	 */

	// 上报队列
	var okMap = {};
	var failMap = {};
	var cancelMap = {};
	var lastReportTimestamp = 0;

	function _trans(result, maps) {
	  var res = Object.keys(maps).filter(function (func) {
	    return APIKeyId[func] || HostMethodId[func];
	  }).map(function (func) {
	    return Object.keys(maps[func]).map(function (errMsg) {
	      // 压缩一下
	      var duration = maps[func][errMsg];
	      var count = duration.length;
	      var durationAmount = duration.reduce(function (total, current) {
	        return total + current;
	      }, 0);
	      var averageDuration = durationAmount / count;
	      return (APIKeyId[func] || HostMethodId[func]) + '|' + result + '|' + count + '|' + averageDuration + '|' + errMsg.replace(func, '');
	    });
	  });

	  return [].concat.apply([], res);
	}

	function clear() {
	  okMap = {};
	  failMap = {};
	  cancelMap = {};
	}

	function reportRealtimeAction() {
	  var okarray = _trans(1, okMap);
	  var failarray = _trans(2, failMap);
	  var cancelarray = _trans(3, cancelMap);
	  var dataArray = [].concat(okarray, failarray, cancelarray);

	  if (dataArray.length > 0) {
	    Reporter.customReport({
	      tag: 'mp_api_analysis',
	      data: {
	        api_data_array: dataArray
	      },
	      cb: clear
	    });
	  }
	}

	function reportJSAPI(func, isOk, isFail, isCancel, errMsg, duration) {
	  var evMap = isOk ? okMap : isFail ? failMap : cancelMap;

	  evMap[func] = evMap[func] || {};
	  evMap[func][errMsg] = (evMap[func][errMsg] || []).concat(duration);

	  if (Date.now() - lastReportTimestamp >= 3e4) {
	    lastReportTimestamp = Date.now();
	    setTimeout(reportRealtimeAction, 3e4);
	  }
	}

	function getDataType(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}

	function isObject$1(val) {
	  return getDataType(val) === 'Object';
	}

	function isFn(fn) {
	  return getDataType(fn) === 'Function';
	}

	function paramCheck(input, shouldbe) {
	  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'param';

	  var inputType = getDataType(input);
	  var shouldbeType = getDataType(shouldbe);

	  if (inputType !== shouldbeType) {
	    return name + ' should pass ' + shouldbeType + ', not ' + inputType;
	  }

	  var message = '';
	  switch (shouldbeType) {
	    case 'Object':
	      for (var key in shouldbe) {
	        message += paramCheck(input[key], shouldbe[key], name + '.' + key);
	      }
	      break;
	    case 'Array':
	      if (input.length < shouldbe.length) {
	        return name + ' should have more than ' + shouldbe.length + ' items, not ' + input.length + ' items';
	      }
	      for (var i = 0; i < shouldbe.length; ++i) {
	        message += paramCheck(input[i], shouldbe[i], name + '[' + i + ']');
	      }
	      break;
	    default:
	      break;
	  }

	  return message;
	}
	// equals to path.join()
	function getRealRoute(root, url) {
	  if (url.indexOf('/') === 0) {
	    return url.substr(1);
	  }

	  if (url.indexOf('./') === 0) {
	    return getRealRoute(root, url.substr(2), false);
	  }

	  // 先从 url 里找到 ../ 的个数，将 url 里的 ../ 删掉，同时从 root 的尾部减去相同数量的层级
	  // 问题是，url 中间的 ../ 是无法处理的
	  var urlPathArr = url.split('/'),
	      rootPathArr = root.length > 0 ? root.split('/') : [],
	      twodotCount = 0,
	      len = urlPathArr.length;
	  for (; twodotCount < len && urlPathArr[twodotCount] === '..'; twodotCount++) {}
	  urlPathArr.splice(0, twodotCount);
	  rootPathArr.splice(rootPathArr.length - twodotCount - 1, twodotCount + 1);
	  return rootPathArr.concat(urlPathArr).join('/');
	}

	function getPlatform() {
	  if (isObject$1(TMAConfig)) {
	    return TMAConfig.platform;
	  } else {
	    return '';
	  }
	}

	function urlEncodeFormData(data) {
	  var needEncode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (data === undefined || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
	    return data;
	  }

	  var res = [];
	  for (var key in data) {
	    if (data.hasOwnProperty(key)) {
	      if (needEncode) {
	        try {
	          res.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));
	        } catch (err) {
	          res.push(key + '=' + data[key]);
	        }
	      } else {
	        res.push(key + '=' + data[key]);
	      }
	    }
	  }
	  return res.join('&');
	}

	function addQueryStringToUrl(url, data) {
	  if (typeof url === 'string' && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && Object.keys(data).length > 0) {
	    var ab = url.split('?');
	    var search = ab[1] || '';

	    var urlQueryObj = search.split('&').reduce(function (searchobj, pair) {
	      if (typeof pair === 'string' && pair.length > 0) {
	        var ps = pair.split('=');
	        searchobj[ps[0]] = ps[1];
	      }
	      return searchobj;
	    }, {});

	    var dataObj = Object.keys(data).reduce(function (dataobj, key) {
	      if (_typeof(data[key]) === 'object') {
	        dataobj[encodeURIComponent(key)] = encodeURIComponent(JSON.stringify(data[key]));
	      } else {
	        dataobj[encodeURIComponent(key)] = encodeURIComponent(data[key]);
	      }
	      return dataobj;
	    }, {});

	    return ab[0] + '?' + urlEncodeFormData(assign$1(urlQueryObj, dataObj));
	  }
	  return url;
	}

	function validateUrl(url) {
	  var protocol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http';

	  if (protocol === 'http') {
	    return (/^(http|https):\/\/.*/i.test(url)
	    );
	  } else if (protocol === 'websocket') {
	    return (/^(ws|wss):\/\/.*/i.test(url)
	    );
	  }
	}

	function assign$1() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return args.reduce(function (obj, cur) {
	    for (var key in cur) {
	      obj[key] = cur[key];
	    }
	    return obj;
	  }, {});
	}

	function encodeUrlQuery(url) {
	  if (typeof url === 'string') {
	    var qs = url.split('?'),
	        path = qs[0],
	        search = qs[1] || '';
	    var searchObj = search.split('&').reduce(function (res, pair) {
	      if (typeof pair === 'string' && pair.length > 0) {
	        var ps = pair.split('=');
	        res[ps[0]] = ps[1];
	      }
	      return res;
	    }, {});

	    var searchArr = [];
	    for (var k in searchObj) {
	      searchObj.hasOwnProperty(k) && searchArr.push(k + '=' + encodeURIComponent(searchObj[k]));
	    }
	    return searchArr.length > 0 ? path + '?' + searchArr.join('&') : url;
	  }
	  return url;
	}

	function removeHtmlSuffixFromUrl(url) {
	  if (typeof url === 'string') {
	    if (url.indexOf('?') > -1) {
	      return url.replace(/\.html\?/, '?');
	    } else {
	      return url.replace(/\.html$/, '');
	    }
	  } else {
	    return url;
	  }
	}
	function guid() {
	  return 'xxxxxxxx'.replace(/x/g, function () {
	    return (16 * Math.random() | 0).toString(16);
	  });
	}

	var alphabet$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	var btoa$1 = btoa$1 || function (e) {
	  for (var t, n, r = String(e), o = '', i = 0, a = alphabet$1; r.charAt(0 | i) || (a = '=', i % 1); o += a.charAt(63 & t >> 8 - i % 1 * 8)) {
	    if ((n = r.charCodeAt(i += 0.75)) > 255) {
	      throw new Error('"btoa" failed');
	    }
	    t = t << 8 | n;
	  }
	  return o;
	};
	var atob$1 = atob$1 || function (e) {
	  var t = String(e).replace(/=+$/, ''),
	      n = '';
	  if (t.length % 4 == 1) {
	    throw new Error('"atob" failed');
	  }
	  /* eslint-disable no-cond-assign */
	  for (var r, o, i = 0, a = 0; o = t.charAt(a++); ~o && (r = i % 4 ? 64 * r + o : o, i++ % 4) ? n += String.fromCharCode(255 & r >> (-2 * i & 6)) : 0) {
	    o = alphabet$1.indexOf(o);
	  }
	  return n;
	};

	function arrayBufferToBase64(ab) {
	  var str = '',
	      reader = new Uint8Array(ab),
	      len = reader.byteLength;
	  for (var i = 0; i < len; i++) {
	    str += String.fromCharCode(reader[i]);
	  }
	  return btoa$1(str);
	}

	function base64ToArrayBuffer(base64) {
	  var str = atob$1(base64),
	      len = str.length,
	      reader = new Uint8Array(len);
	  for (var i = 0; i < len; i++) {
	    reader[i] = str.charCodeAt(i);
	  }
	  return reader.buffer;
	}

	function convertObjectValueToString(obj) {
	  return Object.keys(obj).reduce(function (ret, key) {
	    if (typeof obj[key] == 'string') {
	      ret[key] = obj[key];
	    } else if (typeof obj[key] == 'number') {
	      ret[key] = obj[key] + '';
	    } else {
	      ret[key] = Object.prototype.toString.apply(obj[key]);
	    }
	    return ret;
	  }, {});
	}

	function surroundByTryCatch(func, msg) {
	  return function () {
	    try {
	      return func.apply(func, arguments);
	    } catch (err) {
	      if (Object.prototype.toString.apply(err) === '[object Error]') {
	        if ('AppServiceSdkKnownError' == err.type) {
	          throw err;
	        }
	        'ThirdScriptError' === err.type ? Reporter.thirdErrorReport({
	          error: err,
	          extend: msg
	        }) : Reporter.errorReport({
	          key: 'appServiceSDKScriptError',
	          error: err,
	          extend: msg
	        });
	      }
	    }
	  };
	}

	// 包装第三方 callback
	function surroundByTryCatchFactory(func, msg) {
	  return Reporter.surroundThirdByTryCatch(func, msg);
	}

	function _anyTypeToString(any) {
	  var protoType = Object.prototype.toString.call(any).split(' ')[1].split(']')[0];

	  if (protoType == 'Array' || protoType == 'Object') {
	    try {
	      any = JSON.stringify(any);
	    } catch (err) {
	      throw err;
	    }
	  } else if (protoType == 'String' || protoType == 'Number' || protoType == 'Boolean') {
	    any = any.toString();
	  } else if (protoType == 'Date') {
	    any = any.getTime().toString();
	  } else if (protoType == 'Undefined') {
	    any = 'undefined';
	  } else if (protoType == 'Null') {
	    any = 'null';
	  } else {
	    any = '';
	  }

	  return {
	    data: any,
	    dataType: protoType
	  };
	}
	var anyTypeToString = surroundByTryCatch(_anyTypeToString, 'anyTypeToString');

	function _stringToAnyType(str, protoType) {
	  switch (protoType) {
	    case 'String':
	      return str;
	    case 'Array':
	    case 'Object':
	      return JSON.parse(str);
	    case 'Number':
	      return parseFloat(str);
	    case 'Boolean':
	      return str == 'true';
	    case 'Date':
	      return new Date(parseInt(str));
	    case 'Undefined':
	      return undefined;
	    case 'Null':
	      return null;
	    default:
	      return '';
	  }
	}
	var stringToAnyType = surroundByTryCatch(_stringToAnyType, 'stringToAnyType');

	// 自定义错误类型
	// 简单分就是两种，需要上报和不需要上报
	// 或者是，sdk的错误 和 开发者的错误

	// sdk 错误, 如调用客户端端失败，手动抛出
	var AppServiceSdkKnownError = function (_Error) {
	  inherits(AppServiceSdkKnownError, _Error);

	  function AppServiceSdkKnownError(msg) {
	    classCallCheck(this, AppServiceSdkKnownError);

	    var _this = possibleConstructorReturn(this, _Error.call(this, 'APP-SERVICE-SDK:' + msg));

	    _this.type = 'AppServiceSdkKnownError';
	    return _this;
	  }

	  return AppServiceSdkKnownError;
	}(Error);

	// 开发者使用中的错误，如使用同步接口时发生的错误
	var ThirdScriptError = function (_Error2) {
	  inherits(ThirdScriptError, _Error2);

	  function ThirdScriptError(msg) {
	    classCallCheck(this, ThirdScriptError);

	    var _this2 = possibleConstructorReturn(this, _Error2.call(this, '' + msg));

	    _this2.type = 'ThirdScriptError';
	    return _this2;
	  }

	  return ThirdScriptError;
	}(Error);

	// 开发者使用中的类型错误，如参数不符合预期，手动抛出
	var ThirdScriptTypeError = function (_TypeError) {
	  inherits(ThirdScriptTypeError, _TypeError);

	  function ThirdScriptTypeError(msg) {
	    classCallCheck(this, ThirdScriptTypeError);

	    var _this3 = possibleConstructorReturn(this, _TypeError.call(this, '' + msg));

	    _this3.type = 'ThirdScriptError';
	    return _this3;
	  }

	  return ThirdScriptTypeError;
	}(TypeError);

	function isString(val) {
	  return getDataType(val) === 'String';
	}

	/**
	 * Function => "function"
	 * String => "string"
	 * @param {Function} originFunction
	 */
	function getTransFormType(originFunction) {
	  var abbreviationtype = [String, Number, Boolean, Object, Array];

	  var abbreviationtype2compiler = ['string', 'number', 'boolean', 'object', 'array', 'null'];

	  // 默认值为 null
	  var index = abbreviationtype.length;

	  try {
	    index = abbreviationtype.indexOf(originFunction);
	    if (index === -1) {
	      // 超出 abbreviationtype 下标，命中 abbreviationtype2compiler 最后一位
	      index = abbreviationtype.length;
	    }
	  } catch (err) {}

	  return abbreviationtype2compiler[index];
	}

	/* isEqual taken from underscore */
	function _isFunction(obj) {
	  return typeof obj == 'function' || false;
	}

	function has$1(obj, path) {
	  return obj != null && Object.prototype.hasOwnProperty.call(obj, path);
	}

	var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

	// Internal recursive comparison function for `isEqual`.
	var eq, deepEq;
	eq = function eq(a, b, aStack, bStack) {
	  // Identical objects are equal. `0 === -0`, but they aren't identical.
	  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	  if (a === b) {
	    return a !== 0 || 1 / a === 1 / b;
	  }
	  // `null` or `undefined` only equal to itself (strict comparison).
	  if (a == null || b == null) {
	    return false;
	  }
	  // `NaN`s are equivalent, but non-reflexive.
	  if (a !== a) {
	    return b !== b;
	  }
	  // Exhaust primitive checks
	  var type = typeof a === 'undefined' ? 'undefined' : _typeof(a);
	  if (type !== 'function' && type !== 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') {
	    return false;
	  }
	  return deepEq(a, b, aStack, bStack);
	};

	// Internal recursive comparison function for `isEqual`.
	deepEq = function deepEq(a, b, aStack, bStack) {
	  // Compare `[[Class]]` names.
	  var className = toString.call(a);
	  if (className !== toString.call(b)) {
	    return false;
	  }

	  /* eslint-disable no-fallthrough */
	  switch (className) {
	    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	    case '[object RegExp]':
	    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	    case '[object String]':
	      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	      // equivalent to `new String("5")`.
	      return '' + a === '' + b;
	    case '[object Number]':
	      // `NaN`s are equivalent, but non-reflexive.
	      // Object(NaN) is equivalent to NaN.
	      if (+a !== +a) {
	        return +b !== +b;
	      }
	      // An `egal` comparison is performed for other numeric values.
	      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	    case '[object Date]':
	    case '[object Boolean]':
	      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	      // millisecond representations. Note that invalid dates with millisecond representations
	      // of `NaN` are not equivalent.
	      return +a === +b;
	    case '[object Symbol]':
	      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
	  }

	  var areArrays = className === '[object Array]';
	  if (!areArrays) {
	    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) != 'object' || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') {
	      return false;
	    }

	    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	    // from different frames are.
	    var aCtor = a.constructor,
	        bCtor = b.constructor;
	    if (aCtor !== bCtor && !(_isFunction(aCtor) && aCtor instanceof aCtor && _isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
	      return false;
	    }
	  }
	  // Assume equality for cyclic structures. The algorithm for detecting cyclic
	  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	  // Initializing stack of traversed objects.
	  // It's done here since we only need them for objects and arrays comparison.
	  aStack = aStack || [];
	  bStack = bStack || [];
	  var length = aStack.length;
	  while (length--) {
	    // Linear search. Performance is inversely proportional to the number of
	    // unique nested structures.
	    if (aStack[length] === a) {
	      return bStack[length] === b;
	    }
	  }

	  // Add the first object to the stack of traversed objects.
	  aStack.push(a);
	  bStack.push(b);

	  // Recursively compare objects and arrays.
	  if (areArrays) {
	    // Compare array lengths to determine if a deep comparison is necessary.
	    length = a.length;
	    if (length !== b.length) {
	      return false;
	    }
	    // Deep compare the contents, ignoring non-numeric properties.
	    while (length--) {
	      if (!eq(a[length], b[length], aStack, bStack)) {
	        return false;
	      }
	    }
	  } else {
	    // Deep compare objects.
	    var keys = Object.keys(a),
	        key;
	    length = keys.length;
	    // Ensure that both objects contain the same number of properties before comparing deep equality.
	    if (Object.keys(b).length !== length) {
	      return false;
	    }
	    while (length--) {
	      // Deep compare each member
	      key = keys[length];
	      if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) {
	        return false;
	      }
	    }
	  }
	  // Remove the first object from the stack of traversed objects.
	  aStack.pop();
	  bStack.pop();
	  return true;
	};

	// Perform a deep comparison to check if two objects are equal.
	function isEqual(a, b) {
	  return eq(a, b);
	}

	// import Reporter from '../lib/reporter';

	function invoke$1(api, params, callback) {
	  ttJSBridge.invoke.apply(ttJSBridge, arguments);
	}

	function on() {
	  ttJSBridge.on.apply(ttJSBridge, arguments);
	}

	function publish() {
	  var args = Array.prototype.slice.call(arguments);
	  args[1] = {
	    data: args[1],
	    options: {
	      timestamp: Date.now()
	    }
	  };
	  ttJSBridge.publish.apply(ttJSBridge, args);
	}

	function subscribe() /* event, cb */{
	  var args = Array.prototype.slice.call(arguments),
	      originCallback = args[1];
	  args[1] = function (res, wvid) {
	    var data = res.data,
	        options = res.options;
	    // var startTime = options && options.timestamp || 0;
	    // var endTime = Date.now();
	    // var option = arguments[2] || {};

	    if (typeof originCallback == 'function') {
	      originCallback(data, wvid);
	      // webview2AppService time
	      // Reporter.speedReport({
	      //   key: 'webview2AppService',
	      //   data: data || {},
	      //   timeMark: {
	      //     startTime,
	      //     endTime,
	      //     nativeTime: option.nativeTime || 0,
	      //   },
	      //   eventName: args[0],
	      // });
	    }
	  };
	  ttJSBridge.subscribe.apply(ttJSBridge, args);
	}

	function invokeMethod(api) {
	  var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  var invokeStartTime = Date.now();
	  param = assign$1({}, param);

	  var userUsed = {};
	  for (var i in param) {
	    if ('function' == typeof param[i]) {
	      userUsed[i] = surroundByTryCatchFactory(param[i], 'at api ' + api + ' ' + i + ' callback function');
	      delete param[i];
	    }
	  }

	  var libHooks = {};
	  for (var c in option) {
	    'function' == typeof option[c] && (libHooks[c] = surroundByTryCatchFactory(option[c], 'at api ' + api + ' ' + c + ' callback function'), libHooks[c]._argumentsLength = option[c].length);
	  }

	  // beforeAll
	  // ok:      beforeSuccess - <success> - afterSuccess
	  // cancel:  <fail> - beforeCancel - <!cancel> - afterCancel
	  // fail:    beforeFail - <fail> - afterFail
	  // <complete>
	  // afterAll
	  invoke$1(api, param, function (res) {
	    var invokeEndTime = Date.now();
	    res.errMsg = res.errMsg || api + ':ok';

	    var isOk = res.errMsg.indexOf(api + ':ok') === 0;
	    var isFail = res.errMsg.indexOf(api + ':fail') === 0;
	    var isCancel = res.errMsg.indexOf(api + ':cancel') === 0;

	    typeof libHooks.beforeAll == 'function' && libHooks.beforeAll(res);
	    if (isOk) {
	      var c = function c() {
	        typeof userUsed.success === 'function' && userUsed.success(res);
	        typeof libHooks.afterSuccess === 'function' && libHooks.afterSuccess(res);
	      };

	      if (typeof libHooks.beforeSuccess === 'function') {
	        if (libHooks.beforeSuccess._argumentsLength === 2) {
	          libHooks.beforeSuccess(res, c);
	        } else {
	          libHooks.beforeSuccess(res);
	          c();
	        }
	      } else {
	        c();
	      }
	    } else if (isCancel) {
	      res.errMsg = res.errMsg.replace(api + ':cancel', api + ':fail cancel');
	      typeof userUsed.fail == 'function' && userUsed.fail(res);
	      typeof libHooks.beforeCancel == 'function' && libHooks.beforeCancel(res);
	      typeof userUsed.cancel == 'function' && userUsed.cancel(res);
	      typeof libHooks.afterCancel == 'function' && libHooks.afterCancel(res);
	    } else if (isFail) {
	      typeof libHooks.beforeFail == 'function' && libHooks.beforeFail(res);
	      typeof userUsed.fail == 'function' && userUsed.fail(res);
	      typeof libHooks.afterFail == 'function' && libHooks.afterFail(res);
	    }
	    typeof userUsed.complete == 'function' && userUsed.complete(res);
	    typeof libHooks.afterAll == 'function' && libHooks.afterAll(res);
	    // 统计使用情况
	    // 如果是宿主私有 API，获取真正的 method
	    if ((api === 'callHostMethod' || api === 'callHostMethodSync') && typeof param.method === 'string') {
	      api = param.method;
	    }
	    reportJSAPI(api, isOk, isFail, isCancel, res.errMsg, invokeEndTime - invokeStartTime);
	  });
	}

	function onMethod(event, callback) {
	  on(event, surroundByTryCatchFactory(callback, 'at api ' + event + ' callback function'));
	}

	function noop() {}

	function beforeInvoke(api, param, shouldbe) {
	  var failMessage = paramCheck(param, shouldbe);

	  if (failMessage) {
	    beforeInvokeFail(api, param, failMessage);
	    return false;
	  } else {
	    return true;
	  }
	}

	function beforeInvokeFail(api) {
	  var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var msg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

	  var res = {
	    errMsg: api + ':fail ' + msg
	  };

	  surroundByTryCatchFactory(param.fail || noop, res.errMsg)(res);
	  surroundByTryCatchFactory(param.complete || noop, res.errMsg)(res);
	}

	function checkUrlInConfig(api, url, param) {
	  var path = url.replace(/\.html\?.*|\.html$/, '');
	  path = path.replace(/\?.*$/, '');

	  return TMAConfig.pages.indexOf(path) > -1 || (beforeInvokeFail(api, param, 'url "' + removeHtmlSuffixFromUrl(url) + '" is not in app.json'), false);
	}

	function callbackAppServiceMethod(res, isSuccess, callbackId, wvid) {
	  publish('callbackAppServiceMethod', {
	    res: res,
	    isSuccess: isSuccess,
	    callbackId: callbackId
	  }, [wvid]);
	}

	subscribe('invokeAppServiceMethod', function (event, wvid) {
	  var name = event.name;
	  var type = event.type;
	  var args = event.args;
	  var cbid = event.callbackId;
	  try {
	    if (type === 'bridge') {
	      invoke$1(name, args, function (res) {
	        res.errMsg = res.errMsg || name + ':ok';
	        res.errMsg.indexOf(name + ':ok') > -1 ? callbackAppServiceMethod(res, true, cbid, wvid) : callbackAppServiceMethod(res, false, cbid, wvid);
	      });
	    } else {
	      args.success = function (e) {
	        callbackAppServiceMethod(e, true, cbid, wvid);
	      };
	      args.fail = function (e) {
	        callbackAppServiceMethod(e, false, cbid, wvid);
	      };
	      if (type === 'sdk') {
	        tt[name](args);
	      } else if (type === 'jssdk') {
	        var jssdkWhitelist = ['redirectTo', 'navigateTo', 'switchTab', 'reLaunch', 'navigateBack'];
	        if (jssdkWhitelist.indexOf(name) !== -1) {
	          tt[name](args);
	        }
	      }
	    }
	  } catch (err) {
	    var msg = {
	      errMsg: name + ': fail ' + err.message
	    };
	    callbackAppServiceMethod(msg, false, cbid, wvid);
	  }
	});

	subscribe('WEBVIEW_ERROR_MSG', function (res) {
	  var msg = res.data && res.data.msg || '';
	  Reporter.triggerErrorMessage(msg);
	});

	var cbid = 0;
	var customMethods = [];
	var privateMethods = [];
	var noop$1 = function noop$$1() {};

	function invokeWebviewMethod(e) {
	  var name = e.name;
	  var args = e.args === undefined ? {} : e.args;
	  var ext = e.ext === undefined ? {} : e.ext;
	  var wvids = e.webviewIds;
	  customMethods[cbid] = {
	    success: args.success || noop$1,
	    fail: args.fail || noop$1,
	    complete: args.complete || noop$1
	  };
	  privateMethods[cbid] = {
	    beforeAll: ext.beforeAll || noop$1,
	    beforeSuccess: ext.beforeSuccess || noop$1,
	    afterSuccess: ext.afterSuccess || noop$1,
	    beforeFail: ext.beforeFail || noop$1,
	    afterFail: ext.afterFail || noop$1,
	    afterAll: ext.afterAll || noop$1
	  };
	  publish('invokeWebviewMethod', {
	    name: name,
	    args: args,
	    callbackId: cbid
	  }, wvids);
	  cbid += 1;
	}

	subscribe('callbackWebviewMethod', function (e) {
	  var res = e.res,
	      isOk = e.isSuccess,
	      cbid = e.callbackId,
	      customs = customMethods[cbid],
	      privates = privateMethods[cbid];
	  privates.beforeAll(res);
	  isOk ? (privates.beforeSuccess(res), customs.success(res), privates.afterSuccess(res)) : (privates.beforeFail(res), customs.fail(res), privates.afterFail(res));
	  customs.complete(res);
	  privates.afterAll(res);
	});

	/* !
	* EventEmitter2
	* https://github.com/hij1nx/EventEmitter2
	*
	* Copyright (c) 2013 hij1nx
	* Licensed under the MIT license.
	*/
	var isArray$2 = Array.isArray ? Array.isArray : function _isArray(obj) {
	  return Object.prototype.toString.call(obj) === '[object Array]';
	};
	var defaultMaxListeners = 100;

	function init() {
	  this._events = {};
	  if (this._conf) {
	    configure.call(this, this._conf);
	  }
	}

	function configure(conf) {
	  if (conf) {
	    this._conf = conf;

	    conf.delimiter && (this.delimiter = conf.delimiter);
	    this._maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;

	    conf.wildcard && (this.wildcard = conf.wildcard);
	    conf.newListener && (this._newListener = conf.newListener);
	    conf.removeListener && (this._removeListener = conf.removeListener);
	    conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);

	    if (this.wildcard) {
	      this.listenerTree = {};
	    }
	  } else {
	    this._maxListeners = defaultMaxListeners;
	  }
	}

	function logPossibleMemoryLeak(count, eventName) {
	  var errorMsg = '(node) warning: possible EventEmitter memory ' + 'leak detected. ' + count + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.';

	  if (this.verboseMemoryLeak) {
	    errorMsg += ' Event name: ' + eventName + '.';
	  }

	  if (typeof process !== 'undefined' && process.emitWarning) {
	    var e = new Error(errorMsg);
	    e.name = 'MaxListenersExceededWarning';
	    e.emitter = this;
	    e.count = count;
	    process.emitWarning(e);
	  } else {
	    logger.error(errorMsg);

	    if (logger.trace) {
	      logger.trace();
	    }
	  }
	}

	function EventEmitter(conf) {
	  this._events = {};
	  this._newListener = false;
	  this._removeListener = false;
	  this.verboseMemoryLeak = false;
	  configure.call(this, conf);
	}
	EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

	//
	// Attention, function return type now is array, always !
	// It has zero elements if no any matches found and one or more
	// elements (leafs) if there are matches
	//
	function searchListenerTree(handlers, type, tree, i) {
	  if (!tree) {
	    return [];
	  }
	  var listeners = [],
	      leaf,
	      len,
	      branch,
	      xTree,
	      xxTree,
	      isolatedBranch,
	      endReached,
	      typeLength = type.length,
	      currentType = type[i],
	      nextType = type[i + 1];
	  if (i === typeLength && tree._listeners) {
	    //
	    // If at the end of the event(s) list and the tree has listeners
	    // invoke those listeners.
	    //
	    if (typeof tree._listeners === 'function') {
	      handlers && handlers.push(tree._listeners);
	      return [tree];
	    } else {
	      for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
	        handlers && handlers.push(tree._listeners[leaf]);
	      }
	      return [tree];
	    }
	  }

	  if (currentType === '*' || currentType === '**' || tree[currentType]) {
	    //
	    // If the event emitted is '*' at this part
	    // or there is a concrete match at this patch
	    //
	    if (currentType === '*') {
	      for (branch in tree) {
	        if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
	          listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 1));
	        }
	      }
	      return listeners;
	    } else if (currentType === '**') {
	      endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === '*';
	      if (endReached && tree._listeners) {
	        // The next element has a _listeners, add it to the handlers.
	        listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
	      }

	      for (branch in tree) {
	        if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
	          if (branch === '*' || branch === '**') {
	            if (tree[branch]._listeners && !endReached) {
	              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
	            }
	            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
	          } else if (branch === nextType) {
	            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 2));
	          } else {
	            // No match on this one, shift into the tree but not in the type array.
	            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
	          }
	        }
	      }
	      return listeners;
	    }

	    listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i + 1));
	  }

	  xTree = tree['*'];
	  if (xTree) {
	    //
	    // If the listener tree will allow any match for this part,
	    // then recursively explore all branches of the tree
	    //
	    searchListenerTree(handlers, type, xTree, i + 1);
	  }

	  xxTree = tree['**'];
	  if (xxTree) {
	    if (i < typeLength) {
	      if (xxTree._listeners) {
	        // If we have a listener on a '**', it will catch all, so add its handler.
	        searchListenerTree(handlers, type, xxTree, typeLength);
	      }

	      // Build arrays of matching next branches and others.
	      for (branch in xxTree) {
	        if (branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
	          if (branch === nextType) {
	            // We know the next element will match, so jump twice.
	            searchListenerTree(handlers, type, xxTree[branch], i + 2);
	          } else if (branch === currentType) {
	            // Current node matches, move into the tree.
	            searchListenerTree(handlers, type, xxTree[branch], i + 1);
	          } else {
	            isolatedBranch = {};
	            isolatedBranch[branch] = xxTree[branch];
	            searchListenerTree(handlers, type, { '**': isolatedBranch }, i + 1);
	          }
	        }
	      }
	    } else if (xxTree._listeners) {
	      // We have reached the end and still on a '**'
	      searchListenerTree(handlers, type, xxTree, typeLength);
	    } else if (xxTree['*'] && xxTree['*']._listeners) {
	      searchListenerTree(handlers, type, xxTree['*'], typeLength);
	    }
	  }

	  return listeners;
	}

	function growListenerTree(type, listener) {

	  type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

	  //
	  // Looks for two consecutive '**', if so, don't add the event at all.
	  //
	  for (var i = 0, len = type.length; i + 1 < len; i++) {
	    if (type[i] === '**' && type[i + 1] === '**') {
	      return;
	    }
	  }

	  var tree = this.listenerTree;
	  var name = type.shift();

	  while (name !== undefined) {

	    if (!tree[name]) {
	      tree[name] = {};
	    }

	    tree = tree[name];

	    if (type.length === 0) {

	      if (!tree._listeners) {
	        tree._listeners = listener;
	      } else {
	        if (typeof tree._listeners === 'function') {
	          tree._listeners = [tree._listeners];
	        }

	        tree._listeners.push(listener);

	        if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
	          tree._listeners.warned = true;
	          logPossibleMemoryLeak.call(this, tree._listeners.length, name);
	        }
	      }
	      return true;
	    }
	    name = type.shift();
	  }
	  return true;
	}

	// By default EventEmitters will print a warning if more than
	// 10 listeners are added to it. This is a useful default which
	// helps finding memory leaks.
	//
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.

	EventEmitter.prototype.delimiter = '.';

	EventEmitter.prototype.setMaxListeners = function (n) {
	  if (n !== undefined) {
	    this._maxListeners = n;
	    if (!this._conf) {
	      this._conf = {};
	    }
	    this._conf.maxListeners = n;
	  }
	};

	EventEmitter.prototype.event = '';

	EventEmitter.prototype.once = function (event, fn) {
	  return this._once(event, fn, false);
	};

	EventEmitter.prototype.prependOnceListener = function (event, fn) {
	  return this._once(event, fn, true);
	};

	EventEmitter.prototype._once = function (event, fn, prepend) {
	  this._many(event, 1, fn, prepend);
	  return this;
	};

	EventEmitter.prototype.many = function (event, ttl, fn) {
	  return this._many(event, ttl, fn, false);
	};

	EventEmitter.prototype.prependMany = function (event, ttl, fn) {
	  return this._many(event, ttl, fn, true);
	};

	EventEmitter.prototype._many = function (event, ttl, fn, prepend) {
	  var self = this;

	  if (typeof fn !== 'function') {
	    throw new Error('many only accepts instances of Function');
	  }

	  function listener() {
	    if (--ttl === 0) {
	      self.off(event, listener);
	    }
	    return fn.apply(this, arguments);
	  }

	  listener._origin = fn;

	  this._on(event, listener, prepend);

	  return self;
	};

	EventEmitter.prototype.emit = function () {

	  this._events || init.call(this);

	  var type = arguments[0];

	  if (type === 'newListener' && !this._newListener) {
	    if (!this._events.newListener) {
	      return false;
	    }
	  }

	  var al = arguments.length;
	  var args, l, i, j;
	  var handler;

	  if (this._all && this._all.length) {
	    handler = this._all.slice();
	    if (al > 3) {
	      args = new Array(al);
	      for (j = 0; j < al; j++) {
	        args[j] = arguments[j];
	      }
	    }

	    for (i = 0, l = handler.length; i < l; i++) {
	      this.event = type;
	      switch (al) {
	        case 1:
	          handler[i].call(this, type);
	          break;
	        case 2:
	          handler[i].call(this, type, arguments[1]);
	          break;
	        case 3:
	          handler[i].call(this, type, arguments[1], arguments[2]);
	          break;
	        default:
	          handler[i].apply(this, args);
	      }
	    }
	  }

	  if (this.wildcard) {
	    handler = [];
	    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	    searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
	  } else {
	    handler = this._events[type];
	    if (typeof handler === 'function') {
	      this.event = type;
	      switch (al) {
	        case 1:
	          handler.call(this);
	          break;
	        case 2:
	          handler.call(this, arguments[1]);
	          break;
	        case 3:
	          handler.call(this, arguments[1], arguments[2]);
	          break;
	        default:
	          args = new Array(al - 1);
	          for (j = 1; j < al; j++) {
	            args[j - 1] = arguments[j];
	          }
	          handler.apply(this, args);
	      }
	      return true;
	    } else if (handler) {
	      // need to make copy of handlers because list can change in the middle
	      // of emit call
	      handler = handler.slice();
	    }
	  }

	  if (handler && handler.length) {
	    if (al > 3) {
	      args = new Array(al - 1);
	      for (j = 1; j < al; j++) {
	        args[j - 1] = arguments[j];
	      }
	    }
	    for (i = 0, l = handler.length; i < l; i++) {
	      this.event = type;
	      switch (al) {
	        case 1:
	          handler[i].call(this);
	          break;
	        case 2:
	          handler[i].call(this, arguments[1]);
	          break;
	        case 3:
	          handler[i].call(this, arguments[1], arguments[2]);
	          break;
	        default:
	          handler[i].apply(this, args);
	      }
	    }
	    return true;
	  } else if (!this._all && type === 'error') {
	    if (arguments[1] instanceof Error) {
	      throw arguments[1]; // Unhandled 'error' event
	    } else {
	      throw new Error('Uncaught, unspecified \'error\' event.');
	    }
	  }

	  return !!this._all;
	};

	EventEmitter.prototype.emitAsync = function () {

	  this._events || init.call(this);

	  var type = arguments[0];

	  if (type === 'newListener' && !this._newListener) {
	    if (!this._events.newListener) {
	      return Promise.resolve([false]);
	    }
	  }

	  var promises = [];

	  var al = arguments.length;
	  var args, l, i, j;
	  var handler;

	  if (this._all) {
	    if (al > 3) {
	      args = new Array(al);
	      for (j = 1; j < al; j++) {
	        args[j] = arguments[j];
	      }
	    }
	    for (i = 0, l = this._all.length; i < l; i++) {
	      this.event = type;
	      switch (al) {
	        case 1:
	          promises.push(this._all[i].call(this, type));
	          break;
	        case 2:
	          promises.push(this._all[i].call(this, type, arguments[1]));
	          break;
	        case 3:
	          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
	          break;
	        default:
	          promises.push(this._all[i].apply(this, args));
	      }
	    }
	  }

	  if (this.wildcard) {
	    handler = [];
	    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	    searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
	  } else {
	    handler = this._events[type];
	  }

	  if (typeof handler === 'function') {
	    this.event = type;
	    switch (al) {
	      case 1:
	        promises.push(handler.call(this));
	        break;
	      case 2:
	        promises.push(handler.call(this, arguments[1]));
	        break;
	      case 3:
	        promises.push(handler.call(this, arguments[1], arguments[2]));
	        break;
	      default:
	        args = new Array(al - 1);
	        for (j = 1; j < al; j++) {
	          args[j - 1] = arguments[j];
	        }
	        promises.push(handler.apply(this, args));
	    }
	  } else if (handler && handler.length) {
	    handler = handler.slice();
	    if (al > 3) {
	      args = new Array(al - 1);
	      for (j = 1; j < al; j++) {
	        args[j - 1] = arguments[j];
	      }
	    }
	    for (i = 0, l = handler.length; i < l; i++) {
	      this.event = type;
	      switch (al) {
	        case 1:
	          promises.push(handler[i].call(this));
	          break;
	        case 2:
	          promises.push(handler[i].call(this, arguments[1]));
	          break;
	        case 3:
	          promises.push(handler[i].call(this, arguments[1], arguments[2]));
	          break;
	        default:
	          promises.push(handler[i].apply(this, args));
	      }
	    }
	  } else if (!this._all && type === 'error') {
	    if (arguments[1] instanceof Error) {
	      return Promise.reject(arguments[1]); // Unhandled 'error' event
	    } else {
	      return Promise.reject('Uncaught, unspecified \'error\' event.');
	    }
	  }

	  return Promise.all(promises);
	};

	EventEmitter.prototype.on = function (type, listener) {
	  return this._on(type, listener, false);
	};

	EventEmitter.prototype.prependListener = function (type, listener) {
	  return this._on(type, listener, true);
	};

	EventEmitter.prototype.onAny = function (fn) {
	  return this._onAny(fn, false);
	};

	EventEmitter.prototype.prependAny = function (fn) {
	  return this._onAny(fn, true);
	};

	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	EventEmitter.prototype._onAny = function (fn, prepend) {
	  if (typeof fn !== 'function') {
	    throw new Error('onAny only accepts instances of Function');
	  }

	  if (!this._all) {
	    this._all = [];
	  }

	  // Add the function to the event listener collection.
	  if (prepend) {
	    this._all.unshift(fn);
	  } else {
	    this._all.push(fn);
	  }

	  return this;
	};

	EventEmitter.prototype._on = function (type, listener, prepend) {
	  if (typeof type === 'function') {
	    this._onAny(type, listener);
	    return this;
	  }

	  if (typeof listener !== 'function') {
	    throw new Error('on only accepts instances of Function');
	  }
	  this._events || init.call(this);

	  // To avoid recursion in the case that type == "newListeners"! Before
	  // adding it to the listeners, first emit "newListeners".
	  if (this._newListener) {
	    this.emit('newListener', type, listener);
	  }

	  if (this.wildcard) {
	    growListenerTree.call(this, type, listener);
	    return this;
	  }

	  if (!this._events[type]) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  } else {
	    if (typeof this._events[type] === 'function') {
	      // Change to array.
	      this._events[type] = [this._events[type]];
	    }

	    // If we've already got an array, just add
	    if (prepend) {
	      this._events[type].unshift(listener);
	    } else {
	      this._events[type].push(listener);
	    }

	    // Check for listener leak
	    if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
	      this._events[type].warned = true;
	      logPossibleMemoryLeak.call(this, this._events[type].length, type);
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.off = function (type, listener) {
	  if (typeof listener !== 'function') {
	    throw new Error('removeListener only takes instances of Function');
	  }

	  var handlers,
	      leafs = [];

	  if (this.wildcard) {
	    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	    leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
	  } else {
	    // does not use listeners(), so no side effect of creating _events[type]
	    if (!this._events[type]) {
	      return this;
	    }
	    handlers = this._events[type];
	    leafs.push({ _listeners: handlers });
	  }

	  for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
	    var leaf = leafs[iLeaf];
	    handlers = leaf._listeners;
	    if (isArray$2(handlers)) {

	      var position = -1;

	      for (var i = 0, length = handlers.length; i < length; i++) {
	        if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
	          position = i;
	          break;
	        }
	      }

	      if (position < 0) {
	        continue;
	      }

	      if (this.wildcard) {
	        leaf._listeners.splice(position, 1);
	      } else {
	        this._events[type].splice(position, 1);
	      }

	      if (handlers.length === 0) {
	        if (this.wildcard) {
	          delete leaf._listeners;
	        } else {
	          delete this._events[type];
	        }
	      }
	      if (this._removeListener) {
	        this.emit('removeListener', type, listener);
	      }

	      return this;
	    } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
	      if (this.wildcard) {
	        delete leaf._listeners;
	      } else {
	        delete this._events[type];
	      }
	      if (this._removeListener) {
	        this.emit('removeListener', type, listener);
	      }
	    }
	  }

	  function recursivelyGarbageCollect(root) {
	    if (root === undefined) {
	      return;
	    }
	    var keys = Object.keys(root);
	    for (var i in keys) {
	      var key = keys[i];
	      var obj = root[key];
	      if (obj instanceof Function || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
	        continue;
	      }
	      if (Object.keys(obj).length > 0) {
	        recursivelyGarbageCollect(root[key]);
	      }
	      if (Object.keys(obj).length === 0) {
	        delete root[key];
	      }
	    }
	  }
	  recursivelyGarbageCollect(this.listenerTree);

	  return this;
	};

	EventEmitter.prototype.offAny = function (fn) {
	  var i = 0,
	      l = 0,
	      fns;
	  if (fn && this._all && this._all.length > 0) {
	    fns = this._all;
	    for (i = 0, l = fns.length; i < l; i++) {
	      if (fn === fns[i]) {
	        fns.splice(i, 1);
	        if (this._removeListener) {
	          this.emit('removeListenerAny', fn);
	        }
	        return this;
	      }
	    }
	  } else {
	    fns = this._all;
	    if (this._removeListener) {
	      for (i = 0, l = fns.length; i < l; i++) {
	        this.emit('removeListenerAny', fns[i]);
	      }
	    }
	    this._all = [];
	  }
	  return this;
	};

	EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

	EventEmitter.prototype.removeAllListeners = function (type) {
	  if (type === undefined) {
	    !this._events || init.call(this);
	    return this;
	  }

	  if (this.wildcard) {
	    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	    var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

	    for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
	      var leaf = leafs[iLeaf];
	      leaf._listeners = null;
	    }
	  } else if (this._events) {
	    this._events[type] = null;
	  }
	  return this;
	};

	EventEmitter.prototype.listeners = function (type) {
	  if (this.wildcard) {
	    var handlers = [];
	    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	    searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
	    return handlers;
	  }

	  this._events || init.call(this);

	  if (!this._events[type]) {
	    this._events[type] = [];
	  }
	  if (!isArray$2(this._events[type])) {
	    this._events[type] = [this._events[type]];
	  }
	  return this._events[type];
	};

	EventEmitter.prototype.eventNames = function () {
	  return Object.keys(this._events);
	};

	EventEmitter.prototype.listenerCount = function (type) {
	  return this.listeners(type).length;
	};

	EventEmitter.prototype.listenersAny = function () {

	  if (this._all) {
	    return this._all;
	  } else {
	    return [];
	  }
	};

	var _lifecycleState = {
	  path: '',
	  query: {},
	  scene: 0,
	  subScene: 0,
	  webviewId: -1,
	  __ground: 'foreground'
	};
	var LifecycleState;

	// TODO 其实应该是 内部开发调试时 打开log
	{
	  LifecycleState = new Proxy(_lifecycleState, {
	    set: function set(trapTarget, key, value, receiver) {
	      // logger.log('[发生改变 lifecycle-state]', `key:${key}`, `value:${value}`, trapTarget);
	      return Reflect.set(trapTarget, key, value, receiver);
	    }
	  });
	}

	var LifecycleState$1 = LifecycleState;

	// 之所以建立内部通道，是为了控制有些事件收到后但却不向下派发
	var emitter = new EventEmitter();

	// 页面重新加载
	// 一般来说，此消息在WkWebview崩溃时触发，客户端会在发送消息“时”重新生成一个webview
	onMethod('onPageReload', function () {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  // invoke listener
	  emitter.emit('onPageReload', param);
	});
	function onPageReload(listener) {
	  if (typeof listener === 'function') {
	    emitter.on('onPageReload', listener);
	  }
	}

	// 小程序进入后台 or 进入分享界面 or 进入关于/设置页面
	onMethod('onAppEnterBackground', function () {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  // format param
	  LifecycleState$1.__ground = 'background';

	  // invoke listener
	  emitter.emit('onAppEnterBackground', param);
	});
	function onAppEnterBackground$1(listener) {
	  if (typeof listener === 'function') {
	    emitter.on('onAppEnterBackground', listener);
	  }
	}

	// FG 做两件事
	// 1. 更新scene到全局
	// 2. 处理willRoute标记，供onShow使用
	onMethod('onAppEnterForeground', function () {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  // format param
	  LifecycleState$1.__ground = 'foreground';

	  if (param.scene !== undefined && param.subScene !== undefined) {
	    LifecycleState$1.scene = param.scene;
	    LifecycleState$1.subScene = param.subScene;
	  }
	  param.path = LifecycleState$1.path;
	  param.query = LifecycleState$1.query;

	  // invoke listener
	  emitter.emit('onAppEnterForeground', param, fWillRoute);
	  fWillRoute = false;
	});
	function onAppEnterForeground(listener) {
	  if (typeof listener === 'function') {
	    emitter.on('onAppEnterForeground', listener);
	  }
	}

	// 冷/热启动时会触发
	// 和FG隔离，做不同的事情（主要是path、query的处理）
	var fWillRoute = true;
	onMethod('onAppLaunch', function () {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  // 当path和query「完全一致」时，客户端并不会在接下来切换路由
	  // 可以认为是一次无用的消息，无需派发事件
	  logger.info('onAppLaunch', param, LifecycleState$1);

	  if (param.path === LifecycleState$1.path && isEqual(param.query, LifecycleState$1.query)) {
	    logger.info('onAppLaunch', 'path和query与本地一致，忽略此次事件');
	    return;
	  }

	  // format param
	  fWillRoute = true;
	  ['path', 'query'].forEach(function (attr) {
	    if (param[attr] !== undefined) {
	      LifecycleState$1[attr] = param[attr];
	    }
	  });

	  // invoke listener
	  emitter.emit('onAppLaunch', param);
	});

	var S = {
	  lastRoute: '',
	  query: {},
	  runningStatus: 'active',
	  navigatorLock: false,
	  openUrlLock: false,
	  possessingBackgroundAudioPlayer: false,
	  webviewEventCallback: null,
	  componentEventCallback: null
	};
	var SS;
	// 生产环境不代理
	{
	  SS = new Proxy(S, {
	    set: function set(trapTarget, key, value, receiver) {
	      // logger.log('[发生改变 S]', `key:${key}`, `value:${value}`, trapTarget);
	      return Reflect.set(trapTarget, key, value, receiver);
	    }
	  });
	}

	var GlobalState = SS;

	// currentWebviewId
	// currentClipBoardData
	// appStatus

	function onWebviewEvent(callback) {
	  GlobalState.webviewEventCallback = callback;
	  subscribe('PAGE_EVENT', function (res) {
	    var wvid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    callback({
	      data: res.data,
	      eventName: res.eventName,
	      webviewId: wvid,
	      nodeId: res.nodeId
	    });
	  });
	}

	function onWebviewComponentEvent(callback) {
	  GlobalState.componentEventCallback = callback;
	  subscribe('COMPONENT_EVENT', function (res, wvid) {
	    callback({
	      webviewId: wvid,
	      nodeId: res.nodeId,
	      eventName: res.eventName,
	      data: res.data,
	      islifetime: res.islifetime,
	      route: res.route
	    });
	  });
	}

	function onWebviewDataChange(callback) {
	  subscribe('COMPONENT_DATA_CHANGE', function (res, wvid) {
	    callback({
	      webviewId: wvid,
	      nodeId: res.nodeId,
	      datatype: res.datatype,
	      data: res.data
	    });
	  });
	}

	function onComponentRelationChange(callback) {
	  subscribe('COMPONENT_RELATION_CHANGE', function (res, wvid) {
	    callback({
	      webviewId: wvid,
	      data: res.data
	    });
	  });
	}

	var listeners = [];

	// 接收到客户端派发的onAppRoute事件
	// 更新全局pqs信息
	// 接下来调用注册的回调
	onMethod('onAppRoute', function () {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var wvid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	  // lastroute
	  param.webviewId = param.webviewId || wvid;

	  // appLaunch时参数的解析在客户端处理 -- 历史策略
	  // RTODO 应当把所有客户端解析的场景都排除掉，除了appLaunch外还有热启动时的reLaunch
	  if (param.openType !== 'appLaunch') {
	    for (var key in param.query) {
	      param.query[key] = decodeURIComponent(param.query[key]);
	    }
	  }

	  ['path', 'query', 'webviewId'].forEach(function (attr) {
	    if (param[attr] !== undefined) {
	      LifecycleState$1[attr] = param[attr];
	    }
	  });

	  listeners.forEach(function (cb) {
	    cb(param);
	  });
	});

	function onAppRoute(cb) {
	  if (typeof cb === 'function') {
	    listeners.push(cb);
	  }
	}

	var timingMap = {};

	subscribe('addTimingDots', function (res, wvid) {
	  var timingMap = res && res.timingMap || {};
	  for (var key in timingMap) {
	    addTimingDot(key, timingMap[key]);
	  }
	});

	subscribe('setPerformance', function () {
	  setPerformance();
	});

	/**
	 * @function 设置时间点
	 */
	function addTimingDot(key, value) {
	  timingMap[key] = value;
	}

	/**
	 * @function setPerformance
	 * @description 将timingmap中的时间点注入到客户端的性能时间线中
	 * @return {undefined}
	 */
	function setPerformance() {
	  invokeMethod('setTiming', timingMap);
	  // 清空，方便下个页面的时间点设置
	  timingMap = {};
	}

	/**
	 * getPerformance success callback
	 * @callback getPerformanceSuccessCallback
	 * @param {object} response
	 * @param {string} response.cpu 当前cpu占用
	 * @param {string} response.fps 当前fps
	 * @param {string} response.memory 当前内存占用
	 * @param {Object} response.timing 时间节点（毫秒）
	 */

	function getDataType$1(data) {
	  return Object.prototype.toString.call(data).split(' ')[1].slice(0, -1);
	}

	// 用于包转和页面切换、展示的 API，超时统计 & 错误上报
	function safeInvoke() {
	  var args = Array.prototype.slice.call(arguments);
	  var handlerName = args[0];
	  args = args.slice(1);

	  var result;
	  try {
	    var startTime = Date.now();
	    result = this[handlerName].apply(this, args);
	    var cost = Date.now() - startTime;
	    // 上报 执行时间过长
	    if (cost > 1e3) {
	      Reporter.slowReport({
	        key: 'pageInvoke',
	        cost: cost,
	        extend: 'at ' + this.__route__ + ' page ' + handlerName + ' function'
	      });
	    }
	  } catch (error) {
	    if (Object.prototype.toString.apply(error) === '[object Error]') {
	      Reporter.thirdErrorReport({
	        error: error,
	        extend: 'at ' + this.__route__ + ' page ' + handlerName + ' function'
	      });
	    }
	  }

	  return result;
	}

	function errorReport(err) {
	  var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

	  if (Object.prototype.toString.apply(err) === '[object Error]') {
	    if ('AppServiceEngineKnownError' === err.type) {
	      throw err;
	    }
	    Reporter.errorReport({
	      key: 'jsEngineScriptError',
	      error: err,
	      extend: msg
	    });
	  }
	}

	function collect(desc, func) {
	  return function () {
	    try {
	      return func.apply(func, arguments);
	    } catch (err) {
	      errorReport(err, desc);
	      return function () {};
	    }
	  };
	}

	// service-engine 中的错误，手动抛出，需要上报
	var AppServiceEngineKnownError = function (_Error) {
	  inherits(AppServiceEngineKnownError, _Error);

	  function AppServiceEngineKnownError(msg) {
	    classCallCheck(this, AppServiceEngineKnownError);

	    var _this = possibleConstructorReturn(this, _Error.call(this, 'APP-SERVICE-Engine: ' + msg));

	    _this.type = 'AppServiceEngineKnownError';
	    return _this;
	  }

	  return AppServiceEngineKnownError;
	}(Error);
	function noop$2() {}

	var deepClone = function () {

	  function _instanceof$$1(obj, type) {
	    return type != null && obj instanceof type;
	  }

	  var nativeMap;
	  try {
	    nativeMap = Map;
	  } catch (_) {
	    // maybe a reference error because no `Map`. Give it a dummy value that no
	    // value will ever be an instanceof.
	    nativeMap = function nativeMap() {};
	  }

	  var nativeSet;
	  try {
	    nativeSet = Set;
	  } catch (_) {
	    nativeSet = function nativeSet() {};
	  }

	  var nativePromise;
	  try {
	    nativePromise = Promise;
	  } catch (_) {
	    nativePromise = function nativePromise() {};
	  }

	  /**
	     * Clones (copies) an Object using deep copying.
	     *
	     * This function supports circular references by default, but if you are certain
	     * there are no circular references in your object, you can save some CPU time
	     * by calling clone(obj, false).
	     *
	     * Caution: if `circular` is false and `parent` contains circular references,
	     * your program may enter an infinite loop and crash.
	     *
	     * @param `parent` - the object to be cloned
	     * @param `circular` - set to true if the object to be cloned may contain
	     *    circular references. (optional - true by default)
	     * @param `depth` - set to a number if the object is only to be cloned to
	     *    a particular depth. (optional - defaults to Infinity)
	     * @param `prototype` - sets the prototype to be used when cloning an object.
	     *    (optional - defaults to parent prototype).
	     * @param `includeNonEnumerable` - set to true if the non-enumerable properties
	     *    should be cloned as well. Non-enumerable properties on the prototype
	     *    chain will be ignored. (optional - false by default)
	     */
	  function clone(parent, circular, depth, prototype, includeNonEnumerable) {
	    if ((typeof circular === 'undefined' ? 'undefined' : _typeof(circular)) === 'object') {
	      depth = circular.depth;
	      prototype = circular.prototype;
	      includeNonEnumerable = circular.includeNonEnumerable;
	      circular = circular.circular;
	    }
	    // maintain two arrays for circular references, where corresponding parents
	    // and children have the same index
	    var allParents = [];
	    var allChildren = [];

	    var useBuffer = typeof Buffer != 'undefined';

	    if (typeof circular == 'undefined') {
	      circular = true;
	    }

	    if (typeof depth == 'undefined') {
	      depth = Infinity;
	    }

	    // recurse this function so we don't reset allParents and allChildren
	    function _clone(parent, depth) {
	      // cloning null always returns null
	      if (parent === null) {
	        return null;
	      }

	      if (depth === 0) {
	        return parent;
	      }

	      var child;
	      var proto;
	      if ((typeof parent === 'undefined' ? 'undefined' : _typeof(parent)) != 'object') {
	        return parent;
	      }

	      if (_instanceof$$1(parent, nativeMap)) {
	        child = new nativeMap();
	      } else if (_instanceof$$1(parent, nativeSet)) {
	        child = new nativeSet();
	      } else if (_instanceof$$1(parent, nativePromise)) {
	        child = new nativePromise(function (resolve, reject) {
	          parent.then(function (value) {
	            resolve(_clone(value, depth - 1));
	          }, function (err) {
	            reject(_clone(err, depth - 1));
	          });
	        });
	      } else if (clone.__isArray(parent)) {
	        child = [];
	      } else if (clone.__isRegExp(parent)) {
	        child = new RegExp(parent.source, __getRegExpFlags(parent));
	        if (parent.lastIndex) {
	          child.lastIndex = parent.lastIndex;
	        }
	      } else if (clone.__isDate(parent)) {
	        child = new Date(parent.getTime());
	      } else if (useBuffer && Buffer.isBuffer(parent)) {
	        if (Buffer.allocUnsafe) {
	          // Node.js >= 4.5.0
	          child = Buffer.allocUnsafe(parent.length);
	        } else {
	          // Older Node.js versions
	          child = new Buffer(parent.length);
	        }
	        parent.copy(child);
	        return child;
	      } else if (_instanceof$$1(parent, Error)) {
	        child = Object.create(parent);
	      } else {
	        if (typeof prototype == 'undefined') {
	          proto = Object.getPrototypeOf(parent);
	          child = Object.create(proto);
	        } else {
	          child = Object.create(prototype);
	          proto = prototype;
	        }
	      }

	      if (circular) {
	        var index = allParents.indexOf(parent);

	        if (index != -1) {
	          return allChildren[index];
	        }
	        allParents.push(parent);
	        allChildren.push(child);
	      }

	      if (_instanceof$$1(parent, nativeMap)) {
	        parent.forEach(function (value, key) {
	          var keyChild = _clone(key, depth - 1);
	          var valueChild = _clone(value, depth - 1);
	          child.set(keyChild, valueChild);
	        });
	      }
	      if (_instanceof$$1(parent, nativeSet)) {
	        parent.forEach(function (value) {
	          var entryChild = _clone(value, depth - 1);
	          child.add(entryChild);
	        });
	      }

	      for (var i in parent) {
	        var attrs;
	        if (proto) {
	          attrs = Object.getOwnPropertyDescriptor(proto, i);
	        }

	        if (attrs && attrs.set == null) {
	          continue;
	        }
	        child[i] = _clone(parent[i], depth - 1);
	      }

	      if (Object.getOwnPropertySymbols) {
	        var symbols = Object.getOwnPropertySymbols(parent);
	        for (var _i = 0; _i < symbols.length; _i++) {
	          // Don't need to worry about cloning a symbol because it is a primitive,
	          // like a number or string.
	          var symbol = symbols[_i];
	          var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
	          if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
	            continue;
	          }
	          child[symbol] = _clone(parent[symbol], depth - 1);
	          if (!descriptor.enumerable) {
	            Object.defineProperty(child, symbol, {
	              enumerable: false
	            });
	          }
	        }
	      }

	      if (includeNonEnumerable) {
	        var allPropertyNames = Object.getOwnPropertyNames(parent);
	        for (var _i2 = 0; _i2 < allPropertyNames.length; _i2++) {
	          var propertyName = allPropertyNames[_i2];
	          var _descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
	          if (_descriptor && _descriptor.enumerable) {
	            continue;
	          }
	          child[propertyName] = _clone(parent[propertyName], depth - 1);
	          Object.defineProperty(child, propertyName, {
	            enumerable: false
	          });
	        }
	      }

	      return child;
	    }

	    return _clone(parent, depth);
	  }

	  /**
	     * Simple flat clone using prototype, accepts only objects, usefull for property
	     * override on FLAT configuration object (no nested props).
	     *
	     * USE WITH CAUTION! This may not behave as you wish if you do not know how this
	     * works.
	     */
	  clone.clonePrototype = function clonePrototype(parent) {
	    if (parent === null) {
	      return null;
	    }

	    var c = function c() {};
	    c.prototype = parent;
	    return new c();
	  };

	  // private utility functions

	  function __objToStr(o) {
	    return Object.prototype.toString.call(o);
	  }
	  clone.__objToStr = __objToStr;

	  function __isDate(o) {
	    return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && __objToStr(o) === '[object Date]';
	  }
	  clone.__isDate = __isDate;

	  function __isArray(o) {
	    return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && __objToStr(o) === '[object Array]';
	  }
	  clone.__isArray = __isArray;

	  function __isRegExp(o) {
	    return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && __objToStr(o) === '[object RegExp]';
	  }
	  clone.__isRegExp = __isRegExp;

	  function __getRegExpFlags(re) {
	    var flags = '';
	    if (re.global) {
	      flags += 'g';
	    }
	    if (re.ignoreCase) {
	      flags += 'i';
	    }
	    if (re.multiline) {
	      flags += 'm';
	    }
	    return flags;
	  }
	  clone.__getRegExpFlags = __getRegExpFlags;

	  return clone;
	}();

	function mergeData(data1) {
	  var data2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  for (var i in data2) {
	    if (Object.prototype.hasOwnProperty.call(data1, i)) {
	      if ('object' != _typeof(data1[i]) || 'object' != _typeof(data2[i]) || null === data2[i] || data2[i] instanceof Array) {
	        data1[i] = data2[i];
	      } else {
	        mergeData(data1[i], data2[i]);
	      }
	    } else {
	      data1[i] = data2[i];
	    }
	  }
	}

	function s4() {
	  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	}

	function guid$1() {
	  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
	}

	function queue$1(type) {
	  this.type = type;
	  this.arr = [];
	  this.index = 0;
	}
	queue$1.create = function (type) {
	  var q = new queue$1(type);
	  Object.defineProperty(q, 'empty', {
	    get: function get$$1() {
	      return q.arr.length === 0;
	    }
	  });
	  return q;
	};
	var queueproto = queue$1.prototype = {
	  add: function add(func) {
	    var index = this.index++;
	    this.arr.push({
	      id: index,
	      func: func
	    });
	    return index;
	  },
	  remove: function remove(func) {
	    var arr = this.arr,
	        len = arr.length,
	        i = 0;

	    if (typeof func === 'function') {
	      for (i = 0; i < len; i++) {
	        if (arr[i].func === func) {
	          arr.splice(i, 1);
	          return true;
	        }
	      }
	    } else {
	      for (i = 0; i < len; i++) {
	        if (arr[i].id === func) {
	          arr.splice(i, 1);
	          return true;
	        }
	      }
	    }
	    return false;
	  },
	  call: function call(context, args) {
	    var arr = this.arr,
	        type = this.type,
	        flag = true;
	    for (var i = 0, l = arr.length; i < l; i++) {
	      if (queueproto.safeCallback(type, arr[i].func, context, args) !== true) {
	        flag = false;
	      }
	    }
	    if (!flag) {
	      return flag;
	    }
	  },
	  safeCallback: function safeCallback(type, func, content, args) {
	    try {
	      return func.apply(content, args);
	    } catch (e) {
	      logger.error(e);
	    }
	  }
	};

	var toString$3 = Object.prototype.toString;

	function isFunction(obj) {
	  return toString$3.call(obj) === '[object Function]';
	}
	var ComponentInstances = {};
	function ComponentInstancesGetter() {
	  return ComponentInstances;
	}

	function ComponentInstancesSetter(_componentInstances) {
	  ComponentInstances = _componentInstances;
	}

	var BaseInstance = function () {
	  function BaseInstance() {
	    classCallCheck(this, BaseInstance);
	  }

	  BaseInstance.prototype.selectComponent = function selectComponent(selector) {
	    var _this = this;

	    var completeCb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$2;

	    var cis = ComponentInstancesGetter();

	    var eventName = 'selectComponent';
	    if (!this.__nodeid__ || this.__nodeid__ < 1) {
	      eventName = 'selectComponentInPage';
	    }

	    invokeWebviewMethod({
	      name: eventName,
	      args: {
	        selector: selector,
	        single: true,
	        complete: function complete(res) {
	          if (res !== null) {
	            var components = cis[_this.__webviewId__];
	            if (components && components[res]) {
	              res = components[res].instance;
	            } else {
	              res = null;
	            }
	          }
	          completeCb(res);
	        },
	        nodeid: this.__nodeid__
	      },
	      webviewIds: [this.__webviewId__]
	    });
	  };

	  BaseInstance.prototype.selectAllComponents = function selectAllComponents(selector) {
	    var _this2 = this;

	    var completeCb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$2;

	    var cis = ComponentInstancesGetter();

	    var eventName = 'selectComponent';
	    if (!this.__nodeid__ || this.__nodeid__ < 1) {
	      eventName = 'selectComponentInPage';
	    }

	    invokeWebviewMethod({
	      name: eventName,
	      args: {
	        selector: selector,
	        single: false,
	        complete: function complete(res) {
	          var components = cis[_this2.__webviewId__] || {};

	          completeCb(res.map(function (nid) {
	            return components[nid] ? components[nid].instance : null;
	          }));
	        },
	        nodeid: this.__nodeid__
	      },
	      webviewIds: [this.__webviewId__]
	    });
	  };

	  return BaseInstance;
	}();

	// setData 时支持用'a.b','a[3]'这样的 key
	function parsePath(path) {
	  if ('String' !== getDataType$1(path)) {
	    var errmsg = 'path 类型应为字符串';
	    logger.error('TypeError', errmsg);
	    throw new AppServiceEngineKnownError(errmsg);
	  }

	  var hasNumberinArray = false;
	  var isArrayStarted = false;
	  var len = path.length;
	  var pathArray = [];
	  var result = '';
	  for (var digits = 0, i = 0; i < len; i++) {
	    var char = path[i];
	    if ('\\' === char) {
	      // 处理转义字符
	      i + 1 < len && ('.' === path[i + 1] || '[' === path[i + 1] || ']' === path[i + 1]) ? (result += path[i + 1], i++) : result += '\\';
	    } else if ('.' === char) {
	      // 用点分割，特性之一
	      result && (pathArray.push(result), result = '');
	    } else if ('[' === char) {
	      result && (pathArray.push(result), result = '');
	      // [不能在字符串一开始
	      if (0 === pathArray.length) {
	        logger.error('数据路径错误', 'Path can not start with []: ' + path);
	        throw new AppServiceEngineKnownError('Path can not start with []: ' + path);
	      }
	      isArrayStarted = true;
	      hasNumberinArray = false;
	    } else if (']' === char) {
	      if (!hasNumberinArray) {
	        logger.error('数据路径错误', 'Must have number in []: ' + path);
	        throw new AppServiceEngineKnownError('Must have number in []: ' + path);
	      }
	      isArrayStarted = false;
	      pathArray.push(digits);
	      digits = 0;
	    } else if (isArrayStarted) {
	      if (char < '0' || char > '9') {
	        logger.error('数据路径错误', 'Only number 0-9 could inside []: ' + path);
	        throw new AppServiceEngineKnownError('Only number 0-9 could inside []: ' + path);
	      }
	      hasNumberinArray = true;
	      digits = 10 * digits + char.charCodeAt(0) - 48;
	    } else {
	      result += char;
	    }
	  }
	  result && pathArray.push(result);
	  if (0 === pathArray.length) {
	    logger.error('数据路径错误', 'Path can not be empty');
	    throw new AppServiceEngineKnownError('Path can not be empty');
	  }
	  return pathArray;
	}

	function getObjectByPath(p1, newkey) {
	  for (var pathes = parsePath(newkey), obj = {}, key = void 0, oldData = p1, u = 0; u < pathes.length; u++) {
	    Number(pathes[u]) === pathes[u] && pathes[u] % 1 == 0 ? Array.isArray(oldData) || (obj[key] = [], oldData = obj[key]) : getDataType$1(oldData) === 'Object' || (obj[key] = {}, oldData = obj[key]);
	    key = pathes[u];
	    obj = oldData;
	    oldData = oldData[pathes[u]];
	  }

	  return {
	    obj: obj, // obj是包含 key 的最小一层对象，可以是数组
	    key: key // key是原始 key 的最小一层值，可以是数字（下标）
	  };
	}

	function createIntersectionObserver(content, options) {
	  return new IntersectionObserver(content, options);
	}

	var IntersectionObserver = function () {
	  function IntersectionObserver(content, options) {
	    classCallCheck(this, IntersectionObserver);

	    this._component = content;
	    this._options = options;
	    this._relativeInfo = [];
	    this._observerId = null;
	    this._disconnected = false;

	    if (content) {
	      this._webviewId = content.__webviewId__;
	    } else {
	      var pages = getCurrentPages();
	      this._webviewId = pages[pages.length - 1].__webviewId__;
	    }
	  }

	  IntersectionObserver.prototype.relativeTo = function relativeTo(selector, margins) {
	    if (null !== this._observerId) {
	      throw new Error('Relative nodes cannot be added after "observe" call in IntersectionObserver');
	    }

	    this._relativeInfo.push({
	      selector: selector,
	      margins: margins
	    });

	    return this;
	  };

	  IntersectionObserver.prototype.relativeToViewport = function relativeToViewport(margins) {
	    if (null !== this._observerId) {
	      throw new Error('Relative nodes cannot be added after "observe" call in IntersectionObserver');
	    }

	    this._relativeInfo.push({
	      selector: null,
	      margins: margins
	    });

	    return this;
	  };

	  IntersectionObserver.prototype.observe = function observe(targetSelector, callback) {
	    var _this = this;

	    if (null !== this._observerId) {
	      throw new Error('"observe" call can be only called once in IntersectionObserver');
	    }

	    this._observerId = '';
	    var component = this._component;
	    publishInterSectionObserver(this._webviewId, {
	      type: 'addIntersectionObserver',
	      pluginId: 'unsuport',
	      nodeId: component && component.__nodeid__ !== undefined && component.__nodeid__ > 0 ? component.__nodeid__ : null,
	      targetSelector: targetSelector,
	      relativeInfo: this._relativeInfo,
	      options: this._options
	    }, function (e) {
	      if (!_this._disconnected) {
	        if (e.observerId) {
	          _this._observerId = e.observerId;
	        }
	        if (e.info) {
	          callback.call(_this, e.info);
	        }
	      }
	    });
	  };

	  IntersectionObserver.prototype.disconnect = function disconnect() {
	    publishInterSectionObserver(this._webviewId, {
	      type: 'removeIntersectionObserver',
	      observerId: this._observerId
	    });
	    this._disconnected = true;
	  };

	  return IntersectionObserver;
	}();

	var uuid = 1;
	var privateMethod = {};
	function publishInterSectionObserver(webviewid, req, callback) {
	  uuid++;
	  privateMethod[uuid] = callback;
	  publish('requestComponentObserver', {
	    reqId: uuid,
	    req: req
	  }, [webviewid]);
	}

	subscribe('responseComponentObserver', function (_ref) {
	  var reqEnd = _ref.reqEnd,
	      reqId = _ref.reqId,
	      res = _ref.res;

	  var eid = reqId;
	  var callback = privateMethod[eid];

	  if (reqEnd) {
	    delete privateMethod[eid];
	  } else if (callback) {
	    callback(res);
	  }
	});

	var lifeCycles = ['onLoad', 'onReady', 'onShow', /* "onRouteEnd", */'onHide', 'onUnload'];
	var keywords = ['__webviewId__', '__route__'];

	var Page = function (_BaseInstance) {
	  inherits(Page, _BaseInstance);

	  function Page() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var wvid = arguments[1];
	    var route = arguments[2];
	    classCallCheck(this, Page);

	    var _this = possibleConstructorReturn(this, _BaseInstance.call(this));

	    var that = _this;

	    // default define
	    _this.__route__ = route;
	    _this.__webviewId__ = wvid;

	    // format data
	    options.data = options.data || {};
	    if (getDataType$1(options.data) !== 'Object') {
	      logger.error('Page.data should be an object');
	    }
	    _this.data = JSON.parse(JSON.stringify(options.data)); // 就是文档中提到的拷贝一次，但这里的问题是循环引用怎么破？

	    // 生命周期方法，开发者没写的也要加，防止报错
	    lifeCycles.forEach(function (life) {
	      _this[life] = function () {
	        Reporter.__route__ = route;
	        Reporter.__method__ = life;
	        logger.info(route + '.' + life + ' invoked');

	        var result;
	        try {
	          var startTime = Date.now();
	          result = (options[life] || noop$2).apply(that, arguments);
	          var cost = Date.now() - startTime;
	          // 上报 执行效率低下
	          if (cost > 1e3) {
	            Reporter.slowReport({
	              key: 'pageInvoke',
	              cost: cost,
	              extend: 'at ' + route + ' page lifeCycleMethod ' + life + ' function'
	            });
	          }
	        } catch (error$$1) {
	          Reporter.thirdErrorReport({
	            error: error$$1,
	            extend: 'at ' + route + ' page lifeCycleMethod ' + life + ' function'
	          });
	        }
	        return result;
	      };
	    });

	    // 其他的属性，是方法的包装，不是的拷贝
	    for (var key in options) {
	      if (keywords.indexOf(key) > -1) {
	        logger.warn('Page\'s [' + key + '] is protected, please do not cover it');
	      } else if (key === 'route') {
	        _this.route = route;
	      } else if (key !== 'data' && lifeCycles.indexOf(key) === -1) {
	        if (typeof options[key] === 'function') {
	          (function (fname) {
	            that[fname] = function () {
	              var result;
	              try {
	                var startTime = Date.now();
	                result = options[fname].apply(that, arguments);
	                var cost = Date.now() - startTime;
	                // 上报 执行时间长
	                if (cost > 1e3) {
	                  Reporter.slowReport({
	                    key: 'pageInvoke',
	                    cost: cost,
	                    extend: 'at ' + route + ' page ' + fname + ' function'
	                  });
	                }
	              } catch (error$$1) {
	                Reporter.thirdErrorReport({
	                  error: error$$1,
	                  extend: 'at ' + route + ' page ' + fname + ' function'
	                });
	              }
	              return result;
	            };
	          })(key);
	        } else {
	          _this[key] = deepClone(options[key]);
	        }
	      }
	    }
	    return _this;
	  }

	  Page.prototype.setData = function setData(newData) {
	    var completeCb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$2;

	    var needDataPerformance = newData && newData.needDataPerformance;
	    needDataPerformance && addTimingDot('setDataStart', Date.now());
	    try {
	      var datatype = getDataType$1(newData);

	      if (datatype !== 'Object') {
	        logger.error('setData\'s first param must be object, you pass ' + datatype);
	        return;
	      }

	      // path "arr[0].hello[1].world"
	      for (var path in newData) {
	        if (newData[path] === undefined) {
	          logger.error('setData field ' + path + ' to undefined not work');
	        }

	        var _getObjectByPath = getObjectByPath(this.data, path),
	            obj = _getObjectByPath.obj,
	            key = _getObjectByPath.key;

	        obj && (obj[key] = deepClone(newData[path]));
	      }
	      needDataPerformance && addTimingDot('setDataSendNative', Date.now());
	      invokeWebviewMethod({
	        name: 'appDataChange',
	        args: {
	          data: newData,
	          complete: completeCb
	        },
	        webviewIds: [this.__webviewId__]
	      });
	    } catch (err) {
	      errorReport(err);
	    }
	  };

	  Page.prototype.pageScrollTo = function pageScrollTo(position) {
	    ttJSBridge.publish('pageScrollTo', {
	      data: position,
	      options: {
	        timestamp: Date.now()
	      }
	    }, [this.__webviewId__]);
	  };

	  Page.prototype.createIntersectionObserver = function createIntersectionObserver$$1(options) {
	    return createIntersectionObserver.call(this, this, options);
	  };

	  return Page;
	}(BaseInstance);

	function createSelectorQuery(currentPage) {
	  var webviewid = null;
	  if (currentPage && currentPage.page) {
	    webviewid = currentPage.page.__webviewId__;
	  } else {
	    var pages = getCurrentPages();
	    webviewid = pages[pages.length - 1].__webviewId__;
	  }
	  return new SelectorQuery(webviewid);
	}

	var SelectorQuery = function () {
	  function SelectorQuery(webviewid) {
	    classCallCheck(this, SelectorQuery);

	    this._webviewid = webviewid;
	    this._component = null;
	    this._queue = [];
	    this._queueCb = [];
	  }

	  SelectorQuery.prototype.in = function _in(component) {
	    if (this._webviewid === null) {
	      this._webviewid = component.__webviewId__;
	      this._component = component;
	    } else if (this._webviewid === component.__webviewId__) {
	      this._component = component;
	    } else {
	      logger.error('A single SelectorQuery could not work in components in different pages. A SelectorQuery#in call has been ignored and the page root is used as the current component.');
	    }
	    return this;
	  };

	  SelectorQuery.prototype.select = function select(selector) {
	    return new NodesRef(this, this._component, selector, true);
	  };

	  SelectorQuery.prototype.selectAll = function selectAll(selector) {
	    return new NodesRef(this, this._component, selector, false);
	  };

	  SelectorQuery.prototype.selectViewport = function selectViewport() {
	    return new NodesRef(this, 0, '', true);
	  };

	  SelectorQuery.prototype._push = function _push(selector, component, single, fields, callback) {
	    this._queue.push({
	      component: component ? component.__nodeid__ : component,
	      selector: selector,
	      single: single,
	      fields: fields
	    });
	    this._queueCb.push(callback || null);
	  };

	  SelectorQuery.prototype.exec = function exec(callback) {
	    var that = this;
	    publishSelectQuery(this._webviewid, this._queue, function (res) {
	      var queueCb = that._queueCb;
	      res.forEach(function (value, key) {
	        if (typeof queueCb[key] === 'function') {
	          queueCb[key].call(that, value);
	        }
	      });
	      if ('function' === typeof callback) {
	        callback.call(that, res);
	      }
	    });
	  };

	  return SelectorQuery;
	}();

	var NodesRef = function () {
	  function NodesRef(selectorQuery, component, selector, single) {
	    classCallCheck(this, NodesRef);

	    this._selectorQuery = selectorQuery;
	    this._component = component;
	    this._selector = selector;
	    this._single = single;
	  }

	  NodesRef.prototype.fields = function fields(_fields, callback) {
	    this._selectorQuery._push(this._selector, this._component, this._single, _fields, callback);
	    return this._selectorQuery;
	  };

	  NodesRef.prototype.boundingClientRect = function boundingClientRect(callback) {
	    this._selectorQuery._push(this._selector, this._component, this._single, {
	      id: true,
	      dataset: true,
	      rect: true,
	      size: true
	    }, callback);
	    return this._selectorQuery;
	  };

	  NodesRef.prototype.scrollOffset = function scrollOffset(callback) {
	    this._selectorQuery._push(this._selector, this._component, this._single, {
	      id: true,
	      dataset: true,
	      scrollOffset: true
	    }, callback);
	    return this._selectorQuery;
	  };

	  return NodesRef;
	}();

	var uuid$1 = 1;
	var privateMethod$1 = {};
	function publishSelectQuery(webviewid, queue, callback) {
	  uuid$1++;
	  privateMethod$1[uuid$1] = callback;
	  publish('requestComponentInfo', {
	    reqId: uuid$1,
	    reqs: queue
	  }, [webviewid]);
	}

	subscribe('responseComponentInfo', function (e) {
	  var eid = e.reqId;
	  var callback = privateMethod$1[eid];

	  callback && (delete privateMethod$1[eid], callback(e.res));
	});

	var pageLifeCycles = ['onLoad', 'onReady', 'onShow', /* "onRouteEnd", */'onHide', 'onUnload'];
	// const componentLifeTimes = ['created', 'ready', 'attached', 'moved', 'detached', 'saved', 'restored'];
	// const keywords = ['__webviewId__', '__route__'];
	// const reserved = ['route'];

	var componentBehaviors = new WeakMap();

	var Component = function (_BaseInstance) {
	  inherits(Component, _BaseInstance);

	  // registerOption, wvid, route, nodeid
	  function Component() {
	    var optionsOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var wvid = arguments[1];
	    var route = arguments[2];
	    var nodeid = arguments[3];
	    classCallCheck(this, Component);

	    var _this = possibleConstructorReturn(this, _BaseInstance.call(this));

	    var that = _this;
	    // 防止 setData 影响 registerOption，影响下次自定义组件构建时的初始data
	    var options = deepClone(optionsOrigin);

	    // default define
	    _this.__route__ = route;
	    _this.__webviewId__ = wvid;
	    _this.__nodeid__ = nodeid;

	    if (getDataType$1(options.data) !== 'Object') {
	      options.data = {};
	    }

	    // format data
	    // 微信在2.0.9版本去掉了format
	    // let _data = JSON.parse(JSON.stringify(options.data));
	    var _data = options.data;
	    for (var i in options.properties) {
	      _data[i] = options.properties[i].value;
	    }
	    _this.data = _this.properties = _data;
	    _this.__properties__ = options.properties;

	    _this.dataset = {};
	    _this.id = '';

	    _this.is = options.is;
	    _this.methods = {};

	    pageLifeCycles.forEach(function (life) {
	      _this[life] = noop$2;
	    });

	    // 直接挂载在实例上
	    for (var methodname in options.methods) {
	      (function (methodname) {
	        that[methodname] = function () {
	          var result;
	          try {
	            var startTime = Date.now();
	            result = options.methods[methodname].apply(that, arguments);
	            var cost = Date.now() - startTime;
	            // 上报 执行时间长
	            if (cost > 1e3) {
	              Reporter.slowReport({
	                key: 'componentInvoke',
	                cost: cost,
	                extend: 'at ' + route + ' component ' + methodname + ' function'
	              });
	            }
	          } catch (error$$1) {
	            Reporter.thirdErrorReport({
	              error: error$$1,
	              extend: 'at ' + route + ' component ' + methodname + ' function'
	            });
	          }
	          return result;
	        };
	      })(methodname);
	    }
	    options.__allLifeTimeFuncs = options.getAllLifeTimeFuncs();
	    componentBehaviors.set(_this, options);
	    return _this;
	  }

	  Component.prototype.setData = function setData(newData) {
	    var completeCb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$2;

	    try {
	      var datatype = getDataType$1(newData);

	      if (datatype !== 'Object') {
	        logger.error('setData\'s first param must be object, you pass ' + datatype);
	        return;
	      }

	      // path "arr[0].hello[1].world"
	      for (var path in newData) {
	        if (newData[path] === undefined) {
	          logger.error('setData field ' + path + ' to undefined not work');
	        }

	        var _getObjectByPath = getObjectByPath(this.data, path),
	            obj = _getObjectByPath.obj,
	            key = _getObjectByPath.key;

	        obj && (obj[key] = deepClone(newData[path]));
	      }
	      // 兼容compoent as page
	      if (this.__nodeid__ === 0) {
	        invokeWebviewMethod({
	          name: 'appDataChange',
	          args: {
	            data: newData,
	            complete: completeCb
	          },
	          webviewIds: [this.__webviewId__]
	        });
	      } else {
	        invokeWebviewMethod({
	          name: 'componentDataChange',
	          args: {
	            data: newData,
	            nodeid: this.__nodeid__,
	            complete: completeCb
	          },
	          webviewIds: [this.__webviewId__]
	        });
	      }
	    } catch (err) {
	      logger.error('setData error: ' + err);
	    }
	  };

	  Component.prototype.hasBehavior = function hasBehavior(behavior) {
	    var behaviorself = componentBehaviors.get(this);
	    return behaviorself.hasBehavior(behavior);
	  };

	  Component.prototype.triggerEvent = function triggerEvent(eventName, eventDetail, eventOption) {
	    invokeWebviewMethod({
	      name: 'triggerComponentEvent',
	      args: {
	        eventName: eventName,
	        eventDetail: eventDetail,
	        eventOption: eventOption,
	        nodeid: this.__nodeid__
	      },
	      webviewIds: [this.__webviewId__]
	    });
	  };

	  Component.prototype.createSelectorQuery = function createSelectorQuery$$1() {
	    return createSelectorQuery().in(this);
	  };

	  Component.prototype.createIntersectionObserver = function createIntersectionObserver$$1(options) {
	    return createIntersectionObserver.call(this, this, options);
	  };

	  Component.prototype.getRelationNodes = function getRelationNodes(relation) {
	    var _this2 = this;

	    var completeCb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$2;

	    if (!relation || completeCb === noop$2) {
	      return [];
	    }
	    var cis = ComponentInstancesGetter();

	    invokeWebviewMethod({
	      name: 'getRelationNodes',
	      args: {
	        relation: relation,
	        complete: function complete(res) {
	          // console.info(' get relation nodes success ', res);
	          if (!Array.isArray(res) || res.length === 0) {
	            completeCb.call(_this2, res);
	          }

	          var components = cis[_this2.__webviewId__] || {};

	          completeCb.call(_this2, res.map(function (nodeid) {
	            return components[nodeid] ? components[nodeid].instance : null;
	          }));
	        },
	        nodeid: this.__nodeid__
	      },
	      webviewIds: [this.__webviewId__]
	    });
	    return [];
	  };

	  Component.prototype.pageScrollTo = function pageScrollTo(position) {
	    ttJSBridge.publish('pageScrollTo', {
	      data: position,
	      options: {
	        timestamp: Date.now()
	      }
	    }, [this.__webviewId__]);
	  };

	  return Component;
	}(BaseInstance);

	function triggerComponentLiftTimes(instance) {
	  var eventName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'created';
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  var behavior = componentBehaviors.get(instance);
	  var allLifeTimeFuncs = behavior.__allLifeTimeFuncs;
	  allLifeTimeFuncs[eventName].call(instance, data);
	}

	var propertiesType = [String, Number, Boolean, Object, Array /** , null* */];
	var propertiesTypeValue = ['', 0, false, {}, [], null];
	var lifeTimes = ['created', 'ready', 'attached', 'moved', 'detached', 'saved', 'restored'];

	function Behavior(options) {
	  options.is = '/' + guid$1();

	  BehaviorInner.create(options);

	  return options.is;
	}

	function BehaviorInner() {}

	BehaviorInner._list = {};

	BehaviorInner.create = function (options) {
	  var behavior = new BehaviorInner();

	  behavior.is = options.is;
	  behavior.data = 'object' === _typeof(options.data) ? {} : null;
	  behavior.properties = Object.create(null);
	  behavior.methods = Object.create(null);
	  behavior.relations = Object.create(null);
	  behavior.behaviors = options.behaviors;
	  behavior.ancestors = [];
	  behavior.lifetimes = options.lifetimes;
	  behavior.definitionFilter = options.definitionFilter;
	  behavior._unprepare = options;

	  BehaviorInner._list[options.is] = behavior;

	  // 初始化 definitionFilter
	  BehaviorInner.initDefinitionFilter(options);

	  // TODO是否懒准备
	  BehaviorInner.prepared(behavior);
	  return behavior;
	};

	BehaviorInner.prepared = function (behavior) {
	  var unprepare = behavior._unprepare;

	  if (unprepare) {
	    behavior._unprepare = null;
	    var _unprepare$behaviors = unprepare.behaviors,
	        behaviors = _unprepare$behaviors === undefined ? [] : _unprepare$behaviors;


	    behaviors.forEach(function (behavioritemis) {
	      var behavioritem = BehaviorInner._list[behavioritemis];

	      if (!behavioritem) {
	        return;
	      }

	      if (behavioritem._unprepare) {
	        BehaviorInner.prepared(behavioritem);
	      }

	      // 初始化 data
	      if (!behavior.data) {
	        behavior.data = behavioritem.data;
	      } else {
	        mergeData(behavior.data, behavioritem.data || {});
	      }

	      // 初始化 属性
	      for (var i in behavioritem.properties) {
	        behavior.properties[i] = behavioritem.properties[i];
	      }

	      // 初始化 relation
	      for (var _i in behavioritem.relations) {
	        behavior.relations[_i] = behavioritem.relations[_i];
	      }

	      // 初始化 methods
	      for (var _i2 in behavioritem.methods) {
	        behavior.methods[_i2] = behavioritem.methods[_i2];
	      }

	      for (var _i3 = 0, l = behavioritem.ancestors.length; _i3 < l; _i3++) {
	        var ancestor = behavioritem.ancestors[_i3];
	        if (behavior.ancestors.indexOf(ancestor) === -1) {
	          behavior.ancestors.push(ancestor);
	        }
	      }
	    });

	    if (!behavior.data) {
	      behavior.data = unprepare.data;
	    } else {
	      mergeData(behavior.data, unprepare.data || {});
	    }

	    for (var i in unprepare.properties) {
	      var value = unprepare.properties[i];
	      var index = 5;
	      var observer = void 0;
	      // 写了type 没写value, e.g: {properties: {a: {type: String}}}
	      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && value.value === undefined) {
	        observer = value.observer;
	        value = value.type;
	      }
	      // 只写了type e.g: {properties: {a: String}}
	      if (value === null || (index = propertiesType.indexOf(value)) > -1) {
	        value = {
	          type: value,
	          value: propertiesTypeValue[index],
	          observer: observer
	        };
	      }

	      behavior.properties[i] = value;
	    }

	    for (var _i4 in unprepare.relations) {
	      behavior.relations[_i4] = unprepare.relations[_i4];
	    }

	    for (var _i5 in unprepare.methods) {
	      behavior.methods[_i5] = unprepare.methods[_i5];
	    }

	    for (var _i6 = 0, l = lifeTimes.length; _i6 < l; _i6++) {
	      // 优先从 lifetimes 中获取生命周期回调
	      var result = noop$2;
	      if (unprepare.lifetimes && isFunction(unprepare.lifetimes[lifeTimes[_i6]])) {
	        result = unprepare.lifetimes[lifeTimes[_i6]];
	      } else if (isFunction(unprepare[lifeTimes[_i6]])) {
	        result = unprepare[lifeTimes[_i6]];
	      }
	      behavior[lifeTimes[_i6]] = result;
	    }

	    behavior.ancestors.push(behavior);
	  }
	};

	BehaviorInner.initDefinitionFilter = function (options) {
	  var _options$behaviors = options.behaviors,
	      behaviors = _options$behaviors === undefined ? [] : _options$behaviors;

	  behaviors.forEach(function (behavioritem) {
	    behavioritem = BehaviorInner._list[behavioritem] || {};

	    var _behavioritem = behavioritem,
	        definitionFilter = _behavioritem.definitionFilter;

	    if (isFunction(definitionFilter)) {
	      definitionFilter(options, getBehaviorDefinitionFilter(behavioritem));
	    }
	  });
	};

	BehaviorInner.prototype.getAllLifeTimeFuncs = function () {
	  var ancestors = this.ancestors;
	  var allLifeTimeFuncs = {};
	  lifeTimes.forEach(function (lifeTime) {
	    for (var timefuncqueue = allLifeTimeFuncs[lifeTime] = queue$1.create('Lifetime Method'), i = 0; i < ancestors.length; i++) {
	      var func = ancestors[i][lifeTime];
	      func && timefuncqueue.add(func);
	    }
	  });
	  return allLifeTimeFuncs;
	};

	BehaviorInner.prototype.hasBehavior = function (behavior) {
	  this._unprepare && BehaviorInner.prepared(this);
	  for (var i = 0; i < this.ancestors.length; i++) {
	    if (behavior instanceof BehaviorInner) {
	      if (this.ancestors[i] === behavior) {
	        return true;
	      }
	    } else if (this.ancestors[i] === BehaviorInner._list[behavior]) {
	      return true;
	    }
	  }
	  return false;
	};

	function getBehaviorDefinitionFilter() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var _options$behaviors2 = options.behaviors,
	      behaviors = _options$behaviors2 === undefined ? [] : _options$behaviors2;

	  return behaviors.reduce(function () {
	    var prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var next = arguments[1];

	    next = BehaviorInner._list[next];

	    if (!next) {
	      return prev;
	    }

	    var _next = next,
	        definitionFilter = _next.definitionFilter;

	    if (isFunction(definitionFilter)) {
	      prev.push(function (defFields) {
	        definitionFilter(defFields, getBehaviorDefinitionFilter(next));
	      });
	    }
	    return prev;
	  }, []);
	}

	var pageLifeCycles$1 = ['onLoad', 'onReady', 'onShow', /* "onRouteEnd", */'onHide', 'onUnload'];
	var METHODS_CONST = {
	  onLoad: ['created', 'attached'],
	  onReady: ['ready'],
	  onShow: [],
	  onUnload: ['detached']
	};
	function createPageProxyComponent(registerOption, wvid, route) {
	  var component = new Component(registerOption, wvid, route, 0);
	  rewrite(component);

	  return component;
	}

	function rewrite(component) {
	  for (var fn in component) {
	    if (isFn(component[fn]) && pageLifeCycles$1.indexOf(fn) > -1) {
	      (function (fn) {
	        var oldFn = component[fn];
	        component[fn] = function (data) {
	          triggerLifeTimesProxy(component, fn, data);

	          oldFn.apply(component, Array.from(arguments));
	        };
	      })(fn);
	    }
	  }
	}

	function triggerLifeTimesProxy(component, eventName, data) {
	  var methods = METHODS_CONST[eventName];
	  if (methods && methods.length > 0) {
	    methods.forEach(function (method) {
	      triggerComponentLiftTimes(component, method, data);
	    });
	  }
	}

	function isPageInAppConfig(page) {
	  if (!TMAConfig.pages || !Array.isArray(TMAConfig.pages)) {
	    return false;
	  }

	  for (var i = 0; i < TMAConfig.pages.length; i++) {
	    if (TMAConfig.pages[i] === page) {
	      return true;
	    }
	  }

	  return false;
	}

	function hasProperty(object, property) {
	  // return Object.prototype.hasOwnProperty.call(Object.getPrototypeOf(object), property)
	  return Object.prototype.hasOwnProperty.call(object, property);
	}

	var currentPage;

	/**
	 * 存储开发者注册Page时传入的options
	 */
	var pageOptionsStorebyRoute = {};

	/**
	 *
	 */
	var currentPagesStack = [];

	/**
	 * C[wvid] = {
	    page: page2Instance,
	    route: route
	   };
	 */
	var C = {};

	var ComponentInstances$1 = {};
	// 共享实例
	ComponentInstancesSetter(ComponentInstances$1);

	/**
	 * ComponentInstances[wvid] = {
	 *  nodeid: {
	 *      instance: instance
	 *      route: route，
	 *      webviewId: webviewId,
	 *      status: detached || attached
	 *  }
	 * }
	 */

	// 生产环境不代理
	{
	  C = new Proxy({}, {
	    set: function set$$1(trapTarget, key, value, receiver) {
	      logger.log('[发生改变 C]', 'key:' + key, 'value:' + value, trapTarget);
	      return Reflect.set(trapTarget, key, value, receiver);
	    }
	  });
	  currentPagesStack = new Proxy([], {
	    set: function set$$1(trapTarget, key, value, receiver) {
	      logger.log('[发生改变 currentPagesStack]', 'key:' + key, 'value:' + value, trapTarget);
	      return Reflect.set(trapTarget, key, value, receiver);
	    }
	  });
	}

	// 拼接tab
	var tabPagePathes = [];
	var _tab_runned = false;
	function isTabpage(page) {
	  if (!_tab_runned) {
	    try {
	      TMAConfig.tabBar.list.forEach(function (tab) {
	        tabPagePathes.push(tab.pagePath);
	      });
	    } catch (ex) {
	      // do nothing.
	    }
	    _tab_runned = true;
	  }

	  return tabPagePathes.indexOf(page.route) !== -1;
	}

	var DEFAULT_ON_REACH_BOTTOM_DISTANCE = 50;
	function getDistance(pagepath) {
	  try {
	    if ('number' == typeof TMAConfig.page[pagepath + '.html'].window.onReachBottomDistance) {
	      return TMAConfig.page[pagepath + '.html'].window.onReachBottomDistance;
	    }
	  } catch (err) {
	    return DEFAULT_ON_REACH_BOTTOM_DISTANCE;
	  }
	  return DEFAULT_ON_REACH_BOTTOM_DISTANCE;
	}

	var firstRender = collect('firstRender', function (e, webviewId, usingCustomComponents, timestamp) {
	  var isPageReload = arguments.length > 4 && undefined !== arguments[4] && arguments[4];

	  logger.info('Update view with init data');

	  var pageInstance = e.page;

	  var ext = {};
	  ext.webviewId = webviewId;
	  ext.enablePullUpRefresh = hasProperty(pageInstance, 'onReachBottom');
	  ext.enablePageScroll = hasProperty(pageInstance, 'onPageScroll');
	  ext.onReachBottomDistance = getDistance(pageInstance.__route__);
	  ext.isPageReload = isPageReload;
	  ext.pageScrollTop = pageInstance.__pageScrollTop__;
	  // ext.scene = launchScene;
	  ext.route = pageInstance.__route__;
	  ext.query = pageInstance.options;
	  ext.lastRoute = e.lastRoute;
	  ext.lastQuery = e.lastQuery;
	  // 是否禁用滑动返回
	  ext.disableSwipeBack = TMAConfig.page[ext.route].window.disableSwipeBack;

	  /* global componentsDep */
	  // r2d2 生成的变量，{ 页面路径: [依赖的组件路径] }
	  var customComponents = null;
	  if ((typeof componentsDep === 'undefined' ? 'undefined' : _typeof(componentsDep)) === 'object') {
	    customComponents = {};
	    Array.isArray(componentsDep[pageInstance.__route__]) && componentsDep[pageInstance.__route__].forEach(function (componentPath) {
	      var component = pageOptionsStorebyRoute[componentPath];
	      if (!component) {
	        throw new Error('Component is not found in path "' + componentPath + '" (using by "' + pageInstance.__route__ + '")');
	      }

	      var newProperties = {};
	      Object.keys(component.properties).forEach(function (prop) {
	        newProperties[prop] = {
	          type: getTransFormType(component.properties[prop].type),
	          value: component.properties[prop].value
	        };
	      });

	      customComponents[component.is.replace('/', '')] = {
	        properties: newProperties,
	        data: component.data,
	        relationMap: component.relationMap,
	        ancestors: component.ancestors.map(function (ancestor) {
	          return ancestor.is;
	        })
	      };
	    });
	  }

	  ext.customComponents = customComponents;

	  var firstChangeData = {
	    data: pageInstance.data,
	    ext: ext,
	    options: {
	      firstRender: true,
	      usingCustomComponents: usingCustomComponents,
	      timestamp: timestamp,
	      path: pageInstance.__route__
	    }
	  };

	  invokeWebviewMethod({
	    name: 'appDataChange',
	    args: Object.assign({}, firstChangeData, {
	      complete: function complete() {}
	    }),
	    webviewIds: [webviewId]
	  });

	  // 记录 pageReady
	});

	function getPageOrComponentInstance(registerOption, wvid, route) {
	  var page2Instance = registerOption.__customConstructor__ === Component$1
	  // ? new page2({}, wvid, route)
	  ? createPageProxyComponent(registerOption, wvid, route) : new Page(registerOption, wvid, route);

	  if (registerOption.__customConstructor__ === Component$1) {
	    logger.log('component as page', page2Instance);
	  }
	  return page2Instance;
	}

	// 页面路由相关方法
	function createPage(route, wvid, query) {
	  var registerOption;
	  pageOptionsStorebyRoute.hasOwnProperty(route) ? registerOption = pageOptionsStorebyRoute[route] : (logger.warn('Page route 错误', 'Page[' + route + '] not found. May be caused by: 1. Forgot to add page route in app.json. 2. Invoking Page() in async task.'), registerOption = {});

	  var page2Instance = getPageOrComponentInstance(registerOption, wvid, route);

	  var _options = deepClone(query);

	  currentPage = {
	    page: page2Instance,
	    webviewId: wvid,
	    route: route,
	    lastRoute: currentPage ? currentPage.route : '',
	    lastQuery: currentPage ? currentPage.page.options : {},
	    node: undefined
	  };
	  currentPagesStack.push(currentPage);

	  page2Instance.options = _options;

	  firstRender(currentPage, wvid, false, Date.now());

	  // 显式调用
	  // 隐藏分享
	  if (!page2Instance.onShareAppMessage || typeof page2Instance.onShareAppMessage !== 'function') {
	    ttJSBridge.invoke('hideShareMenu');
	  }
	  page2Instance.onLoad(query);

	  page2Instance.onShow();
	  C[wvid] = {
	    page: page2Instance,
	    route: route
	  };
	}

	function beforeNavigate(e) {
	  e.page.onHide();
	  // 记录 leavePage
	}

	function beforeRedirect(opt) {
	  opt.page.onUnload();

	  delete C[opt.webviewId];
	  destroyComponentsInPage(opt.webviewId);

	  currentPagesStack = currentPagesStack.slice(0, currentPagesStack.length - 1);
	  // 记录 pageUnload
	  // 记录 leavePage
	}

	function oar_navigateTo(route, wvid, qurey) {
	  currentPage && beforeNavigate(currentPage);
	  C.hasOwnProperty(wvid) ? logger.error('Page route 错误(system error)', 'navigateTo with an already exist webviewId ' + wvid) : createPage(route, wvid, qurey);
	}

	function oar_redirectTo(route, wvid, query) {
	  currentPage && beforeRedirect(currentPage);
	  C.hasOwnProperty(wvid) ? logger.error('Page route 错误(system error)', 'redirectTo with an already exist webviewId ' + wvid) : createPage(route, wvid, query);
	}

	function oar_navigateBack(route, wvid) {
	  var targetPageFounded = false;
	  // IDE模式，取出要回退页面实例，然后用这个实例渲染
	  for (var n = currentPagesStack.length - 1; n >= 0; n--) {
	    var r = currentPagesStack[n];
	    if (r.webviewId === wvid) {
	      targetPageFounded = true;
	      currentPage = r;
	      r.page.onShow();
	      // 记录 enterPage
	      break;
	    }
	    beforeRedirect(r);
	  }
	  !targetPageFounded && logger.error('Page route 错误(system error)', 'navigateBack with an unexist webviewId ' + wvid);
	}

	function oar_switchTab(route, wvid, query) {
	  var hasMoreThanOnePageCleaned = true;
	  if (0 === currentPagesStack.length) {
	    return void logger.warn('Page route 错误', 'switchTab before pages are registered.');
	  }

	  // 从后往前 关闭所有页面，可能存在只有一个 page 的情形
	  for (; currentPagesStack.length > 1;) {
	    beforeRedirect(currentPagesStack[currentPagesStack.length - 1]);
	    hasMoreThanOnePageCleaned = false;
	  }

	  // 剩最后一个页面
	  // 如果是目标页面，onShow
	  // 不是目标页面的话
	  // 如果是某个 tab，bN，不是 tab，bR
	  // 如果记录里有，onShow，没有 cP
	  if (currentPagesStack[0].webviewId === wvid) {
	    currentPage = currentPagesStack[0];
	    hasMoreThanOnePageCleaned || currentPage.page.onShow();
	  } else if (isTabpage(currentPagesStack[0]) ? hasMoreThanOnePageCleaned && beforeNavigate(currentPagesStack[0]) : beforeRedirect(currentPagesStack[0]), C.hasOwnProperty(wvid)) {
	    var o = C[wvid].page;
	    currentPage = {
	      webviewId: wvid,
	      route: route,
	      page: o
	    }, currentPagesStack = [currentPage], o.onShow();
	    // 记录 enterPage
	    // 记录 switchTab
	  } else {
	    currentPagesStack = [];
	    createPage(route, wvid, query);
	  }
	}

	function oar_appLaunch(route, wvid, query) {
	  C.hasOwnProperty(wvid) ? logger.error('Page route 错误(system error)', 'appLaunch with an already exist webviewId ' + wvid) : createPage(route, wvid, query);
	}

	function oar_reLaunch(route, wvid, query) {
	  // 删除所有页面
	  for (; currentPagesStack.length > 0;) {
	    beforeRedirect(currentPagesStack[currentPagesStack.length - 1]);
	  }
	  createPage(route, wvid, query);
	}

	function destroyComponentsInPage(wvid) {
	  var allComponents = ComponentInstances$1[wvid] || {};

	  Object.entries(allComponents).forEach(function (_ref) {
	    var nodeid = _ref[0],
	        _ref$ = _ref[1],
	        instance = _ref$.instance,
	        status = _ref$.status;

	    if (status === 'attached') {
	      triggerComponentLiftTimes(instance, 'detached', {});
	    }
	  });

	  delete ComponentInstances$1[wvid];
	}

	// 非常非常重要的入口级方法
	function _onAppRoute(route, wvid, query, openType) {
	  logger.log('On app route: ' + route);
	  addTimingDot('pageRoute', Date.now());
	  if (openType === 'navigateTo') {
	    oar_navigateTo(route, wvid, query);
	  } else if (openType === 'redirectTo') {
	    oar_redirectTo(route, wvid, query);
	  } else if (openType === 'navigateBack') {
	    oar_navigateBack(route, wvid);
	  } else if (openType === 'switchTab') {
	    oar_switchTab(route, wvid, query);
	  } else if (openType === 'appLaunch') {
	    oar_appLaunch(route, wvid, query);
	  } else if (openType === 'reLaunch' || 'autoReLaunch' === openType) {
	    oar_reLaunch(route, wvid, query);
	  } else {
	    logger.error('Page route 错误(system error)', 'Illegal open type: ' + openType);
	  }
	}
	onAppRoute(collect('onAppRoute', function (ev) {
	  _onAppRoute(ev.path, ev.webviewId, ev.query || {}, ev.openType);
	}));

	// 监听页面重新加载
	// 一般来说，此消息在WkWebview崩溃时触发，客户端重新生成一个webview
	// service需要重新渲染对应页面即可
	function _onPageReload(wvid) {
	  logger.info('On page reload');

	  if (C.hasOwnProperty(wvid)) {
	    firstRender(C[wvid], wvid, false, Date.now(), true);
	  } else {
	    // TODO need report to serve
	    logger.error('Page reload(system error)', 'Can not find webviewId ' + wvid);
	  }
	}
	onPageReload(collect('onPageReload', function (ev) {
	  _onPageReload(ev.webviewId);
	}));

	// 响应webview事件，由webview触发的PAGE_EVENT分发过来的
	function _onWebviewEvent(wvid, nodeId, eventName, data) {
	  if (!C.hasOwnProperty(wvid)) {
	    logger.warn('事件警告', 'OnWebviewEvent: ' + eventName + ', WebviewId: ' + wvid + ' not found');
	    return;
	  }
	  var o = C[wvid],
	      pageInstance = o.page;
	  if (eventName === '__DOMReady') {

	    addTimingDot('pageRenderEnd', Date.now());
	    setPerformance();

	    logger.info('Invoke event onReady in page: ' + o.route);

	    pageInstance.onReady();
	    return;
	  }
	  logger.info('Invoke event ' + eventName + ' in page: ' + o.route);
	  return hasProperty(pageInstance, eventName) ? safeInvoke.call(pageInstance, eventName, data) : void logger.warn('事件警告', 'Do not have ' + eventName + ' handler in current page: ' + o.route + '. Please make sure that ' + eventName + ' handler has been defined in ' + o.route + ', or ' + o.route + ' has been added into app.json');
	}
	onWebviewEvent(collect('onWebviewEvent', function (ev) {
	  return _onWebviewEvent(ev.webviewId, ev.nodeId, ev.eventName, ev.data);
	}));

	function _onWebviewComponentCreate(nodeid, route, wvid) {
	  // logger.info('create custom component', nodeid, route, wvid);
	  var registerOption = getComponentRegisterOption(route);

	  var instance = new Component(registerOption, wvid, route, nodeid);
	  !ComponentInstances$1[wvid] && (ComponentInstances$1[wvid] = {});
	  ComponentInstances$1[wvid][nodeid] = {
	    instance: instance,
	    route: route,
	    webviewId: wvid,
	    // 标记是否attach，退出页面时，是否需要调用detached
	    status: 'attached'
	  };
	}

	function getComponentRegisterOption(route) {
	  var registerOption = void 0;
	  pageOptionsStorebyRoute.hasOwnProperty(route) ? registerOption = pageOptionsStorebyRoute[route] : (logger.warn('Component route 错误', 'Component[' + route + '] not found'), registerOption = {});
	  return registerOption;
	}
	function _onWebviewComponentEvent(wvid, nodeid, eventName, data) {
	  var route = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
	  var islifetime = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

	  if (nodeid === undefined) {
	    return;
	  }

	  if (!Array.isArray(data)) {
	    data = [data];
	  }

	  if (islifetime && eventName === 'created') {
	    _onWebviewComponentCreate(nodeid, route, wvid);
	  }

	  if (!ComponentInstances$1[wvid] || !ComponentInstances$1[wvid][nodeid]) {
	    return;
	  }

	  // switch detach attache
	  if (islifetime && ['attached', 'detached'].indexOf(eventName) > -1) {
	    ComponentInstances$1[wvid][nodeid]['status'] = eventName;
	  }

	  var instance = ComponentInstances$1[wvid][nodeid].instance;


	  if (islifetime) {
	    triggerComponentLiftTimes(instance, eventName, data);
	  } else {
	    var fn = instance[eventName];
	    if (isFn(fn)) {
	      fn.apply(instance, data);
	    } else {
	      logger.warn('Component "' + instance.__route__ + '" does not have a method "' + eventName + '"');
	    }
	  }
	}

	onWebviewComponentEvent(collect('onWebviewComponentEvent', function (ev) {
	  return _onWebviewComponentEvent(ev.webviewId, ev.nodeId, ev.eventName, ev.data, ev.route, ev.islifetime);
	}));

	// 监听自定义组件的数据传输
	onWebviewDataChange(collect('onWebviewDataChange', function (ev) {
	  var webviewId = ev.webviewId,
	      nodeId = ev.nodeId,
	      datatype = ev.datatype,
	      data = ev.data;


	  if (!ComponentInstances$1[webviewId] || !ComponentInstances$1[webviewId][nodeId]) {
	    return;
	  }

	  var instance = ComponentInstances$1[webviewId][nodeId].instance;


	  switch (datatype) {
	    case 'dataset':
	      instance.dataset = Object.assign({}, instance.dataset, data);

	      break;
	    case 'properties':
	      var oldData = instance.properties;

	      instance.data = instance.properties = Object.assign({}, instance.properties, data);

	      Object.keys(data).forEach(function (key) {
	        // if (!equal(data[key], oldData[key])) {
	        if (data[key] !== oldData[key]) {
	          var property = instance.__properties__[key];

	          if ((typeof property === 'undefined' ? 'undefined' : _typeof(property)) !== 'object') {
	            return;
	          }

	          var observer = property.observer;

	          if (typeof observer === 'string') {
	            observer = instance[observer];
	          }

	          if (isFn(observer)) {
	            observer.bind(instance)(data[key], oldData[key]);
	          }
	        }
	      });

	      break;
	  }
	}));

	// 监听自定义组件的关系变化
	onComponentRelationChange(collect('onComponentRelationChange', function (ev) {
	  var webviewId = ev.webviewId,
	      _ev$data = ev.data,
	      data = _ev$data === undefined ? [] : _ev$data;

	  var allNodes = ComponentInstances$1[webviewId];

	  if (!allNodes || !data) {
	    return;
	  }

	  data.forEach(function (_ref2) {
	    var nodeid = _ref2.nodeid,
	        originalKey = _ref2.originalKey,
	        target = _ref2.target,
	        type = _ref2.type;

	    var _ref3 = allNodes[target] || {},
	        targetNode = _ref3.instance;

	    var _ref4 = allNodes[nodeid] || {},
	        selfNode = _ref4.instance,
	        selfRoute = _ref4.route;

	    if (!targetNode || !selfNode) {
	      return;
	    }

	    try {
	      var selfRegisterOption = getComponentRegisterOption(selfRoute);
	      var callback = selfRegisterOption.relations[originalKey][type];
	      'function' === typeof callback && callback.call(selfNode, targetNode);
	    } catch (e) {
	      logger.log('执行用户指定回调异常， ', e);
	    }
	  });
	}));

	// onPullDownRefresh 事件接收到后调用开发者设置的 onPullDownRefresh 方法
	function onPullDownRefresh(webviewId) {
	  if (!C.hasOwnProperty(webviewId)) {
	    return;
	  }
	  var t = C[webviewId],
	      pageInstance = t.page;
	  if (hasProperty(pageInstance, 'onPullDownRefresh')) {
	    logger.info('Invoke event onPullDownRefresh in page: ' + t.route);
	    safeInvoke.call(pageInstance, 'onPullDownRefresh'); // 无参数调用
	    // 记录 pullDownRefresh
	  }
	}
	ttJSBridge.on('onPullDownRefresh', collect('onPullDownRefresh', function (ev, data) {
	  onPullDownRefresh(data);
	}));

	// share 部分
	// 点击菜单分享会直接调用 onShareAppMessage
	// 点击受控按钮会由 webview 触发 tapShareButton，然后再调用 onShareAppMessage
	// 接下来按照文档所描述，调用 Page 上的 onShareAppMessage，获得开发者设置的分享参数
	// 最终的 invoke 是 shareAppMessage
	function getCustomeShareOption(options, wvid) {
	  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' || options === null) {
	    options = {};
	  }

	  var USER_CALLBACK = 'onShareAppMessage';
	  var _page = C[wvid];
	  var _pagei = _page.page;
	  var result = Object.assign({}, options);

	  var currentPath = _page.route;
	  if (Object.keys(_pagei.options).length > 0) {
	    currentPath += '?' + Object.keys(_pagei.options).map(function (e) {
	      return e + '=' + encodeURIComponent(_pagei.options[e]);
	    }).join('&');
	  }
	  result.path = currentPath;

	  if (hasProperty(_pagei, USER_CALLBACK)) {
	    var input = {
	      from: options.from || 'menu',
	      target: options.target,
	      channel: options.channel,
	      webViewUrl: options.webviewUrl
	    };

	    // 封装客户端给的入参，调用用户设定的回调，获取用户设置的分享数据
	    var custom = safeInvoke.call(_pagei, USER_CALLBACK, input) || {};

	    // merge 结果
	    result = Object.assign(result, custom);
	  }

	  if (typeof result.path === 'string' && result.path !== '') {
	    if (result.path[0] === '/') {
	      result.path = result.path.substr(1);
	    }
	    result.path = encodeURIComponent(result.path);
	  }

	  // logger.log('SHARE_RESULT', result);

	  return result;
	}

	function onShareAppMessage() {
	  var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var wvid = arguments[1];

	  logger.log('onShareAppMessage事件监听1', arguments, currentPagesStack, C);

	  if (event === null) {
	    event = {};
	  }

	  if (!wvid) {
	    wvid = currentPagesStack[currentPagesStack.length - 1].webviewId;
	  }

	  if (!C[wvid]) {
	    return;
	  }

	  logger.log('onShareAppMessage事件监听2', event, wvid, C[wvid]);

	  // 获取用户设置的分享参 数
	  var option = getCustomeShareOption(event, wvid);

	  // 保证如果客户端传递了channel，调用客户端的时候仍然传递，不允许修改
	  if ('channel' in event) {
	    option.channel = event.channel;
	  }

	  // call native method
	  ttJSBridge.invoke('shareAppMessageDirectly', option, function (res) {
	    res.errMsg = res.errMsg.replace('shareAppMessageDirectly', 'shareAppMessage');

	    if (/^shareAppMessage:ok/.test(res.errMsg) && typeof option.success === 'function') {
	      surroundByTryCatch(option.success, 'shareAppMessageDirectly')(res);
	    } else if (/^shareAppMessage:cancel/.test(res.errMsg) && typeof option.fail === 'function') {
	      res.errMsg = 'shareAppMessage:fail cancel';
	      surroundByTryCatch(option.fail, 'shareAppMessageDirectly')(res);
	    } else if (/^shareAppMessage:fail/.test(res.errMsg) && typeof option.fail === 'function') {
	      surroundByTryCatch(option.fail, 'shareAppMessageDirectly')(res);
	    }
	    typeof option.complete === 'function' && surroundByTryCatch(option.complete, 'shareAppMessageDirectly')(res);
	  });
	}

	ttJSBridge.on('onShareAppMessage', collect('onShareAppMessage', onShareAppMessage));
	ttJSBridge.subscribe('tapShareButton', function () {
	  var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var wvid = arguments[1];

	  var sharedata = {
	    target: event.target,
	    from: 'button',
	    channel: event.channel
	  };
	  logger.log('tapShareButton sharedata', sharedata);
	  collect('onShareAppMessage', onShareAppMessage)(sharedata, wvid);
	});

	// 当一些特殊情况出现，会引起webview崩溃，导致页面白屏
	// native端检测到崩溃后会重起一个新的webview，销毁现在的webview
	ttJSBridge.on('onDestroyWebview', collect('onDestroyWebview', function (ev, wvid) {
	  if (!C.hasOwnProperty(wvid)) {
	    logger.warn('事件警告', 'destroy a no exist webview id: ' + wvid);
	    return;
	  }
	  var i = currentPagesStack.length - 1,
	      index = -1;
	  for (; i >= 0; i--) {
	    if (currentPagesStack[i].webviewId === wvid) {
	      index = i;
	      break;
	    }
	  }
	  index !== -1 && currentPagesStack.splice(index, 1);
	  delete C[wvid];
	  destroyComponentsInPage(wvid);
	}));

	// onWebViewWillManuallyTerminate 时由webview派发过来
	// scrollTop是页面退出时的状态
	// savePageState这里看只是一个记录，要知道C最后是怎么处理的
	ttJSBridge.subscribe('savePageState', collect('savePageState', function (ev, wvid) {
	  if (!C.hasOwnProperty(wvid)) {
	    logger.warn('事件警告', 'onPageWillManuallyTerminate WebviewId: ' + wvid + ' not found');
	    return;
	  }
	  C[wvid].page.__pageScrollTop__ = ev.scrollTop;
	}));

	/* global globPageRegistering 控制在某一个define中只能注册一次Page */
	/* global globPageRegistPath 当前define的path */
	function Page$1(options) {
	  /* eslint-disable no-global-assign */
	  if (!globPageRegistering) {
	    throw new AppServiceEngineKnownError('Can not declare more than one Page in same js file, otherwise will be ignore. see ' + globPageRegistPath + '.js');
	  }
	  globPageRegistering = false;

	  if (!isPageInAppConfig(globPageRegistPath)) {
	    throw new AppServiceEngineKnownError('Invalid path: ' + globPageRegistPath + ', it doesn\'t declared in app.json\'s pages attribue.');
	  }

	  if ('Object' !== getDataType$1(options)) {
	    throw new AppServiceEngineKnownError('Page\'s option must be an object, see ' + globPageRegistPath + '.js');
	  }
	  options.__customConstructor__ = Page$1;

	  logger.info('Add Page: ' + globPageRegistPath);
	  pageOptionsStorebyRoute[globPageRegistPath] = options;
	}

	function getCurrentPages$1() {
	  return currentPagesStack.map(function (i) {
	    return i.page;
	  });
	}

	function Component$1(options) {
	  if (getDataType$1(options) !== 'Object') {
	    logger.warn('Component\'s option must be an object, see ' + globPageRegistPath + '.js');
	    return;
	  }

	  var newOption = deepClone(options);

	  Object.assign(newOption, {
	    is: '/' + globPageRegistPath
	  });

	  var component = BehaviorInner.create(newOption);

	  // 格式化 relations 的 target
	  if (component.relations) {
	    var relations = {};
	    var relationMap = component.relationMap = {};

	    for (var i in component.relations) {
	      var relation = component.relations[i],
	          type = relation.type;

	      if (relation.target) {
	        relation.target = String(relation.target);
	      } else if (i.startsWith('/')) {
	        relation.target = i;
	      } else {
	        var pathArr = globPageRegistPath.split('/');
	        pathArr.pop();

	        for (var arr = i.split('/'); arr.length;) {
	          var path = arr.shift();
	          if (path !== '' && path !== '.') {
	            if (path === '..') {
	              pathArr.pop();
	            } else {
	              pathArr.push(path);
	            }
	          }
	        }

	        relation.target = '/' + pathArr.join('/');
	      }

	      // 方便 webview 发送事件到jsc
	      relation.originalKey = i;

	      relationMap[type] ? relationMap[type].push(relation) : relationMap[type] = [relation];

	      relations[i] = relation;
	    }

	    component.relations = relations;
	  }

	  component.__customConstructor__ = Component$1;

	  logger.info('Add Component: ' + globPageRegistPath);

	  pageOptionsStorebyRoute[globPageRegistPath] = component;
	}

	var __data__ = {};

	function normalizeaddata(data) {
	  return {
	    cid: data.cid || 0,
	    value: data.cid || 0,
	    app_id: data.aid || '',
	    user_id: data.user_id || '',
	    app_name: data.appName || '',
	    net_type: data.netType || '',
	    log_extra: data.log_extra || {},
	    device_id: data.device_id || '',
	    app_version: data.appVersion || '',
	    version_code: data.version_code || ''
	  };
	}

	function installTAQ() {
	  var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var toutiao_params = {};

	  if (query._toutiao_params) {
	    try {
	      toutiao_params = JSON.parse(query._toutiao_params);
	    } catch (err) {
	      logger.error('install TAQ error: ad data format error');
	    }
	  }

	  __data__ = normalizeaddata(toutiao_params);
	  logger.log('TAQ install', query, query._toutiao_params, toutiao_params, __data__);
	}

	function sendtoTAQ() {
	  var conversion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (!conversion.event_type) {
	    logger.error('send TAQ error: no conversion');
	    return;
	  }

	  var extraData = {
	    tag: 'embeded_ad',
	    label: 'convert',
	    source: 'mini program',
	    category: 'umeng',
	    is_ad_event: '1',
	    convert_id: conversion.convert_id || 0,
	    event_type: conversion.event_type || '',
	    event_value: conversion.event_value || ''
	  };
	  var data = Object.assign({}, __data__, extraData);
	  data.log_extra = JSON.stringify(data.log_extra);

	  logger.log('TAQ push', conversion, data);

	  invokeMethod('systemLog', {
	    tag: 'convert',
	    data: data
	  });
	}

	var localLaunchOptions = null;

	function getLaunchOptionsSync() {
	  if (!localLaunchOptions) {
	    invokeMethod('getLaunchOptionsSync', {}, {
	      beforeAll: function beforeAll(res) {
	        if (res.errMsg === 'getLaunchOptionsSync:ok') {
	          delete res.errMsg;
	          localLaunchOptions = res;
	        }
	      }
	    });
	  }

	  return localLaunchOptions;
	}

	var lifeCycles$1 = ['onLaunch', 'onShow', 'onHide', 'onUnlaunch'];

	var currentAppInstance;

	var CreateApp = function CreateApp(options) {
	  classCallCheck(this, CreateApp);

	  var that = this;

	  lifeCycles$1.forEach(function (life) {
	    that[life] = function () {
	      logger.info('App.' + life + ' invoked');

	      Reporter.__route__ = 'App';
	      Reporter.__method__ = life;
	      var result;
	      try {
	        result = (options[life] || noop$2).apply(that, arguments);
	      } catch (error$$1) {
	        Reporter.thirdErrorReport({
	          error: error$$1,
	          extend: 'at App lifeCycleMethod ' + life + ' function'
	        });
	      }
	      return result;
	    };
	  });

	  for (var key in options) {
	    if (lifeCycles$1.indexOf(key) === -1) {
	      if (typeof options[key] === 'function') {
	        (function (fname) {
	          that[fname] = function () {
	            var result;
	            try {
	              result = options[fname].apply(that, arguments);
	            } catch (error$$1) {
	              Reporter.thirdErrorReport({
	                error: error$$1,
	                extend: 'App.' + fname + ' error'
	              });
	            }
	            return result;
	          };
	        })(key);
	      } else {
	        that[key] = deepClone(options[key]);
	      }
	    }
	  }

	  if (typeof this.onError === 'function') {
	    Reporter.registerErrorListener(this.onError);
	  }

	  // 页面切到后台时，将最上层页面‘隐藏’，然后让App‘隐藏’
	  onAppEnterBackground$1(function () {
	    var pages = getCurrentPages$1();
	    if (pages.length) {
	      pages[pages.length - 1].onHide();
	    }

	    that.onHide();
	  });

	  // 页面切回前台时，先‘显示’App，再‘显示’最上层页面
	  // 忽略首次调用以保证冷启同步
	  var firstColdLaunch = true;
	  onAppEnterForeground(function () {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var willRoute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    if (firstColdLaunch) {
	      firstColdLaunch = false;
	      logger.info('onAppEnterFG触发app.onShow', '首次调用直接忽略以保证onShow同步');
	      return;
	    }
	    logger.info('onAppEnterFG触发app.onShow', param, willRoute ? '有applaunch事件，不会触发页面的onshow' : '');
	    that.onShow(param);

	    // hook ad log
	    installTAQ(param.query);

	    // willRoute 意味着接下来会有路由事件，此时不派发页面级别的 onShow
	    // e.g. 当从A页面切后台，从B页面进前台，此时不派发A的onShow
	    if (!willRoute) {
	      var pages = getCurrentPages$1();
	      if (pages.length) {
	        pages[pages.length - 1].onShow();
	      }
	    }
	  });

	  if (TMAConfig) {
	    // NOTE 客户端能够在收到JSCore的ready之前同步invoke的消息
	    TMAConfig.launch = getLaunchOptionsSync();

	    // 第一入口方法
	    this.onLaunch(TMAConfig.launch);

	    // hook ad log
	    if ('query' in TMAConfig.launch) {
	      installTAQ(TMAConfig.launch.query);
	    }

	    this.onShow(TMAConfig.launch);
	  } else {
	    logger.error('App Launch Error: NO Configuration.');
	  }
	};

	var App = collect('Initializing', function (param) {
	  currentAppInstance = new CreateApp(param);
	});

	function getApp() {
	  return currentAppInstance;
	}

	// all es6/es7 shim

	console.log('TMAConfig', TMAConfig);

	function exitMiniProgram() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('exitMiniProgram', param);
	}

	function reportNetworkAPI(api, url, result, duration, errMsg) {
	  Reporter.customReport({
	    tag: 'mp_net_request_result',
	    data: {
	      request_type: api,
	      // 不需要上报 query + hash
	      url: url.split('?')[0],
	      result: result,
	      duration: duration,
	      error_msg: result === 'fail' ? errMsg : ''
	    }
	  });
	}

	function createRequestTask() {
	  var that = this;
	  var param = requestParamStore.get(this);
	  var errMsg;

	  requestStatusStore.set(this, 'sending');
	  requestCreateTimeStore.set(this, Date.now());

	  invokeMethod('createRequestTask', {
	    data: param.data,
	    url: param.url,
	    header: param.header,
	    method: param.method,
	    responseType: param.responseType,
	    success: function success(res) {
	      requestTaskIdStore.set(that, res.requestTaskId);
	      concurrentRequestCount += 1;
	      requestInstances[res.requestTaskId] = that;
	    },
	    fail: function fail(res) {
	      errMsg = res.errMsg;
	      var duration = Date.now() - requestCreateTimeStore.get(that);
	      reportNetworkAPI('request', param.url, 'fail', duration, errMsg);
	    },
	    complete: function complete() {
	      requestStatusStore.set(that, 'done');
	    }
	  });

	  if (errMsg) {
	    setTimeout(function () {
	      var res = {
	        errMsg: errMsg.replace('createRequestTask', 'request')
	      };
	      typeof param.fail === 'function' && param.fail(res);
	      typeof param.complete === 'function' && param.complete(res);
	    }, 0);
	  } else {
	    emitter$1.on(requestTaskIdStore.get(this) + 'success', function (res) {
	      res.errMsg = 'request:ok';
	      if (typeof res.data == 'string' && res.data.charCodeAt(0) === 65279) {
	        res.data = res.data.substr(1);
	      }
	      if (param.dataType === 'json' && typeof res.data === 'string') {
	        try {
	          res.data = JSON.parse(res.data);
	        } catch (e) {}
	      }
	      res.statusCode = parseInt(res.statusCode);
	      if (_typeof(res.header) === 'object') {
	        res.header = Object.keys(res.header).reduce(function (obj, key) {
	          Array.isArray(res.header[key]) ? obj[key] = res.header[key].join(',') : 'string' == typeof res.header[key] && (obj[key] = res.header[key]);
	          return obj;
	        }, {});
	      }
	      'function' == typeof param.success && param.success(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	    emitter$1.on(requestTaskIdStore.get(this) + 'fail', function (res) {
	      res.errMsg = 'request:fail ' + res.errMsg;
	      'function' == typeof param.fail && param.fail(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	  }
	}

	var MAX_REQUEST_CONCURRENT = 5;
	var requestTaskIdCounter = 0;
	var waitingIdStore = new WeakMap();
	var requestTaskIdStore = new WeakMap();
	var requestStatusStore = new WeakMap();
	var requestParamStore = new WeakMap();
	var requestCreateTimeStore = new WeakMap();
	var concurrentRequestCount = 0;
	var waitingQueue = [];
	var requestInstances = {};
	var emitter$1 = new EventEmitter();

	// 监听客户端派发的状态变化事件
	onMethod('onRequestTaskStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var state = res.state,
	      taskId = res.requestTaskId;
	  delete res.state;
	  delete res.requestTaskId;
	  state !== 'success' && state !== 'fail' || (concurrentRequestCount -= 1, waitingQueue.length > 0 && createRequestTask.call(waitingQueue.shift().item)), emitter$1.emit('' + taskId + state, res);

	  if (state === 'success' || state === 'fail') {
	    var task = requestInstances[taskId];
	    if (task) {
	      try {
	        var url = requestParamStore.get(task).url;
	        var duration = Date.now() - requestCreateTimeStore.get(task);
	        reportNetworkAPI('request', url, state, duration, res.errMsg);
	      } catch (e) {}

	      delete requestInstances[taskId];
	      emitter$1.removeAllListeners(taskId + 'success');
	      emitter$1.removeAllListeners(taskId + 'fail');
	    }
	  }
	});

	/**
	 * @class RequestTask
	 */

	var Request$1 = function () {
	  function Request(param) {
	    classCallCheck(this, Request);

	    var id = requestTaskIdCounter++;
	    waitingIdStore.set(this, id);
	    requestStatusStore.set(this, 'waiting');
	    ['success', 'fail', 'complete'].forEach(function (status) {
	      if (typeof param[status] === 'function') {
	        param[status] = surroundByTryCatchFactory(param[status], 'at api request ' + status + ' callback function');
	      }
	    });
	    requestParamStore.set(this, param);

	    if (concurrentRequestCount >= MAX_REQUEST_CONCURRENT) {
	      return void waitingQueue.push({
	        id: id,
	        item: this
	      });
	    }

	    createRequestTask.call(this);
	  }

	  /**
	     * 结束正在执行的请求，如果请求在等待队列，则直接将其移除
	     * @memberof RequestTask
	     */


	  Request.prototype.abort = function abort() {
	    var that = this;
	    /* eslint-disable valid-typeof */
	    if (typeof requestStatusStore.get(this) == 'waiting') {
	      var idx = waitingQueue.findIndex(function (tmp) {
	        return tmp.id === waitingIdStore.get(that);
	      });
	      if (idx > -1) {
	        waitingQueue.splice(idx, 1);
	        concurrentRequestCount -= 1;
	      }
	      requestStatusStore.set(this, 'done');
	    } else {
	      invokeMethod('operateRequestTask', {
	        requestTaskId: requestTaskIdStore.get(that),
	        operationType: 'abort'
	      });
	    }
	  };

	  return Request;
	}();

	function factory() {

	  return function () {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (beforeInvoke('request', param, { url: '' })) {
	      if (!validateUrl(param.url)) {
	        beforeInvokeFail('request', param, 'invalid url "' + param.url + '"');
	        return;
	      }

	      if ('function' === param.data) {
	        beforeInvokeFail('request', param, 'data should not be Function');
	        return;
	      }

	      var headerDataType = getDataType(param.header);
	      param.header = param.header || {};
	      param.header = convertObjectValueToString(param.header);
	      if (headerDataType !== 'Undefined' && headerDataType !== 'Object') {
	        // console.warn("request: header must be an object");
	        param.header = {};
	      }
	      param.header = Object.keys(param.header).reduce(function (obj, key) {
	        key.toLowerCase() === 'content-type' ? obj[key.toLowerCase()] = param.header[key] : obj[key] = param.header[key];
	        return obj;
	      }, {});
	      var header = param.header || {};

	      var method = 'GET';
	      param.method && (param.method = param.method.toUpperCase());
	      typeof param.method === 'string' && (method = param.method.toUpperCase());

	      var responseType = 'text';
	      param.responseType && (responseType = param.responseType.toLowerCase());

	      var data;
	      param.dataType = param.dataType || 'json';
	      header['content-type'] = header['content-type'] || 'application/json';

	      if (param.data === undefined) {
	        data = '';
	      } else if (typeof param.data === 'string' || param.data instanceof ArrayBuffer) {
	        data = param.data;
	      } else if (header['content-type'].indexOf('application/x-www-form-urlencoded') > -1) {
	        data = urlEncodeFormData(param.data, true);
	      } else if (header['content-type'].indexOf('application/json') > -1) {
	        data = JSON.stringify(param.data);
	      } else if (_typeof(param.data) === 'object') {
	        data = JSON.stringify(param.data);
	      } else {
	        data = param.data.toString();
	      }

	      method == 'GET' && (param.url = addQueryStringToUrl(param.url, param.data));

	      try {
	        return new Request$1(Object.assign({}, param, {
	          header: header,
	          method: method,
	          responseType: responseType,
	          data: data
	        }));
	      } catch (error) {
	        beforeInvokeFail('request', error, error && error.message);
	      }
	    }
	  };
	}

	/**
	 * @function request
	 * @description
	 *   发起网络请求
	 * @param {object} param
	 * @param {string} param.url 开发者服务器接口地址
	 * @param {object|string|arraybuffer} [param.data] 请求的参数
	 *   注意：最终发给服务器的 data 是字符串
	 * @param {object} param.header 设置请求的 header，header 中不能设置 Referer
	 *   注意：根据 dataType，content-type 字段的值默认为 application/json。
	 * @param {string} [param.method = GET] 请求方法，暂时只支持 POST 和 GET
	 * @param {string} [param.dataType = json] 请求数据类型？
	 * @param {string} [param.responseType = text] 返回数据类型
	 * @param {requestSuccessCallback} param.success
	 * @param {function} param.fail
	 * @param {function} param.complete
	 * @returns {RequestTask}
	 * @example
	var requestTask = tt.request({
	  url: 'http://developer.bytedance.com/getlist',
	  data: {
	    a: '',
	    b: ''
	  },
	  header: {
	    'private-header': 'private/value'
	  },
	  success: function(res) {
	    logger.log(res.data)
	  }
	});
	requestTask.abort(); // 取消请求任务
	 *
	 */
	var request = factory();

	var uploadTaskIdStore = new WeakMap(),
	    uploadTaskParamStore = new WeakMap(),
	    uploadTaskCreateTimeStore = new WeakMap(),
	    uploadInstances = {},
	    emitter$2 = new EventEmitter();
	onMethod('onUploadTaskStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var state = res.state,
	      taskId = res.uploadTaskId;
	  delete res.state;
	  delete res.uploadTaskId;

	  emitter$2.emit('' + taskId + state, res);

	  if ('success' === state || 'fail' === state) {
	    var task = uploadInstances[taskId];
	    if (task) {
	      try {
	        var url = uploadTaskParamStore.get(task).url;
	        var duration = Date.now() - uploadTaskCreateTimeStore.get(task);
	        reportNetworkAPI('uploadFile', url, state, duration, res.errMsg);
	      } catch (e) {}

	      delete uploadInstances[taskId];
	      emitter$2.removeAllListeners(taskId + 'success');
	      emitter$2.removeAllListeners(taskId + 'fail');
	      emitter$2.removeAllListeners(taskId + 'progressUpdate');
	    }
	  }
	});

	/**
	 * @class UploadFileTask
	 */

	var Upload = function () {
	  function Upload(param) {
	    classCallCheck(this, Upload);

	    var that = this;
	    var errMsg;

	    ['success', 'fail', 'complete'].forEach(function (func) {
	      'function' == typeof param[func] && (param[func] = surroundByTryCatchFactory(param[func], 'at api uploadFile ' + func + ' callback function'));
	    });

	    uploadTaskParamStore.set(this, param);
	    uploadTaskCreateTimeStore.set(this, Date.now());

	    invokeMethod('createUploadTask', {
	      url: param.url,
	      header: param.header,
	      filePath: param.filePath,
	      name: param.name,
	      formData: param.formData,
	      success: function success(res) {
	        uploadTaskIdStore.set(that, res.uploadTaskId);
	        uploadInstances[res.uploadTaskId] = that;
	      },
	      fail: function fail(res) {
	        errMsg = res.errMsg;
	        var duration = Date.now() - uploadTaskCreateTimeStore.get(that);
	        reportNetworkAPI('uploadFile', param.url, 'fail', duration, errMsg);
	      },
	      complete: function complete() {}
	    });

	    if (errMsg) {
	      throw new Error(errMsg);
	    }

	    emitter$2.on(uploadTaskIdStore.get(this) + 'success', function (res) {
	      res.errMsg = 'uploadFile:ok';
	      res.statusCode = parseInt(res.statusCode);
	      -1 === [200, 304].indexOf(res.statusCode) && delete res.tempPath;
	      'function' == typeof param.success && param.success(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	    emitter$2.on(uploadTaskIdStore.get(this) + 'fail', function (res) {
	      res.errMsg = 'uploadFile:fail ' + res.errMsg;
	      'function' == typeof param.fail && param.fail(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	  }

	  /**
	     * 中断上传任务
	     * @memberof UploadFileTask
	     */


	  Upload.prototype.abort = function abort() {
	    invokeMethod('operateUploadTask', {
	      uploadTaskId: uploadTaskIdStore.get(this),
	      operationType: 'abort'
	    });
	  };

	  /**
	     * 监听上传进度变化
	     * @memberof UploadFileTask
	     * @param {uploadFileOnProgressUpdateCallback} callback 回调方法
	     */


	  Upload.prototype.onProgressUpdate = function onProgressUpdate(callback) {
	    emitter$2.on(uploadTaskIdStore.get(this) + 'progressUpdate', function (t) {
	      'function' == typeof callback && surroundByTryCatchFactory(callback, 'at UploadTask.onProgressUpdate callback function')(t);
	    });
	  };

	  return Upload;
	}();

	/**
	 * @function uploadFile
	 * @description 将本地资源上传到开发者服务器
	 * @param {object} param
	 * @param {string} param.url 开发者服务器 url
	 * @param {string} param.filePath 要上传文件资源的路径
	 * @param {string} param.name 文件对应的 key , 开发者在服务器端通过这个 key 可以获取到文件二进制内容
	 * @param {object} [param.header] HTTP 请求 Header, header 中不能设置 Referer
	 * @param {object} [param.formData] HTTP 请求中其他额外的 form data
	 * @param {uploadFileSuccessCallback} [param.success] 上传成功的回调方法
	 * @example
	tt.chooseImage({
	  success: function(res) {
	    var tempFilePaths = res.tempFilePaths
	    tt.uploadFile({
	      url: 'https://a.com/upload/', //仅为示例，非真实的接口地址
	      filePath: tempFilePaths[0],
	      name: 'file',
	      formData:{
	        'user': 'test'
	      },
	      success: function(res){
	        var data = res.data
	        //do something
	      }
	    })
	  }
	});
	 * @example
	const uploadTask = tt.uploadFile({
	    url: 'http://a.com/upload', //仅为示例，非真实的接口地址
	    filePath: tempFilePaths[0],
	    name: 'file',
	    formData:{
	        'user': 'test'
	    },
	    success: function(res){
	        var data = res.data
	        //do something
	    }
	})
	uploadTask.onProgressUpdate((res) => {
	    logger.log('上传进度', res.progress)
	    logger.log('已经上传的数据长度', res.totalBytesSent)
	    logger.log('预期需要上传的数据总长度', res.totalBytesExpectedToSend)
	})
	uploadTask.abort() // 取消上传任务
	 * @returns {UploadFileTask}
	 */


	function uploadFile() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('uploadFile', param, {
	    url: '',
	    filePath: '',
	    name: ''
	  })) {
	    if (_typeof(param.header) !== 'object' && param.header !== undefined) {
	      logger.warn('uploadFile: header must be an object');
	      delete param.header;
	    }

	    if (_typeof(param.formData) !== 'object' && param.formData !== undefined) {
	      logger.warn('uploadFile: formData must be an object');
	      delete param.formData;
	    }

	    var headerString = param.header ? convertObjectValueToString(param.header) : {};
	    var formDataString = param.formData ? convertObjectValueToString(param.formData) : {};

	    try {
	      return new Upload(Object.assign({}, param, {
	        header: headerString,
	        formData: formDataString
	      }));
	    } catch (ex) {
	      beforeInvokeFail('uploadFile', param, ex.message);
	    }
	  }
	}

	function createDownloadTask() {
	  var param = downloadTaskParamStore.get(this);

	  downloadTaskStateStore.set(this, 'sending');
	  downloadTaskCreateTimeStore.set(this, Date.now());
	  var that = this;
	  var errMsg;
	  invokeMethod('createDownloadTask', {
	    url: param.url,
	    header: param.header,
	    filePath: param.filePath,
	    success: function success(res) {

	      downloadTaskIdStore.set(that, res.downloadTaskId);
	      concurrentDownload += 1;
	      downloadInstances[res.downloadTaskId] = that;
	    },
	    fail: function fail(res) {
	      errMsg = res.errMsg;
	      var duration = Date.now() - downloadTaskCreateTimeStore.get(that);
	      reportNetworkAPI('downloadFile', param.url, 'fail', duration, errMsg);
	    },
	    complete: function complete() {
	      downloadTaskStateStore.set(this, 'done');
	    }
	  });
	  if (errMsg) {
	    setTimeout(function () {
	      var res = {
	        errMsg: errMsg.replace('createDownloadTask', 'downloadFile')
	      };
	      'function' == typeof param.fail && param.fail(res);
	      'function' == typeof param.complete && param.complete(res);
	    }, 0);
	  } else {

	    emitter$3.on(downloadTaskIdStore.get(this) + 'success', function (res) {

	      res.errMsg = 'downloadFile:ok';
	      res.statusCode = parseInt(res.statusCode);
	      -1 === [200, 304].indexOf(res.statusCode) && delete res.tempPath;
	      delete res.timeInterval;

	      'function' == typeof param.success && param.success(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	    emitter$3.on(downloadTaskIdStore.get(this) + 'fail', function (res) {
	      res.errMsg = 'downloadFile:fail ' + res.errMsg;
	      'function' == typeof param.fail && param.fail(res);
	      'function' == typeof param.complete && param.complete(res);
	    });
	  }
	}

	var maxDownloadConcurrent = 5;

	var idCounter = 0,
	    instanceIdStore = new WeakMap(),
	    downloadTaskIdStore = new WeakMap(),
	    downloadTaskStateStore = new WeakMap(),
	    downloadTaskParamStore = new WeakMap(),
	    downloadTaskCreateTimeStore = new WeakMap(),
	    concurrentDownload = 0,
	    waitingQueue$1 = [],
	    downloadInstances = {},
	    emitter$3 = new EventEmitter();

	onMethod('onDownloadTaskStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (typeof res === 'string') {
	    res = JSON.parse(res);
	  }
	  var state = res.state,
	      downloadTaskId = res.downloadTaskId;
	  delete res.state;
	  delete res.downloadTaskId;

	  emitter$3.emit('' + downloadTaskId + state, res);

	  if (state === 'success' || state === 'fail') {
	    concurrentDownload -= 1;
	    waitingQueue$1.length > 0 && createDownloadTask.call(waitingQueue$1.shift().item);

	    var task = downloadInstances[downloadTaskId];

	    if (task) {
	      try {
	        var url = downloadTaskParamStore.get(task).url;
	        var duration = Date.now() - downloadTaskCreateTimeStore.get(task);
	        reportNetworkAPI('downloadFile', url, state, duration, res.errMsg);
	      } catch (e) {}

	      delete downloadInstances[downloadTaskId];

	      emitter$3.removeAllListeners(downloadTaskId + 'success');
	      emitter$3.removeAllListeners(downloadTaskId + 'fail');
	      emitter$3.removeAllListeners(downloadTaskId + 'progressUpdate');
	    }
	  }
	});

	/**
	 * @class downloadFileTask
	 */

	var Download = function () {
	  function Download(param) {
	    classCallCheck(this, Download);

	    var id = idCounter++;
	    instanceIdStore.set(this, id);

	    downloadTaskStateStore.set(this, 'waiting');

	    ['success', 'fail', 'complete'].forEach(function (func) {
	      'function' == typeof param[func] && (param[func] = surroundByTryCatchFactory(param[func], 'at api downloadFile ' + func + ' callback function'));
	    });

	    downloadTaskParamStore.set(this, param);

	    if (concurrentDownload >= maxDownloadConcurrent) {
	      waitingQueue$1.push({
	        id: id,
	        item: this
	      });
	      return;
	    }

	    createDownloadTask.call(this);
	  }

	  /**
	   * 中断下载任务
	   * @memberOf downloadFileTask
	   */


	  Download.prototype.abort = function abort() {
	    invokeMethod('operateDownloadTask', {
	      downloadTaskId: downloadTaskIdStore.get(this),
	      operationType: 'abort'
	    });
	  };

	  /**
	   * 监听下载进度变化
	   * @memberof downloadFileTask
	   * @param {downloadFileOnProgressUpdateCallback} callback 回调方法
	   */


	  Download.prototype.onProgressUpdate = function onProgressUpdate(cb) {
	    emitter$3.on(downloadTaskIdStore.get(this) + 'progressUpdate', function (res) {
	      'function' == typeof cb && surroundByTryCatchFactory(cb, 'at DownloadTask.onProgressUpdate callback function')(res);
	    });
	  };

	  return Download;
	}();

	/**
	 * @function downloadFile
	 * @description 下载文件资源到本地，返回文件的本地临时路径。
	 * @param {*} param
	 * @param {string} param.url 下载资源的 url
	 * @param {object} [param.header] HTTP 请求 Header，header 中不能设置 Referer
	 * @param {downloadFileSuccessCallback} [param.success] 下载成功回调函数
	 * @returns {downloadFileTask}
	 * @example
	 const downloadTask = tt.downloadFile({
	    url: 'http://a.com/sample',
	    success: function(res) {
	        logger.log(res.tempFilePath);
	    }
	})
	 downloadTask.onProgressUpdate((res) => {
	    logger.log('下载进度', res.progress)
	    logger.log('已经下载的数据长度', res.totalBytesWritten)
	    logger.log('预期需要下载的数据总长度', res.totalBytesExpectedToWrite)
	})
	 downloadTask.abort() // 取消下载任务
	 */


	function downloadFile() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('downloadFile', param, {
	    url: ''
	  })) {
	    try {
	      return new Download(param);
	    } catch (ex) {
	      beforeInvokeFail('downloadFile', param, ex.message);
	    }
	  }
	}

	var acounter = 0,
	    counterStore = new WeakMap(),
	    taskIdStore = new WeakMap(),
	    paramStore = new WeakMap();

	var socketTaskMap = {};
	var emitter$4 = new EventEmitter();

	onMethod("onSocketTaskStateChange", function () {
	    var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    var state = res.state,
	        socketTaskId = res.socketTaskId,
	        task = socketTaskMap[socketTaskId],
	        counter = counterStore.get(task);
	    delete res.state;
	    delete res.socketTaskId;
	    if (task) {
	        "open" === state ? task.readyState = task.OPEN : "close" !== state && "error" !== state || (task.readyState = task.CLOSED);
	        // @important!
	        // task 上监听 3close 4message
	        // tt 上监听 onSocketClose
	        emitter$4.emit("" + counter + state, res);
	        emitter$4.emit("onSocket" + (state[0].toUpperCase() + state.substr(1)), res, task);

	        "close" === state && (delete socketTaskMap[socketTaskId], emitter$4.removeAllListeners(counter + "open"), emitter$4.removeAllListeners(counter + "close"), emitter$4.removeAllListeners(counter + "error"), emitter$4.removeAllListeners(counter + "message"));
	    }
	});

	var listeneTaskStateChange = function listeneTaskStateChange(cmd, callback) {
	    counterStore.get(this);
	    emitter$4.on("" + counterStore.get(this) + cmd, surroundByTryCatchFactory(callback, "at socketTask.on" + cmd + " callback function"));
	};

	/**
	 * @class SocketTask
	 */
	var SocketTask = function () {
	    function SocketTask(instanceKey, param) {
	        classCallCheck(this, SocketTask);

	        var instance = this;

	        this.CONNECTING = 0;
	        this.OPEN = 1;
	        this.CLOSING = 2;
	        this.CLOSED = 3;

	        this.readyState = this.CONNECTING;

	        var counter = acounter++;

	        counterStore.set(this, counter);
	        paramStore.set(this, param);

	        Object.defineProperty(this, "__socketInstance__", {
	            value: instanceKey,
	            writable: !1,
	            configurable: !1,
	            enumerable: !1
	        });

	        ["success", "fail", "complete"].forEach(function (e) {
	            "function" == typeof param[e] && (param[e] = surroundByTryCatchFactory(param[e], "at api connectSocket " + e + " callback function"));
	        });

	        var ifFailed;
	        invokeMethod("createSocketTask", param, {
	            beforeAll: function beforeAll(res) {
	                res.errMsg = res.errMsg.replace("createSocketTask", "connectSocket");
	            },
	            beforeSuccess: function beforeSuccess(res) {
	                taskIdStore.set(instance, res.socketTaskId), socketTaskMap[res.socketTaskId] = instance;
	            },
	            beforeFail: function beforeFail(e) {
	                ifFailed = e.errMsg;
	            }
	        });
	        ifFailed && (this.readyState = this.CLOSED, setTimeout(function () {
	            emitter$4.emit(counter + "error", {
	                errMsg: ifFailed
	            });
	        }, 0));
	    }

	    /**
	     * 发送数据
	     * @memberOf SocketTask
	     * @param {object} param 
	     * @param {string|arraybuffer} param.data 要发送的数据
	     */


	    SocketTask.prototype.send = function send(param) {
	        if (this.readyState === this.OPEN) {
	            var copyParam = Object.assign({}, param);
	            "android" === getPlatform() && void 0 !== param.data && param.data instanceof ArrayBuffer && void 0 !== param.data.byteLength && param.data.byteLength > 0 && (copyParam.__nativeBuffers__ = [{
	                key: "data",
	                base64: arrayBufferToBase64(param.data)
	            }], delete copyParam.data);

	            invokeMethod("operateSocketTask", Object.assign({}, copyParam, {
	                operationType: "send",
	                socketTaskId: taskIdStore.get(this)
	            }), {
	                beforeAll: function beforeAll(e) {
	                    e.errMsg = e.errMsg.replace("operateSocketTask", "sendSocketMessage");
	                }
	            });
	        } else {
	            beforeInvokeFail("SocketTask.send", param, "SocketTask.readState is not OPEN");
	        }
	    };

	    /**
	     * 关闭 WebSocket 连接
	     * @memberOf SocketTask
	     * @param {object} param 
	     * @param {number} [param.code=1000] 一个数字值表示关闭连接的状态号，表示连接被关闭的原因。
	     * @param {string} [param.reason] 一个可读的字符串，表示连接被关闭的原因。这个字符串必须是不长于123字节的UTF-8 文本（不是字符）
	     */


	    SocketTask.prototype.close = function close() {
	        var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        invokeMethod("operateSocketTask", Object.assign({}, param, {
	            operationType: "close",
	            code: 1e3,
	            socketTaskId: taskIdStore.get(this)
	        }), {
	            beforeAll: function beforeAll(e) {
	                e.errMsg = e.errMsg.replace("operateSocketTask", "closeSocket");
	            }
	        });
	    };

	    /**
	     * 监听 WebSocket 连接打开事件
	     * @memberOf SocketTask
	     * @param {function} cb 回调方法
	     */


	    SocketTask.prototype.onOpen = function onOpen(cb) {
	        listeneTaskStateChange.call(this, "open", cb);
	    };

	    /**
	     * 监听 WebSocket 连接关闭事件
	     * @memberOf SocketTask
	     * @param {function} cb 回调方法
	     */


	    SocketTask.prototype.onClose = function onClose(cb) {
	        listeneTaskStateChange.call(this, "close", cb);
	    };

	    /**
	     * 监听WebSocket接受到服务器的消息事件
	     * @memberOf SocketTask
	     * @param {function} cb 回调方法
	     */


	    SocketTask.prototype.onMessage = function onMessage(cb) {
	        listeneTaskStateChange.call(this, "message", cb);
	    };

	    /**
	     * 监听 WebSocket 错误
	     * @memberOf SocketTask
	     * @param {function} cb 回调方法
	     */


	    SocketTask.prototype.onError = function onError(cb) {
	        listeneTaskStateChange.call(this, "error", cb);
	    };

	    return SocketTask;
	}();

	function onSocket(instanceKey, cmd) {
	    if (!commandCallbackMap[cmd]) {
	        commandCallbackMap[cmd] = new WeakMap();
	        emitter$4.on("onSocket" + cmd, _check(cmd));
	    }

	    return function (callback) {
	        beforeInvoke("onSocket" + cmd, callback, noop) && commandCallbackMap[cmd].set(instanceKey, callback);
	    };
	}

	function _check(cmd) {
	    return function (res, task) {
	        var instanceKey = task.__socketInstance__,
	            cb = commandCallbackMap[cmd].get(instanceKey),
	            originTask = socketTaskPool.get(instanceKey);
	        cb && task === originTask && surroundByTryCatchFactory(cb, "at onSocket" + cmd + " callback function")(res);
	    };
	}

	var socketTaskPool = new WeakMap();
	var commandCallbackMap = {};
	var factory$1 = function factory() {

	    var instanceKey = {};

	    return {
	        /**
	         * @function connectSocket
	         * @description 创建一个 WebSocket 连接
	         * @param {object} param
	         * @param {string} param.url 开发者服务器接口地址，必须是 wss 协议，且域名必须是后台配置的合法域名
	         * @param {object} [param.header] HTTP Header , header 中不能设置 Referer
	         * @param {string} [param.method=GET] OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT
	         * @param {string[]} [param.protocols] 子协议数组
	         * @returns {SocketTask}
	         */
	        connectSocket: function connectSocket(param) {
	            if (beforeInvoke("connectSocket", param, {
	                url: ""
	            })) {
	                if (!validateUrl(param.url, "websocket")) {
	                    return void beforeInvokeFail("request", param, 'invalid url "' + param.url + '"');
	                }

	                _typeof(param.header) !== 'object' && param.header !== undefined && delete param.header;
	                var headerString = {};
	                param.header && (headerString = convertObjectValueToString(param.header));

	                try {
	                    var oldTask = socketTaskPool.get(instanceKey),
	                        socketTask = new SocketTask(instanceKey, Object.assign({}, param, {
	                        header: headerString
	                    }));
	                    oldTask && oldTask.readyState !== oldTask.CLOSED || socketTaskPool.set(instanceKey, socketTask);
	                    return socketTask;
	                } catch (ex) {
	                    beforeInvokeFail("connectSocket", param, ex.message);
	                }
	            }
	        },
	        closeSocket: function closeSocket(param) {
	            var socketTask = socketTaskPool.get(instanceKey);
	            socketTask && socketTask.readyState !== socketTask.CLOSED ? (socketTask.readyState = socketTask.CLOSED, socketTask.close(param)) : beforeInvokeFail("closeSocket", param, "WebSocket is not connected");
	            for (key in socketTaskMap) {
	                var r = socketTaskMap[key];
	                r.__socketInstance__ === instanceKey && (r.readyState = r.CLOSED, r !== socketTask && r.close());
	            }
	        },
	        sendSocketMessage: function sendSocketMessage(param) {
	            var socketTask = socketTaskPool.get(instanceKey);
	            socketTask && socketTask.readyState === socketTask.OPEN ? socketTask.send(param) : beforeInvokeFail("sendSocketMessage", param, "WebSocket is not connected");
	        },
	        onSocketOpen: onSocket(instanceKey, "Open"),
	        onSocketClose: onSocket(instanceKey, "Close"),
	        onSocketMessage: onSocket(instanceKey, "Message"),
	        onSocketError: onSocket(instanceKey, "Error")
	    };
	};

	var socket = factory$1();

	/**
	 * @function chooseImage
	 * @description 从本地相册选择图片或使用相机拍照
	 *
	 * @param {object} param
	 * @param {number} [param.count=9] 最多可以选择的图片张数
	 * @param {string[]} [param.sizeType=['original','compressed']] original 原图，compressed 压缩图
	 * @param {string[]} [param.sourceType=['album', 'camera']] album 从相册选图，camera 使用相机
	 * @param {chooseImageSuccessCallback} [param.success] 成功则返回图片的本地文件路径列表 tempFilePaths
	 * @example
	tt.chooseImage({
	  count: 1, // 默认9
	  sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有
	  sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有
	  success: function (res) {
	    // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片
	    var tempFilePaths = res.tempFilePaths
	  }
	})
	 */
	function chooseImage() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('chooseImage', assign$1({
	    count: 9,
	    sizeType: ['original', 'compressed'],
	    sourceType: ['album', 'camera']
	  }, param), {
	    beforeSuccess: function beforeSuccess(res) {
	      if (res.tempFileSizes) {
	        res.tempFiles = res.tempFilePaths.map(function (path, idx) {
	          return {
	            path: path,
	            size: res.tempFileSizes[idx]
	          };
	        });
	      }
	      delete res.tempFileSizes;
	    }
	  });
	}

	/**
	 * chooseImage success callback
	 * @callback chooseImageSuccessCallback
	 * @param {object} response
	 * @param {string[]} response.tempFilePaths 图片的本地文件路径列表
	 * @param {object[]} response.tempFiles 图片的本地文件列表，每一项是一个 File 对象
	 * @param {string} response.tempFiles[].path 本地文件路径
	 * @param {number} response.tempFiles[].size 本地文件大小，单位：B
	 */

	/**
	 * @function previewImage
	 * @description 预览图片
	 * @param {object} param
	 * @param {string[]} param.urls 需要预览的图片链接列表
	 * @param {string} [param.current] 当前显示图片的链接，不填则默认为 urls 的第一张
	 */
	function previewImage() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('previewImage', param, {
	    urls: ['']
	  })) {
	    if (param.urls) {
	      param.urls = param.urls.map(function (item) {
	        return FakeTempFilePathMap.get(item) || item;
	      });
	    }
	    invokeMethod('previewImage', param);
	  }
	}

	/**
	 * @function getImageInfo
	 * @description 获取图片信息
	 * @param {object} param
	 * @param {string} param.src 图片的路径，可以是相对路径，临时文件路径，存储文件路径，网络图片路径
	 * @param {getImageInfoSuccessCallback} param.success 成功回调
	 */
	function getImageInfo(param) {
	  if (beforeInvoke('getImageInfo', param, {
	    src: ''
	  })) {

	    if (/^(http|https):\/\//.test(param.src)) {
	      downloadFile({
	        url: param.src,
	        success: function success(res) {
	          param.src = res.tempFilePath;
	          invokeMethod('getImageInfo', param, {
	            beforeSuccess: function beforeSuccess(res2) {
	              res2.path = param.src;
	            }
	          });
	        },
	        fail: function fail(res) {
	          beforeInvokeFail('getImageInfo', param, 'download image fail');
	        }
	      });
	    } else if (/^(tt)?file:\/\//.test(param.src)) {
	      invokeMethod('getImageInfo', param, {
	        beforeSuccess: function beforeSuccess(res) {
	          res.path = param.src;
	        }
	      });
	    } else {
	      param.src = getRealRoute(LifecycleState$1.path, param.src, !1);
	      invokeMethod('getImageInfo', param, {
	        beforeSuccess: function beforeSuccess(res) {
	          res.path = param.src;
	        }
	      });
	    }
	  }
	}

	/**
	 * getImageInfo success callback
	 * @callback getImageInfoSuccessCallback
	 * @param {object} response
	 * @param {number} response.width 图片宽度，单位px
	 * @param {number} response.height 图片高度，单位px
	 * @param {string} response.path 返回图片的本地路径
	 */

	/**
	 * @function saveImageToPhotosAlbum
	 * @description 保存图片到系统相册
	 * @param {object} param
	 * @param {string} param.filePath 图片文件路径，可以是临时文件路径也可以是永久文件路径，不支持网络图片路径
	 */
	function saveImageToPhotosAlbum() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  param.filePath = FakeTempFilePathMap.get(param.filePath) || param.filePath;
	  invokeMethod('saveImageToPhotosAlbum', param, {});
	}

	var GlobalEmitter = new EventEmitter();
	var FakeTempFilePathMap = {
	  map: {},
	  set: function set(path) {
	    var id = guid();
	    this.map[id] = path;
	    return id;
	  },
	  get: function get(path) {
	    return this.map[path];
	  }
	};

	var eventEmitter = new EventEmitter();
	var VALID_RATES = {
	  8000: [16000, 48000],
	  11025: [16000, 48000],
	  12000: [24000, 64000],
	  16000: [24000, 96000],
	  22050: [32000, 128000],
	  24000: [32000, 128000],
	  32000: [48000, 192000],
	  44100: [64000, 320000],
	  48000: [64000, 320000]
	};
	var VALID_SAMPLE_RATES = Object.keys(VALID_RATES).map(function (rate) {
	  return parseInt(rate);
	});

	onMethod('onRecorderStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var state = res.state;
	  delete res.state;
	  eventEmitter.emit('onRecorderStateChange_' + state, res);
	});

	function operateRecorder(param) {
	  invokeMethod('operateRecorder', Object.assign({}, param));
	}

	var RecorderManager = {
	  start: function start() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    var invokeParam = Object.assign({
	      format: 'aac',
	      sampleRate: 8000,
	      encodeBitRate: 48000,
	      numberOfChannels: 2,
	      duration: 60000
	    }, param, {
	      operationType: 'start',
	      fail: function fail(e) {
	        eventEmitter.emit('onRecorderStateChange_error', e);
	      }
	    });

	    if (VALID_SAMPLE_RATES.indexOf(invokeParam.sampleRate) === -1) {
	      throw new Error('invalid sampleRate "' + invokeParam.sampleRate + '", sampleRate should be one of ' + JSON.stringify(Object.keys(VALID_RATES)));
	    }

	    if (invokeParam.encodeBitRate > VALID_RATES[invokeParam.sampleRate][1] || invokeParam.encodeBitRate < VALID_RATES[invokeParam.sampleRate][0]) {
	      throw new Error('invalid encodeBitRate "' + invokeParam.encodeBitRate + '", encodeBitRate should be greater than ' + VALID_RATES[invokeParam.sampleRate][0] + ' and less than ' + VALID_RATES[invokeParam.sampleRate][1]);
	    }

	    if (invokeParam.duration > 600000 || invokeParam.duration < 0) {
	      invokeParam.duration = 60000;
	    }

	    operateRecorder(invokeParam);
	  },
	  pause: function pause() {
	    operateRecorder({
	      operationType: 'pause',
	      fail: function fail(err) {
	        eventEmitter.emit('onRecorderStateChange_error', err);
	      }
	    });
	  },
	  resume: function resume() {
	    operateRecorder({
	      operationType: 'resume',
	      success: function success() {
	        eventEmitter.emit('onRecorderStateChange_resume');
	      },
	      fail: function fail(err) {
	        eventEmitter.emit('onRecorderStateChange_error', err);
	      }
	    });
	  },
	  stop: function stop() {
	    operateRecorder({
	      operationType: 'stop',
	      fail: function fail(err) {
	        eventEmitter.emit('onRecorderStateChange_error', err);
	      }
	    });
	  },
	  onStart: function onStart(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_start');
	    eventEmitter.on('onRecorderStateChange_start', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onPause callback function')(res);
	      }
	    });
	  },
	  onResume: function onResume(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_resume');
	    eventEmitter.on('onRecorderStateChange_resume', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onResume callback function')(res);
	      }
	    });
	  },
	  onPause: function onPause(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_pause');
	    eventEmitter.on('onRecorderStateChange_pause', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onPause callback function')(res);
	      }
	    });
	  },
	  onStop: function onStop(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_stop');
	    eventEmitter.on('onRecorderStateChange_stop', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onStop callback function')(res);
	      }
	    });
	  },
	  onFrameRecorded: function onFrameRecorded(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_frameRecorded');
	    eventEmitter.on('onRecorderStateChange_frameRecorded', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onFrameRecorded callback function')(res);
	      }
	    });
	  },
	  onError: function onError(callback) {
	    eventEmitter.removeAllListeners('onRecorderStateChange_error');
	    eventEmitter.on('onRecorderStateChange_error', function (res) {
	      if (typeof callback === 'function') {
	        surroundByTryCatchFactory(callback, 'at recorderManager.onError callback function')(res);
	      }
	    });
	  }
	};

	function getRecorderManager() {
	  return RecorderManager;
	}

	var AudioPool = function () {
	  function AudioPool(maxSize, timeout) {
	    classCallCheck(this, AudioPool);

	    this.resourceMap = new Map();
	    this.resourceList = [];
	    this.destroyTimmer = null;
	    this.timeout = timeout;
	    this.maxSize = maxSize;
	    this.destroyHandler = null;
	  }

	  /**
	     * 从缓存池中得到一个资源
	     *
	     * @param key 资源key
	     * @return 资源，如果没有找到，则调用 onCreate 来生成资源
	     */


	  AudioPool.prototype.get = function get$$1(key) {
	    if (this.resourceMap.has(key)) {
	      var list = this.resourceMap.get(key);
	      var len = list.length;
	      if (len > 0) {
	        var entry = list.pop();
	        var index = this.resourceList.lastIndexOf(entry);
	        if (index > -1) {
	          this.resourceList.splice(index, 1);
	        }

	        // console.log(`pool:get [key:${key}]:${entry.payload}`);
	        return entry.payload;
	      }
	    }

	    // console.log(`pool:get [key:${key}]:null`);
	    return this.onCreate(key);
	  };

	  /**
	     * 释放一个资源到缓存池中
	     *
	     * @param key 资源key
	     * @param resource 资源
	     */


	  AudioPool.prototype.release = function release(key, resource) {
	    var _this = this;

	    // console.log(`pool:release [key:${key}, resource:${resource}]`);
	    var now = new Date().getTime();
	    var entry = {
	      expires: now + this.timeout,
	      payload: resource,
	      list: null
	    };

	    if (!this.resourceMap.has(key)) {
	      this.resourceMap.set(key, []);
	    }

	    var list = this.resourceMap.get(key);
	    entry.list = list;
	    list.push(entry);

	    this.resourceList.push(entry);

	    if (this.resourceList.length > this.maxSize) {
	      entry = this.resourceList.shift();
	      destroyEntry.call(this, entry);
	    }

	    if (this.destroyTimmer === null) {
	      this.destroyTimmer = setTimeout(function () {
	        onDestroyTimeout.call(_this);
	      }, this.timeout);
	    }
	  };

	  AudioPool.prototype.onCreate = function onCreate(key) {
	    return null;
	  };

	  AudioPool.prototype.onDestroy = function onDestroy(callback) {
	    this.destroyHandler = callback;
	  };
	  //  onDestroy(resource) {
	  //      console.log(`pool:destroy [resource:${resource}]`);
	  //      return null;
	  //  }


	  return AudioPool;
	}();
	function destroyEntry(entry) {
	  var list = entry.list;
	  var index = list.indexOf(entry);
	  if (index > -1) {
	    list.splice(index, 1);
	  }

	  list = this.resourceList;
	  index = list.indexOf(entry);
	  if (index > -1) {
	    list.splice(index, 1);
	  }

	  if (this.destroyHandler !== null) {
	    this.destroyHandler(entry.payload);
	  }
	  // this.onDestroy(entry.payload);
	}

	/**
	 * 超时销毁资源
	 */
	function onDestroyTimeout() {
	  var _this2 = this;

	  var list = this.resourceList;
	  var now = new Date().getTime();
	  var hasAlive = false;
	  // eslint-disable-next-line no-constant-condition
	  while (true) {
	    if (list.length <= 0) {
	      break;
	    }

	    var entry = list[0];
	    var timeout = entry.expires - now;
	    if (timeout > 0) {
	      hasAlive = true;
	      this.destroyTimmer = setTimeout(function () {
	        onDestroyTimeout.call(_this2);
	      }, timeout);
	      break;
	    } else {
	      entry = list.shift();
	      destroyEntry.call(this, entry);
	    }
	  }

	  if (!hasAlive) {
	    this.destroyTimmer = null;
	  }
	}

	var isRunning = false;
	var nextTickCallbacks = [];

	function nextTick(fn) {
	  nextTickCallbacks.push(fn);
	  if (!isRunning) {
	    isRunning = true;
	    setTimeout(doNextTick, 0);
	  }
	}

	function doNextTick() {
	  var index = 0;
	  var count = nextTickCallbacks.length;

	  while (index < count) {
	    for (; index < count; index++) {
	      try {
	        // FIXME
	        nextTickCallbacks[index].call(null);
	      } catch (e) {
	        logger.error(e);
	      }
	    }
	    count = nextTickCallbacks.length;
	  }

	  nextTickCallbacks = [];
	  isRunning = false;
	}

	var Queue = function () {
	  function Queue(onExecute) {
	    classCallCheck(this, Queue);

	    this.isRunning = false;
	    this.taskList = [];
	    this.onExecute = onExecute;
	  }

	  Queue.prototype.getTaskList = function getTaskList() {
	    return this.taskList;
	  };

	  Queue.prototype.setTaskList = function setTaskList(list) {
	    this.taskList = list;
	    if (list.length > 0 && !this.isRunning) {
	      this.isRunning = true;
	      this.next();
	    }
	  };

	  Queue.prototype.push = function push(task) {
	    var taskLen = this.taskList.push(task);

	    // if (taskLen > 5) {
	    //     console.warn(`task length:${taskLen}`);
	    // }

	    if (!this.isRunning) {
	      this.isRunning = true;
	      this.next();
	    }
	  };

	  Queue.prototype.next = function next() {
	    var _this = this;

	    nextTick(function () {
	      _this.execute();
	    });
	  };

	  Queue.prototype.execute = function execute() {
	    var _this2 = this;

	    if (this.taskList.length <= 0) {
	      this.isRunning = false;
	      return;
	    }
	    try {
	      var task = this.taskList.shift();
	      this.onExecute(task, function () {
	        _this2.next();
	      });
	    } catch (e) {
	      logger.error(e);
	      this.next();
	    }
	  };

	  return Queue;
	}();

	function invokeMethod$1(name, param) {
	  // console.log(`invokeMethod(${JSON.stringify(name)}, ${JSON.stringify(param)})`);
	  return invokeMethod.apply(this, arguments);
	}

	var TASK_CREATE = 0;
	var TASK_DESTROY = 1;
	var TASK_OPERATE = 2;
	var TASK_SETSTATE = 3;
	var TASK_GETSTATE = 4;

	/**
	 * 音频默认属性
	 */
	var DEFAULT_AUDIO_ATTRS = {
	  src: '',
	  startTime: 0,
	  paused: true,
	  currentTime: 0,
	  duration: 0,
	  obeyMuteSwitch: true,
	  volume: 1,
	  autoplay: false,
	  loop: false,
	  buffered: 0
	};

	/**
	 * audioId 到 audio 对象的映射
	 * 用于 onMethod 回调时查找 audio 对象
	 */
	var idAudioStore = new Map();

	/**
	 * 对原生音频的封装，
	 * 屏蔽 Native 调用的异步性
	 * 上层应用可以同步的调用所有方法
	 */
	var NativeAudio = function () {
	  function NativeAudio() {
	    var _this = this;

	    classCallCheck(this, NativeAudio);

	    // console.log(`create native audio`);

	    // 是否来自于本地 audioPool 的复用
	    this.isFromAudioPool = false;

	    /**
	     * 音频 id，在创建真实 native 音频后设置
	     */
	    this.id = null;

	    /**
	     * 是否已经被销毁
	     * 被销毁后会忽略方法调用
	     */
	    this.destroyed = false;

	    /**
	     * 本地状态是否脏
	     */
	    this.isDirty = true;

	    /**
	     * 是否正在从 Native 获取状态
	     */
	    this.isLoadingState = false;

	    /**
	     * 状态改变监听函数
	     */
	    this.stateHandler = null;

	    /**
	     * 设置过的属性
	     */
	    this.settedAttrStore = {};

	    /**
	     * Native 属性，会从 Native 同步
	     */
	    this.audioAttrStore = Object.assign({}, DEFAULT_AUDIO_ATTRS);

	    /**
	     * 任务队列，用于确保前一个操作结束后，再进行下一个操作
	     * 比如音频创建成功后，才能用 audioId 去设置 src 属性
	     */
	    this.taskQueue = new Queue(function (task, next) {
	      task.callback.call(_this, task, next);
	    });

	    this.taskQueue.push({
	      type: TASK_CREATE,
	      callback: this._createTaskHandler
	    });
	  }

	  NativeAudio.prototype._createTaskHandler = function _createTaskHandler(task, next) {
	    var _this2 = this;

	    invokeMethod$1('createAudioInstance', {
	      success: function success(res) {
	        var audioId = res.audioId;
	        _this2.id = audioId;

	        // 在没有被销毁的时候，才会建立引用关系
	        if (!_this2.destroyed) {
	          idAudioStore.set(audioId, _this2);
	        }

	        next();
	      }
	      // TODO 错误处理
	    });
	  };

	  NativeAudio.prototype.destroy = function destroy() {
	    if (this.destroyed) {
	      // console.error('destroyed');
	      return;
	    }

	    // 标记为已被销毁，
	    // 如果已经绑定了id，则解除引用关系
	    // 如果没有绑定id，在create后会判断是否已被销毁，如果被销毁则不会绑定id
	    this.destroyed = true;
	    var audioId = this.id;
	    if (audioId !== null) {
	      idAudioStore.delete(audioId);
	    }

	    this.taskQueue.push({
	      type: TASK_DESTROY,
	      callback: this._destroyTaskHandler
	    });
	  };

	  NativeAudio.prototype._destroyTaskHandler = function _destroyTaskHandler(task, next) {
	    var audioId = this.id;
	    idAudioStore.delete(audioId);
	    invokeMethod$1('destroyAudioInstance', {
	      audioId: audioId
	      // complete: () => {
	      //     next();
	      // }
	    });

	    // if (__audioMap__.hasOwnProperty(audioId)) {
	    //     __audioList__[__audioMap__[audioId]].state = " ";
	    //     __audioList__[__audioMap__[audioId]].destroyed = true;
	    //     treacAudioState();
	    // }

	    next();
	  };

	  NativeAudio.prototype.operate = function operate(op) {
	    if (this.destroyed) {
	      // console.error('destroyed');
	      return;
	    }
	    this.taskQueue.push({
	      type: TASK_OPERATE,
	      operation: Object.assign({}, op),
	      callback: this._operateTaskHandler
	    });
	  };

	  NativeAudio.prototype._operateTaskHandler = function _operateTaskHandler(task, next) {
	    var _this3 = this;

	    var operation = task.operation;

	    // 这里是针对 Cocos 做的优化，Cocos 会 seek 0 然后 pause,
	    // 如果是这种情况我们将两个操作合并为 stop 操g作，
	    // 以便触发 endded 事件
	    if (operation.operationType === 'seek' && operation.currentTime === 0) {
	      var taskList = this.taskQueue.getTaskList();
	      if (taskList.length) {
	        var nextTask = taskList[0];
	        if (nextTask.type === TASK_OPERATE && nextTask.operation.operationType === 'pause') {
	          taskList.shift();
	          operation = {
	            operationType: 'stop'
	          };
	          this.settedAttrStore.paused = true;
	        }
	      }
	    }

	    var audioId = this.id;
	    invokeMethod$1('operateAudio', Object.assign({
	      audioId: audioId,
	      // TODO 错误处理
	      complete: function complete() {
	        // next();
	        if (operation.operationType === 'seek') {
	          _this3._isSeeking = false;
	        }
	      }
	    }, operation));
	    next();
	  };

	  NativeAudio.prototype.setState = function setState(key, value) {
	    if (this.destroyed) {
	      // console.error('destroyed');
	      return;
	    }

	    this.settedAttrStore[key] = value;

	    // FIXME 这个地方的处理好trick
	    // if (key === 'src') {
	    //     this.audioAttrStore.paused = true;
	    // }

	    this.taskQueue.push({
	      type: TASK_SETSTATE,
	      stateKey: key,
	      stateValue: value,
	      callback: this._setStateTaskHandler
	    });
	  };

	  NativeAudio.prototype._setStateTaskHandler = function _setStateTaskHandler(task, next) {
	    var _state,
	        _this4 = this;

	    var taskList = this.taskQueue.getTaskList();
	    var state = (_state = {}, _state[task.stateKey] = task.stateValue, _state);

	    // 合并多次 setState 操作
	    // 这里采用从任务队列中获取之后的任务列表，
	    // 主要是为了保证只 merge 连续的 setState 任务
	    // 因为如果合并 [setState, otherTask, setState] 这种队列中的
	    // 两个 setState 可能造成表现不一致
	    while (taskList.length > 0) {
	      var item = taskList[0];
	      if (item.type !== TASK_SETSTATE) {
	        break;
	      }

	      item = taskList.shift();
	      state[item.stateKey] = item.stateValue;
	    }

	    var audioId = this.id;
	    Object.assign(this.audioAttrStore, state);
	    invokeMethod$1('setAudioState', Object.assign({
	      audioId: audioId,
	      success: function success() {
	        Object.assign(_this4.audioAttrStore, state);
	      },
	      fail: function fail() {
	        _this4.isDirty = true;
	        _this4.getState();
	      }
	      // complete: () => {
	      //     next();
	      // }
	    }, this.audioAttrStore, state));

	    next();
	  };

	  NativeAudio.prototype.getState = function getState(key) {
	    var ret = {};
	    if (key === 'currentTime' && typeof this.id !== 'undefined') {
	      if (this._isSeeking) {
	        return this.settedAttrStore[key];
	      }
	      // currentTime同步获取
	      var time = 0;
	      invokeMethod$1(TMAConfig.platform === 'android' ? 'getAudioStateSync' : 'getAudioState', {
	        audioId: this.id,
	        success: function success(res) {
	          time = (key === 'duration' || key === 'currentTime') && (res[key] / 1000).toFixed(6);
	        },
	        complete: function complete() {}
	      });
	      return time;
	    }
	    // 因为游戏中端的实现全是异步的，所以这里只能同步返回缓存的数据
	    if (this.settedAttrStore.hasOwnProperty(key)) {
	      ret = this.settedAttrStore[key];
	    } else if (this.audioAttrStore.hasOwnProperty(key)) {
	      ret = this.audioAttrStore[key];
	    }
	    if (this.destroyed) {
	      return ret;
	    }
	    if (!this.isLoadingState && this.isDirty) {
	      this.isLoadingState = true;
	      this.taskQueue.push({
	        type: TASK_GETSTATE,
	        callback: this._getStateTaskHandler
	      });
	    }
	    return ret;
	  };

	  NativeAudio.prototype._getStateTaskHandler = function _getStateTaskHandler(task, next) {
	    var _this5 = this;

	    var audioId = this.id;
	    invokeMethod$1('getAudioState', {
	      audioId: audioId,
	      success: function success(res) {
	        // 如果处于 seek 状态，不更新 currentTime
	        _this5._isSeeking || (res.currentTime = (res.currentTime / 1000).toFixed(6));
	        res.duration = (res.duration / 1000).toFixed(6);
	        // FIXME: trick for cocos paused get
	        res.paused = _this5.settedAttrStore.paused;
	        Object.assign(_this5.audioAttrStore, res);
	        Object.assign(_this5.settedAttrStore, res);
	        // this.isDirty = false;
	      },
	      complete: function complete() {
	        _this5.isLoadingState = false;
	        // next();
	      }
	    });

	    next();
	  };

	  NativeAudio.prototype.onStateChange = function onStateChange(callback) {
	    this.stateHandler = callback;
	  };

	  return NativeAudio;
	}();

	/**
	 * 响应音频状态改变事件
	 */

	// let __audioList__ = [];
	// let __audioMap__ = {};

	// function treacAudioState() {
	//     console.log(__audioList__.map(item => {
	//         return item.state[0].toUpperCase();
	//     }));
	//     console.log(__audioList__);
	// }


	onMethod('onAudioStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var state = res.state.toLowerCase();
	  var audioId = res.audioId;

	  // if (!__audioMap__.hasOwnProperty(audioId)) {
	  //     __audioMap__[audioId] = __audioList__.length;
	  //     __audioList__[__audioMap__[audioId]] = {};
	  // }
	  // if (!__audioList__[__audioMap__[audioId]].destroyed) {
	  //     __audioList__[__audioMap__[audioId]] = Object.assign({}, res);
	  // }
	  // treacAudioState();

	  // console.log(`onAudioStateChange(${JSON.stringify(res)})`);

	  delete res.state;
	  delete res.audioId;

	  if (idAudioStore.has(audioId)) {
	    var audio = idAudioStore.get(audioId);
	    if (audio.stateHandler !== null) {
	      audio.stateHandler(state, res);
	    }
	  }
	});

	/**
	 * 音频缓存池
	 * 第一个参数是缓存池大小
	 * 第二个参数是自动销毁时间
	 *
	 * 在超过缓存池大小或者缓存超时时会销毁缓存的对象
	 */
	var audioPool = new AudioPool(10, 3000);
	audioPool.onDestroy(function (audio) {
	  audio.destroy();
	});

	/**
	 * InnerAudio 到 NativeAudio 的映射
	 * 使用 WeakMap 主要是模拟 private，防止暴露 NativeAudio 对象
	 */
	var nativeAudioStore = new WeakMap();

	function hasNativeAudio(audio) {
	  return nativeAudioStore.has(audio);
	}

	function getNativeAudio(audio) {
	  if (hasNativeAudio(audio)) {
	    return nativeAudioStore.get(audio);
	  } else {
	    return null;
	  }
	}

	function unbindNativeAudio(audio) {
	  var nativeAudio = getNativeAudio(audio);
	  if (nativeAudio) {
	    nativeAudio.onStateChange(null);
	  }
	  nativeAudioStore.delete(audio);
	}

	function bindNativeAudio(audio, nativeAudio) {
	  nativeAudio.onStateChange(function (state, res) {
	    nativeAudioStateChangeHandler.call(audio, state, res);
	  });
	  nativeAudioStore.set(audio, nativeAudio);
	}

	function setNativeAudioStateExceptKeys(nativeAudio, state, exceptKeys) {
	  exceptKeys = exceptKeys || [];
	  var keys = Object.keys(state);
	  keys.forEach(function (key) {
	    // 排除的 key 列表中找不到的话，则设置。。有点绕-_-!
	    if (exceptKeys.indexOf(key) < 0) {
	      nativeAudio.setState(key, state[key]);
	    }
	  });
	  return nativeAudio;
	}

	function getState(audio, key) {
	  var nativeAudio = getNativeAudio(audio);
	  if (nativeAudio !== null) {
	    var value = nativeAudio.getState(key);
	    setAttr(audio, key, value);
	    return value;
	  } else {
	    return getAttr(audio, key);
	  }
	}

	function setState(audio, key, value) {
	  setAttr(audio, key, value);
	  var nativeAudio = getNativeAudio(audio);
	  if (nativeAudio !== null) {
	    nativeAudio.setState(key, value);
	  }
	}

	/**
	 * timeUpdate callback
	 */
	var timeupdateFuncStore = new WeakMap();

	/**
	 * 属性缓存
	 */
	var attrStore = new WeakMap();

	/**
	 * 事件处理器缓存
	 */
	var emitterStore = new WeakMap();

	function getAttr(audio, key) {
	  if (arguments.length < 2) {
	    if (attrStore.has(audio)) {
	      return attrStore.get(audio);
	    }
	  } else {
	    if (attrStore.has(audio)) {
	      return attrStore.get(audio)[key];
	    }
	  }
	  return undefined;
	}

	function setAttr(audio, key, value) {
	  if (arguments.length < 3) {
	    attrStore.set(audio, key);
	  } else {
	    if (!attrStore.has(audio)) {
	      attrStore.set(audio, {});
	    }

	    attrStore.get(audio)[key] = value;
	  }
	}

	function loadNativeAudio(audio, src) {
	  // 播放时，检查是否有绑定的NativeAudio，如果没有，
	  // 则从缓存池中获取，如果未获取到，则新建NativeAudio对象
	  var nativeAudio = getNativeAudio(audio);
	  if (nativeAudio === null) {
	    nativeAudio = audioPool.get(src);
	    if (nativeAudio === null) {
	      nativeAudio = new NativeAudio();
	      nativeAudio.setState('src', src);
	    } else {
	      nativeAudio.isFromAudioPool = true;
	    }

	    setNativeAudioStateExceptKeys(nativeAudio, getAttr(audio), ['src']);
	    bindNativeAudio(audio, nativeAudio);
	  }
	  return nativeAudio;
	}

	var InnerAudio = function () {
	  function InnerAudio() {
	    classCallCheck(this, InnerAudio);

	    setAttr(this, Object.assign({}, DEFAULT_AUDIO_ATTRS));
	  }

	  InnerAudio.prototype.play = function play() {
	    var nativeAudio = loadNativeAudio(this, this.src);
	    nativeAudio.operate({
	      operationType: 'play'
	    });
	    // FIXME: trick for cocos paused get
	    nativeAudio.settedAttrStore.paused = false;
	    // nativeAudio._isPlaying = true;
	  };

	  InnerAudio.prototype.pause = function pause() {
	    var nativeAudio = getNativeAudio(this);
	    if (nativeAudio !== null) {
	      nativeAudio.operate({
	        operationType: 'pause'
	      });
	      // FIXME: trick for cocos paused get
	      nativeAudio.settedAttrStore.paused = true;
	      // nativeAudio._isPlaying = false;
	    }
	  };

	  InnerAudio.prototype.stop = function stop() {
	    var nativeAudio = getNativeAudio(this);
	    if (nativeAudio !== null) {
	      nativeAudio.operate({
	        operationType: 'stop'
	      });
	      audioPool.release(this.src, nativeAudio);
	      setState(this, 'paused', true);
	      // FIXME: trick for cocos paused get
	      nativeAudio.settedAttrStore.paused = true;
	      // nativeAudio._isPlaying = false;
	      unbindNativeAudio(this);
	    }
	  };

	  InnerAudio.prototype.seek = function seek(position) {
	    var nativeAudio = getNativeAudio(this);
	    if (nativeAudio !== null) {
	      // seek 操作时手动设置 currentTime
	      nativeAudio.settedAttrStore.currentTime = position.toFixed(6);
	      // seek 是一个异步操作，标记 nativeaudio 处于 seek 状态，用户在 seek 过程中获取 currentTime 为手动设置的 time
	      nativeAudio._isSeeking = true;
	      nativeAudio.operate({
	        operationType: 'seek',
	        currentTime: 1e3 * position
	      });
	    }
	  };

	  InnerAudio.prototype.destroy = function destroy() {
	    var nativeAudio = getNativeAudio(this);
	    if (nativeAudio !== null) {
	      nativeAudio.destroy();
	      var timer = timeupdateFuncStore.get(this);
	      clearInterval(timer);
	      timeupdateFuncStore.set(this, null);
	      // nativeAudio._isPlaying = false;
	      // FIXME: trick for cocos paused get
	      nativeAudio.settedAttrStore.paused = true;
	    }
	  };

	  createClass(InnerAudio, [{
	    key: 'src',
	    set: function set$$1(value) {
	      var origSrc = getState(this, 'src');

	      if (!emitterStore.has(this)) {
	        emitterStore.set(this, new EventEmitter());
	      }

	      var emitter = emitterStore.get(this);

	      // Cocos Creator v2.0.8 版本的audioPool 实现有bug，stop 操作会设置 src 为null，下次复用又不会重新设置src，导致无法播放
	      if (value === '' || !isString(value) || value === origSrc) {
	        return;
	      }

	      // 如果有 NativeAudio，则将之前的 NativeAudio 释放
	      var nativeAudio = getNativeAudio(this);
	      if (nativeAudio !== null) {
	        // 如果已经有了 audio 实例，先暂停之前的 aduio
	        nativeAudio.settedAttrStore.paused = true;
	        nativeAudio.__played__ = false;
	        // setNativeAudioStateExceptKeys(nativeAudio, DEFAULT_AUDIO_ATTRS, ['src']);
	        // audioPool.release(origSrc, nativeAudio);
	        // unbindNativeAudio(this);
	      }

	      setTimeout(function () {
	        return emitter.emit('canplay');
	      }, 0);
	      setState(this, 'src', value);
	      if (this.autoplay) {
	        loadNativeAudio(this, value);
	      }
	    },
	    get: function get$$1() {
	      return getState(this, 'src');
	    }
	  }, {
	    key: 'autoplay',
	    set: function set$$1(value) {
	      value = !!value;
	      setState(this, 'autoplay', value);
	      var src = this.src;
	      if (value && src) {
	        var nativeAudio = loadNativeAudio(this, src);
	        if (nativeAudio.isFromAudioPool) {
	          this.play();
	        }
	      }
	    },
	    get: function get$$1() {
	      return getState(this, 'autoplay');
	    }
	  }, {
	    key: 'loop',
	    set: function set$$1(value) {
	      setState(this, 'loop', value);
	    },
	    get: function get$$1() {
	      return getState(this, 'loop');
	    }
	  }, {
	    key: 'obeyMuteSwitch',
	    set: function set$$1(value) {
	      setState(this, 'obeyMuteSwitch', value);
	    },
	    get: function get$$1() {
	      return getState(this, 'obeyMuteSwitch');
	    }
	  }, {
	    key: 'duration',
	    get: function get$$1() {
	      return getState(this, 'duration');
	    }
	  }, {
	    key: 'currentTime',
	    get: function get$$1() {
	      return getState(this, 'currentTime');
	    }
	  }, {
	    key: 'paused',
	    get: function get$$1() {
	      return getState(this, 'paused');
	    }
	  }, {
	    key: 'buffered',
	    get: function get$$1() {
	      return getState(this, 'buffered');
	    }
	  }, {
	    key: 'volume',
	    set: function set$$1(value) {
	      value = Math.min(1, Math.max(value, 0));
	      !isNaN(value) && setState(this, 'volume', value);
	    },
	    get: function get$$1() {
	      return getState(this, 'volume');
	    }
	  }]);
	  return InnerAudio;
	}();

	['Play', 'Pause', 'Stop', 'Canplay', 'Error', 'Ended', 'Waiting', 'Seeking', 'Seeked', 'TimeUpdate'].forEach(function (event) {
	  var eventName = event.toLowerCase();
	  if (eventName === 'error') {
	    eventName = '_error';
	  }

	  InnerAudio.prototype['on' + event] = function (callback) {
	    var _this = this;

	    if (!emitterStore.has(this)) {
	      emitterStore.set(this, new EventEmitter());
	    }

	    var emitter = emitterStore.get(this);

	    if (event === 'TimeUpdate') {
	      if (!timeupdateFuncStore.get(this)) {
	        var _lastTime = void 0;
	        var timer = setInterval(function () {
	          var nativeAudio = getNativeAudio(_this);
	          if (nativeAudio && !nativeAudio.settedAttrStore.paused) {
	            var ct = getState(_this, 'currentTime');
	            if (ct !== _lastTime) {
	              emitter.emit(eventName);
	            }
	          }
	        }, 250);

	        timeupdateFuncStore.set(this, timer);
	      }

	      emitter.removeAllListeners(eventName);
	    }

	    emitter.on(eventName, callback);
	  };

	  InnerAudio.prototype['off' + event] = function (callback) {
	    if (!emitterStore.has(this)) {
	      return;
	    }
	    var emitter = emitterStore.get(this);
	    if (callback === undefined || callback === null) {
	      emitter.removeAllListeners(eventName);
	    } else {
	      emitter.off(eventName, callback);
	    }
	  };
	});

	function nativeAudioStateChangeHandler(state, props) {
	  var _this2 = this;

	  // 音频播放结束时，将资源放回缓存池
	  switch (state) {
	    case 'play':
	      {
	        // autoplay 时需要手动设置 _isPlaying 属性
	        var nativeAudio = getNativeAudio(this);
	        var autoplay = getAttr(this, 'autoplay');
	        if (autoplay && !nativeAudio.__played__) {
	          // nativeAudio._isPlaying = true;
	          nativeAudio.settedAttrStore.paused = false;
	          nativeAudio.__played__ = true;
	        }
	      }
	      break;
	    case 'ended':
	    case 'stop':
	      {
	        var _nativeAudio = getNativeAudio(this);
	        var src = this.src;
	        if (_nativeAudio == null) {
	          break;
	        }
	        // nativeAudio._isPlaying标记位防止音乐在播放时被释放
	        if (_nativeAudio.settedAttrStore.paused) {
	          audioPool.release(src, _nativeAudio);
	          unbindNativeAudio(this);
	        } else if (state === 'ended') {
	          // nativeAudio._isPlaying = false;
	          setAttr(this, 'paused', true);
	          _nativeAudio.settedAttrStore.paused = true;
	          // 由于端触发为异步回调
	          // 防止此时开发者调用play方法
	          // 此处使用setTimeout 0推后调用
	          setTimeout(function () {
	            // 假如js同步代码中在ended触发后
	            // nativeAudio._isPlaying没有变为true(执行了play操作)
	            // 或资源src被修改
	            // 则释放该音频资源
	            if (_nativeAudio.settedAttrStore.paused && _this2.src === src) {
	              audioPool.release(src, _nativeAudio);
	              unbindNativeAudio(_this2);
	            }
	          }, 0);
	        }
	      }
	      break;

	    case 'error':
	      {
	        logger.error('error');
	        var _nativeAudio2 = getNativeAudio(this);
	        if (_nativeAudio2 !== null) {
	          unbindNativeAudio(this);
	          _nativeAudio2.destroy();
	          // setNativeAudioStateExceptKeys(nativeAudio, DEFAULT_AUDIO_ATTRS, ['src']);
	          // audioPool.release(src, nativeAudio);
	        }
	      }
	      break;
	  }

	  if (emitterStore.has(this)) {
	    var emitter = emitterStore.get(this);
	    if (state === 'error') {
	      state = '_error';
	    }
	    emitter.emit(state, props);
	  }
	}

	function createInnerAudioContext() {
	  return new InnerAudio();
	}

	var isRunning$1 = false;
	var nextTickCallbacks$1 = [];

	function nextTick$1(fn) {
	  nextTickCallbacks$1.push(fn);
	  if (!isRunning$1) {
	    isRunning$1 = true;
	    setTimeout(doNextTick$1, 0);
	  }
	}

	function doNextTick$1() {
	  var index = 0;
	  var count = nextTickCallbacks$1.length;

	  while (index < count) {
	    for (; index < count; index++) {
	      try {
	        nextTickCallbacks$1[index].call(null);
	      } catch (e) {
	        logger.error(e);
	      }
	    }
	    count = nextTickCallbacks$1.length;
	  }

	  nextTickCallbacks$1 = [];
	  isRunning$1 = false;
	}

	var emitter$5 = new EventEmitter();

	onMethod('onBgAudioStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  res.state = res.state.toLowerCase();
	  var state = res.state;
	  delete res.audioId;
	  delete res.state;

	  emitter$5.emit('_onAudioStateChange_' + state, res);
	});

	function setAudioState(key, val) {
	  var _target;

	  var target = (_target = {}, _target[key] = val, _target);

	  this.audioAttr = Object.assign(this.audioAttr, target);

	  if (key === 'src') {
	    this.audioAttr = Object.assign(this.audioAttr, {
	      paused: true
	    });
	  }
	  var that = this;
	  if (this.canSet) {
	    setTimeout(function () {
	      invokeMethod('setBgAudioState', Object.assign({}, that.audioAttr, that.settedAttr, {
	        success: function success() {
	          // audioAttr.set(this, Object.assign(audioAttr.get(this), target));
	          that.audioAttr = Object.assign(that.audioAttr, target);
	        },
	        fail: function fail() {
	          getAudioState.call(that);
	        }
	      }));
	      that.canSet = true;
	    }, 50); // 50ms内只能set客户端一次

	    that.canSet = false;
	  }
	  this.settedAttr = Object.assign(this.settedAttr, target);
	}

	// 现在看起来是每次调用getAudioState都会向客户端询问一次
	// 客户端压力会有点大啊?
	var canAsyncGetAudioStateTime = Date.now();

	function getAudioState(key, cb) {
	  var that = this;
	  if (Date.now() - canAsyncGetAudioStateTime >= 50) {
	    invokeMethod('getBgAudioState', {
	      success: function success(res) {
	        that.audioAttr = Object.assign(that.audioAttr, res);
	        if (typeof cb === 'function') {
	          cb(res[key]);
	        }
	      }
	    });
	    canAsyncGetAudioStateTime = Date.now();
	  }
	  return this.audioAttr[key];
	}

	function operateAudio(operation) {
	  invokeMethod('operateBgAudio', Object.assign({
	    fail: function fail(res) {
	      invokeStateChange('error', {
	        errMsg: res.errMsg,
	        errCode: -1
	      });
	    }
	  }, operation));
	}

	function onEvent(ev, cb) {
	  var that = this,
	      evName = '_onAudioStateChange_' + ev;
	  var realCb = function realCb(res) {
	    that.audioAttr = Object.assign(that.audioAttr, {
	      paused: ev !== 'seeking' && ev !== 'seeked' ? ev !== 'play' : that.audioAttr.paused
	    });
	    surroundByTryCatchFactory(cb, 'at audioContext.on' + ev + ' callback function')(res);
	  };
	  this.realCallbackStore.set(cb, realCb);
	  emitter$5.on(evName, realCb);
	}

	function offEvent(event, listener) {
	  var emitterEvent = '_onAudioStateChange_' + event;
	  if (typeof listener === 'function') {
	    var realCb = this.realCallbackStore.get(listener);
	    emitter$5.off(emitterEvent, realCb);
	  } else {
	    emitter$5.removeAllListeners(emitterEvent);
	  }
	}

	function invokeStateChange(state, data) {
	  emitter$5.emit('_onAudioStateChange_' + state, data);
	}

	var BackgroundAudio = function () {
	  function BackgroundAudio() {
	    classCallCheck(this, BackgroundAudio);

	    var that = this;
	    var errMsg = void 0;
	    // 以下状态全局唯一，不需要Map
	    this.audioAttr = {};
	    this.timeUpdateFunc = null;
	    this.canSet = true;
	    this.settedAttr = {};
	    this.realCallbackStore = new WeakMap();

	    // 强行调一下客户端,让客户端提前做初始化
	    invokeMethod('getBackgroundAudioContext', {
	      success: function success() {
	        that.audioAttr = {
	          src: '',
	          startTime: 0,
	          paused: !0,
	          currentTime: 0,
	          duration: 0,
	          obeyMuteSwitch: !0,
	          volume: 1,
	          autoplay: !1,
	          loop: !1,
	          buffered: 0
	        };
	      },
	      fail: function fail(e) {
	        errMsg = e.errMsg;
	      }
	    });

	    ['Play', 'Pause', 'Stop', 'Canplay', 'Error', 'Ended', 'Waiting', 'Seeking', 'Seeked'].forEach(function (event) {
	      that['on' + event] = function (cb) {
	        onEvent.call(that, event.toLowerCase(), cb);
	      };

	      that['off' + event] = function (cb) {
	        offEvent.call(that, event.toLowerCase(), cb);
	      };
	    });
	  }

	  BackgroundAudio.prototype.play = function play() {
	    var _this = this;

	    // setTimeout(() => {
	    nextTick$1(function () {
	      operateAudio.call(_this, {
	        operationType: 'play'
	      });
	    }, 0);
	  };

	  BackgroundAudio.prototype.pause = function pause() {
	    var _this2 = this;

	    // setTimeout(() => {
	    nextTick$1(function () {
	      operateAudio.call(_this2, {
	        operationType: 'pause'
	      });
	    }, 0);
	  };

	  BackgroundAudio.prototype.stop = function stop() {
	    var _this3 = this;

	    // setTimeout(() => {
	    nextTick$1(function () {
	      operateAudio.call(_this3, {
	        operationType: 'stop'
	      });
	    }, 0);
	  };

	  BackgroundAudio.prototype.seek = function seek(position) {
	    var _this4 = this;

	    if ('number' != typeof position || position < 0) {
	      invokeStateChange('error', {
	        errMsg: 'Failed to seek, the currentTime ' + position + ' is invalid.'
	      });
	      return;
	    }

	    // setTimeout(() => {
	    nextTick$1(function () {
	      operateAudio.call(_this4, {
	        operationType: 'seek',
	        currentTime: 1e3 * position
	      });
	    }, 0);
	  };

	  BackgroundAudio.prototype.onTimeUpdate = function onTimeUpdate(cb) {
	    var that = this;
	    var emitterTimeUpdateEvent = '_onAudioStateChange_timeupdate';

	    if (!this.timeUpdateFunc) {
	      this.timeUpdateFunc = setInterval(function timeUpdateTimer() {
	        // GSTODO 逻辑上应当在后台停止更新
	        if (!0 !== that.audioAttr.paused && 1 !== that.audioAttr.paused) {
	          var ct = that.audioAttr.currentTime;
	          getAudioState.call(that, 'currentTime', function (newVal) {
	            newVal !== ct && emitter$5.emit(emitterTimeUpdateEvent);
	          });
	        }
	      }, 250);
	    }

	    emitter$5.removeAllListeners(emitterTimeUpdateEvent);
	    emitter$5.on(emitterTimeUpdateEvent, function () {
	      if (typeof cb === 'function') {
	        surroundByTryCatchFactory(cb, 'at audioContext.onTimeUpdate callback function')();
	      }
	    });
	  };

	  BackgroundAudio.prototype.offTimeUpdate = function offTimeUpdate(listener) {
	    offEvent.call(this, 'timeupdate', listener);
	  };

	  createClass(BackgroundAudio, [{
	    key: 'src',
	    get: function get$$1() {
	      return getAudioState.call(this, 'src');
	    },
	    set: function set$$1(val) {
	      if ('string' != typeof val || 0 === val.length) {
	        invokeStateChange.call(this, 'error', {
	          errMsg: 'Failed to set src, the src ' + val + ' is invalid.'
	        });
	        return;
	      }
	      setAudioState.call(this, 'src', val);
	    }
	  }, {
	    key: 'startTime',
	    get: function get$$1() {
	      return getAudioState.call(this, 'startTime') / 1e3;
	    },
	    set: function set$$1(val) {
	      if ('number' != typeof val) {
	        return void invokeStateChange('error', {
	          errMsg: 'Failed to set startTime, the startTime ' + val + ' is invalid.'
	        });
	      }
	      setAudioState.call(this, 'startTime', 1e3 * val);
	    }
	  }, {
	    key: 'autoplay',
	    set: function set$$1(val) {
	      'boolean' == typeof val && setAudioState.call(this, 'autoplay', val);
	    },
	    get: function get$$1() {
	      return getAudioState.call(this, 'autoplay');
	    }
	  }, {
	    key: 'loop',
	    set: function set$$1(val) {
	      'boolean' == typeof val && setAudioState.call(this, 'loop', val);
	    },
	    get: function get$$1() {
	      return getAudioState.call(this, 'loop');
	    }
	  }, {
	    key: 'obeyMuteSwitch',
	    set: function set$$1(val) {
	      'boolean' == typeof val && setAudioState.call(this, 'obeyMuteSwitch', val);
	    },
	    get: function get$$1() {
	      return getAudioState.call(this, 'obeyMuteSwitch');
	    }
	  }, {
	    key: 'volume',
	    set: function set$$1(val) {
	      'number' != typeof val || val < 0 || val > 1 || setAudioState.call(this, 'volume', val);
	    },
	    get: function get$$1() {
	      return getAudioState.call(this, 'volume');
	    }
	  }, {
	    key: 'paused',
	    get: function get$$1() {
	      return getAudioState.call(this, 'paused');
	    }
	  }, {
	    key: 'duration',
	    get: function get$$1() {
	      return getAudioState.call(this, 'duration') / 1e3;
	    }
	  }, {
	    key: 'currentTime',
	    get: function get$$1() {
	      return getAudioState.call(this, 'currentTime') / 1e3;
	    }
	  }, {
	    key: 'buffered',
	    get: function get$$1() {
	      var self = this;
	      return getAudioState.call(self, 'buffered');
	    }
	  }]);
	  return BackgroundAudio;
	}();

	var backgroundAudioContext = new BackgroundAudio();

	/**
	 * @function getBackgroundAudioContext
	 * @description 返回全局唯一的 backgroundAudioContext 对象
	 * @returns {BackgroundAudio}
	 */
	function getBackgroundAudioContext() {
	  return backgroundAudioContext;
	}

	/**
	 * @function chooseVideo
	 * @description 拍摄视频或从手机相册中选视频，返回视频的临时文件路径
	 *
	 * @param {object} param
	 * @param {string[]} [param.sourceType=['album', 'camera']] 视频来源，有效值有 album/camera
	 * @param {string[]} [param.camera=['fromt', 'back']] 视频来源为摄像头时，设置使用前置或后置
	 * @param {boolean} [param.compressed=true] 是否压缩所选的视频源文件
	 * @param {number} [param.maxDuration=60] 拍摄视频最长拍摄时间，单位秒
	 * @param {chooseVideoSuccessCallback} [param.success] 执行成功的回调方法
	 *
	 * @example
	tt.chooseVideo({
	  sourceType: ['camera'],
	  camera: ['back'],
	  success: function(res) {
	    logger.log(res.tempFilePath);
	  }
	});
	 */
	function chooseVideo() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  param.sourceType = param.sourceType || ['album', 'camera'];
	  param.camera = param.camera || ['front', 'back'];
	  'boolean' != typeof param.compressed && (param.compressed = !0);
	  invokeMethod('chooseVideo', param);
	}

	/**
	 * @function saveVideoToPhotosAlbum
	 * @description 保存视频到系统相册
	 * @param {object} param
	 * @param {string} param.filePath 视频文件路径，可以是临时文件路径也可以是永久文件路径
	 */
	function saveVideoToPhotosAlbum() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('saveVideoToPhotosAlbum', param, {});
	}

	/**
	 * chooseVideo success callback
	 * @callback chooseVideoSuccessCallback
	 * @param {object} response
	 * @param {string} response.tempFilePath 选定视频的临时文件路径
	 * @param {number} response.duration 选定视频的时间长度
	 * @param {number} response.size 选定视频的数据量大小
	 * @param {number} response.height 返回选定视频的长
	 * @param {number} response.width 返回选定视频的宽
	 */

	/**
	 * @function saveFile
	 * @description 保存文件到本地
	 * 
	 * @param {object} param
	 * @param {string} tempFilePath 需要保存的文件的临时路径
	 * @param {saveFileSuccessCallback} [param.success] 执行成功的回调方法
	 * 
	 * @example
	tt.chooseImage({
	  success: function(res) {
	    var tempFilePaths = res.tempFilePaths
	    tt.saveFile({
	      tempFilePath: tempFilePaths[0],
	      success: function(res) {
	        var savedFilePath = res.savedFilePath
	      }
	    })
	  }
	})
	 */
	function saveFile() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('saveFile', param, {
	    tempFilePath: ''
	  })) {
	    invokeMethod('saveFile', param);
	  }
	}

	/**
	 * saveFile success callback
	 * @callback saveFileSuccessCallback
	 * @param {object} response
	 * @param {string} response.savedFilePath 文件的保存路径
	 */

	/**
	 * @function getStorage
	 * @description 从本地缓存中异步获取指定 key 对应的内容
	 * @param {object} param
	 * @param {string} param.key 本地缓存中的指定的 key
	 * @param {getStorageSuccessCallback} [param.success] 成功回调
	 */
	var getStorage = function getStorage(param) {
	  if (beforeInvoke('getStorage', param, {
	    key: ''
	  })) {
	    invokeMethod('getStorage', param, {
	      beforeSuccess: function beforeSuccess(res) {
	        res.data = stringToAnyType(res.data, res.dataType);
	        delete res.dataType;
	      },
	      afterFail: function afterFail() {
	        var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        if (res.errMsg && res.errMsg.indexOf('data not found') > 0) {
	          return false;
	        }
	      }
	    });
	  }
	};

	/**
	 * @function getStorageSync
	 * @description 从本地缓存中同步获取指定 key 对应的内容
	 * @param {string} key 本地缓存中的指定的 key
	 * @returns {*} 指定的 key 对应的内容
	 */
	var getStorageSync = function getStorageSync(key) {
	  if (beforeInvoke('getStorageSync', key, '')) {
	    var result;

	    invokeMethod('getStorageSync', {
	      key: key
	    }, {
	      beforeAll: function beforeAll() {
	        var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        result = stringToAnyType(res.data, res.dataType);
	      },
	      afterFail: function afterFail() {
	        var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        if (res.errMsg && res.errMsg.indexOf('data not found') > 0) {
	          return false;
	        }
	      }
	    });

	    return result;
	  }
	};

	/**
	 * @function setStorage
	 * @description 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口
	 * @param {*} param
	 * @param {string} param.key 本地缓存中的指定的 key
	 * @param {object|string} param.data 需要存储的内容
	 */
	var setStorage = function setStorage(param) {
	  if (beforeInvoke('setStorage', param, {
	    key: ''
	  })) {
	    try {
	      var _anyTypeToString = anyTypeToString(param.data),
	          data = _anyTypeToString.data,
	          dataType = _anyTypeToString.dataType;

	      invokeMethod('setStorage', Object.assign(param, {
	        data: data,
	        dataType: dataType
	      }));
	    } catch (ex) {
	      typeof param.fail === 'function' && param.fail({
	        errMsg: 'setStorage:fail ' + ex.message
	      });
	      typeof param.complete === 'function' && param.complete({
	        errMsg: 'setStorage:fail ' + ex.message
	      });
	    }
	  }
	};

	/**
	 * @function setStorageSync
	 * @description 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口
	 * @param {string} key 本地缓存中的指定的 key
	 * @param {object|string} data 需要存储的内容
	 */
	var setStorageSync = function setStorageSync(key) {
	  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

	  if (beforeInvoke('setStorageSync', key, '')) {
	    var tmp = anyTypeToString(data),
	        dataString = tmp.data,
	        dataType = tmp.dataType;
	    var callFailed = false;
	    var errMsg = '';
	    invokeMethod('setStorageSync', {
	      key: key,
	      data: dataString,
	      dataType: dataType,
	      fail: function fail() {
	        var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        errMsg = res.errMsg;
	        callFailed = true;
	      }
	    });

	    if (callFailed) {
	      throw new AppServiceSdkKnownError(errMsg);
	    }
	  }
	};

	/**
	 * @function removeStorage
	 * @description 从本地缓存中异步移除指定 key
	 * @param {object} param
	 * @param {string} param.key 本地缓存中的指定的 key
	 */
	var removeStorage = function removeStorage(param) {
	  if (beforeInvoke('removeStorage', param, {
	    key: ''
	  })) {
	    invokeMethod('removeStorage', param);
	  }
	};

	/**
	 * @function removeStorageSync
	 * @description 从本地缓存中同步移除指定 key
	 * @param {string} key 本地缓存中的指定的 key
	 */
	var removeStorageSync = function removeStorageSync(key) {
	  if (beforeInvoke('removeStorageSync', key, '')) {
	    invokeMethod('removeStorageSync', {
	      key: key
	    });
	  }
	};

	/**
	 * @function clearStorage
	 * @description 清理本地数据缓存
	 */
	var clearStorage = function clearStorage(param) {
	  invokeMethod('clearStorage', param);
	};

	/**
	 * @function clearStorageSync
	 * @description 同步清理本地数据缓存
	 */
	var clearStorageSync = function clearStorageSync() {
	  invokeMethod('clearStorageSync');
	};

	/**
	 * @function getStorageInfo
	 * @description 异步获取当前storage的相关信息
	 * @param {object} param
	 * @param {getStorageInfoSuccessCallback} [param.success] 成功回调
	 */
	var getStorageInfo = function getStorageInfo(param) {
	  invokeMethod('getStorageInfo', param);
	};

	/**
	 * @function getStorageInfoSync
	 * @description 同步获取当前storage的相关信息
	 * @returns {object}
	 * @example
	try {
	  var res = tt.getStorageInfoSync()
	  logger.log(res.keys);
	  logger.log(res.currentSize);
	  logger.log(res.limitSize);
	} catch (error) {
	  // Do something when catch error
	}
	 */
	var getStorageInfoSync = function getStorageInfoSync() {
	  var result;
	  invokeMethod('getStorageInfoSync', {}, {
	    beforeAll: function beforeAll(res) {
	      result = res;
	      delete res.errMsg;
	    }
	  });
	  return result;
	};

	/**
	 * getStorage success callback
	 * @callback getStorageSuccessCallback
	 * @param {object} response
	 * @param {*} response.data 指定 key 对应的内容
	 */

	/**
	 * getStorageInfo success callback
	 * @callback getStorageInfoSuccessCallback
	 * @param {object} response
	 * @param {string[]} response.keys 当前storage中所有的key
	 * @param {number} response.currentSize 当前占用的空间大小, 单位kb
	 * @param {number} response.limitSize 限制的空间大小，单位kb
	 */

	var isGettingLocation = false;
	var invokeQueue = [];

	/**
	 * @function getLocation
	 * @description 获取当前的地理位置
	 * @param {object} param
	 * @param {getLocationSuccessCallback} [param.success] 成功回调
	 */
	function getLocation() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (isGettingLocation) {
	        invokeQueue.push(param);
	    } else {
	        isGettingLocation = true;
	        invokeMethod("getLocation", param, {
	            beforeAll: function beforeAll() {
	                isGettingLocation = false;
	            },
	            afterAll: function afterAll(res) {
	                invokeQueue.forEach(function (t) {
	                    "function" == typeof t.complete && surroundByTryCatchFactory(t.complete, "at getLocation complete callback function")(res);
	                });
	                invokeQueue = [];
	            },
	            afterSuccess: function afterSuccess(res) {
	                invokeQueue.forEach(function (t) {
	                    "function" == typeof t.success && surroundByTryCatchFactory(t.success, "at getLocation success callback function")(res);
	                });
	            },
	            afterFail: function afterFail(res) {
	                invokeQueue.forEach(function (t) {
	                    "function" == typeof t.fail && surroundByTryCatchFactory(t.fail, "at getLocation fail callback function")(res);
	                });
	            }
	        });
	    }
	}

	/**
	 * getLocation success callback
	 * @callback getLocationSuccessCallback
	 * @param {object} response
	 * @param {number} response.latitude 纬度，范围为-90~90，负数表示南纬
	 * @param {number} response.longitude 经度，范围为-180~180，负数表示西经
	 */

	/**
	 * openLocation
	 * @description ​使用头条内置地图查看位置
	 * @param {object} param
	 * @param {number} param.latitude 纬度，范围为-90~90，负数表示南纬
	 * @param {number} param.longitude 经度，范围为-180~180，负数表示西经
	 * @param {number} [param.scale] 缩放比例，范围5~18，默认为18
	 * @param {string} [param.name] 位置名
	 * @param {function} [param.success] 接口调用成功的回调函数
	 * @param {function} [param.fail] 接口调用失败的回调函数
	 * @param {function} [param.complete] 接口调用结束的回调函数（调用成功、失败都会执行）
	 */
	function openLocation() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (beforeInvoke('openLocation', param, {
	        latitude: 0,
	        longitude: 0
	    })) {
	        invokeMethod('openLocation', param);
	    }
	}

	var _global$__JSSDK_VERSI = _global$2.__JSSDK_VERSION__,
	    SDKVersion = _global$__JSSDK_VERSI.SDKVersion,
	    SDKUpdateVersion = _global$__JSSDK_VERSI.SDKUpdateVersion,
	    CommitHash = _global$__JSSDK_VERSI.CommitHash;

	/**
	 * @function getSystemInfo
	 * @description 获取系统信息
	 * @param {object} param
	 * @param {getSystemInfoSuccessCallback} [param.success] 回调
	 */

	function getSystemInfo(param) {
	  invokeMethod('getSystemInfo', param, {
	    beforeSuccess: function beforeSuccess(res) {
	      res.SDKVersion = SDKVersion;
	      res.SDKUpdateVersion = SDKUpdateVersion;
	      res.platform = res.platform && res.platform.toLocaleLowerCase();
	    }
	  });
	}

	/**
	 * @function getSystemInfoSync
	 * @description 同步获取系统信息
	 * @returns {object}
	 */
	function getSystemInfoSync$1() {

	  var ret = {};
	  invokeMethod('getSystemInfoSync', {}, {
	    beforeSuccess: function beforeSuccess() {
	      var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      res.platform = res.platform && res.platform.toLocaleLowerCase();
	      res.SDKVersion = SDKVersion;
	      res.SDKUpdateVersion = SDKUpdateVersion;
	      res.devicePixelRatio = res.pixelRatio; // 兼容cocos adapter高分屏支持
	      ret = res;
	    }
	  });
	  return ret;
	}

	/**
	 * getSystemInfo success callback
	 * @callback getSystemInfoSuccessCallback
	 * @param {object} response
	 * @param {*} response.data 指定 key 对应的内容
	 * @param {string} response.brand 手机品牌
	 * @param {string} response.model 手机型号
	 * @param {number} response.pixelRatio 设备像素比
	 * @param {number} response.screenWidth 屏幕宽度
	 * @param {number} response.screenHeight 屏幕高度
	 * @param {number} response.windowWidth 可使用窗口宽度
	 * @param {number} response.windowHeight 可使用窗口高度
	 * @param {string} response.version App 版本号
	 * @param {string} response.system 操作系统版本
	 * @param {string} response.platform 客户端平台
	 * @param {string} response.SDKVersion 客户端基础库版本
	 */

	var listeners$1 = [];

	onMethod('onNetworkStatusChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  listeners$1.forEach(function (cb) {
	    typeof cb === 'function' && cb(res);
	  });
	});

	/**
	 * @function getNetworkType
	 * @description 获取网络类型
	 * @param {object} param
	 * @param {getNetworkTypeSuccessCallback} param.success 执行成功的回调方法
	 * @example
	tt.getNetworkType({
	    success (res) {
	        let network = res.networkType
	    }
	});
	 */
	function getNetworkType() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('getNetworkType', param);
	}

	/**
	 * @function getConnectedWifi
	 * @description 获取链接的wifi信息
	 * @param {object} param
	 * @param {getConnectedWifiSuccessCallback} param.success 执行成功的回调方法
	 * @example
	tt.getConnectedWifi({
	    success (res) {
	        let SSID = res.SSID
	    }
	});
	 */
	function getConnectedWifi() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('getConnectedWifi', param);
	}

	/**
	 * @function onNetworkStatusChange
	 * @description 监听网络状态变化
	 * @param {onNetworkStatusChangeCallback} callback
	 * @example
	tt.onNetworkStatusChange(function(res) {
	  logger.log(res.isConnected, res.networkType);
	});
	 */
	function onNetworkStatusChange(callback) {
	  listeners$1.push(surroundByTryCatchFactory(callback, 'onNetworkStatusChange'));
	}

	// TODO 确认返回值准确范围
	/**
	 * getNetworkType success callback
	 * @callback getNetworkTypeSuccessCallback
	 * @param {object} response
	 * @param {string} response.networkType 网络类型，有效值包括 wifi/2g/3g/4g
	 */
	/**
	 * onNetworkStatusChange callback
	 * @callback onNetworkStatusChangeCallback
	 * @param {object} response
	 * @param {boolean} response.isConnected 当前是否有网
	 * @param {string} response.networkType 网络类型，有效值包括 wifi/2g/3g/4g
	 */

	var listeners$2 = [];
	var enableCompass = false;

	onMethod('onCompassChange', function () {
	  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  listeners$2.forEach(function (fn) {
	    'function' === typeof fn && fn(e);
	  });
	});

	function onCompassChange(cb) {
	  enableCompass || (invokeMethod('startCompass', {}), enableCompass = true);
	  if ('function' === typeof cb) {
	    listeners$2.push(Reporter.surroundThirdByTryCatch(cb, 'onCompassChange'));
	  }
	}

	function startCompass() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('startCompass', param);
	  enableCompass = true;
	}

	function stopCompass() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('stopCompass', param);
	  enableCompass = false;
	}

	var enable$1 = false;
	var listeners$3 = [];

	function startAccelerometer() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  enable$1 = true;

	  invokeMethod('enableAccelerometer', _extends({}, param, {
	    enable: enable$1
	  }), {
	    beforeAll: function beforeAll(res) {
	      res.errMsg = res.errMsg.replace('enableAccelerometer', 'startAccelerometer');
	    }
	  });
	}

	function stopAccelerometer() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  enable$1 = false;

	  invokeMethod('enableAccelerometer', _extends({}, param, { enable: enable$1 }), _extends({}, param, {
	    beforeAll: function beforeAll(res) {
	      res.errMsg = res.errMsg.replace('enableAccelerometer', 'stopAccelerometer');
	    }
	  }));
	}

	function onAccelerometerChange(cb) {
	  if (typeof cb !== 'function') {
	    return;
	  }

	  if (!enable$1) {
	    enable$1 = true;

	    invokeMethod('enableAccelerometer', { enable: enable$1 });
	  }

	  listeners$3.push(surroundByTryCatchFactory(cb, 'onAccelerometerChange'));
	}

	onMethod('onAccelerometerChange', function () {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  for (var i in listeners$3) {
	    listeners$3[i](param);
	  }
	});

	/**
	 * @function makePhoneCall
	 * @description 调起系统电话
	 * @param {object} param
	 * @param {string} param.phoneNumber 需要拨打的电话号码
	 * @param {function} [param.success] 接口调用成功的回调函数
	 * @param {function} [param.fail] 接口调用失败的回调函数
	 * @param {function} [param.complete] 接口调用结束的回调函数（调用成功、失败都会执行）
	 * @return {undefined}
	 */
	function makePhoneCall(param) {
	    if (beforeInvoke('makePhoneCall', param, {
	        phoneNumber: ''
	    })) {
	        invokeMethod('makePhoneCall', param);
	    }
	}

	/**
	 * @function scanCode
	 * @description 扫描二维码，返回结果
	 * 
	 * @param {object} param
	 * @param {scanCodeSuccessCallback} param.success 成功回调
	 */
	function scanCode() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (beforeInvoke("scanCode", param, {})) {
	        invokeMethod("scanCode", param, {
	            beforeSuccess: function beforeSuccess(res) {
	                "string" == typeof res.path && (res.path = res.path.replace(/\.html$/, ""), res.path = res.path.replace(/\.html\?/, "?"));
	            }
	        });
	    }
	}

	/**
	 * scanCode success callback
	 * @callback scanCodeSuccessCallback
	 * @param {object} response
	 * @param {string} response.result 所扫码的内容
	 */

	/**
	 * @function getClipboardData
	 * @description 获取系统剪贴板内容
	 * @example
	tt.getClipboardData({
	    success: function(res){
	        logger.log(res.data)
	    }
	})
	 */
	function getClipboardData() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('getClipboardData', param);
	}

	/**
	 * @function setClipboardData
	 * @description 设置系统剪贴板的内容
	 * @param {object} param
	 * @param {string} param.data 需要设置的内容
	 * @example
	tt.setClipboardData({
	    data: 'data',
	    success: function(res) {
	        tt.getClipboardData({
	            success: function(res) {
	                logger.log(res.data);
	            }
	        });
	    }
	})
	 */
	var paramDataType = {
	    data: 'String'
	};
	function setClipboardData() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (beforeInvoke('setClipboardData', param, paramDataType)) {
	        invokeMethod('setClipboardData', param);
	    }
	}

	/**
	 * @function setKeepScreenOn
	 * @description 设置是否保持常亮状态。 仅在当前小功能生效， 离开小功能后设置失效。
	 * @param {object} param
	 * @param {boolean} [param.keepScreenOn=true] 是否保持屏幕常亮
	 * @example
	tt.setKeepScreenOn({
	    keepScreenOn: true
	})
	 */
	function setKeepScreenOn() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (typeof param.keepScreenOn === 'undefined') {
	    param.keepScreenOn = true;
	  }

	  if (beforeInvoke('setKeepScreenOn', param, {
	    keepScreenOn: true
	  })) {
	    invokeMethod('setKeepScreenOn', param);
	  }
	}

	/**
	 * @function vibrateShort
	 * @description 使手机发生较短时间的振动
	 * 只有部分机型生效
	 */
	function vibrateShort() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('vibrateShort', param);
	}

	/**
	 * @function vibrateLong
	 * @description 使手机发生较长时间的振动
	 */
	function vibrateLong() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('vibrateLong', param);
	}

	/**
	 * @function showModal
	 * @description 显示模态弹窗
	 * @param {object} param
	 * @param {string} param.title 提示的标题
	 * @param {string} param.content 提示的内容
	 * @param {string} [param.confirmText=确定] 确定按钮的文字，最多 4 个字符
	 * @param {string} [param.confirmColor=#3CC51F] 确定按钮的文字颜色
	 * @param {boolean} [param.showCancel=true] 是否显示取消按钮
	 * @param {string} [param.cancelText=取消] 取消按钮的文字，最多 4 个字符
	 * @param {string} [param.cancelColor=#000000] 取消按钮的文字颜色
	 * @param {showModalSuccessCallback} [param.success] 执行成功的回调方法
	 * @example
	tt.showModal({
	  title: '提示',
	  content: '这是一个模态弹窗',
	  success: function(res) {
	    if (res.confirm) {
	      logger.log('用户点击确定')
	    } else if (res.cancel) {
	      logger.log('用户点击取消')
	    }
	  }
	})
	 */
	function showModal() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var defaultParam = {
	    title: '',
	    content: '',
	    confirmText: '确定',
	    cancelText: '取消',
	    showCancel: true,
	    confirmColor: '#3CC51F',
	    cancelColor: '#000000'
	  };

	  var paramDataType = {
	    title: 'String',
	    content: 'String',
	    confirmText: 'String',
	    cancelText: 'String',
	    confirmColor: 'String',
	    cancelColor: 'String'
	  };

	  // 计算str字节长度
	  var getByteLength = function getByteLength(str) {
	    return str.replace(/[^\u0000-\u00ff]/g, 'aa').length;
	  };

	  param = Object.assign({}, defaultParam, param);

	  if (beforeInvoke('showModal', param, paramDataType)) {
	    if (getByteLength(param.confirmText) > 8) {
	      beforeInvokeFail('showModal', param, 'confirmText length should not larger than 4 Chinese characters');
	    } else if (getByteLength(param.cancelText) > 8) {
	      beforeInvokeFail('showModal', param, 'cancelText length should not larger than 4 Chinese characters');
	    } else {
	      invokeMethod('showModal', param);
	    }
	  }
	}

	/**
	 * @function showToast
	 * @description 显示消息提示
	 * @param {object} param
	 * @param {string} param.title 提示的内容
	 * @param {number} [param.duration=1500] 提示的延迟时间，单位毫秒
	 * @param {string} [param.icon=success] 图标类型，有效值有 success/loading/none。当显示图标时，提示内容最多展示 7 个汉字，无图标时，提示内容可显示 14 个汉字。
	 * @param {string} [param.image] 自定义图标的本地路径，image 的优先级高于 icon
	 * @param {boolean} [param.mask=false] 是否显示透明蒙层，防止触摸穿透
	 * @example
	tt.showToast({
	  title: '举报成功',
	  icon: 'success',
	  duration: 2000
	});
	 */
	function showToast() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var defaultParam = {
	    duration: 1500,
	    title: '',
	    icon: 'success'
	  };

	  var paramDataType = {
	    duration: 1,
	    title: 'String',
	    icon: 'String'
	  };

	  param = Object.assign({}, defaultParam, param);

	  if (['success', 'loading', 'none'].indexOf(param.icon) === -1) {
	    param.icon = 'success';
	  } else if (param.icon === 'none') {
	    param.icon = '';
	  }

	  if (beforeInvoke('showToast', param, paramDataType)) {
	    invokeMethod('showToast', param);
	  }
	}

	/**
	 * @function hideToast
	 * @description 隐藏消息提示框
	 */
	function hideToast() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('hideToast', param);
	}

	/**
	 * @function showLoading
	 * @description 显示 loading 提示框, 需主动调用 hideLoading 才能关闭提示框
	 * @param {object} param
	 * @param {string} param.title 提示的内容
	 */
	function showLoading() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var ONE_DAY_MS = 24 * 60 * 60 * 1000;
	  var coverParam = {
	    icon: 'loading',
	    duration: ONE_DAY_MS
	  };

	  var paramDataType = {
	    title: 'String'
	  };

	  param = Object.assign(param, coverParam);

	  // showLoading的本质是 showToast
	  if (beforeInvoke('showLoading', param, paramDataType)) {
	    invokeMethod('showToast', param, {
	      beforeAll: function beforeAll(res) {
	        res.errMsg = res.errMsg.replace('showToast', 'showLoading');
	      }
	    });
	  }
	}

	/**
	 * @function hideLoading
	 * @description 隐藏 loading 提示框
	 */
	function hideLoading(param) {
	  invokeMethod('hideToast', param, {
	    beforeAll: function beforeAll(res) {
	      res.errMsg = res.errMsg.replace('hideToast', 'hideLoading');
	    }
	  });
	}

	/**
	 * @function showActionSheet
	 * @description 显示操作菜单
	 * @param {object} param
	 * @param {string[]} param.itemList 按钮的文字数组，数组长度最大为6个
	 * @param {string} [param.itemColor=#000000] 按钮的文字颜色
	 * @param {showActionSheetSuccessCallback} [param.success] 接口调用成功的回调函数
	 * @example
	tt.showActionSheet({
	  itemList: ['微信', '微博', '陌陌'],
	  success: function(res) {
	    logger.log(res.tapIndex)
	  }
	});
	 */
	function showActionSheet() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var paramDataType = {
	    itemList: ['String']
	  };

	  if (beforeInvoke('showActionSheet', param, paramDataType)) {
	    if (param.itemList.length < 1) {
	      beforeInvokeFail('showActionSheet', param, 'param.itemList should has at least 1 item');
	    }
	    if (param.itemList.length > 6) {
	      beforeInvokeFail('showActionSheet', param, 'param.itemList should has at most 6 items');
	    } else {
	      invokeMethod('showActionSheet', param);
	    }
	  }
	}

	/**
	 * showModal success callback
	 * @callback showModalSuccessCallback
	 * @param {object} response
	 * @param {boolean} response.confirm 为 true 时，表示用户点击了确定按钮
	 * @param {boolean} response.cancel 为 true 时，表示用户点击了取消（用于 Android 系统区分点击蒙层关闭还是点击取消按钮关闭）
	 */
	/**
	 * showActionSheet success callback
	 * @callback showActionSheetSuccessCallback
	 * @param {object} response
	 * @param {number} response.tapIndex 用户点击的按钮，从上到下的顺序，从0开始
	 */

	/**
	 * @function setNavigationBarTitle
	 * @description 动态设置当前页面的标题
	 * @param {object} param 
	 * @param {string} param.title 标题
	 * @example
	tt.setNavigationBarTitle({
	  title: '当前页面'
	})
	 */
	var api = 'setNavigationBarTitle';
	var paramDataType$1 = {
	    title: 'String'
	};
	function setNavigationBarTitle() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (beforeInvoke(api, param, paramDataType$1)) {
	        invokeMethod(api, param);
	    }
	}

	/**
	 * @function redirectTo
	 * @description 关闭当前页面，跳转到应用内的某个页面
	 * @param {object} param
	 * @param {string} param.url 需要跳转的应用内非 tabBar 的页面的路径，路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&分隔；如 'path?key=value&key2=value2'
	 */
	function redirectTo(param) {
	  if (beforeInvoke('redirectTo', param, {
	    url: ''
	  })) {
	    param.url = getRealRoute(LifecycleState$1.path, param.url);
	    param.url = encodeUrlQuery(param.url);
	    if (checkUrlInConfig('redirectTo', param.url, param)) {
	      GlobalState.navigatorLock = true;
	      invokeMethod('redirectTo', param, {
	        afterFail: function afterFail() {
	          GlobalState.navigatorLock = false;
	        }
	      });
	    }
	  }
	}

	/**
	 * @function reLaunch
	 * @description 关闭所有页面，打开到应用内的某个页面
	 * @param {object} param
	 * @param {string} param.url 需要跳转的应用内页面路径 , 路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&分隔；如 'path?key=value&key2=value2'，如果跳转的页面路径是 tabBar 页面则不能带参数
	 */
	function reLaunch(param) {
	  // GSTODO 需要对齐一下微信的逻辑，貌似是后台不能reLaunch？为什么呢？
	  if (beforeInvoke('reLaunch', param, {
	    url: ''
	  })) {
	    param.url = getRealRoute(LifecycleState$1.path, param.url);
	    param.url = encodeUrlQuery(param.url);
	    checkUrlInConfig('reLaunch', param.url, param) && (GlobalState.navigatorLock = true, invokeMethod('reLaunch', param, {
	      afterFail: function afterFail() {
	        GlobalState.navigatorLock = false;
	      }
	    }));
	  }
	}

	/**
	 * @function navigateTo
	 * @description 保留当前页面，跳转到应用内的某个页面
	 * @param {object} param
	 * @param {string} param.url 需要跳转的应用内非 tabBar 的页面的路径 , 路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&分隔；如 'path?key=value&key2=value2'
	 */
	function navigateTo(param) {
	  var pages = getCurrentPages();
	  // arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
	  beforeInvoke('navigateTo', param, {
	    url: ''
	  }) && (param.url = getRealRoute(LifecycleState$1.path, param.url), param.url = encodeUrlQuery(param.url), checkUrlInConfig('navigateTo', param.url, param) && (GlobalState.navigatorLock = true, invokeMethod('navigateTo', param, {
	    beforeSuccess: function beforeSuccess() {
	      publish('onHide', {}, [pages[pages.length - 1].__webviewId__]);
	    },
	    afterFail: function afterFail() {
	      GlobalState.navigatorLock = false;
	    }
	  })));
	}

	/**
	 * @function switchTab
	 * @description 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
	 * @param {object} param
	 * @param {string} param.url 需要跳转的 tabBar 页面的路径（需在 app.json 的 tabBar 字段定义的页面），路径后不能带参数
	 */
	function switchTab() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  beforeInvoke('switchTab', param, {
	    url: ''
	  }) && (/\?.*$/.test(param.url) && (logger.warn('switchTab: url 不支持 queryString'), param.url = param.url.replace(/\?.*$/, '')), param.url = getRealRoute(LifecycleState$1.path, param.url), param.url = encodeUrlQuery(param.url), logger.log(LifecycleState$1.path, param.url), checkUrlInConfig('switchTab', param.url, param) && (GlobalState.navigatorLock = true, invokeMethod('switchTab', param, {
	    afterFail: function afterFail() {
	      GlobalState.navigatorLock = false;
	    }
	  })));
	}

	/**
	 * @function navigateBack
	 * @description 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages()) 获取当前的页面栈，决定需要返回几层。
	 * @param {object} param
	 * @param {number} param.delta 返回的页面数，如果 delta 大于现有页面数，则返回到首页
	 */
	function navigateBack() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (typeof param.delta !== 'number') {
	    param.delta = 1;
	  } else {
	    param.delta = parseInt(param.delta);
	    param.delta < 1 && (param.delta = 1);
	  }
	  invokeMethod('navigateBack', param);
	}

	function toDashcase(str) {
	  return str.replace(/[A-Z]/g, function (code) {
	    return '-' + code.toLowerCase();
	  });
	}

	function plusDeg(e) {
	  return e + 'deg';
	}

	function plusPx(e) {
	  return 'number' == typeof e ? e + 'px' : e;
	}

	function pinOneAction(oneAction) {
	  var oneAnimates = oneAction.animates,
	      oneOption = oneAction.option;

	  var transformString = oneAnimates.filter(function (animate) {
	    return animate.type !== 'style';
	  }).map(function (animate) {
	    var property = animate.type,
	        values = animate.args;
	    switch (property) {
	      case 'matrix':
	        return 'matrix(' + values.join(',') + ')';
	      case 'matrix3d':
	        return 'matrix3d(' + values.join(',') + ')';
	      case 'rotate':
	        values = values.map(plusDeg);
	        return 'rotate(' + values[0] + ')';
	      case 'rotate3d':
	        var deg = values[3];

	        if (deg && !String(deg).endsWith('deg')) {
	          values[3] = plusDeg(deg);
	        }

	        return 'rotate3d(' + values.join(',') + ')';
	      case 'rotateX':
	        values = values.map(plusDeg);
	        return 'rotateX(' + values[0] + ')';
	      case 'rotateY':
	        values = values.map(plusDeg);
	        return 'rotateY(' + values[0] + ')';
	      case 'rotateZ':
	        values = values.map(plusDeg);
	        return 'rotateZ(' + values[0] + ')';
	      case 'scale':
	        return 'scale(' + values.join(',') + ')';
	      case 'scale3d':
	        return 'scale3d(' + values.join(',') + ')';
	      case 'scaleX':
	        return 'scaleX(' + values[0] + ')';
	      case 'scaleY':
	        return 'scaleY(' + values[0] + ')';
	      case 'scaleZ':
	        return 'scaleZ(' + values[0] + ')';
	      case 'translate':
	        values = values.map(plusPx);
	        return 'translate(' + values.join(',') + ')';
	      case 'translate3d':
	        values = values.map(plusPx);
	        return 'translate3d(' + values.join(',') + ')';
	      case 'translateX':
	        values = values.map(plusPx);
	        return 'translateX(' + values[0] + ')';
	      case 'translateY':
	        values = values.map(plusPx);
	        return 'translateY(' + values[0] + ')';
	      case 'translateZ':
	        values = values.map(plusPx);
	        return 'translateZ(' + values[0] + ')';
	      case 'skew':
	        values = values.map(plusDeg);
	        return 'skew(' + values.join(',') + ')';
	      case 'skewX':
	        values = values.map(plusDeg);
	        return 'skewX(' + values[0] + ')';
	      case 'skewY':
	        values = values.map(plusDeg);
	        return 'skewY(' + values[0] + ')';
	      default:
	        return '';
	    }
	  }).join(' ');

	  var styleMap = oneAnimates.filter(function (animate) {
	    return 'style' === animate.type;
	  }).reduce(function (result, animate) {
	    result[animate.args[0]] = animate.args[1];
	    return result;
	  }, {});

	  var css = ';';
	  for (var i in styleMap) {
	    css += i + ': ' + styleMap[i] + '; ';
	  }

	  if (oneOption.transformOrigin) {
	    css += 'transform-origin: ' + oneOption.transformOrigin + '; '; // add px
	  }

	  var transition = oneOption.duration + 'ms ' + oneOption.timingFunction + ' ' + oneOption.delay + 'ms';
	  var transStyles = ['transform'];
	  if (Object.keys(styleMap).length > 0) {
	    transStyles = transStyles.concat(Object.keys(styleMap));
	  }
	  css += 'transition: ';
	  css += transStyles.map(function (pro) {
	    return pro + ' ' + transition;
	  }).join(' , ');
	  css += ';';

	  if (transformString) {
	    css += 'transform: ' + transformString + ';';
	  }

	  // return {
	  //     style: styleMap,
	  //     transformOrigin: oneOption.transformOrigin,
	  //     transform: transformString,
	  //     transitionProperty: ["transform"].concat(copyArray(Object.keys(styleMap))).join(","),
	  //     transition: oneOption.duration + "ms " + oneOption.timingFunction + " " + oneOption.delay + "ms"
	  // }

	  return css;
	}

	var CreateAnimation = function () {
	  function CreateAnimation() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    classCallCheck(this, CreateAnimation);

	    this.actions = []; // actions是最终导出的
	    this.currentTransform = [];
	    this.currentStepAnimates = [];
	    this.option = {
	      duration: param.duration || 400,
	      timingFunction: param.timingFunction || 'linear',
	      delay: param.delay || 0,
	      transformOrigin: param.transformOrigin || '50% 50% 0'
	    };
	  }

	  CreateAnimation.prototype.export = function _export() {
	    var steps = this.actions;
	    this.actions = [];
	    return JSON.stringify({
	      steps: steps
	    });
	  };

	  //


	  CreateAnimation.prototype.step = function step() {
	    var _this = this;

	    var currentOption = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    this.currentStepAnimates.forEach(function (step) {
	      if (step.type === 'style') {
	        _this.currentTransform[step.type + '.' + step.args[0]] = step;
	      } else {
	        _this.currentTransform[step.type] = step;
	      }
	    });

	    var animates = Object.keys(this.currentTransform).reduce(function (res, key) {
	      return [].concat(res, [_this.currentTransform[key]]);
	    }, []);
	    var option = Object.assign({}, this.option, currentOption);

	    this.actions.push({
	      text: pinOneAction({
	        animates: animates,
	        option: option
	      }),
	      option: option
	    });

	    this.currentStepAnimates = [];

	    return this;
	  };

	  CreateAnimation.prototype.scale = function scale() {
	    var sx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	    var sy = arguments[1];

	    sy = void 0 !== sy ? sy : sx;
	    this.currentStepAnimates.push({
	      type: 'scale',
	      args: [sx, sy]
	    });
	    return this;
	  };

	  CreateAnimation.prototype.translate = function translate() {
	    var tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    this.currentStepAnimates.push({
	      type: 'translate',
	      args: [tx, ty]
	    });
	    return this;
	  };

	  CreateAnimation.prototype.skew = function skew() {
	    var ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var ay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    this.currentStepAnimates.push({
	      type: 'skew',
	      args: [ax, ay]
	    });
	    return this;
	  };

	  CreateAnimation.prototype.rotate3d = function rotate3d() {
	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	    this.currentStepAnimates.push({
	      type: 'rotate3d',
	      args: [x, y, z, a]
	    });

	    // this.stepping = false;

	    return this;
	  };

	  CreateAnimation.prototype.scale3d = function scale3d() {
	    var sx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	    var sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	    var sz = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

	    this.currentStepAnimates.push({
	      type: 'scale3d',
	      args: [sx, sy, sz]
	    });
	    return this;
	  };

	  CreateAnimation.prototype.translate3d = function translate3d() {
	    var tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var tz = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	    this.currentStepAnimates.push({
	      type: 'translate3d',
	      args: [tx, ty, tz]
	    });
	    return this;
	  };

	  CreateAnimation.prototype.matrix = function matrix() {
	    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
	    var tx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
	    var ty = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

	    this.currentStepAnimates.push({
	      type: 'matrix',
	      args: [a, b, c, d, tx, ty]
	    });
	    return this;
	  };

	  CreateAnimation.prototype.matrix3d = function matrix3d() {
	    var a1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	    var b1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var c1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var d1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	    var a2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
	    var b2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
	    var c2 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
	    var d2 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
	    var a3 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
	    var b3 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
	    var c3 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
	    var d3 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
	    var a4 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
	    var b4 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
	    var c4 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
	    var d4 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;

	    this.currentStepAnimates.push({
	      type: 'matrix3d',
	      args: [a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4]
	    });
	    // this.stepping = false;
	    return this;
	  };

	  return CreateAnimation;
	}();

	// 样式


	['opacity', 'backgroundColor'].forEach(function (property) {
	  CreateAnimation.prototype[property] = function (value) {
	    this.currentStepAnimates.push({
	      type: 'style',
	      args: [toDashcase(property), value]
	    });
	    return this;
	  };
	});
	['width', 'height', 'top', 'bottom', 'left', 'right'].forEach(function (direction) {
	  CreateAnimation.prototype[direction] = function (length) {
	    if (typeof length === 'number') {
	      length += 'px';
	    }

	    this.currentStepAnimates.push({
	      type: 'style',
	      args: [direction, length]
	    });

	    return this;
	  };
	});

	// 旋转
	['rotate', 'rotateX', 'rotateY', 'rotateZ'].forEach(function (method) {
	  CreateAnimation.prototype[method] = function () {
	    var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    this.currentStepAnimates.push({
	      type: method,
	      args: [angle]
	    });
	    // if (method !== 'rotate') {
	    //     this.stepping = false;
	    // }
	    return this;
	  };
	});
	// rotate3d

	// 缩放
	['scaleX', 'scaleY', 'scaleZ'].forEach(function (method) {
	  CreateAnimation.prototype[method] = function () {
	    var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

	    this.currentStepAnimates.push({
	      type: method,
	      args: [scale]
	    });
	    return this;
	  };
	});
	// scale, scale3d

	// 偏移
	// translate, translate3d
	['translateX', 'translateY', 'translateZ'].forEach(function (method) {
	  CreateAnimation.prototype[method] = function () {
	    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    this.currentStepAnimates.push({
	      type: method,
	      args: [value]
	    });
	    return this;
	  };
	});

	// 倾斜
	// skew
	['skewX', 'skewY'].forEach(function (method) {
	  CreateAnimation.prototype[method] = function () {
	    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    this.currentStepAnimates.push({
	      type: method,
	      args: [value]
	    });
	    return this;
	  };
	});

	// 矩阵变形
	// 都在类里 matrix matrix3d

	/**
	 * @function createAnimation
	 * @description 创建一个动画实例animation。调用实例的方法来描述动画。最后通过动画实例的export方法导出动画数据传递给组件的animation属性。
	 *
	 * @param {object} param
	 * @param {number} [param.duration=400] 动画持续时间，单位ms
	 * @param {string} [param.timingFunction="linear"] 定义动画的效果，可选值："linear", "ease", "ease-in", "ease-in-out", "ease-out", "step-start", "step-end"
	 * @param {boolean} [param.delay=true] 是否压缩所选的视频源文件
	 * @param {number} [param.transformOrigin="50% 50% 0"] 设置transform-origin
	 * @return {object} 动画示例
	 */
	function createAnimation() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  return new CreateAnimation(param);
	}

	/**
	 * @function pageScrollTo
	 * @description 将页面滚动到目标位置
	 * @param {object} param
	 * @param {number} param.scrollTop 滚动到页面的目标位置（单位px）
	 * @param {number} [param.duration] 滚动动画的时长，默认300ms，单位 ms
	 */
	function pageScrollTo(param) {
	  var pages = getCurrentPages();
	  var targetWvid = pages[pages.length - 1].__webviewId__;
	  param.hasOwnProperty('page') && param.page.hasOwnProperty('__webviewId__') && (targetWvid = param.page.__webviewId__);
	  publish('pageScrollTo', param, [targetWvid]);
	}

	var disablePageScroll = function disablePageScroll(disable) {
	  var pages = getCurrentPages();
	  var targetWvid = pages[pages.length - 1].__webviewId__;

	  publish('disable-scroll', {
	    disable: disable
	  }, [targetWvid]);
	};

	function startPullDownRefresh() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod("startPullDownRefresh", param, {});
	}

	/**
	 * @function stopPullDownRefresh
	 * @description 停止当前页面下拉刷新
	 * @example
	Page({
	    onPullDownRefresh: function(){
	        tt.stopPullDownRefresh()
	    }
	})
	 */
	function stopPullDownRefresh(param) {
	    invokeMethod("stopPullDownRefresh", param);
	}

	function noop$3() {}

	function deepcopy(variable) {
	  if (Array.isArray(variable)) {
	    var res = [];
	    variable.forEach(function (item) {
	      res.push(deepcopy(item));
	    });
	    return res;
	  }

	  if ((typeof variable === 'undefined' ? 'undefined' : _typeof(variable)) === 'object') {
	    var reso = {};
	    for (var i in variable) {
	      reso[i] = deepcopy(variable[i]);
	    }
	    return reso;
	  }

	  return variable;
	}

	function transformColor(e) {
	  var t = null;
	  if (null != (t = /^#([0-9|A-F|a-f]{6})$/.exec(e))) {
	    var n = parseInt(t[1].slice(0, 2), 16),
	        r = parseInt(t[1].slice(2, 4), 16),
	        o = parseInt(t[1].slice(4), 16);
	    return [n, r, o, 255];
	  }
	  if (null != (t = /^rgb\((.+)\)$/.exec(e))) {
	    return t[1].split(',').map(function (e) {
	      return parseInt(e.trim());
	    }).concat(255);
	  }
	  if (null != (t = /^rgba\((.+)\)$/.exec(e))) {
	    return t[1].split(',').map(function (e, t) {
	      return 3 == t ? Math.floor(255 * parseFloat(e.trim())) : parseInt(e.trim());
	    });
	  }
	  var i = e.toLowerCase();
	  if (predefinedColor.hasOwnProperty(i)) {
	    t = /^#([0-9|A-F|a-f]{6})$/.exec(predefinedColor[i]);
	    var _n = parseInt(t[1].slice(0, 2), 16),
	        _r = parseInt(t[1].slice(2, 4), 16),
	        _o = parseInt(t[1].slice(4), 16);
	    return [_n, _r, _o, 255];
	  }
	  logger.error('不支持颜色：' + e);
	}

	var Gradient = function () {
	  function Gradient(type, data) {
	    classCallCheck(this, Gradient);

	    this.type = type;
	    this.data = data;
	    this.colorStop = [];
	  }

	  Gradient.prototype.addColorStop = function addColorStop(e, color) {
	    this.colorStop.push([e, transformColor(color)]);
	  };

	  return Gradient;
	}();

	var WebCanvas = function () {
	  function WebCanvas(canvasId, webviewId) {
	    classCallCheck(this, WebCanvas);

	    this.actions = [];
	    this.canvasId = canvasId;
	    this.webviewId = webviewId;
	    this.path = [];
	  }

	  WebCanvas.prototype.draw = function draw() {
	    var reserve = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$3;

	    var actions = deepcopy(this.actions);

	    this.actions = [];
	    this.path = [];

	    var options = {
	      canvasId: this.canvasId,
	      webviewId: this.webviewId,
	      actions: actions,
	      reserve: reserve,
	      callback: callback
	    };

	    var iid = infix(this.webviewId, this.canvasId);

	    if (canvasStore[iid] && Array.isArray(actions)) {
	      callDraw(options);
	    } else {
	      actionsCache[iid] = (actionsCache[iid] || []).concat(options);
	    }
	  };

	  WebCanvas.prototype.beginPath = function beginPath() {
	    this.path = [];
	  };

	  WebCanvas.prototype.clip = function clip() {
	    this.actions.push({
	      method: 'clip',
	      data: deepcopy(this.path)
	    });
	  };

	  WebCanvas.prototype.lineTo = function lineTo() {
	    if (this.path.length > 0) {
	      this.path.push({
	        method: 'lineTo',
	        data: [].concat(Array.prototype.slice.call(arguments))
	      });
	    } else {
	      this.path.push({
	        method: 'moveTo',
	        data: [].concat(Array.prototype.slice.call(arguments))
	      });
	    }
	  };

	  WebCanvas.prototype.setFillStyle = function setFillStyle(color) {
	    if (typeof color === 'string') {
	      this.actions.push({
	        method: 'setFillStyle',
	        data: ['normal', transformColor(color)]
	      });
	    } else if (color instanceof Gradient) {
	      this.actions.push({
	        method: 'setFillStyle',
	        data: [color.type, color.data, color.colorStop]
	      });
	    }
	  };

	  WebCanvas.prototype.setStrokeStyle = function setStrokeStyle(color) {
	    if (typeof color === 'string') {
	      this.actions.push({
	        method: 'setStrokeStyle',
	        data: ['normal', transformColor(color)]
	      });
	    } else if (color instanceof Gradient) {
	      this.actions.push({
	        method: 'setStrokeStyle',
	        data: [color.type, color.data, color.colorStop]
	      });
	    }
	  };

	  WebCanvas.prototype.setGlobalAlpha = function setGlobalAlpha(alpha) {
	    this.actions.push({
	      method: 'setGlobalAlpha',
	      data: [Math.floor(255 * alpha)]
	    });
	  };

	  WebCanvas.prototype.setShadow = function setShadow(x, y, blur, color) {
	    this.actions.push({
	      method: 'setShadow',
	      data: [x, y, blur, transformColor(color)]
	    });
	  };

	  WebCanvas.prototype.setLineDash = function setLineDash() {
	    var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0];
	    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    this.actions.push({
	      method: 'setLineDash',
	      data: [pattern, offset]
	    });
	  };

	  WebCanvas.prototype.fill = function fill() {
	    this.actions.push({
	      method: 'fillPath',
	      data: deepcopy(this.path)
	    });
	  };

	  WebCanvas.prototype.stroke = function stroke() {
	    this.actions.push({
	      method: 'strokePath',
	      data: deepcopy(this.path)
	    });
	  };

	  WebCanvas.prototype.fillRect = function fillRect(x, y, w, h) {
	    this.actions.push({
	      method: 'fillPath',
	      data: [{
	        method: 'rect',
	        data: [x, y, w, h]
	      }]
	    });
	  };

	  WebCanvas.prototype.strokeRect = function strokeRect(x, y, w, h) {
	    this.actions.push({
	      method: 'strokePath',
	      data: [{
	        method: 'rect',
	        data: [x, y, w, h]
	      }]
	    });
	  };

	  WebCanvas.prototype.drawImage = function drawImage() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    logger.log('drawImage inner webcanvas', args);
	    if (args[0].indexOf('ttfile://') === 0) {
	      invokeMethod('protocolPathToAbsPath', {
	        protocolPath: args[0]
	      }, {
	        beforeAll: function beforeAll(res) {
	          args[0] = 'file://' + res.absPath;
	        }
	      });
	    }

	    var argsLen = args.length;

	    if (argsLen === 3 || argsLen === 5 || argsLen === 9) ; else {
	      throw new Error('drawImage 参数不合法');
	    }

	    this.actions.push({
	      method: 'drawImage',
	      data: args
	    });
	  };

	  return WebCanvas;
	}();

	['scale', 'rotate', 'translate', 'save', 'restore', 'clearRect', 'fillText', 'setTextAlign', 'setFontSize', 'setLineCap', 'setLineJoin', 'setLineWidth', 'setMiterLimit', 'setTextBaseline'].forEach(function (method) {
	  WebCanvas.prototype[method] = function () {
	    this.actions.push({
	      method: method,
	      data: [].concat(Array.prototype.slice.call(arguments))
	    });
	  };
	});
	['moveTo', 'rect', 'arc', 'quadraticCurveTo', 'bezierCurveTo', 'closePath'].forEach(function (method) {
	  WebCanvas.prototype[method] = function () {
	    this.path.push({
	      method: method,
	      data: [].concat(Array.prototype.slice.call(arguments))
	    });
	  };
	});

	function infix(webviewId, canvasId) {
	  // return `${webviewId}_cvs_${canvasId}`;
	  return '_cvs_' + canvasId;
	}

	function callDraw(_ref) {
	  var canvasId = _ref.canvasId,
	      webviewId = _ref.webviewId,
	      actions = _ref.actions,
	      reserve = _ref.reserve,
	      callback = _ref.callback;

	  logger.log('invoke callDraw', arguments[0]);

	  var randid = guid();

	  ttJSBridge.publish('canvas' + canvasId + 'Draw', {
	    actions: actions,
	    reserve: reserve,
	    randid: randid
	  }, [webviewId]);

	  ttJSBridge.subscribe('canvas' + canvasId + 'DrawDone' + randid, function () {
	    callback();
	  });
	}

	// 先通知webview获取base64图像内容
	// 获取到base64后，交给native处理成本地文件
	// 再返回给调用者
	function getBase64Data(param) {
	  publish('canvas' + param.canvasId + 'ToBase64', param, [param.webviewId]);

	  ttJSBridge.subscribe('canvas' + param.canvasId + 'ToBase64Done', function (res) {
	    invokeMethod('base64ToTempFilePath', Object.assign({
	      base64Data: res.dataUrl
	    }, param), {
	      beforeAll: function beforeAll(res) {
	        res.errMsg = res.errMsg.replace('base64ToTempFilePath', 'canvasToTempFilePath');
	      }
	    });
	  });
	}

	// webview发过来的消息，记录下对应的canvas在store里，
	// 创建ctx时，记录wvid（当前的）和canvasId。使用时（actionsChange 和 image）传回，在store里对比
	// 还有点问题在于，canvasInsert的时候，**不一定**有WebCanvas实例。
	// 这么看，有实例，才会有actionCache对吧。那有actionsCache，一定有实例
	ttJSBridge.subscribe('canvasInsert', function (event, webviewId) {

	  logger.log('subscribe [canvasInsert]', event, webviewId);

	  var iid = infix(webviewId, event.data.canvasId);
	  canvasStore[iid] = true;

	  if (Array.isArray(actionsCache[iid])) {
	    logger.warn('flush old actions');
	    actionsCache[iid].forEach(function (options) {
	      callDraw(options);
	    });
	    actionsCache[iid] = []; // or delete
	  }
	});

	var canvasStore = {};
	var actionsCache = {};

	function createCanvasContext(canvasId) {
	  var cps = getCurrentPages();
	  // TODO 运行时确定，卧槽，这段代码在第一个webview ready之前就tm要执行?！
	  var wvid = cps.length >= 1 ? cps[cps.length - 1].__webviewId__ : -1;

	  logger.log('createCanvasContext', canvasId, wvid);

	  var wc = new WebCanvas(canvasId, wvid);

	  // if (canvasStore[iid]) {
	  //     canvasStore[iid] = wc;
	  // }

	  return wc;
	}

	function canvasToTempFilePath(param) {
	  var cps = getCurrentPages();
	  var cpid = cps[cps.length - 1].__webviewId__;
	  param.webviewId = cpid;

	  var iid = infix(cpid, param.canvasId);

	  if (canvasStore[iid]) {
	    getBase64Data(param);
	  } else {
	    typeof param.fail === 'function' && param.fail({
	      errMsg: 'canvasToTempFilePath: fail canvas is empty'
	    });
	  }
	}

	var predefinedColor = {
	  aliceblue: '#f0f8ff',
	  antiquewhite: '#faebd7',
	  aqua: '#00ffff',
	  aquamarine: '#7fffd4',
	  azure: '#f0ffff',
	  beige: '#f5f5dc',
	  bisque: '#ffe4c4',
	  black: '#000000',
	  blanchedalmond: '#ffebcd',
	  blue: '#0000ff',
	  blueviolet: '#8a2be2',
	  brown: '#a52a2a',
	  burlywood: '#deb887',
	  cadetblue: '#5f9ea0',
	  chartreuse: '#7fff00',
	  chocolate: '#d2691e',
	  coral: '#ff7f50',
	  cornflowerblue: '#6495ed',
	  cornsilk: '#fff8dc',
	  crimson: '#dc143c',
	  cyan: '#00ffff',
	  darkblue: '#00008b',
	  darkcyan: '#008b8b',
	  darkgoldenrod: '#b8860b',
	  darkgray: '#a9a9a9',
	  darkgrey: '#a9a9a9',
	  darkgreen: '#006400',
	  darkkhaki: '#bdb76b',
	  darkmagenta: '#8b008b',
	  darkolivegreen: '#556b2f',
	  darkorange: '#ff8c00',
	  darkorchid: '#9932cc',
	  darkred: '#8b0000',
	  darksalmon: '#e9967a',
	  darkseagreen: '#8fbc8f',
	  darkslateblue: '#483d8b',
	  darkslategray: '#2f4f4f',
	  darkslategrey: '#2f4f4f',
	  darkturquoise: '#00ced1',
	  darkviolet: '#9400d3',
	  deeppink: '#ff1493',
	  deepskyblue: '#00bfff',
	  dimgray: '#696969',
	  dimgrey: '#696969',
	  dodgerblue: '#1e90ff',
	  firebrick: '#b22222',
	  floralwhite: '#fffaf0',
	  forestgreen: '#228b22',
	  fuchsia: '#ff00ff',
	  gainsboro: '#dcdcdc',
	  ghostwhite: '#f8f8ff',
	  gold: '#ffd700',
	  goldenrod: '#daa520',
	  gray: '#808080',
	  grey: '#808080',
	  green: '#008000',
	  greenyellow: '#adff2f',
	  honeydew: '#f0fff0',
	  hotpink: '#ff69b4',
	  indianred: '#cd5c5c',
	  indigo: '#4b0082',
	  ivory: '#fffff0',
	  khaki: '#f0e68c',
	  lavender: '#e6e6fa',
	  lavenderblush: '#fff0f5',
	  lawngreen: '#7cfc00',
	  lemonchiffon: '#fffacd',
	  lightblue: '#add8e6',
	  lightcoral: '#f08080',
	  lightcyan: '#e0ffff',
	  lightgoldenrodyellow: '#fafad2',
	  lightgray: '#d3d3d3',
	  lightgrey: '#d3d3d3',
	  lightgreen: '#90ee90',
	  lightpink: '#ffb6c1',
	  lightsalmon: '#ffa07a',
	  lightseagreen: '#20b2aa',
	  lightskyblue: '#87cefa',
	  lightslategray: '#778899',
	  lightslategrey: '#778899',
	  lightsteelblue: '#b0c4de',
	  lightyellow: '#ffffe0',
	  lime: '#00ff00',
	  limegreen: '#32cd32',
	  linen: '#faf0e6',
	  magenta: '#ff00ff',
	  maroon: '#800000',
	  mediumaquamarine: '#66cdaa',
	  mediumblue: '#0000cd',
	  mediumorchid: '#ba55d3',
	  mediumpurple: '#9370db',
	  mediumseagreen: '#3cb371',
	  mediumslateblue: '#7b68ee',
	  mediumspringgreen: '#00fa9a',
	  mediumturquoise: '#48d1cc',
	  mediumvioletred: '#c71585',
	  midnightblue: '#191970',
	  mintcream: '#f5fffa',
	  mistyrose: '#ffe4e1',
	  moccasin: '#ffe4b5',
	  navajowhite: '#ffdead',
	  navy: '#000080',
	  oldlace: '#fdf5e6',
	  olive: '#808000',
	  olivedrab: '#6b8e23',
	  orange: '#ffa500',
	  orangered: '#ff4500',
	  orchid: '#da70d6',
	  palegoldenrod: '#eee8aa',
	  palegreen: '#98fb98',
	  paleturquoise: '#afeeee',
	  palevioletred: '#db7093',
	  papayawhip: '#ffefd5',
	  peachpuff: '#ffdab9',
	  peru: '#cd853f',
	  pink: '#ffc0cb',
	  plum: '#dda0dd',
	  powderblue: '#b0e0e6',
	  purple: '#800080',
	  rebeccapurple: '#663399',
	  red: '#ff0000',
	  rosybrown: '#bc8f8f',
	  royalblue: '#4169e1',
	  saddlebrown: '#8b4513',
	  salmon: '#fa8072',
	  sandybrown: '#f4a460',
	  seagreen: '#2e8b57',
	  seashell: '#fff5ee',
	  sienna: '#a0522d',
	  silver: '#c0c0c0',
	  skyblue: '#87ceeb',
	  slateblue: '#6a5acd',
	  slategray: '#708090',
	  slategrey: '#708090',
	  snow: '#fffafa',
	  springgreen: '#00ff7f',
	  steelblue: '#4682b4',
	  tan: '#d2b48c',
	  teal: '#008080',
	  thistle: '#d8bfd8',
	  tomato: '#ff6347',
	  turquoise: '#40e0d0',
	  violet: '#ee82ee',
	  wheat: '#f5deb3',
	  white: '#ffffff',
	  whitesmoke: '#f5f5f5',
	  yellow: '#ffff00',
	  yellowgreen: '#9acd32'
	};

	function login(param) {
	  var newParam = Object.assign({
	    force: true
	  }, param);

	  var loginName = TMAConfig.platform === 'ios' ? 'tma_login' : 'login';
	  invokeMethod(loginName, newParam, {
	    beforeAll: function beforeAll(res) {
	      res.errMsg = res.errMsg.replace('tma_login', 'login');
	    }
	  });
	}

	function checkSession(param) {
	  invokeMethod('checkSession', param);
	}

	/**
	 * @function getUserInfo
	 * @description 获取用户信息
	 * @param {object} param
	 * @param {getUserInfoSuccessCallback} [param.success] 执行成功的回调方法
	 *
	 */
	function getUserInfo() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('getUserInfo', param, {});
	}

	/**
	 * getUserInfo success callback
	 * @callback getUserInfoSuccessCallback
	 * @param {object} response
	 * @param {object} response.userInfo 用户信息对象，不包含 openid 等敏感信息
	 * @param {string} response.rawData 不包括敏感信息的原始数据字符串，用于计算签名。
	 * @param {string} response.signature 使用 sha1( rawData + sessionkey ) 得到字符串
	 * @param {string} response.encryptedData 包括敏感数据在内的完整用户信息的加密数据
	 * @param {string} response.iv 加密算法的初始向量
	 */

	function getUseDuration() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('getUseDuration', param, {});
	}

	function dealUserRelation() {
	    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('dealUserRelation', param);
	}

	/**
	 * @function requestPayment
	 * @description 发起头条支付
	 *  头条支付流程参考 https://wiki.bytedance.net/pages/viewpage.action?pageId=173643106
	 * @param {object} param
	 * @param {string} param.app_id 支付分配给业务方的id
	 * @param {string} param.method 固定值 "tp.trade.confirm"
	 * @param {string} param.sign 商户签名
	 * @param {string} param.sign_type 签名算法，暂支持MD5
	 * @param {string} param.timestamp 发送请求的时间，长整型的时间戳
	 * @param {string} param.trade_no 支付订单号, 商户在头条支付系统下单获取的返回值
	 * @param {string} param.merchant_id 商户id
	 * @param {number} param.total_amount 订单金额，单位为分
	 * @param {string} param.uid 用户的唯一标识id
	 * @param {string} param.pay_channel 支付渠道，目前只支持支付宝，值为 "ALIPAY_NO_SIGN"
	 * @param {string} param.pay_type 支付方式，目前只支持支付宝，值为 "ALIPAY_APP"
	 * @param {string} param.risk_info 风控信息，标准json格式字符串，目前需要传入用户的真实IP："{\"ip\":\"127.0.0.1\"}"
	 * @param {string} [param.return_url] (支付宝)支付完成返回的地址
	 * @param {string} [param.show_url] (支付宝)支付失败返回的地址
	 * @param {string} [pay_info] 不同支付方式下需要添加的支付信息，ALIPAY_APP：{"open_id": "...."}
	 * @param {string} param.params 传递给支付方的支付信息，不同的支付方参数格式不一样
	 * @param {string} param.params.url 最终可以吊起支付宝的最终的字符串，url 拼接详见 https://docs.open.alipay.com/204/105465/，
	 * @param {function} [param.success] 接口调用成功的回调函数
	 * @param {function} [param.fail] 接口调用失败的回调函数
	 * @param {function} [param.complete] 接口调用结束的回调函数（调用成功、失败都会执行）
	 * @returns {undefined}
	 */
	function requestPayment() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('requestPayment', param, {
	    data: {
	      app_id: '',
	      method: '',
	      sign: '',
	      sign_type: '',
	      timestamp: '',
	      trade_no: '',
	      merchant_id: '',
	      uid: '',
	      pay_channel: '',
	      pay_type: '',
	      risk_info: '',
	      params: '',
	      total_amount: 0
	    }
	  })) {
	    var data = param.data,
	        _success = param.success,
	        _fail = param.fail,
	        _complete = param.complete;
	    var confirmDevPayUrl = 'https://tp-pay-test.snssdk.com/gateway';

	    {
	      data = assign$1(data, {
	        debug_back_door: '__b2ff8079074e8806ba3c8f67e403903e_caijing_salt'
	      });
	    }

	    request({
	      url: confirmDevPayUrl,
	      method: 'POST',
	      header: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      data: data,
	      success: function success(res) {
	        var data = res.data;
	        if (data.response && +data.response.code === 10000) {
	          // 成功
	          var newData = assign$1({ data: data.response.old_pay_param }, {
	            success: _success,
	            fail: _fail,
	            complete: _complete
	          });
	          invokeMethod('requestPayment', newData);
	        } else {
	          typeof _fail === 'function' && surroundByTryCatchFactory(_fail, 'at api requestPayment confirm-pay-success phase fail callback function')(data);
	        }
	        typeof _complete === 'function' && surroundByTryCatchFactory(_complete, 'at api requestPayment confirm-pay-success phase complete callback function')(data);
	      },
	      fail: function fail() {
	        typeof _fail === 'function' && surroundByTryCatchFactory(_fail, 'at api requestPayment confirm-pay phase fail callback function')('requestPayment:fail 确认订单失败');
	      },
	      complete: function complete(res) {
	        typeof _complete === 'function' && surroundByTryCatchFactory(_complete, 'at api requestPayment confirm-pay phase complete callback function')(res);
	      }
	    });
	  }
	}

	/**
	 * 小店微信支付
	 * @description 小店发起微信支付，非真正的微信支付，调起微信小程序
	 * @param {object} param
	 */
	function requestWXPayment() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('requestWXPayment', param);
	}

	/**
	 * @function chooseAddress
	 * @description 调起用户编辑收货地址原生界面，并在编辑完成后返回用户选择的地址。
	 * @param {object} param
	 * @param {function} [param.success] 接口调用成功的回调函数
	 * @param {function} [param.fail] 接口调用失败的回调函数
	 * @param {function} [param.complete] 接口调用结束的回调函数（调用成功、失败都会执行）
	 * @returns {undefined}
	 */
	function chooseAddress(param) {
	  invokeMethod('chooseAddress', param);
	}

	/**
	 * chooseAddress success callback
	 * @callback chooseAddressSuccessCallback
	 * @param {object} response
	 * @param {string} response.errMsg 调用结果
	 * @param {string} response.userName 收货人姓名
	 * @param {string} response.provinceName 国标收货地址第一级地址
	 * @param {string} response.cityName 国标收货地址第二级地址
	 * @param {string} response.countyName 国标收货地址第三级地址
	 * @param {string} response.detailInfo 详细收货地址信息
	 * @param {string} response.telNumber 收货人手机号码
	 */

	var Settings = function () {
	  function Settings() {
	    classCallCheck(this, Settings);
	  }

	  Settings.prototype.destroy = function destroy() {};

	  Settings.prototype.hide = function hide() {};

	  Settings.prototype.show = function show() {};

	  return Settings;
	}();

	var OpenSettingButton = new Settings();

	function getSetting() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('getSetting', param);
	}

	function openSetting() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('openSetting', param);
	}

	function authorize() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (beforeInvoke('authorize', param, { scope: '' })) {
	    invokeMethod('authorize', param);
	  }
	}

	function showShareMenu() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('showShareMenu', param, {});
	}

	function hideShareMenu() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('hideShareMenu', param, {});
	}

	var eventEmitter$1 = new EventEmitter();

	onMethod('onCheckForUpdate', function (res) {
	  eventEmitter$1.emit('onCheckForUpdate', res || {});
	});
	onMethod('onUpdateFailed', function (res) {
	  eventEmitter$1.emit('onUpdateFailed', res || {});
	});
	onMethod('onUpdateReady', function (res) {
	  eventEmitter$1.emit('onUpdateReady', res || {});
	});

	var UpdateManager = function () {
	  function UpdateManager() {
	    classCallCheck(this, UpdateManager);
	  }

	  /**
	   * 强制小程序重启并使用新版本
	   * @param {Object} params
	   * @param {Function} params.success 成功回调
	   * @param {Function} params.fail 失败回调
	   * @param {Fucntion} params.complete 不论成功或者失败，都会回调
	   */


	  UpdateManager.prototype.applyUpdate = function applyUpdate() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    invokeMethod('applyUpdate', params);
	  };

	  // 监听检查更新结果回调


	  UpdateManager.prototype.onCheckForUpdate = function onCheckForUpdate(cb) {
	    var eventName = 'onCheckForUpdate';
	    eventEmitter$1.removeAllListeners(eventName);
	    eventEmitter$1.on(eventName, function (data) {
	      if (typeof cb === 'function') {
	        surroundByTryCatchFactory(cb, 'at updateManager.onCheckForUpdate callback function')(data);
	      }
	    });
	    return this;
	  };

	  // 监听更新包下载成功回调


	  UpdateManager.prototype.onUpdateReady = function onUpdateReady(cb) {
	    var eventName = 'onUpdateReady';
	    eventEmitter$1.removeAllListeners(eventName);
	    eventEmitter$1.on(eventName, function (data) {
	      if (typeof cb === 'function') {
	        surroundByTryCatchFactory(cb, 'at updateManager.onUpdateReady callback function')(data);
	      }
	    });
	    return this;
	  };

	  // 监听更新包下载失败回调


	  UpdateManager.prototype.onUpdateFailed = function onUpdateFailed(cb) {
	    var eventName = 'onUpdateFailed';
	    eventEmitter$1.removeAllListeners(eventName);
	    eventEmitter$1.on(eventName, function (data) {
	      if (typeof cb === 'function') {
	        surroundByTryCatchFactory(cb, 'at updateManager.onUpdateFailed callback function')(data);
	      }
	    });
	    return this;
	  };

	  return UpdateManager;
	}();

	var updateManager = new UpdateManager();

	function getUpdateManager() {
	  return updateManager;
	}

	function invokeBusiness() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (typeof param.__method === 'string') {
	    var method = param.__method;
	    delete param.__method;

	    // console.log('before invoke business', param);
	    invokeMethod(method, param);
	  }
	}

	function openSchema(param) {
	  if (beforeInvoke('openSchema', param, {
	    schema: ''
	  })) {
	    invokeBusiness(_extends({}, param, {
	      __method: 'openSchema'
	    }));
	  }
	}

	/**
	* @function getGeneralInfo
	* @description 获取通用参数
	* @param {object} param
	* @param {getGeneralInfoSuccessCallback} [param.success] 执行成功的回调方法
	*
	*/
	function getGeneralInfo() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  invokeMethod('getGeneralInfo', param, {});
	}

	/**
	* @function callHostMethod
	* @description 直接调用宿主实现的方法
	*/
	function callHostMethod() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  beforeInvoke('callHostMethod', param, {
	    method: ''
	  }) && invokeMethod('callHostMethod', param);
	}

	/**
	* @function callHostMethod
	* @description 同步调用宿主实现的方法
	*/
	function callHostMethodSync() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var errMsg = void 0,
	      result = void 0;
	  if (beforeInvoke('callHostMethodSync', param, {
	    method: ''
	  })) {
	    invokeMethod('callHostMethodSync', param, {
	      success: function success(res) {
	        result = res;
	      },
	      fail: function fail() {
	        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        errMsg = e.errMsg;
	      }
	    });

	    if (errMsg) {
	      throw new ThirdScriptError(errMsg);
	    }

	    return result;
	  }
	}

	var globalTasks = {};

	var DownloadOperations = ['pause', 'resume'];
	var taskStateMap = {
	  onError: 'error',
	  onDownloadStart: 'start',
	  onDownloadProgress: 'progress',
	  onDownloadPause: 'pause',
	  onDownloadResume: 'resume',
	  onDownloadCancel: 'cancel',
	  onDownloadFail: 'fail',
	  onDownloadFinish: 'finish',
	  onInstalled: 'install',
	  onOpenAppStore: 'loadProductDone',
	  onOpenAppStoreFail: 'loadProductFailed'
	};

	// onDownloadAppTaskStateChange是一个全局消息，需要在内部区分具体是哪个下载任务的消息
	/** e.g.
	{
	  guid: 'xxx-xxx',
	  state: 'idle',
	  data: {
	    percent: 0.87,
	  },
	}
	 */
	onMethod('onDownloadAppTaskStateChange', function () {
	  var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (globalTasks[res.guid] instanceof DownloadAppTask) {
	    globalTasks[res.guid].eventemitter.emit(res.state, res.data);
	  }
	  // 接收到任何状态变化，均允许开发者重新调用（解锁)，start除外
	  if (res.state !== 'start') {
	    globalTasks[res.guid]._lock = false;
	  }
	});

	var DownloadAppTask = function () {
	  function DownloadAppTask(param) {
	    classCallCheck(this, DownloadAppTask);

	    logger.log('createDownloadAppTask', param);

	    this.eventemitter = new EventEmitter();

	    this.param = param;

	    this.restart();
	  }

	  DownloadAppTask.prototype.restart = function restart() {
	    var _this = this;

	    if (this._lock) {
	      return;
	    }
	    this._lock = true;

	    logger.log('createDownloadAppTask', 'restart');

	    // 每次restart将缓存队列清空
	    this._canoperate = false;
	    this._operateQueue = [];

	    if (typeof this.param.apple_id !== 'string') {
	      setTimeout(function () {
	        _this.eventemitter.emit('error', {
	          errMsg: 'param must contains apple_id'
	        });
	      }, 100);
	    } else if (typeof this.param.download_url !== 'string') {
	      setTimeout(function () {
	        _this.eventemitter.emit('error', {
	          errMsg: 'param must contains download_url'
	        });
	      }, 100);
	    } else {
	      invokeMethod('createDownloadAppTask', this.param, {
	        beforeSuccess: function beforeSuccess() {
	          _this._canoperate = true;

	          _this._operateQueue.forEach(function (operation) {
	            setTimeout(function () {
	              _this[operation + 'Download']();
	            }, 100);
	          });
	          _this._operateQueue = [];
	        },
	        beforeFail: function beforeFail(err) {
	          _this.eventemitter.emit('error', {
	            errMsg: err.errMsg
	          });
	        }
	      });
	    }
	  };

	  DownloadAppTask.prototype.cancelDownload = function cancelDownload() {
	    var _this2 = this;

	    var operation = 'cancel';
	    if (this._canoperate) {
	      invokeMethod('showModal', {
	        title: '提示',
	        content: '\u786E\u5B9A\u8981\u5220\u9664' + this.param.app_name + '\u7684\u4E0B\u8F7D\u4EFB\u52A1\u5417\uFF1F',
	        confirmText: '确定',
	        cancelText: '取消',
	        showCancel: true,
	        confirmColor: '#3CC51F',
	        cancelColor: '#000000',
	        success: function success(res) {
	          if (res.confirm) {
	            invokeMethod('operateDownloadAppTask', Object.assign({}, _this2.param, {
	              operation: operation
	            }));
	          }
	        }
	      });
	    } else {
	      this._operateQueue.push(operation);
	    }
	  };

	  return DownloadAppTask;
	}();

	// 批量设定三个方法，通过判断标识位决定是否立刻操作
	// 标识位会在create后设定，并同时flush已缓存的操作


	DownloadOperations.forEach(function (operation) {
	  DownloadAppTask.prototype[operation + 'Download'] = function () {
	    if (this._canoperate) {
	      invokeMethod('operateDownloadAppTask', Object.assign({}, this.param, {
	        operation: operation
	      }));
	    } else {
	      this._operateQueue.push(operation);
	    }
	  };
	});

	var _loop = function _loop(method) {
	  var state = taskStateMap[method];
	  DownloadAppTask.prototype[method] = function (callback) {
	    if (typeof callback === 'function') {
	      this.eventemitter.on(state, callback);
	    }
	  };
	};

	for (var method in taskStateMap) {
	  _loop(method);
	}

	function createDownloadAppTask() {
	  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var guid = param.download_url;

	  if (!(globalTasks[guid] instanceof DownloadAppTask)) {
	    param.guid = guid;
	    globalTasks[guid] = new DownloadAppTask(param);
	  } else {
	    globalTasks[guid].restart();
	  }

	  return globalTasks[guid];
	}

	var reportAnalytics = function reportAnalytics(eventName, data) {

	  if (!isString(eventName) || !eventName) {
	    throw new ThirdScriptError('eventName must be a string.');
	  }

	  if (eventName.length > 110) {
	    throw new ThirdScriptError('eventName exceeded the maximum length: 110.');
	  }

	  if (!isObject$1(data)) {
	    throw new ThirdScriptError('data must be an object.');
	  }

	  var keys = Object.keys(data);
	  var params = {
	    value: {}
	  };
	  if (keys.length > 256) {
	    throw new ThirdScriptError('data exceeded the maximum number of fields: 256.');
	  }

	  keys.filter(function (v) {
	    return !isObject$1(data[v]);
	  }).forEach(function (key) {
	    if (key.length > 128) {
	      throw new ThirdScriptError(key + ' exceeded the maximum number of bytes: 128.');
	    }

	    if (String(data[key]).length > 1024) {
	      throw new ThirdScriptError('the value of data[' + key + '] exceeded the maximum number of bytes: 1024.');
	    }

	    if (key && key[0] === '_') {
	      throw new ThirdScriptError('the key first char can not be _.');
	    }

	    if (key === 'mp_id' || key === 'mp_name') {
	      throw new ThirdScriptError('the key can not be mp_name or mp_id.');
	    }

	    params['value'][key] = data[key];
	  });

	  invokeMethod('microappLog', _extends({}, params, {
	    event: eventName
	  }));
	};

	// input组件和textarea组件
	var timer;
	onMethod('onKeyboardValueChange', function (ev, webviewId) {
	  publish('setKeyboardValue', {
	    value: ev.value,
	    cursor: ev.cursor,
	    inputId: ev.inputId
	  }, [webviewId]);

	  clearTimeout(timer);
	  timer = setTimeout(handler.bind(null, ev, webviewId), 60);
	});

	function handler(ev) {
	  var webviewId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	  var value = ev.value;

	  if (ev.data) {
	    var data = JSON.parse(ev.data);
	    var isComponent = data.isCustomComponent;
	    var event = isComponent ? GlobalState.componentEventCallback : GlobalState.webviewEventCallback;

	    if ('function' !== typeof event) {
	      return;
	    }

	    logger.log('!!!onKeyboardValueChange!!! invoke ' + isComponent ? 'componentEventCallback' : 'webviewEventCallback');

	    if (data.bindinput) {
	      var res = void 0;
	      try {
	        res = event({
	          data: {
	            type: 'input',
	            target: data.target,
	            currentTarget: data.target,
	            timeStamp: Date.now(),
	            touches: [],
	            detail: {
	              value: ev.value,
	              cursor: ev.cursor
	            }
	          },
	          eventName: data.bindinput,
	          webviewId: webviewId,
	          nodeId: data.nodeId
	        });
	      } catch (err) {
	        throw new Error('bind key input error');
	      }

	      if (undefined === res || null === res || !1 === res) ; else if ('Object' === getDataType(res)) {
	        var s = {
	          inputId: ev.inputId
	        };
	        if (value != res.value && res.value !== undefined) {
	          s.value = res.value + '';
	        }
	        if (!isNaN(parseInt(res.cursor))) {
	          s.cursor = parseInt(res.cursor);
	        }
	        if (s.value === undefined) {
	          s.value = value;
	        }
	        if (s.cursor > s.value.length) {
	          s.cursor = -1;
	        }
	        invokeMethod('setKeyboardValue', s);
	      } else {
	        value != res && invokeMethod('setKeyboardValue', {
	          value: res + '',
	          cursor: -1,
	          inputId: ev.inputId
	        });
	      }
	    }
	  }
	}

	// video组件
	[{
	  message: 'onVideoPlay',
	  handlerName: 'bindplay',
	  type: 'play'
	}, {
	  message: 'onVideoPause',
	  handlerName: 'bindpause',
	  type: 'pause'
	}, {
	  message: 'onVideoEnded',
	  handlerName: 'bindended',
	  type: 'ended'
	}, {
	  message: 'onVideoError',
	  handlerName: 'binderror',
	  type: 'error'
	}].forEach(function (_ref) {
	  var message = _ref.message,
	      handlerName = _ref.handlerName,
	      type = _ref.type;

	  // add event listener
	  onMethod(message, function (ev, webviewId) {
	    if (ev.data) {
	      var data = JSON.parse(ev.data);
	      var isComponent = data.isCustomComponent;
	      var event = isComponent ? GlobalState.componentEventCallback : GlobalState.webviewEventCallback;

	      if ('function' !== typeof event) {
	        return;
	      }

	      logger.log('!!!' + message + '!!! invoke ' + isComponent ? 'componentEventCallback' : 'webviewEventCallback');

	      if (data.handlers && data.handlers[handlerName]) {
	        try {
	          event({
	            data: {
	              type: type,
	              target: data.target,
	              currentTarget: data.target,
	              timeStamp: Date.now(),
	              touches: [],
	              detail: {}
	            },
	            eventName: data.handlers[handlerName],
	            webviewId: webviewId,
	            nodeId: data.nodeId
	          });
	        } catch (err) {
	          throw new Error('bind key input error');
	        }
	      }
	    }
	  });
	});

	/* global nativeTMAConfig */

	function doInit() {
	}

	// 由于此次安卓修改v8初始化时机，不修改R2D2，故暂时如下修改。
	// 后续分包加载可以重构此逻辑。

	// 老版本执行这行代码会立即调用，同时由于有debug变量，所以正常执行
	// 新版本执行这行代码会立即调用，但没有debug变量，不会正常执行
	if (typeof TMAConfig.onReady === 'function') {
	  TMAConfig.onReady(doInit);
	}
	// 老版本只会注册，不会执行
	// 新版本客户端会触发ready，导致段代码执行
	if (typeof TMAConfig.onRealReady === 'function') {
	  TMAConfig.onRealReady(doInit);
	}

	function hideKeyboard() {
	  invokeMethod('hideKeyboard');
	}

	/** don't delete, for doc
	export {
	  connectSocket
	} */
	var connectSocket = socket.connectSocket;

	var ttMethodsMap = /*#__PURE__*/Object.freeze({
		connectSocket: connectSocket,
		getLaunchOptionsSync: getLaunchOptionsSync,
		exitMiniProgram: exitMiniProgram,
		request: request,
		uploadFile: uploadFile,
		downloadFile: downloadFile,
		chooseImage: chooseImage,
		saveImageToPhotosAlbum: saveImageToPhotosAlbum,
		previewImage: previewImage,
		getImageInfo: getImageInfo,
		getRecorderManager: getRecorderManager,
		createInnerAudioContext: createInnerAudioContext,
		getBackgroundAudioContext: getBackgroundAudioContext,
		chooseVideo: chooseVideo,
		saveVideoToPhotosAlbum: saveVideoToPhotosAlbum,
		saveFile: saveFile,
		getStorage: getStorage,
		getStorageSync: getStorageSync,
		setStorage: setStorage,
		setStorageSync: setStorageSync,
		removeStorage: removeStorage,
		removeStorageSync: removeStorageSync,
		clearStorage: clearStorage,
		clearStorageSync: clearStorageSync,
		getStorageInfo: getStorageInfo,
		getStorageInfoSync: getStorageInfoSync,
		getLocation: getLocation,
		openLocation: openLocation,
		getSystemInfo: getSystemInfo,
		getSystemInfoSync: getSystemInfoSync$1,
		getNetworkType: getNetworkType,
		onNetworkStatusChange: onNetworkStatusChange,
		getConnectedWifi: getConnectedWifi,
		startCompass: startCompass,
		stopCompass: stopCompass,
		onCompassChange: onCompassChange,
		startAccelerometer: startAccelerometer,
		stopAccelerometer: stopAccelerometer,
		onAccelerometerChange: onAccelerometerChange,
		makePhoneCall: makePhoneCall,
		scanCode: scanCode,
		getClipboardData: getClipboardData,
		setClipboardData: setClipboardData,
		setKeepScreenOn: setKeepScreenOn,
		vibrateLong: vibrateLong,
		vibrateShort: vibrateShort,
		showToast: showToast,
		hideToast: hideToast,
		showLoading: showLoading,
		hideLoading: hideLoading,
		showModal: showModal,
		showActionSheet: showActionSheet,
		setNavigationBarTitle: setNavigationBarTitle,
		navigateTo: navigateTo,
		redirectTo: redirectTo,
		switchTab: switchTab,
		navigateBack: navigateBack,
		reLaunch: reLaunch,
		createAnimation: createAnimation,
		pageScrollTo: pageScrollTo,
		disablePageScroll: disablePageScroll,
		stopPullDownRefresh: stopPullDownRefresh,
		startPullDownRefresh: startPullDownRefresh,
		createCanvasContext: createCanvasContext,
		canvasToTempFilePath: canvasToTempFilePath,
		createSelectorQuery: createSelectorQuery,
		createIntersectionObserver: createIntersectionObserver,
		login: login,
		checkSession: checkSession,
		getUserInfo: getUserInfo,
		getUseDuration: getUseDuration,
		dealUserRelation: dealUserRelation,
		requestPayment: requestPayment,
		requestWXPayment: requestWXPayment,
		chooseAddress: chooseAddress,
		getSetting: getSetting,
		openSetting: openSetting,
		authorize: authorize,
		showShareMenu: showShareMenu,
		hideShareMenu: hideShareMenu,
		getUpdateManager: getUpdateManager,
		openSchema: openSchema,
		getGeneralInfo: getGeneralInfo,
		invokeBusiness: invokeBusiness,
		callHostMethod: callHostMethod,
		callHostMethodSync: callHostMethodSync,
		createDownloadAppTask: createDownloadAppTask,
		sendtoTAQ: sendtoTAQ,
		reportAnalytics: reportAnalytics,
		arrayBufferToBase64: arrayBufferToBase64,
		base64ToArrayBuffer: base64ToArrayBuffer,
		hideKeyboard: hideKeyboard,
		invokeWebviewMethod: invokeWebviewMethod,
		onAppEnterForeground: onAppEnterForeground,
		onAppEnterBackground: onAppEnterBackground$1,
		onPageReload: onPageReload,
		onWebviewEvent: onWebviewEvent,
		onWebviewComponentEvent: onWebviewComponentEvent,
		onWebviewDataChange: onWebviewDataChange,
		onAppRoute: onAppRoute,
		onComponentRelationChange: onComponentRelationChange
	});

	var stringify_1 = createCommonjsModule(function (module, exports) {
	  /*
	   json-stringify-safe
	   Like JSON.stringify, but doesn't throw on circular references.
	  
	   Originally forked from https://github.com/isaacs/json-stringify-safe
	   version 5.0.1 on 3/8/2017 and modified to handle Errors serialization
	   and IE8 compatibility. Tests for this are in test/vendor.
	  
	   ISC license: https://github.com/isaacs/json-stringify-safe/blob/master/LICENSE
	  */

	  exports = module.exports = stringify;
	  exports.getSerialize = serializer;

	  function indexOf(haystack, needle) {
	    for (var i = 0; i < haystack.length; ++i) {
	      if (haystack[i] === needle) return i;
	    }
	    return -1;
	  }

	  function stringify(obj, replacer, spaces, cycleReplacer) {
	    return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
	  }

	  // https://github.com/ftlabs/js-abbreviate/blob/fa709e5f139e7770a71827b1893f22418097fbda/index.js#L95-L106
	  function stringifyError(value) {
	    var err = {
	      // These properties are implemented as magical getters and don't show up in for in
	      stack: value.stack,
	      message: value.message,
	      name: value.name
	    };

	    for (var i in value) {
	      if (Object.prototype.hasOwnProperty.call(value, i)) {
	        err[i] = value[i];
	      }
	    }

	    return err;
	  }

	  function serializer(replacer, cycleReplacer) {
	    var stack = [];
	    var keys = [];

	    if (cycleReplacer == null) {
	      cycleReplacer = function cycleReplacer(key, value) {
	        if (stack[0] === value) {
	          return '[Circular ~]';
	        }
	        return '[Circular ~.' + keys.slice(0, indexOf(stack, value)).join('.') + ']';
	      };
	    }

	    return function (key, value) {
	      if (stack.length > 0) {
	        var thisPos = indexOf(stack, this);
	        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
	        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);

	        if (~indexOf(stack, value)) {
	          value = cycleReplacer.call(this, key, value);
	        }
	      } else {
	        stack.push(value);
	      }

	      return replacer == null ? value instanceof Error ? stringifyError(value) : value : replacer.call(this, key, value);
	    };
	  }
	});
	var stringify_2 = stringify_1.getSerialize;

	var stringify = /*#__PURE__*/Object.freeze({
		default: stringify_1,
		__moduleExports: stringify_1,
		getSerialize: stringify_2
	});

	var stringify$1 = ( stringify && stringify_1 ) || stringify;

	var _window = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

	function isObject$2(what) {
	  return (typeof what === 'undefined' ? 'undefined' : _typeof(what)) === 'object' && what !== null;
	}

	// Yanked from https://git.io/vS8DV re-used under CC0
	// with some tiny modifications
	function isError(value) {
	  switch (Object.prototype.toString.call(value)) {
	    case '[object Error]':
	      return true;
	    case '[object Exception]':
	      return true;
	    case '[object DOMException]':
	      return true;
	    default:
	      return value instanceof Error;
	  }
	}

	function isErrorEvent(value) {
	  return Object.prototype.toString.call(value) === '[object ErrorEvent]';
	}

	function isDOMError(value) {
	  return Object.prototype.toString.call(value) === '[object DOMError]';
	}

	function isDOMException(value) {
	  return Object.prototype.toString.call(value) === '[object DOMException]';
	}

	function isUndefined(what) {
	  return what === void 0;
	}

	function isFunction$1(what) {
	  return typeof what === 'function';
	}

	function isPlainObject(what) {
	  return Object.prototype.toString.call(what) === '[object Object]';
	}

	function isString$1(what) {
	  return Object.prototype.toString.call(what) === '[object String]';
	}

	function isArray$3(what) {
	  return Object.prototype.toString.call(what) === '[object Array]';
	}

	function isEmptyObject(what) {
	  if (!isPlainObject(what)) return false;

	  for (var _ in what) {
	    if (what.hasOwnProperty(_)) {
	      return false;
	    }
	  }
	  return true;
	}

	function supportsErrorEvent() {
	  try {
	    new ErrorEvent(''); // eslint-disable-line no-new
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function supportsDOMError() {
	  try {
	    new DOMError(''); // eslint-disable-line no-new
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function supportsDOMException() {
	  try {
	    new DOMException(''); // eslint-disable-line no-new
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function supportsFetch() {
	  if (!('fetch' in _window)) return false;

	  try {
	    new Headers(); // eslint-disable-line no-new
	    new Request(''); // eslint-disable-line no-new
	    new Response(); // eslint-disable-line no-new
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	// Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
	// https://caniuse.com/#feat=referrer-policy
	// It doesn't. And it throw exception instead of ignoring this parameter...
	// REF: https://github.com/getsentry/raven-js/issues/1233
	function supportsReferrerPolicy() {
	  if (!supportsFetch()) return false;

	  try {
	    // eslint-disable-next-line no-new
	    new Request('pickleRick', {
	      referrerPolicy: 'origin'
	    });
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function supportsPromiseRejectionEvent() {
	  return typeof PromiseRejectionEvent === 'function';
	}

	function wrappedCallback(callback) {
	  function dataCallback(data, original) {
	    var normalizedData = callback(data) || data;
	    if (original) {
	      return original(normalizedData) || normalizedData;
	    }
	    return normalizedData;
	  }

	  return dataCallback;
	}

	function each(obj, callback) {
	  var i, j;

	  if (isUndefined(obj.length)) {
	    for (i in obj) {
	      if (hasKey(obj, i)) {
	        callback.call(null, i, obj[i]);
	      }
	    }
	  } else {
	    j = obj.length;
	    if (j) {
	      for (i = 0; i < j; i++) {
	        callback.call(null, i, obj[i]);
	      }
	    }
	  }
	}

	function objectMerge(obj1, obj2) {
	  if (!obj2) {
	    return obj1;
	  }
	  each(obj2, function (key, value) {
	    obj1[key] = value;
	  });
	  return obj1;
	}

	/**
	 * This function is only used for react-native.
	 * react-native freezes object that have already been sent over the
	 * js bridge. We need this function in order to check if the object is frozen.
	 * So it's ok that objectFrozen returns false if Object.isFrozen is not
	 * supported because it's not relevant for other "platforms". See related issue:
	 * https://github.com/getsentry/react-native-sentry/issues/57
	 */
	function objectFrozen(obj) {
	  if (!Object.isFrozen) {
	    return false;
	  }
	  return Object.isFrozen(obj);
	}

	function truncate(str, max) {
	  if (typeof max !== 'number') {
	    throw new Error('2nd argument to `truncate` function should be a number');
	  }
	  if (typeof str !== 'string' || max === 0) {
	    return str;
	  }
	  return str.length <= max ? str : str.substr(0, max) + '\u2026';
	}

	/**
	 * hasKey, a better form of hasOwnProperty
	 * Example: hasKey(MainHostObject, property) === true/false
	 *
	 * @param {Object} host object to check property
	 * @param {string} key to check
	 */
	function hasKey(object, key) {
	  return Object.prototype.hasOwnProperty.call(object, key);
	}

	function joinRegExp(patterns) {
	  // Combine an array of regular expressions and strings into one large regexp
	  // Be mad.
	  var sources = [],
	      i = 0,
	      len = patterns.length,
	      pattern;

	  for (; i < len; i++) {
	    pattern = patterns[i];
	    if (isString$1(pattern)) {
	      // If it's a string, we need to escape it
	      // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
	      sources.push(pattern.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'));
	    } else if (pattern && pattern.source) {
	      // If it's a regexp already, we want to extract the source
	      sources.push(pattern.source);
	    }
	    // Intentionally skip other cases
	  }
	  return new RegExp(sources.join('|'), 'i');
	}

	function urlencode(o) {
	  var pairs = [];
	  each(o, function (key, value) {
	    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
	  });
	  return pairs.join('&');
	}

	// borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
	// intentionally using regex and not <a/> href parsing trick because React Native and other
	// environments where DOM might not be available
	function parseUrl(url) {
	  if (typeof url !== 'string') return {};
	  var match = url.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);

	  // coerce to undefined values to empty string so we don't get 'undefined'
	  var query = match[6] || '';
	  var fragment = match[8] || '';
	  return {
	    protocol: match[2],
	    host: match[4],
	    path: match[5],
	    relative: match[5] + query + fragment // everything minus origin
	  };
	}
	function uuid4() {
	  var crypto = _window.crypto || _window.msCrypto;

	  if (!isUndefined(crypto) && crypto.getRandomValues) {
	    // Use window.crypto API if available
	    // eslint-disable-next-line no-undef
	    var arr = new Uint16Array(8);
	    crypto.getRandomValues(arr);

	    // set 4 in byte 7
	    arr[3] = arr[3] & 0xfff | 0x4000;
	    // set 2 most significant bits of byte 9 to '10'
	    arr[4] = arr[4] & 0x3fff | 0x8000;

	    var pad = function pad(num) {
	      var v = num.toString(16);
	      while (v.length < 4) {
	        v = '0' + v;
	      }
	      return v;
	    };

	    return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
	  } else {
	    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
	    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	      var r = Math.random() * 16 | 0,
	          v = c === 'x' ? r : r & 0x3 | 0x8;
	      return v.toString(16);
	    });
	  }
	}

	/**
	 * Given a child DOM element, returns a query-selector statement describing that
	 * and its ancestors
	 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
	 * @param elem
	 * @returns {string}
	 */
	function htmlTreeAsString(elem) {
	  /* eslint no-extra-parens:0*/
	  var MAX_TRAVERSE_HEIGHT = 5,
	      MAX_OUTPUT_LEN = 80,
	      out = [],
	      height = 0,
	      len = 0,
	      separator = ' > ',
	      sepLength = separator.length,
	      nextStr;

	  while (elem && height++ < MAX_TRAVERSE_HEIGHT) {
	    nextStr = htmlElementAsString(elem);
	    // bail out if
	    // - nextStr is the 'html' element
	    // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
	    //   (ignore this limit if we are on the first iteration)
	    if (nextStr === 'html' || height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN) {
	      break;
	    }

	    out.push(nextStr);

	    len += nextStr.length;
	    elem = elem.parentNode;
	  }

	  return out.reverse().join(separator);
	}

	/**
	 * Returns a simple, query-selector representation of a DOM element
	 * e.g. [HTMLElement] => input#foo.btn[name=baz]
	 * @param HTMLElement
	 * @returns {string}
	 */
	function htmlElementAsString(elem) {
	  var out = [],
	      className,
	      classes,
	      key,
	      attr,
	      i;

	  if (!elem || !elem.tagName) {
	    return '';
	  }

	  out.push(elem.tagName.toLowerCase());
	  if (elem.id) {
	    out.push('#' + elem.id);
	  }

	  className = elem.className;
	  if (className && isString$1(className)) {
	    classes = className.split(/\s+/);
	    for (i = 0; i < classes.length; i++) {
	      out.push('.' + classes[i]);
	    }
	  }
	  var attrWhitelist = ['type', 'name', 'title', 'alt'];
	  for (i = 0; i < attrWhitelist.length; i++) {
	    key = attrWhitelist[i];
	    attr = elem.getAttribute(key);
	    if (attr) {
	      out.push('[' + key + '="' + attr + '"]');
	    }
	  }
	  return out.join('');
	}

	/**
	 * Returns true if either a OR b is truthy, but not both
	 */
	function isOnlyOneTruthy(a, b) {
	  return !!(!!a ^ !!b);
	}

	/**
	 * Returns true if both parameters are undefined
	 */
	function isBothUndefined(a, b) {
	  return isUndefined(a) && isUndefined(b);
	}

	/**
	 * Returns true if the two input exception interfaces have the same content
	 */
	function isSameException(ex1, ex2) {
	  if (isOnlyOneTruthy(ex1, ex2)) return false;

	  ex1 = ex1.values[0];
	  ex2 = ex2.values[0];

	  if (ex1.type !== ex2.type || ex1.value !== ex2.value) return false;

	  // in case both stacktraces are undefined, we can't decide so default to false
	  if (isBothUndefined(ex1.stacktrace, ex2.stacktrace)) return false;

	  return isSameStacktrace(ex1.stacktrace, ex2.stacktrace);
	}

	/**
	 * Returns true if the two input stack trace interfaces have the same content
	 */
	function isSameStacktrace(stack1, stack2) {
	  if (isOnlyOneTruthy(stack1, stack2)) return false;

	  var frames1 = stack1.frames;
	  var frames2 = stack2.frames;

	  // Exit early if frame count differs
	  if (frames1.length !== frames2.length) return false;

	  // Iterate through every frame; bail out if anything differs
	  var a, b;
	  for (var i = 0; i < frames1.length; i++) {
	    a = frames1[i];
	    b = frames2[i];
	    if (a.filename !== b.filename || a.lineno !== b.lineno || a.colno !== b.colno || a['function'] !== b['function']) return false;
	  }
	  return true;
	}

	/**
	 * Polyfill a method
	 * @param obj object e.g. `document`
	 * @param name method name present on object e.g. `addEventListener`
	 * @param replacement replacement function
	 * @param track {optional} record instrumentation to an array
	 */
	function fill(obj, name, replacement, track) {
	  if (obj == null) return;
	  var orig = obj[name];
	  obj[name] = replacement(orig);
	  obj[name].__raven__ = true;
	  obj[name].__orig__ = orig;
	  if (track) {
	    track.push([obj, name, orig]);
	  }
	}

	/**
	 * Join values in array
	 * @param input array of values to be joined together
	 * @param delimiter string to be placed in-between values
	 * @returns {string}
	 */
	function safeJoin(input, delimiter) {
	  if (!isArray$3(input)) return '';

	  var output = [];

	  for (var i = 0; i < input.length; i++) {
	    try {
	      output.push(String(input[i]));
	    } catch (e) {
	      output.push('[value cannot be serialized]');
	    }
	  }

	  return output.join(delimiter);
	}

	// Default Node.js REPL depth
	var MAX_SERIALIZE_EXCEPTION_DEPTH = 3;
	// 50kB, as 100kB is max payload size, so half sounds reasonable
	var MAX_SERIALIZE_EXCEPTION_SIZE = 50 * 1024;
	var MAX_SERIALIZE_KEYS_LENGTH = 40;

	function utf8Length(value) {
	  return ~-encodeURI(value).split(/%..|./).length;
	}

	function jsonSize(value) {
	  return utf8Length(JSON.stringify(value));
	}

	function serializeValue(value) {
	  if (typeof value === 'string') {
	    var maxLength = 40;
	    return truncate(value, maxLength);
	  } else if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'undefined') {
	    return value;
	  }

	  var type = Object.prototype.toString.call(value);

	  // Node.js REPL notation
	  if (type === '[object Object]') return '[Object]';
	  if (type === '[object Array]') return '[Array]';
	  if (type === '[object Function]') return value.name ? '[Function: ' + value.name + ']' : '[Function]';

	  return value;
	}

	function serializeObject(value, depth) {
	  if (depth === 0) return serializeValue(value);

	  if (isPlainObject(value)) {
	    return Object.keys(value).reduce(function (acc, key) {
	      acc[key] = serializeObject(value[key], depth - 1);
	      return acc;
	    }, {});
	  } else if (Array.isArray(value)) {
	    return value.map(function (val) {
	      return serializeObject(val, depth - 1);
	    });
	  }

	  return serializeValue(value);
	}

	function serializeException(ex, depth, maxSize) {
	  if (!isPlainObject(ex)) return ex;

	  depth = typeof depth !== 'number' ? MAX_SERIALIZE_EXCEPTION_DEPTH : depth;
	  maxSize = typeof depth !== 'number' ? MAX_SERIALIZE_EXCEPTION_SIZE : maxSize;

	  var serialized = serializeObject(ex, depth);

	  if (jsonSize(stringify$1(serialized)) > maxSize) {
	    return serializeException(ex, depth - 1);
	  }

	  return serialized;
	}

	function serializeKeysForMessage(keys, maxLength) {
	  if (typeof keys === 'number' || typeof keys === 'string') return keys.toString();
	  if (!Array.isArray(keys)) return '';

	  keys = keys.filter(function (key) {
	    return typeof key === 'string';
	  });
	  if (keys.length === 0) return '[object has no keys]';

	  maxLength = typeof maxLength !== 'number' ? MAX_SERIALIZE_KEYS_LENGTH : maxLength;
	  if (keys[0].length >= maxLength) return keys[0];

	  for (var usedKeys = keys.length; usedKeys > 0; usedKeys--) {
	    var serialized = keys.slice(0, usedKeys).join(', ');
	    if (serialized.length > maxLength) continue;
	    if (usedKeys === keys.length) return serialized;
	    return serialized + '\u2026';
	  }

	  return '';
	}

	function sanitize(input, sanitizeKeys) {
	  if (!isArray$3(sanitizeKeys) || isArray$3(sanitizeKeys) && sanitizeKeys.length === 0) return input;

	  var sanitizeRegExp = joinRegExp(sanitizeKeys);
	  var sanitizeMask = '********';
	  var safeInput;

	  try {
	    safeInput = JSON.parse(stringify$1(input));
	  } catch (o_O) {
	    return input;
	  }

	  function sanitizeWorker(workerInput) {
	    if (isArray$3(workerInput)) {
	      return workerInput.map(function (val) {
	        return sanitizeWorker(val);
	      });
	    }

	    if (isPlainObject(workerInput)) {
	      return Object.keys(workerInput).reduce(function (acc, k) {
	        if (sanitizeRegExp.test(k)) {
	          acc[k] = sanitizeMask;
	        } else {
	          acc[k] = sanitizeWorker(workerInput[k]);
	        }
	        return acc;
	      }, {});
	    }

	    return workerInput;
	  }

	  return sanitizeWorker(safeInput);
	}

	var utils = {
	  isObject: isObject$2,
	  isError: isError,
	  isErrorEvent: isErrorEvent,
	  isDOMError: isDOMError,
	  isDOMException: isDOMException,
	  isUndefined: isUndefined,
	  isFunction: isFunction$1,
	  isPlainObject: isPlainObject,
	  isString: isString$1,
	  isArray: isArray$3,
	  isEmptyObject: isEmptyObject,
	  supportsErrorEvent: supportsErrorEvent,
	  supportsDOMError: supportsDOMError,
	  supportsDOMException: supportsDOMException,
	  supportsFetch: supportsFetch,
	  supportsReferrerPolicy: supportsReferrerPolicy,
	  supportsPromiseRejectionEvent: supportsPromiseRejectionEvent,
	  wrappedCallback: wrappedCallback,
	  each: each,
	  objectMerge: objectMerge,
	  truncate: truncate,
	  objectFrozen: objectFrozen,
	  hasKey: hasKey,
	  joinRegExp: joinRegExp,
	  urlencode: urlencode,
	  uuid4: uuid4,
	  htmlTreeAsString: htmlTreeAsString,
	  htmlElementAsString: htmlElementAsString,
	  isSameException: isSameException,
	  isSameStacktrace: isSameStacktrace,
	  parseUrl: parseUrl,
	  fill: fill,
	  safeJoin: safeJoin,
	  serializeException: serializeException,
	  serializeKeysForMessage: serializeKeysForMessage,
	  sanitize: sanitize
	};
	var utils_1 = utils.isObject;
	var utils_2 = utils.isError;
	var utils_3 = utils.isErrorEvent;
	var utils_4 = utils.isDOMError;
	var utils_5 = utils.isDOMException;
	var utils_6 = utils.isUndefined;
	var utils_7 = utils.isFunction;
	var utils_8 = utils.isPlainObject;
	var utils_9 = utils.isString;
	var utils_10 = utils.isArray;
	var utils_11 = utils.isEmptyObject;
	var utils_12 = utils.supportsErrorEvent;
	var utils_13 = utils.supportsDOMError;
	var utils_14 = utils.supportsDOMException;
	var utils_15 = utils.supportsFetch;
	var utils_16 = utils.supportsReferrerPolicy;
	var utils_17 = utils.supportsPromiseRejectionEvent;
	var utils_18 = utils.wrappedCallback;
	var utils_19 = utils.each;
	var utils_20 = utils.objectMerge;
	var utils_21 = utils.truncate;
	var utils_22 = utils.objectFrozen;
	var utils_23 = utils.hasKey;
	var utils_24 = utils.joinRegExp;
	var utils_25 = utils.urlencode;
	var utils_26 = utils.uuid4;
	var utils_27 = utils.htmlTreeAsString;
	var utils_28 = utils.htmlElementAsString;
	var utils_29 = utils.isSameException;
	var utils_30 = utils.isSameStacktrace;
	var utils_31 = utils.parseUrl;
	var utils_32 = utils.fill;
	var utils_33 = utils.safeJoin;
	var utils_34 = utils.serializeException;
	var utils_35 = utils.serializeKeysForMessage;
	var utils_36 = utils.sanitize;

	var utils$1 = /*#__PURE__*/Object.freeze({
		default: utils,
		__moduleExports: utils,
		isObject: utils_1,
		isError: utils_2,
		isErrorEvent: utils_3,
		isDOMError: utils_4,
		isDOMException: utils_5,
		isUndefined: utils_6,
		isFunction: utils_7,
		isPlainObject: utils_8,
		isString: utils_9,
		isArray: utils_10,
		isEmptyObject: utils_11,
		supportsErrorEvent: utils_12,
		supportsDOMError: utils_13,
		supportsDOMException: utils_14,
		supportsFetch: utils_15,
		supportsReferrerPolicy: utils_16,
		supportsPromiseRejectionEvent: utils_17,
		wrappedCallback: utils_18,
		each: utils_19,
		objectMerge: utils_20,
		truncate: utils_21,
		objectFrozen: utils_22,
		hasKey: utils_23,
		joinRegExp: utils_24,
		urlencode: utils_25,
		uuid4: utils_26,
		htmlTreeAsString: utils_27,
		htmlElementAsString: utils_28,
		isSameException: utils_29,
		isSameStacktrace: utils_30,
		parseUrl: utils_31,
		fill: utils_32,
		safeJoin: utils_33,
		serializeException: utils_34,
		serializeKeysForMessage: utils_35,
		sanitize: utils_36
	});

	var utils$2 = ( utils$1 && utils ) || utils$1;

	/*
	 TraceKit - Cross brower stack traces

	 This was originally forked from github.com/occ/TraceKit, but has since been
	 largely re-written and is now maintained as part of raven-js.  Tests for
	 this are in test/vendor.

	 MIT license
	*/

	var TraceKit = {
	  collectWindowErrors: true,
	  debug: false
	};

	// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
	var _window$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

	// global reference to slice
	var _slice = [].slice;
	var UNKNOWN_FUNCTION = '?';

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
	var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;

	function getLocationHref() {
	  if (typeof document === 'undefined' || document.location == null) return '';
	  return document.location.href;
	}

	function getLocationOrigin() {
	  if (typeof document === 'undefined' || document.location == null) return '';

	  // Oh dear IE10...
	  if (!document.location.origin) {
	    document.location.origin = document.location.protocol + '//' + document.location.hostname + (document.location.port ? ':' + document.location.port : '');
	  }

	  return document.location.origin;
	}

	/**
	 * TraceKit.report: cross-browser processing of unhandled exceptions
	 *
	 * Syntax:
	 *   TraceKit.report.subscribe(function(stackInfo) { ... })
	 *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
	 *   TraceKit.report(exception)
	 *   try { ...code... } catch(ex) { TraceKit.report(ex); }
	 *
	 * Supports:
	 *   - Firefox: full stack trace with line numbers, plus column number
	 *              on top frame; column number is not guaranteed
	 *   - Opera:   full stack trace with line and column numbers
	 *   - Chrome:  full stack trace with line and column numbers
	 *   - Safari:  line and column number for the top frame only; some frames
	 *              may be missing, and column number is not guaranteed
	 *   - IE:      line and column number for the top frame only; some frames
	 *              may be missing, and column number is not guaranteed
	 *
	 * In theory, TraceKit should work on all of the following versions:
	 *   - IE5.5+ (only 8.0 tested)
	 *   - Firefox 0.9+ (only 3.5+ tested)
	 *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
	 *     Exceptions Have Stacktrace to be enabled in opera:config)
	 *   - Safari 3+ (only 4+ tested)
	 *   - Chrome 1+ (only 5+ tested)
	 *   - Konqueror 3.5+ (untested)
	 *
	 * Requires TraceKit.computeStackTrace.
	 *
	 * Tries to catch all unhandled exceptions and report them to the
	 * subscribed handlers. Please note that TraceKit.report will rethrow the
	 * exception. This is REQUIRED in order to get a useful stack trace in IE.
	 * If the exception does not reach the top of the browser, you will only
	 * get a stack trace from the point where TraceKit.report was called.
	 *
	 * Handlers receive a stackInfo object as described in the
	 * TraceKit.computeStackTrace docs.
	 */
	TraceKit.report = function reportModuleWrapper() {
	  var handlers = [],
	      lastArgs = null,
	      lastException = null,
	      lastExceptionStack = null;

	  /**
	   * Add a crash handler.
	   * @param {Function} handler
	   */
	  function subscribe(handler) {
	    installGlobalHandler();
	    handlers.push(handler);
	  }

	  /**
	   * Remove a crash handler.
	   * @param {Function} handler
	   */
	  function unsubscribe(handler) {
	    for (var i = handlers.length - 1; i >= 0; --i) {
	      if (handlers[i] === handler) {
	        handlers.splice(i, 1);
	      }
	    }
	  }

	  /**
	   * Remove all crash handlers.
	   */
	  function unsubscribeAll() {
	    uninstallGlobalHandler();
	    handlers = [];
	  }

	  /**
	   * Dispatch stack information to all handlers.
	   * @param {Object.<string, *>} stack
	   */
	  function notifyHandlers(stack, isWindowError) {
	    var exception = null;
	    if (isWindowError && !TraceKit.collectWindowErrors) {
	      return;
	    }
	    for (var i in handlers) {
	      if (handlers.hasOwnProperty(i)) {
	        try {
	          handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
	        } catch (inner) {
	          exception = inner;
	        }
	      }
	    }

	    if (exception) {
	      throw exception;
	    }
	  }

	  var _oldOnerrorHandler, _onErrorHandlerInstalled;

	  /**
	   * Ensures all global unhandled exceptions are recorded.
	   * Supported by Gecko and IE.
	   * @param {string} msg Error message.
	   * @param {string} url URL of script that generated the exception.
	   * @param {(number|string)} lineNo The line number at which the error
	   * occurred.
	   * @param {?(number|string)} colNo The column number at which the error
	   * occurred.
	   * @param {?Error} ex The actual Error object.
	   */
	  function traceKitWindowOnError(msg, url, lineNo, colNo, ex) {
	    var stack = null;
	    // If 'ex' is ErrorEvent, get real Error from inside
	    var exception = utils$2.isErrorEvent(ex) ? ex.error : ex;
	    // If 'msg' is ErrorEvent, get real message from inside
	    var message = utils$2.isErrorEvent(msg) ? msg.message : msg;

	    if (lastExceptionStack) {
	      TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
	      processLastException();
	    } else if (exception && utils$2.isError(exception)) {
	      // non-string `exception` arg; attempt to extract stack trace

	      // New chrome and blink send along a real error object
	      // Let's just report that like a normal error.
	      // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
	      stack = TraceKit.computeStackTrace(exception);
	      notifyHandlers(stack, true);
	    } else {
	      var location = {
	        url: url,
	        line: lineNo,
	        column: colNo
	      };

	      var name = undefined;
	      var groups;

	      if ({}.toString.call(message) === '[object String]') {
	        var groups = message.match(ERROR_TYPES_RE);
	        if (groups) {
	          name = groups[1];
	          message = groups[2];
	        }
	      }

	      location.func = UNKNOWN_FUNCTION;

	      stack = {
	        name: name,
	        message: message,
	        url: getLocationHref(),
	        stack: [location]
	      };
	      notifyHandlers(stack, true);
	    }

	    if (_oldOnerrorHandler) {
	      return _oldOnerrorHandler.apply(this, arguments);
	    }

	    return false;
	  }

	  function installGlobalHandler() {
	    if (_onErrorHandlerInstalled) {
	      return;
	    }
	    _oldOnerrorHandler = _window$1.onerror;
	    _window$1.onerror = traceKitWindowOnError;
	    _onErrorHandlerInstalled = true;
	  }

	  function uninstallGlobalHandler() {
	    if (!_onErrorHandlerInstalled) {
	      return;
	    }
	    _window$1.onerror = _oldOnerrorHandler;
	    _onErrorHandlerInstalled = false;
	    _oldOnerrorHandler = undefined;
	  }

	  function processLastException() {
	    var _lastExceptionStack = lastExceptionStack,
	        _lastArgs = lastArgs;
	    lastArgs = null;
	    lastExceptionStack = null;
	    lastException = null;
	    notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
	  }

	  /**
	   * Reports an unhandled Error to TraceKit.
	   * @param {Error} ex
	   * @param {?boolean} rethrow If false, do not re-throw the exception.
	   * Only used for window.onerror to not cause an infinite loop of
	   * rethrowing.
	   */
	  function report(ex, rethrow) {
	    var args = _slice.call(arguments, 1);
	    if (lastExceptionStack) {
	      if (lastException === ex) {
	        return; // already caught by an inner catch block, ignore
	      } else {
	        processLastException();
	      }
	    }

	    var stack = TraceKit.computeStackTrace(ex);
	    lastExceptionStack = stack;
	    lastException = ex;
	    lastArgs = args;

	    // If the stack trace is incomplete, wait for 2 seconds for
	    // slow slow IE to see if onerror occurs or not before reporting
	    // this exception; otherwise, we will end up with an incomplete
	    // stack trace
	    setTimeout(function () {
	      if (lastException === ex) {
	        processLastException();
	      }
	    }, stack.incomplete ? 2000 : 0);

	    if (rethrow !== false) {
	      throw ex; // re-throw to propagate to the top level (and cause window.onerror)
	    }
	  }

	  report.subscribe = subscribe;
	  report.unsubscribe = unsubscribe;
	  report.uninstall = unsubscribeAll;
	  return report;
	}();

	/**
	 * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
	 *
	 * Syntax:
	 *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
	 * Returns:
	 *   s.name              - exception name
	 *   s.message           - exception message
	 *   s.stack[i].url      - JavaScript or HTML file URL
	 *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)
	 *   s.stack[i].args     - arguments passed to the function, if known
	 *   s.stack[i].line     - line number, if known
	 *   s.stack[i].column   - column number, if known
	 *
	 * Supports:
	 *   - Firefox:  full stack trace with line numbers and unreliable column
	 *               number on top frame
	 *   - Opera 10: full stack trace with line and column numbers
	 *   - Opera 9-: full stack trace with line numbers
	 *   - Chrome:   full stack trace with line and column numbers
	 *   - Safari:   line and column number for the topmost stacktrace element
	 *               only
	 *   - IE:       no line numbers whatsoever
	 *
	 * Tries to guess names of anonymous functions by looking for assignments
	 * in the source code. In IE and Safari, we have to guess source file names
	 * by searching for function bodies inside all page scripts. This will not
	 * work for scripts that are loaded cross-domain.
	 * Here be dragons: some function names may be guessed incorrectly, and
	 * duplicate functions may be mismatched.
	 *
	 * TraceKit.computeStackTrace should only be used for tracing purposes.
	 * Logging of unhandled exceptions should be done with TraceKit.report,
	 * which builds on top of TraceKit.computeStackTrace and provides better
	 * IE support by utilizing the window.onerror event to retrieve information
	 * about the top of the stack.
	 *
	 * Note: In IE and Safari, no stack trace is recorded on the Error object,
	 * so computeStackTrace instead walks its *own* chain of callers.
	 * This means that:
	 *  * in Safari, some methods may be missing from the stack trace;
	 *  * in IE, the topmost function in the stack trace will always be the
	 *    caller of computeStackTrace.
	 *
	 * This is okay for tracing (because you are likely to be calling
	 * computeStackTrace from the function you want to be the topmost element
	 * of the stack trace anyway), but not okay for logging unhandled
	 * exceptions (because your catch block will likely be far away from the
	 * inner function that actually caused the exception).
	 *
	 */
	TraceKit.computeStackTrace = function computeStackTraceWrapper() {
	  // Contents of Exception in various browsers.
	  //
	  // SAFARI:
	  // ex.message = Can't find variable: qq
	  // ex.line = 59
	  // ex.sourceId = 580238192
	  // ex.sourceURL = http://...
	  // ex.expressionBeginOffset = 96
	  // ex.expressionCaretOffset = 98
	  // ex.expressionEndOffset = 98
	  // ex.name = ReferenceError
	  //
	  // FIREFOX:
	  // ex.message = qq is not defined
	  // ex.fileName = http://...
	  // ex.lineNumber = 59
	  // ex.columnNumber = 69
	  // ex.stack = ...stack trace... (see the example below)
	  // ex.name = ReferenceError
	  //
	  // CHROME:
	  // ex.message = qq is not defined
	  // ex.name = ReferenceError
	  // ex.type = not_defined
	  // ex.arguments = ['aa']
	  // ex.stack = ...stack trace...
	  //
	  // INTERNET EXPLORER:
	  // ex.message = ...
	  // ex.name = ReferenceError
	  //
	  // OPERA:
	  // ex.message = ...message... (see the example below)
	  // ex.name = ReferenceError
	  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
	  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

	  /**
	   * Computes stack trace information from the stack property.
	   * Chrome and Gecko use this property.
	   * @param {Error} ex
	   * @return {?Object.<string, *>} Stack trace information.
	   */
	  function computeStackTraceFromStackProp(ex) {
	    if (typeof ex.stack === 'undefined' || !ex.stack) return;

	    var chrome = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
	    var winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx(?:-web)|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
	    // NOTE: blob urls are now supposed to always have an origin, therefore it's format
	    // which is `blob:http://url/path/with-some-uuid`, is matched by `blob.*?:\/` as well
	    var gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\/.*?|\[native code\]|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
	    // Used to additionally parse URL/line/column from eval frames
	    var geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
	    var chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/;
	    var lines = ex.stack.split('\n');
	    var stack = [];
	    var submatch;
	    var parts;
	    var element;
	    var reference = /^(.*) is undefined$/.exec(ex.message);

	    for (var i = 0, j = lines.length; i < j; ++i) {
	      if (parts = chrome.exec(lines[i])) {
	        var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
	        var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
	        if (isEval && (submatch = chromeEval.exec(parts[2]))) {
	          // throw out eval line/column and use top-most line/column number
	          parts[2] = submatch[1]; // url
	          parts[3] = submatch[2]; // line
	          parts[4] = submatch[3]; // column
	        }
	        element = {
	          url: !isNative ? parts[2] : null,
	          func: parts[1] || UNKNOWN_FUNCTION,
	          args: isNative ? [parts[2]] : [],
	          line: parts[3] ? +parts[3] : null,
	          column: parts[4] ? +parts[4] : null
	        };
	      } else if (parts = winjs.exec(lines[i])) {
	        element = {
	          url: parts[2],
	          func: parts[1] || UNKNOWN_FUNCTION,
	          args: [],
	          line: +parts[3],
	          column: parts[4] ? +parts[4] : null
	        };
	      } else if (parts = gecko.exec(lines[i])) {
	        var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
	        if (isEval && (submatch = geckoEval.exec(parts[3]))) {
	          // throw out eval line/column and use top-most line number
	          parts[3] = submatch[1];
	          parts[4] = submatch[2];
	          parts[5] = null; // no column when eval
	        } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {
	          // FireFox uses this awesome columnNumber property for its top frame
	          // Also note, Firefox's column number is 0-based and everything else expects 1-based,
	          // so adding 1
	          // NOTE: this hack doesn't work if top-most frame is eval
	          stack[0].column = ex.columnNumber + 1;
	        }
	        element = {
	          url: parts[3],
	          func: parts[1] || UNKNOWN_FUNCTION,
	          args: parts[2] ? parts[2].split(',') : [],
	          line: parts[4] ? +parts[4] : null,
	          column: parts[5] ? +parts[5] : null
	        };
	      } else {
	        continue;
	      }

	      if (!element.func && element.line) {
	        element.func = UNKNOWN_FUNCTION;
	      }

	      if (element.url && element.url.substr(0, 5) === 'blob:') {
	        // Special case for handling JavaScript loaded into a blob.
	        // We use a synchronous AJAX request here as a blob is already in
	        // memory - it's not making a network request.  This will generate a warning
	        // in the browser console, but there has already been an error so that's not
	        // that much of an issue.
	        var xhr = new XMLHttpRequest();
	        xhr.open('GET', element.url, false);
	        xhr.send(null);

	        // If we failed to download the source, skip this patch
	        if (xhr.status === 200) {
	          var source = xhr.responseText || '';

	          // We trim the source down to the last 300 characters as sourceMappingURL is always at the end of the file.
	          // Why 300? To be in line with: https://github.com/getsentry/sentry/blob/4af29e8f2350e20c28a6933354e4f42437b4ba42/src/sentry/lang/javascript/processor.py#L164-L175
	          source = source.slice(-300);

	          // Now we dig out the source map URL
	          var sourceMaps = source.match(/\/\/# sourceMappingURL=(.*)$/);

	          // If we don't find a source map comment or we find more than one, continue on to the next element.
	          if (sourceMaps) {
	            var sourceMapAddress = sourceMaps[1];

	            // Now we check to see if it's a relative URL.
	            // If it is, convert it to an absolute one.
	            if (sourceMapAddress.charAt(0) === '~') {
	              sourceMapAddress = getLocationOrigin() + sourceMapAddress.slice(1);
	            }

	            // Now we strip the '.map' off of the end of the URL and update the
	            // element so that Sentry can match the map to the blob.
	            element.url = sourceMapAddress.slice(0, -4);
	          }
	        }
	      }

	      stack.push(element);
	    }

	    if (!stack.length) {
	      return null;
	    }

	    return {
	      name: ex.name,
	      message: ex.message,
	      url: getLocationHref(),
	      stack: stack
	    };
	  }

	  /**
	   * Adds information about the first frame to incomplete stack traces.
	   * Safari and IE require this to get complete data on the first frame.
	   * @param {Object.<string, *>} stackInfo Stack trace information from
	   * one of the compute* methods.
	   * @param {string} url The URL of the script that caused an error.
	   * @param {(number|string)} lineNo The line number of the script that
	   * caused an error.
	   * @param {string=} message The error generated by the browser, which
	   * hopefully contains the name of the object that caused the error.
	   * @return {boolean} Whether or not the stack information was
	   * augmented.
	   */
	  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
	    var initial = {
	      url: url,
	      line: lineNo
	    };

	    if (initial.url && initial.line) {
	      stackInfo.incomplete = false;

	      if (!initial.func) {
	        initial.func = UNKNOWN_FUNCTION;
	      }

	      if (stackInfo.stack.length > 0) {
	        if (stackInfo.stack[0].url === initial.url) {
	          if (stackInfo.stack[0].line === initial.line) {
	            return false; // already in stack trace
	          } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
	            stackInfo.stack[0].line = initial.line;
	            return false;
	          }
	        }
	      }

	      stackInfo.stack.unshift(initial);
	      stackInfo.partial = true;
	      return true;
	    } else {
	      stackInfo.incomplete = true;
	    }

	    return false;
	  }

	  /**
	   * Computes stack trace information by walking the arguments.caller
	   * chain at the time the exception occurred. This will cause earlier
	   * frames to be missed but is the only way to get any stack trace in
	   * Safari and IE. The top frame is restored by
	   * {@link augmentStackTraceWithInitialElement}.
	   * @param {Error} ex
	   * @return {?Object.<string, *>} Stack trace information.
	   */
	  function computeStackTraceByWalkingCallerChain(ex, depth) {
	    var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
	        stack = [],
	        funcs = {},
	        recursion = false,
	        parts,
	        item;

	    for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
	      if (curr === computeStackTrace || curr === TraceKit.report) {
	        // console.log('skipping internal function');
	        continue;
	      }

	      item = {
	        url: null,
	        func: UNKNOWN_FUNCTION,
	        line: null,
	        column: null
	      };

	      if (curr.name) {
	        item.func = curr.name;
	      } else if (parts = functionName.exec(curr.toString())) {
	        item.func = parts[1];
	      }

	      if (typeof item.func === 'undefined') {
	        try {
	          item.func = parts.input.substring(0, parts.input.indexOf('{'));
	        } catch (e) {}
	      }

	      if (funcs['' + curr]) {
	        recursion = true;
	      } else {
	        funcs['' + curr] = true;
	      }

	      stack.push(item);
	    }

	    if (depth) {
	      // console.log('depth is ' + depth);
	      // console.log('stack is ' + stack.length);
	      stack.splice(0, depth);
	    }

	    var result = {
	      name: ex.name,
	      message: ex.message,
	      url: getLocationHref(),
	      stack: stack
	    };
	    augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
	    return result;
	  }

	  /**
	   * Computes a stack trace for an exception.
	   * @param {Error} ex
	   * @param {(string|number)=} depth
	   */
	  function computeStackTrace(ex, depth) {
	    var stack = null;
	    depth = depth == null ? 0 : +depth;

	    try {
	      stack = computeStackTraceFromStackProp(ex);
	      if (stack) {
	        return stack;
	      }
	    } catch (e) {
	      if (TraceKit.debug) {
	        throw e;
	      }
	    }

	    try {
	      stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
	      if (stack) {
	        return stack;
	      }
	    } catch (e) {
	      if (TraceKit.debug) {
	        throw e;
	      }
	    }
	    return {
	      name: ex.name,
	      message: ex.message,
	      url: getLocationHref()
	    };
	  }

	  computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
	  computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;

	  return computeStackTrace;
	}();

	var tracekit = TraceKit;

	var tracekit$1 = /*#__PURE__*/Object.freeze({
		default: tracekit,
		__moduleExports: tracekit
	});

	/*
	 * JavaScript MD5
	 * https://github.com/blueimp/JavaScript-MD5
	 *
	 * Copyright 2011, Sebastian Tschan
	 * https://blueimp.net
	 *
	 * Licensed under the MIT license:
	 * https://opensource.org/licenses/MIT
	 *
	 * Based on
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	/*
	* Add integers, wrapping at 2^32. This uses 16-bit operations internally
	* to work around bugs in some JS interpreters.
	*/
	function safeAdd(x, y) {
	  var lsw = (x & 0xffff) + (y & 0xffff);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return msw << 16 | lsw & 0xffff;
	}

	/*
	* Bitwise rotate a 32-bit number to the left.
	*/
	function bitRotateLeft(num, cnt) {
	  return num << cnt | num >>> 32 - cnt;
	}

	/*
	* These functions implement the four basic operations the algorithm uses.
	*/
	function md5cmn(q, a, b, x, s, t) {
	  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
	}
	function md5ff(a, b, c, d, x, s, t) {
	  return md5cmn(b & c | ~b & d, a, b, x, s, t);
	}
	function md5gg(a, b, c, d, x, s, t) {
	  return md5cmn(b & d | c & ~d, a, b, x, s, t);
	}
	function md5hh(a, b, c, d, x, s, t) {
	  return md5cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5ii(a, b, c, d, x, s, t) {
	  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
	}

	/*
	* Calculate the MD5 of an array of little-endian words, and a bit length.
	*/
	function binlMD5(x, len) {
	  /* append padding */
	  x[len >> 5] |= 0x80 << len % 32;
	  x[(len + 64 >>> 9 << 4) + 14] = len;

	  var i;
	  var olda;
	  var oldb;
	  var oldc;
	  var oldd;
	  var a = 1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d = 271733878;

	  for (i = 0; i < x.length; i += 16) {
	    olda = a;
	    oldb = b;
	    oldc = c;
	    oldd = d;

	    a = md5ff(a, b, c, d, x[i], 7, -680876936);
	    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
	    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
	    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
	    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
	    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
	    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
	    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
	    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
	    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
	    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
	    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
	    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
	    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
	    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
	    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);

	    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
	    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
	    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
	    b = md5gg(b, c, d, a, x[i], 20, -373897302);
	    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
	    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
	    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
	    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
	    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
	    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
	    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
	    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
	    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
	    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
	    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
	    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);

	    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
	    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
	    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
	    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
	    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
	    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
	    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
	    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
	    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
	    d = md5hh(d, a, b, c, x[i], 11, -358537222);
	    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
	    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
	    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
	    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
	    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
	    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);

	    a = md5ii(a, b, c, d, x[i], 6, -198630844);
	    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
	    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
	    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
	    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
	    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
	    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
	    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
	    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
	    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
	    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
	    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
	    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
	    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
	    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
	    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);

	    a = safeAdd(a, olda);
	    b = safeAdd(b, oldb);
	    c = safeAdd(c, oldc);
	    d = safeAdd(d, oldd);
	  }
	  return [a, b, c, d];
	}

	/*
	* Convert an array of little-endian words to a string
	*/
	function binl2rstr(input) {
	  var i;
	  var output = '';
	  var length32 = input.length * 32;
	  for (i = 0; i < length32; i += 8) {
	    output += String.fromCharCode(input[i >> 5] >>> i % 32 & 0xff);
	  }
	  return output;
	}

	/*
	* Convert a raw string to an array of little-endian words
	* Characters >255 have their high-byte silently ignored.
	*/
	function rstr2binl(input) {
	  var i;
	  var output = [];
	  output[(input.length >> 2) - 1] = undefined;
	  for (i = 0; i < output.length; i += 1) {
	    output[i] = 0;
	  }
	  var length8 = input.length * 8;
	  for (i = 0; i < length8; i += 8) {
	    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;
	  }
	  return output;
	}

	/*
	* Calculate the MD5 of a raw string
	*/
	function rstrMD5(s) {
	  return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
	}

	/*
	* Calculate the HMAC-MD5, of a key and some data (raw strings)
	*/
	function rstrHMACMD5(key, data) {
	  var i;
	  var bkey = rstr2binl(key);
	  var ipad = [];
	  var opad = [];
	  var hash;
	  ipad[15] = opad[15] = undefined;
	  if (bkey.length > 16) {
	    bkey = binlMD5(bkey, key.length * 8);
	  }
	  for (i = 0; i < 16; i += 1) {
	    ipad[i] = bkey[i] ^ 0x36363636;
	    opad[i] = bkey[i] ^ 0x5c5c5c5c;
	  }
	  hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
	  return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
	}

	/*
	* Convert a raw string to a hex string
	*/
	function rstr2hex(input) {
	  var hexTab = '0123456789abcdef';
	  var output = '';
	  var x;
	  var i;
	  for (i = 0; i < input.length; i += 1) {
	    x = input.charCodeAt(i);
	    output += hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f);
	  }
	  return output;
	}

	/*
	* Encode a string as utf-8
	*/
	function str2rstrUTF8(input) {
	  return unescape(encodeURIComponent(input));
	}

	/*
	* Take string arguments and return either raw or hex encoded strings
	*/
	function rawMD5(s) {
	  return rstrMD5(str2rstrUTF8(s));
	}
	function hexMD5(s) {
	  return rstr2hex(rawMD5(s));
	}
	function rawHMACMD5(k, d) {
	  return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
	}
	function hexHMACMD5(k, d) {
	  return rstr2hex(rawHMACMD5(k, d));
	}

	function md5(string, key, raw) {
	  if (!key) {
	    if (!raw) {
	      return hexMD5(string);
	    }
	    return rawMD5(string);
	  }
	  if (!raw) {
	    return hexHMACMD5(key, string);
	  }
	  return rawHMACMD5(key, string);
	}

	var md5_1 = md5;

	var md5$1 = /*#__PURE__*/Object.freeze({
		default: md5_1,
		__moduleExports: md5_1
	});

	function RavenConfigError(message) {
	  this.name = 'RavenConfigError';
	  this.message = message;
	}
	RavenConfigError.prototype = new Error();
	RavenConfigError.prototype.constructor = RavenConfigError;

	var configError = RavenConfigError;

	var configError$1 = /*#__PURE__*/Object.freeze({
		default: configError,
		__moduleExports: configError
	});

	var wrapMethod = function wrapMethod(console, level, callback) {
	  var originalConsoleLevel = console[level];
	  var originalConsole = console;

	  if (!(level in console)) {
	    return;
	  }

	  var sentryLevel = level === 'warn' ? 'warning' : level;

	  console[level] = function () {
	    var args = [].slice.call(arguments);

	    var msg = utils$2.safeJoin(args, ' ');
	    var data = { level: sentryLevel, logger: 'console', extra: { arguments: args } };

	    if (level === 'assert') {
	      if (args[0] === false) {
	        // Default browsers message
	        msg = 'Assertion failed: ' + (utils$2.safeJoin(args.slice(1), ' ') || 'console.assert');
	        data.extra.arguments = args.slice(1);
	        callback && callback(msg, data);
	      }
	    } else {
	      callback && callback(msg, data);
	    }

	    // this fails for some browsers. :(
	    if (originalConsoleLevel) {
	      // IE9 doesn't allow calling apply on console functions directly
	      // See: https://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function#answer-5473193
	      Function.prototype.apply.call(originalConsoleLevel, originalConsole, args);
	    }
	  };
	};

	var console$1 = {
	  wrapMethod: wrapMethod
	};
	var console_1 = console$1.wrapMethod;

	var console$2 = /*#__PURE__*/Object.freeze({
		default: console$1,
		__moduleExports: console$1,
		wrapMethod: console_1
	});

	var TraceKit$1 = ( tracekit$1 && tracekit ) || tracekit$1;

	var md5$2 = ( md5$1 && md5_1 ) || md5$1;

	var RavenConfigError$1 = ( configError$1 && configError ) || configError$1;

	var require$$0$29 = ( console$2 && console$1 ) || console$2;

	/*global XDomainRequest:false */

	var isErrorEvent$1 = utils$2.isErrorEvent;
	var isDOMError$1 = utils$2.isDOMError;
	var isDOMException$1 = utils$2.isDOMException;
	var isError$1 = utils$2.isError;
	var isObject$3 = utils$2.isObject;
	var isPlainObject$1 = utils$2.isPlainObject;
	var isUndefined$1 = utils$2.isUndefined;
	var isFunction$2 = utils$2.isFunction;
	var isString$2 = utils$2.isString;
	var isArray$4 = utils$2.isArray;
	var isEmptyObject$1 = utils$2.isEmptyObject;
	var each$1 = utils$2.each;
	var objectMerge$1 = utils$2.objectMerge;
	var truncate$1 = utils$2.truncate;
	var objectFrozen$1 = utils$2.objectFrozen;
	var hasKey$1 = utils$2.hasKey;
	var joinRegExp$1 = utils$2.joinRegExp;
	var urlencode$1 = utils$2.urlencode;
	var uuid4$1 = utils$2.uuid4;
	var htmlTreeAsString$1 = utils$2.htmlTreeAsString;
	var isSameException$1 = utils$2.isSameException;
	var isSameStacktrace$1 = utils$2.isSameStacktrace;
	var parseUrl$1 = utils$2.parseUrl;
	var fill$1 = utils$2.fill;
	var supportsFetch$1 = utils$2.supportsFetch;
	var supportsReferrerPolicy$1 = utils$2.supportsReferrerPolicy;
	var serializeKeysForMessage$1 = utils$2.serializeKeysForMessage;
	var serializeException$1 = utils$2.serializeException;
	var sanitize$1 = utils$2.sanitize;

	var wrapConsoleMethod = require$$0$29.wrapMethod;

	var dsnKeys = 'source protocol user pass host port path'.split(' '),
	    dsnPattern = /^(?:(\w+):)?\/\/(?:(\w+)(:\w+)?@)?([\w\.-]+)(?::(\d+))?(\/.*)/;

	function now() {
	  return +new Date();
	}

	// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
	var _window$2 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};
	var _document = _window$2.document;
	var _navigator = _window$2.navigator;

	function keepOriginalCallback(original, callback) {
	  return isFunction$2(callback) ? function (data) {
	    return callback(data, original);
	  } : callback;
	}

	// First, check for JSON support
	// If there is no JSON, we no-op the core features of Raven
	// since JSON is required to encode the payload
	function Raven() {
	  this._hasJSON = !!((typeof JSON === 'undefined' ? 'undefined' : _typeof(JSON)) === 'object' && JSON.stringify);
	  // Raven can run in contexts where there's no document (react-native)
	  this._hasDocument = !isUndefined$1(_document);
	  this._hasNavigator = !isUndefined$1(_navigator);
	  this._lastCapturedException = null;
	  this._lastData = null;
	  this._lastEventId = null;
	  this._globalServer = null;
	  this._globalKey = null;
	  this._globalProject = null;
	  this._globalContext = {};
	  this._globalOptions = {
	    // SENTRY_RELEASE can be injected by https://github.com/getsentry/sentry-webpack-plugin
	    release: _window$2.SENTRY_RELEASE && _window$2.SENTRY_RELEASE.id,
	    logger: 'javascript',
	    ignoreErrors: [],
	    ignoreUrls: [],
	    whitelistUrls: [],
	    includePaths: [],
	    headers: null,
	    collectWindowErrors: true,
	    captureUnhandledRejections: true,
	    maxMessageLength: 0,
	    // By default, truncates URL values to 250 chars
	    maxUrlLength: 250,
	    stackTraceLimit: 50,
	    autoBreadcrumbs: true,
	    instrument: true,
	    sampleRate: 1,
	    sanitizeKeys: []
	  };
	  this._fetchDefaults = {
	    method: 'POST',
	    keepalive: true,
	    // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
	    // https://caniuse.com/#feat=referrer-policy
	    // It doesn't. And it throw exception instead of ignoring this parameter...
	    // REF: https://github.com/getsentry/raven-js/issues/1233
	    referrerPolicy: supportsReferrerPolicy$1() ? 'origin' : ''
	  };
	  this._ignoreOnError = 0;
	  this._isRavenInstalled = false;
	  this._originalErrorStackTraceLimit = Error.stackTraceLimit;
	  // capture references to window.console *and* all its methods first
	  // before the console plugin has a chance to monkey patch
	  this._originalConsole = _window$2.console || {};
	  this._originalConsoleMethods = {};
	  this._plugins = [];
	  this._startTime = now();
	  this._wrappedBuiltIns = [];
	  this._breadcrumbs = [];
	  this._lastCapturedEvent = null;
	  this._keypressTimeout;
	  this._location = _window$2.location;
	  this._lastHref = this._location && this._location.href;
	  this._resetBackoff();

	  // eslint-disable-next-line guard-for-in
	  for (var method in this._originalConsole) {
	    this._originalConsoleMethods[method] = this._originalConsole[method];
	  }
	}

	/*
	 * The core Raven singleton
	 *
	 * @this {Raven}
	 */

	Raven.prototype = {
	  // Hardcode version string so that raven source can be loaded directly via
	  // webpack (using a build step causes webpack #1617). Grunt verifies that
	  // this value matches package.json during build.
	  //   See: https://github.com/getsentry/raven-js/issues/465
	  VERSION: '3.25.2',

	  debug: false,

	  TraceKit: TraceKit$1, // alias to TraceKit

	  /*
	     * Configure Raven with a DSN and extra options
	     *
	     * @param {string} dsn The public Sentry DSN
	     * @param {object} options Set of global options [optional]
	     * @return {Raven}
	     */
	  config: function config(dsn, options) {
	    var self = this;

	    if (self._globalServer) {
	      this._logDebug('error', 'Error: Raven has already been configured');
	      return self;
	    }
	    if (!dsn) return self;

	    var globalOptions = self._globalOptions;

	    // merge in options
	    if (options) {
	      each$1(options, function (key, value) {
	        // tags and extra are special and need to be put into context
	        if (key === 'tags' || key === 'extra' || key === 'user') {
	          self._globalContext[key] = value;
	        } else {
	          globalOptions[key] = value;
	        }
	      });
	    }

	    self.setDSN(dsn);

	    // "Script error." is hard coded into browsers for errors that it can't read.
	    // this is the result of a script being pulled in from an external domain and CORS.
	    globalOptions.ignoreErrors.push(/^Script error\.?$/);
	    globalOptions.ignoreErrors.push(/^Javascript error: Script error\.? on line 0$/);

	    // join regexp rules into one big rule
	    globalOptions.ignoreErrors = joinRegExp$1(globalOptions.ignoreErrors);
	    globalOptions.ignoreUrls = globalOptions.ignoreUrls.length ? joinRegExp$1(globalOptions.ignoreUrls) : false;
	    globalOptions.whitelistUrls = globalOptions.whitelistUrls.length ? joinRegExp$1(globalOptions.whitelistUrls) : false;
	    globalOptions.includePaths = joinRegExp$1(globalOptions.includePaths);
	    globalOptions.maxBreadcrumbs = Math.max(0, Math.min(globalOptions.maxBreadcrumbs || 100, 100)); // default and hard limit is 100

	    var autoBreadcrumbDefaults = {
	      xhr: true,
	      console: true,
	      dom: true,
	      location: true,
	      sentry: true
	    };

	    var autoBreadcrumbs = globalOptions.autoBreadcrumbs;
	    if ({}.toString.call(autoBreadcrumbs) === '[object Object]') {
	      autoBreadcrumbs = objectMerge$1(autoBreadcrumbDefaults, autoBreadcrumbs);
	    } else if (autoBreadcrumbs !== false) {
	      autoBreadcrumbs = autoBreadcrumbDefaults;
	    }
	    globalOptions.autoBreadcrumbs = autoBreadcrumbs;

	    var instrumentDefaults = {
	      tryCatch: true
	    };

	    var instrument = globalOptions.instrument;
	    if ({}.toString.call(instrument) === '[object Object]') {
	      instrument = objectMerge$1(instrumentDefaults, instrument);
	    } else if (instrument !== false) {
	      instrument = instrumentDefaults;
	    }
	    globalOptions.instrument = instrument;

	    TraceKit$1.collectWindowErrors = !!globalOptions.collectWindowErrors;

	    // return for chaining
	    return self;
	  },

	  /*
	     * Installs a global window.onerror error handler
	     * to capture and report uncaught exceptions.
	     * At this point, install() is required to be called due
	     * to the way TraceKit is set up.
	     *
	     * @return {Raven}
	     */
	  install: function install() {
	    var self = this;
	    if (self.isSetup() && !self._isRavenInstalled) {
	      TraceKit$1.report.subscribe(function () {
	        self._handleOnErrorStackInfo.apply(self, arguments);
	      });

	      if (self._globalOptions.captureUnhandledRejections) {
	        self._attachPromiseRejectionHandler();
	      }

	      self._patchFunctionToString();

	      if (self._globalOptions.instrument && self._globalOptions.instrument.tryCatch) {
	        self._instrumentTryCatch();
	      }

	      if (self._globalOptions.autoBreadcrumbs) self._instrumentBreadcrumbs();

	      // Install all of the plugins
	      self._drainPlugins();

	      self._isRavenInstalled = true;
	    }

	    Error.stackTraceLimit = self._globalOptions.stackTraceLimit;
	    return this;
	  },

	  /*
	     * Set the DSN (can be called multiple time unlike config)
	     *
	     * @param {string} dsn The public Sentry DSN
	     */
	  setDSN: function setDSN(dsn) {
	    var self = this,
	        uri = self._parseDSN(dsn),
	        lastSlash = uri.path.lastIndexOf('/'),
	        path = uri.path.substr(1, lastSlash);

	    self._dsn = dsn;
	    self._globalKey = uri.user;
	    self._globalSecret = uri.pass && uri.pass.substr(1);
	    self._globalProject = uri.path.substr(lastSlash + 1);

	    self._globalServer = self._getGlobalServer(uri);

	    self._globalEndpoint = self._globalServer + '/' + path + 'api/' + self._globalProject + '/store/';

	    // Reset backoff state since we may be pointing at a
	    // new project/server
	    this._resetBackoff();
	  },

	  /*
	     * Wrap code within a context so Raven can capture errors
	     * reliably across domains that is executed immediately.
	     *
	     * @param {object} options A specific set of options for this context [optional]
	     * @param {function} func The callback to be immediately executed within the context
	     * @param {array} args An array of arguments to be called with the callback [optional]
	     */
	  context: function context(options, func, args) {
	    if (isFunction$2(options)) {
	      args = func || [];
	      func = options;
	      options = undefined;
	    }

	    return this.wrap(options, func).apply(this, args);
	  },

	  /*
	     * Wrap code within a context and returns back a new function to be executed
	     *
	     * @param {object} options A specific set of options for this context [optional]
	     * @param {function} func The function to be wrapped in a new context
	     * @param {function} func A function to call before the try/catch wrapper [optional, private]
	     * @return {function} The newly wrapped functions with a context
	     */
	  wrap: function wrap(options, func, _before) {
	    var self = this;
	    // 1 argument has been passed, and it's not a function
	    // so just return it
	    if (isUndefined$1(func) && !isFunction$2(options)) {
	      return options;
	    }

	    // options is optional
	    if (isFunction$2(options)) {
	      func = options;
	      options = undefined;
	    }

	    // At this point, we've passed along 2 arguments, and the second one
	    // is not a function either, so we'll just return the second argument.
	    if (!isFunction$2(func)) {
	      return func;
	    }

	    // We don't wanna wrap it twice!
	    try {
	      if (func.__raven__) {
	        return func;
	      }

	      // If this has already been wrapped in the past, return that
	      if (func.__raven_wrapper__) {
	        return func.__raven_wrapper__;
	      }
	    } catch (e) {
	      // Just accessing custom props in some Selenium environments
	      // can cause a "Permission denied" exception (see raven-js#495).
	      // Bail on wrapping and return the function as-is (defers to window.onerror).
	      return func;
	    }

	    function wrapped() {
	      var args = [],
	          i = arguments.length,
	          deep = !options || options && options.deep !== false;

	      if (_before && isFunction$2(_before)) {
	        _before.apply(this, arguments);
	      }

	      // Recursively wrap all of a function's arguments that are
	      // functions themselves.
	      while (i--) {
	        args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];
	      }try {
	        // Attempt to invoke user-land function
	        // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
	        //       means Raven caught an error invoking your application code. This is
	        //       expected behavior and NOT indicative of a bug with Raven.js.
	        return func.apply(this, args);
	      } catch (e) {
	        self._ignoreNextOnError();
	        self.captureException(e, options);
	        throw e;
	      }
	    }

	    // copy over properties of the old function
	    for (var property in func) {
	      if (hasKey$1(func, property)) {
	        wrapped[property] = func[property];
	      }
	    }
	    wrapped.prototype = func.prototype;

	    func.__raven_wrapper__ = wrapped;
	    // Signal that this function has been wrapped/filled already
	    // for both debugging and to prevent it to being wrapped/filled twice
	    wrapped.__raven__ = true;
	    wrapped.__orig__ = func;

	    return wrapped;
	  },

	  /**
	   * Uninstalls the global error handler.
	   *
	   * @return {Raven}
	   */
	  uninstall: function uninstall() {
	    TraceKit$1.report.uninstall();

	    this._detachPromiseRejectionHandler();
	    this._unpatchFunctionToString();
	    this._restoreBuiltIns();
	    this._restoreConsole();

	    Error.stackTraceLimit = this._originalErrorStackTraceLimit;
	    this._isRavenInstalled = false;

	    return this;
	  },

	  /**
	   * Callback used for `unhandledrejection` event
	   *
	   * @param {PromiseRejectionEvent} event An object containing
	   *   promise: the Promise that was rejected
	   *   reason: the value with which the Promise was rejected
	   * @return void
	   */
	  _promiseRejectionHandler: function _promiseRejectionHandler(event) {
	    this._logDebug('debug', 'Raven caught unhandled promise rejection:', event);
	    this.captureException(event.reason, {
	      extra: {
	        unhandledPromiseRejection: true
	      }
	    });
	  },

	  /**
	   * Installs the global promise rejection handler.
	   *
	   * @return {raven}
	   */
	  _attachPromiseRejectionHandler: function _attachPromiseRejectionHandler() {
	    this._promiseRejectionHandler = this._promiseRejectionHandler.bind(this);
	    _window$2.addEventListener && _window$2.addEventListener('unhandledrejection', this._promiseRejectionHandler);
	    return this;
	  },

	  /**
	   * Uninstalls the global promise rejection handler.
	   *
	   * @return {raven}
	   */
	  _detachPromiseRejectionHandler: function _detachPromiseRejectionHandler() {
	    _window$2.removeEventListener && _window$2.removeEventListener('unhandledrejection', this._promiseRejectionHandler);
	    return this;
	  },

	  /**
	   * Manually capture an exception and send it over to Sentry
	   *
	   * @param {error} ex An exception to be logged
	   * @param {object} options A specific set of options for this error [optional]
	   * @return {Raven}
	   */
	  captureException: function captureException(ex, options) {
	    options = objectMerge$1({ trimHeadFrames: 0 }, options ? options : {});

	    if (isErrorEvent$1(ex) && ex.error) {
	      // If it is an ErrorEvent with `error` property, extract it to get actual Error
	      ex = ex.error;
	    } else if (isDOMError$1(ex) || isDOMException$1(ex)) {
	      // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)
	      // then we just extract the name and message, as they don't provide anything else
	      // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
	      // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
	      var name = ex.name || (isDOMError$1(ex) ? 'DOMError' : 'DOMException');
	      var message = ex.message ? name + ': ' + ex.message : name;

	      return this.captureMessage(message, objectMerge$1(options, {
	        // neither DOMError or DOMException provide stack trace and we most likely wont get it this way as well
	        // but it's barely any overhead so we may at least try
	        stacktrace: true,
	        trimHeadFrames: options.trimHeadFrames + 1
	      }));
	    } else if (isError$1(ex)) {
	      // we have a real Error object
	      ex = ex;
	    } else if (isPlainObject$1(ex)) {
	      // If it is plain Object, serialize it manually and extract options
	      // This will allow us to group events based on top-level keys
	      // which is much better than creating new group when any key/value change
	      options = this._getCaptureExceptionOptionsFromPlainObject(options, ex);
	      ex = new Error(options.message);
	    } else {
	      // If none of previous checks were valid, then it means that
	      // it's not a DOMError/DOMException
	      // it's not a plain Object
	      // it's not a valid ErrorEvent (one with an error property)
	      // it's not an Error
	      // So bail out and capture it as a simple message:
	      return this.captureMessage(ex, objectMerge$1(options, {
	        stacktrace: true, // if we fall back to captureMessage, default to attempting a new trace
	        trimHeadFrames: options.trimHeadFrames + 1
	      }));
	    }

	    // Store the raw exception object for potential debugging and introspection
	    this._lastCapturedException = ex;

	    // TraceKit.report will re-raise any exception passed to it,
	    // which means you have to wrap it in try/catch. Instead, we
	    // can wrap it here and only re-raise if TraceKit.report
	    // raises an exception different from the one we asked to
	    // report on.
	    try {
	      var stack = TraceKit$1.computeStackTrace(ex);
	      this._handleStackInfo(stack, options);
	    } catch (ex1) {
	      if (ex !== ex1) {
	        throw ex1;
	      }
	    }

	    return this;
	  },

	  _getCaptureExceptionOptionsFromPlainObject: function _getCaptureExceptionOptionsFromPlainObject(currentOptions, ex) {
	    var exKeys = Object.keys(ex).sort();
	    var options = objectMerge$1(currentOptions, {
	      message: 'Non-Error exception captured with keys: ' + serializeKeysForMessage$1(exKeys),
	      fingerprint: [md5$2(exKeys)],
	      extra: currentOptions.extra || {}
	    });
	    options.extra.__serialized__ = serializeException$1(ex);

	    return options;
	  },

	  /*
	     * Manually send a message to Sentry
	     *
	     * @param {string} msg A plain message to be captured in Sentry
	     * @param {object} options A specific set of options for this message [optional]
	     * @return {Raven}
	     */
	  captureMessage: function captureMessage(msg, options) {
	    // config() automagically converts ignoreErrors from a list to a RegExp so we need to test for an
	    // early call; we'll error on the side of logging anything called before configuration since it's
	    // probably something you should see:
	    if (!!this._globalOptions.ignoreErrors.test && this._globalOptions.ignoreErrors.test(msg)) {
	      return;
	    }

	    options = options || {};
	    msg = msg + ''; // Make sure it's actually a string

	    var data = objectMerge$1({
	      message: msg
	    }, options);

	    var ex;
	    // Generate a "synthetic" stack trace from this point.
	    // NOTE: If you are a Sentry user, and you are seeing this stack frame, it is NOT indicative
	    //       of a bug with Raven.js. Sentry generates synthetic traces either by configuration,
	    //       or if it catches a thrown object without a "stack" property.
	    try {
	      throw new Error(msg);
	    } catch (ex1) {
	      ex = ex1;
	    }

	    // null exception name so `Error` isn't prefixed to msg
	    ex.name = null;
	    var stack = TraceKit$1.computeStackTrace(ex);

	    // stack[0] is `throw new Error(msg)` call itself, we are interested in the frame that was just before that, stack[1]
	    var initialCall = isArray$4(stack.stack) && stack.stack[1];

	    // if stack[1] is `Raven.captureException`, it means that someone passed a string to it and we redirected that call
	    // to be handled by `captureMessage`, thus `initialCall` is the 3rd one, not 2nd
	    // initialCall => captureException(string) => captureMessage(string)
	    if (initialCall && initialCall.func === 'Raven.captureException') {
	      initialCall = stack.stack[2];
	    }

	    var fileurl = initialCall && initialCall.url || '';

	    if (!!this._globalOptions.ignoreUrls.test && this._globalOptions.ignoreUrls.test(fileurl)) {
	      return;
	    }

	    if (!!this._globalOptions.whitelistUrls.test && !this._globalOptions.whitelistUrls.test(fileurl)) {
	      return;
	    }

	    if (this._globalOptions.stacktrace || options && options.stacktrace) {
	      // fingerprint on msg, not stack trace (legacy behavior, could be revisited)
	      data.fingerprint = data.fingerprint == null ? msg : data.fingerprint;

	      options = objectMerge$1({
	        trimHeadFrames: 0
	      }, options);
	      // Since we know this is a synthetic trace, the top frame (this function call)
	      // MUST be from Raven.js, so mark it for trimming
	      // We add to the trim counter so that callers can choose to trim extra frames, such
	      // as utility functions.
	      options.trimHeadFrames += 1;

	      var frames = this._prepareFrames(stack, options);
	      data.stacktrace = {
	        // Sentry expects frames oldest to newest
	        frames: frames.reverse()
	      };
	    }

	    // Make sure that fingerprint is always wrapped in an array
	    if (data.fingerprint) {
	      data.fingerprint = isArray$4(data.fingerprint) ? data.fingerprint : [data.fingerprint];
	    }

	    // Fire away!
	    this._send(data);

	    return this;
	  },

	  captureBreadcrumb: function captureBreadcrumb(obj) {
	    var crumb = objectMerge$1({
	      timestamp: now() / 1000
	    }, obj);

	    if (isFunction$2(this._globalOptions.breadcrumbCallback)) {
	      var result = this._globalOptions.breadcrumbCallback(crumb);

	      if (isObject$3(result) && !isEmptyObject$1(result)) {
	        crumb = result;
	      } else if (result === false) {
	        return this;
	      }
	    }

	    this._breadcrumbs.push(crumb);
	    if (this._breadcrumbs.length > this._globalOptions.maxBreadcrumbs) {
	      this._breadcrumbs.shift();
	    }
	    return this;
	  },

	  addPlugin: function addPlugin(plugin /*arg1, arg2, ... argN*/) {
	    var pluginArgs = [].slice.call(arguments, 1);

	    this._plugins.push([plugin, pluginArgs]);
	    if (this._isRavenInstalled) {
	      this._drainPlugins();
	    }

	    return this;
	  },

	  /*
	     * Set/clear a user to be sent along with the payload.
	     *
	     * @param {object} user An object representing user data [optional]
	     * @return {Raven}
	     */
	  setUserContext: function setUserContext(user) {
	    // Intentionally do not merge here since that's an unexpected behavior.
	    this._globalContext.user = user;

	    return this;
	  },

	  /*
	     * Merge extra attributes to be sent along with the payload.
	     *
	     * @param {object} extra An object representing extra data [optional]
	     * @return {Raven}
	     */
	  setExtraContext: function setExtraContext(extra) {
	    this._mergeContext('extra', extra);

	    return this;
	  },

	  /*
	     * Merge tags to be sent along with the payload.
	     *
	     * @param {object} tags An object representing tags [optional]
	     * @return {Raven}
	     */
	  setTagsContext: function setTagsContext(tags) {
	    this._mergeContext('tags', tags);

	    return this;
	  },

	  /*
	     * Clear all of the context.
	     *
	     * @return {Raven}
	     */
	  clearContext: function clearContext() {
	    this._globalContext = {};

	    return this;
	  },

	  /*
	     * Get a copy of the current context. This cannot be mutated.
	     *
	     * @return {object} copy of context
	     */
	  getContext: function getContext() {
	    // lol javascript
	    return JSON.parse(stringify$1(this._globalContext));
	  },

	  /*
	     * Set environment of application
	     *
	     * @param {string} environment Typically something like 'production'.
	     * @return {Raven}
	     */
	  setEnvironment: function setEnvironment(environment) {
	    this._globalOptions.environment = environment;

	    return this;
	  },

	  /*
	     * Set release version of application
	     *
	     * @param {string} release Typically something like a git SHA to identify version
	     * @return {Raven}
	     */
	  setRelease: function setRelease(release) {
	    this._globalOptions.release = release;

	    return this;
	  },

	  /*
	     * Set the dataCallback option
	     *
	     * @param {function} callback The callback to run which allows the
	     *                            data blob to be mutated before sending
	     * @return {Raven}
	     */
	  setDataCallback: function setDataCallback(callback) {
	    var original = this._globalOptions.dataCallback;
	    this._globalOptions.dataCallback = keepOriginalCallback(original, callback);
	    return this;
	  },

	  /*
	     * Set the breadcrumbCallback option
	     *
	     * @param {function} callback The callback to run which allows filtering
	     *                            or mutating breadcrumbs
	     * @return {Raven}
	     */
	  setBreadcrumbCallback: function setBreadcrumbCallback(callback) {
	    var original = this._globalOptions.breadcrumbCallback;
	    this._globalOptions.breadcrumbCallback = keepOriginalCallback(original, callback);
	    return this;
	  },

	  /*
	     * Set the shouldSendCallback option
	     *
	     * @param {function} callback The callback to run which allows
	     *                            introspecting the blob before sending
	     * @return {Raven}
	     */
	  setShouldSendCallback: function setShouldSendCallback(callback) {
	    var original = this._globalOptions.shouldSendCallback;
	    this._globalOptions.shouldSendCallback = keepOriginalCallback(original, callback);
	    return this;
	  },

	  /**
	   * Override the default HTTP transport mechanism that transmits data
	   * to the Sentry server.
	   *
	   * @param {function} transport Function invoked instead of the default
	   *                             `makeRequest` handler.
	   *
	   * @return {Raven}
	   */
	  setTransport: function setTransport(transport) {
	    this._globalOptions.transport = transport;

	    return this;
	  },

	  /*
	     * Get the latest raw exception that was captured by Raven.
	     *
	     * @return {error}
	     */
	  lastException: function lastException() {
	    return this._lastCapturedException;
	  },

	  /*
	     * Get the last event id
	     *
	     * @return {string}
	     */
	  lastEventId: function lastEventId() {
	    return this._lastEventId;
	  },

	  /*
	     * Determine if Raven is setup and ready to go.
	     *
	     * @return {boolean}
	     */
	  isSetup: function isSetup() {
	    if (!this._hasJSON) return false; // needs JSON support
	    if (!this._globalServer) {
	      if (!this.ravenNotConfiguredError) {
	        this.ravenNotConfiguredError = true;
	        this._logDebug('error', 'Error: Raven has not been configured.');
	      }
	      return false;
	    }
	    return true;
	  },

	  afterLoad: function afterLoad() {
	    // TODO: remove window dependence?

	    // Attempt to initialize Raven on load
	    var RavenConfig = _window$2.RavenConfig;
	    if (RavenConfig) {
	      this.config(RavenConfig.dsn, RavenConfig.config).install();
	    }
	  },

	  showReportDialog: function showReportDialog(options) {
	    if (!_document // doesn't work without a document (React native)
	    ) return;

	    options = options || {};

	    var lastEventId = options.eventId || this.lastEventId();
	    if (!lastEventId) {
	      throw new RavenConfigError$1('Missing eventId');
	    }

	    var dsn = options.dsn || this._dsn;
	    if (!dsn) {
	      throw new RavenConfigError$1('Missing DSN');
	    }

	    var encode = encodeURIComponent;
	    var qs = '';
	    qs += '?eventId=' + encode(lastEventId);
	    qs += '&dsn=' + encode(dsn);

	    var user = options.user || this._globalContext.user;
	    if (user) {
	      if (user.name) qs += '&name=' + encode(user.name);
	      if (user.email) qs += '&email=' + encode(user.email);
	    }

	    var globalServer = this._getGlobalServer(this._parseDSN(dsn));

	    var script = _document.createElement('script');
	    script.async = true;
	    script.src = globalServer + '/api/embed/error-page/' + qs;
	    (_document.head || _document.body).appendChild(script);
	  },

	  /**** Private functions ****/
	  _ignoreNextOnError: function _ignoreNextOnError() {
	    var self = this;
	    this._ignoreOnError += 1;
	    setTimeout(function () {
	      // onerror should trigger before setTimeout
	      self._ignoreOnError -= 1;
	    });
	  },

	  _triggerEvent: function _triggerEvent(eventType, options) {
	    // NOTE: `event` is a native browser thing, so let's avoid conflicting wiht it
	    var evt, key;

	    if (!this._hasDocument) return;

	    options = options || {};

	    eventType = 'raven' + eventType.substr(0, 1).toUpperCase() + eventType.substr(1);

	    if (_document.createEvent) {
	      evt = _document.createEvent('HTMLEvents');
	      evt.initEvent(eventType, true, true);
	    } else {
	      evt = _document.createEventObject();
	      evt.eventType = eventType;
	    }

	    for (key in options) {
	      if (hasKey$1(options, key)) {
	        evt[key] = options[key];
	      }
	    }if (_document.createEvent) {
	      // IE9 if standards
	      _document.dispatchEvent(evt);
	    } else {
	      // IE8 regardless of Quirks or Standards
	      // IE9 if quirks
	      try {
	        _document.fireEvent('on' + evt.eventType.toLowerCase(), evt);
	      } catch (e) {
	        // Do nothing
	      }
	    }
	  },

	  /**
	   * Wraps addEventListener to capture UI breadcrumbs
	   * @param evtName the event name (e.g. "click")
	   * @returns {Function}
	   * @private
	   */
	  _breadcrumbEventHandler: function _breadcrumbEventHandler(evtName) {
	    var self = this;
	    return function (evt) {
	      // reset keypress timeout; e.g. triggering a 'click' after
	      // a 'keypress' will reset the keypress debounce so that a new
	      // set of keypresses can be recorded
	      self._keypressTimeout = null;

	      // It's possible this handler might trigger multiple times for the same
	      // event (e.g. event propagation through node ancestors). Ignore if we've
	      // already captured the event.
	      if (self._lastCapturedEvent === evt) return;

	      self._lastCapturedEvent = evt;

	      // try/catch both:
	      // - accessing evt.target (see getsentry/raven-js#838, #768)
	      // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
	      //   can throw an exception in some circumstances.
	      var target;
	      try {
	        target = htmlTreeAsString$1(evt.target);
	      } catch (e) {
	        target = '<unknown>';
	      }

	      self.captureBreadcrumb({
	        category: 'ui.' + evtName, // e.g. ui.click, ui.input
	        message: target
	      });
	    };
	  },

	  /**
	   * Wraps addEventListener to capture keypress UI events
	   * @returns {Function}
	   * @private
	   */
	  _keypressEventHandler: function _keypressEventHandler() {
	    var self = this,
	        debounceDuration = 1000; // milliseconds

	    // TODO: if somehow user switches keypress target before
	    //       debounce timeout is triggered, we will only capture
	    //       a single breadcrumb from the FIRST target (acceptable?)
	    return function (evt) {
	      var target;
	      try {
	        target = evt.target;
	      } catch (e) {
	        // just accessing event properties can throw an exception in some rare circumstances
	        // see: https://github.com/getsentry/raven-js/issues/838
	        return;
	      }
	      var tagName = target && target.tagName;

	      // only consider keypress events on actual input elements
	      // this will disregard keypresses targeting body (e.g. tabbing
	      // through elements, hotkeys, etc)
	      if (!tagName || tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable) return;

	      // record first keypress in a series, but ignore subsequent
	      // keypresses until debounce clears
	      var timeout = self._keypressTimeout;
	      if (!timeout) {
	        self._breadcrumbEventHandler('input')(evt);
	      }
	      clearTimeout(timeout);
	      self._keypressTimeout = setTimeout(function () {
	        self._keypressTimeout = null;
	      }, debounceDuration);
	    };
	  },

	  /**
	   * Captures a breadcrumb of type "navigation", normalizing input URLs
	   * @param to the originating URL
	   * @param from the target URL
	   * @private
	   */
	  _captureUrlChange: function _captureUrlChange(from, to) {
	    var parsedLoc = parseUrl$1(this._location.href);
	    var parsedTo = parseUrl$1(to);
	    var parsedFrom = parseUrl$1(from);

	    // because onpopstate only tells you the "new" (to) value of location.href, and
	    // not the previous (from) value, we need to track the value of the current URL
	    // state ourselves
	    this._lastHref = to;

	    // Use only the path component of the URL if the URL matches the current
	    // document (almost all the time when using pushState)
	    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) to = parsedTo.relative;
	    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) from = parsedFrom.relative;

	    this.captureBreadcrumb({
	      category: 'navigation',
	      data: {
	        to: to,
	        from: from
	      }
	    });
	  },

	  _patchFunctionToString: function _patchFunctionToString() {
	    var self = this;
	    self._originalFunctionToString = Function.prototype.toString;
	    // eslint-disable-next-line no-extend-native
	    Function.prototype.toString = function () {
	      if (typeof this === 'function' && this.__raven__) {
	        return self._originalFunctionToString.apply(this.__orig__, arguments);
	      }
	      return self._originalFunctionToString.apply(this, arguments);
	    };
	  },

	  _unpatchFunctionToString: function _unpatchFunctionToString() {
	    if (this._originalFunctionToString) {
	      // eslint-disable-next-line no-extend-native
	      Function.prototype.toString = this._originalFunctionToString;
	    }
	  },

	  /**
	   * Wrap timer functions and event targets to catch errors and provide
	   * better metadata.
	   */
	  _instrumentTryCatch: function _instrumentTryCatch() {
	    var self = this;

	    var wrappedBuiltIns = self._wrappedBuiltIns;

	    function wrapTimeFn(orig) {
	      return function (fn, t) {
	        // preserve arity
	        // Make a copy of the arguments to prevent deoptimization
	        // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
	        var args = new Array(arguments.length);
	        for (var i = 0; i < args.length; ++i) {
	          args[i] = arguments[i];
	        }
	        var originalCallback = args[0];
	        if (isFunction$2(originalCallback)) {
	          args[0] = self.wrap(originalCallback);
	        }

	        // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
	        // also supports only two arguments and doesn't care what this is, so we
	        // can just call the original function directly.
	        if (orig.apply) {
	          return orig.apply(this, args);
	        } else {
	          return orig(args[0], args[1]);
	        }
	      };
	    }

	    var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

	    function wrapEventTarget(global) {
	      var proto = _window$2[global] && _window$2[global].prototype;
	      if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {
	        fill$1(proto, 'addEventListener', function (orig) {
	          return function (evtName, fn, capture, secure) {
	            // preserve arity
	            try {
	              if (fn && fn.handleEvent) {
	                fn.handleEvent = self.wrap(fn.handleEvent);
	              }
	            } catch (err) {}
	            // can sometimes get 'Permission denied to access property "handle Event'


	            // More breadcrumb DOM capture ... done here and not in `_instrumentBreadcrumbs`
	            // so that we don't have more than one wrapper function
	            var before, clickHandler, keypressHandler;

	            if (autoBreadcrumbs && autoBreadcrumbs.dom && (global === 'EventTarget' || global === 'Node')) {
	              // NOTE: generating multiple handlers per addEventListener invocation, should
	              //       revisit and verify we can just use one (almost certainly)
	              clickHandler = self._breadcrumbEventHandler('click');
	              keypressHandler = self._keypressEventHandler();
	              before = function before(evt) {
	                // need to intercept every DOM event in `before` argument, in case that
	                // same wrapped method is re-used for different events (e.g. mousemove THEN click)
	                // see #724
	                if (!evt) return;

	                var eventType;
	                try {
	                  eventType = evt.type;
	                } catch (e) {
	                  // just accessing event properties can throw an exception in some rare circumstances
	                  // see: https://github.com/getsentry/raven-js/issues/838
	                  return;
	                }
	                if (eventType === 'click') return clickHandler(evt);else if (eventType === 'keypress') return keypressHandler(evt);
	              };
	            }
	            return orig.call(this, evtName, self.wrap(fn, undefined, before), capture, secure);
	          };
	        }, wrappedBuiltIns);
	        fill$1(proto, 'removeEventListener', function (orig) {
	          return function (evt, fn, capture, secure) {
	            try {
	              fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);
	            } catch (e) {
	              // ignore, accessing __raven_wrapper__ will throw in some Selenium environments
	            }
	            return orig.call(this, evt, fn, capture, secure);
	          };
	        }, wrappedBuiltIns);
	      }
	    }

	    fill$1(_window$2, 'setTimeout', wrapTimeFn, wrappedBuiltIns);
	    fill$1(_window$2, 'setInterval', wrapTimeFn, wrappedBuiltIns);
	    if (_window$2.requestAnimationFrame) {
	      fill$1(_window$2, 'requestAnimationFrame', function (orig) {
	        return function (cb) {
	          return orig(self.wrap(cb));
	        };
	      }, wrappedBuiltIns);
	    }

	    // event targets borrowed from bugsnag-js:
	    // https://github.com/bugsnag/bugsnag-js/blob/master/src/bugsnag.js#L666
	    var eventTargets = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];
	    for (var i = 0; i < eventTargets.length; i++) {
	      wrapEventTarget(eventTargets[i]);
	    }
	  },

	  /**
	   * Instrument browser built-ins w/ breadcrumb capturing
	   *  - XMLHttpRequests
	   *  - DOM interactions (click/typing)
	   *  - window.location changes
	   *  - console
	   *
	   * Can be disabled or individually configured via the `autoBreadcrumbs` config option
	   */
	  _instrumentBreadcrumbs: function _instrumentBreadcrumbs() {
	    var self = this;
	    var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

	    var wrappedBuiltIns = self._wrappedBuiltIns;

	    function wrapProp(prop, xhr) {
	      if (prop in xhr && isFunction$2(xhr[prop])) {
	        fill$1(xhr, prop, function (orig) {
	          return self.wrap(orig);
	        }); // intentionally don't track filled methods on XHR instances
	      }
	    }

	    if (autoBreadcrumbs.xhr && 'XMLHttpRequest' in _window$2) {
	      var xhrproto = _window$2.XMLHttpRequest && _window$2.XMLHttpRequest.prototype;
	      fill$1(xhrproto, 'open', function (origOpen) {
	        return function (method, url) {
	          // preserve arity

	          // if Sentry key appears in URL, don't capture
	          if (isString$2(url) && url.indexOf(self._globalKey) === -1) {
	            this.__raven_xhr = {
	              method: method,
	              url: url,
	              status_code: null
	            };
	          }

	          return origOpen.apply(this, arguments);
	        };
	      }, wrappedBuiltIns);

	      fill$1(xhrproto, 'send', function (origSend) {
	        return function () {
	          // preserve arity
	          var xhr = this;

	          function onreadystatechangeHandler() {
	            if (xhr.__raven_xhr && xhr.readyState === 4) {
	              try {
	                // touching statusCode in some platforms throws
	                // an exception
	                xhr.__raven_xhr.status_code = xhr.status;
	              } catch (e) {
	                /* do nothing */
	              }

	              self.captureBreadcrumb({
	                type: 'http',
	                category: 'xhr',
	                data: xhr.__raven_xhr
	              });
	            }
	          }

	          var props = ['onload', 'onerror', 'onprogress'];
	          for (var j = 0; j < props.length; j++) {
	            wrapProp(props[j], xhr);
	          }

	          if ('onreadystatechange' in xhr && isFunction$2(xhr.onreadystatechange)) {
	            fill$1(xhr, 'onreadystatechange', function (orig) {
	              return self.wrap(orig, undefined, onreadystatechangeHandler);
	            } /* intentionally don't track this instrumentation */
	            );
	          } else {
	            // if onreadystatechange wasn't actually set by the page on this xhr, we
	            // are free to set our own and capture the breadcrumb
	            xhr.onreadystatechange = onreadystatechangeHandler;
	          }

	          return origSend.apply(this, arguments);
	        };
	      }, wrappedBuiltIns);
	    }

	    if (autoBreadcrumbs.xhr && supportsFetch$1()) {
	      fill$1(_window$2, 'fetch', function (origFetch) {
	        return function () {
	          // preserve arity
	          // Make a copy of the arguments to prevent deoptimization
	          // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
	          var args = new Array(arguments.length);
	          for (var i = 0; i < args.length; ++i) {
	            args[i] = arguments[i];
	          }

	          var fetchInput = args[0];
	          var method = 'GET';
	          var url;

	          if (typeof fetchInput === 'string') {
	            url = fetchInput;
	          } else if ('Request' in _window$2 && fetchInput instanceof _window$2.Request) {
	            url = fetchInput.url;
	            if (fetchInput.method) {
	              method = fetchInput.method;
	            }
	          } else {
	            url = '' + fetchInput;
	          }

	          // if Sentry key appears in URL, don't capture, as it's our own request
	          if (url.indexOf(self._globalKey) !== -1) {
	            return origFetch.apply(this, args);
	          }

	          if (args[1] && args[1].method) {
	            method = args[1].method;
	          }

	          var fetchData = {
	            method: method,
	            url: url,
	            status_code: null
	          };

	          return origFetch.apply(this, args).then(function (response) {
	            fetchData.status_code = response.status;

	            self.captureBreadcrumb({
	              type: 'http',
	              category: 'fetch',
	              data: fetchData
	            });

	            return response;
	          })['catch'](function (err) {
	            // if there is an error performing the request
	            self.captureBreadcrumb({
	              type: 'http',
	              category: 'fetch',
	              data: fetchData,
	              level: 'error'
	            });

	            throw err;
	          });
	        };
	      }, wrappedBuiltIns);
	    }

	    // Capture breadcrumbs from any click that is unhandled / bubbled up all the way
	    // to the document. Do this before we instrument addEventListener.
	    if (autoBreadcrumbs.dom && this._hasDocument) {
	      if (_document.addEventListener) {
	        _document.addEventListener('click', self._breadcrumbEventHandler('click'), false);
	        _document.addEventListener('keypress', self._keypressEventHandler(), false);
	      } else if (_document.attachEvent) {
	        // IE8 Compatibility
	        _document.attachEvent('onclick', self._breadcrumbEventHandler('click'));
	        _document.attachEvent('onkeypress', self._keypressEventHandler());
	      }
	    }

	    // record navigation (URL) changes
	    // NOTE: in Chrome App environment, touching history.pushState, *even inside
	    //       a try/catch block*, will cause Chrome to output an error to console.error
	    // borrowed from: https://github.com/angular/angular.js/pull/13945/files
	    var chrome = _window$2.chrome;
	    var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
	    var hasPushAndReplaceState = !isChromePackagedApp && _window$2.history && _window$2.history.pushState && _window$2.history.replaceState;
	    if (autoBreadcrumbs.location && hasPushAndReplaceState) {
	      // TODO: remove onpopstate handler on uninstall()
	      var oldOnPopState = _window$2.onpopstate;
	      _window$2.onpopstate = function () {
	        var currentHref = self._location.href;
	        self._captureUrlChange(self._lastHref, currentHref);

	        if (oldOnPopState) {
	          return oldOnPopState.apply(this, arguments);
	        }
	      };

	      var historyReplacementFunction = function historyReplacementFunction(origHistFunction) {
	        // note history.pushState.length is 0; intentionally not declaring
	        // params to preserve 0 arity
	        return function () /* state, title, url */{
	          var url = arguments.length > 2 ? arguments[2] : undefined;

	          // url argument is optional
	          if (url) {
	            // coerce to string (this is what pushState does)
	            self._captureUrlChange(self._lastHref, url + '');
	          }

	          return origHistFunction.apply(this, arguments);
	        };
	      };

	      fill$1(_window$2.history, 'pushState', historyReplacementFunction, wrappedBuiltIns);
	      fill$1(_window$2.history, 'replaceState', historyReplacementFunction, wrappedBuiltIns);
	    }

	    if (autoBreadcrumbs.console && 'console' in _window$2 && console.log) {
	      // console
	      var consoleMethodCallback = function consoleMethodCallback(msg, data) {
	        self.captureBreadcrumb({
	          message: msg,
	          level: data.level,
	          category: 'console'
	        });
	      };

	      each$1(['debug', 'info', 'warn', 'error', 'log'], function (_, level) {
	        wrapConsoleMethod(console, level, consoleMethodCallback);
	      });
	    }
	  },

	  _restoreBuiltIns: function _restoreBuiltIns() {
	    // restore any wrapped builtins
	    var builtin;
	    while (this._wrappedBuiltIns.length) {
	      builtin = this._wrappedBuiltIns.shift();

	      var obj = builtin[0],
	          name = builtin[1],
	          orig = builtin[2];

	      obj[name] = orig;
	    }
	  },

	  _restoreConsole: function _restoreConsole() {
	    // eslint-disable-next-line guard-for-in
	    for (var method in this._originalConsoleMethods) {
	      this._originalConsole[method] = this._originalConsoleMethods[method];
	    }
	  },

	  _drainPlugins: function _drainPlugins() {
	    var self = this;

	    // FIX ME TODO
	    each$1(this._plugins, function (_, plugin) {
	      var installer = plugin[0];
	      var args = plugin[1];
	      installer.apply(self, [self].concat(args));
	    });
	  },

	  _parseDSN: function _parseDSN(str) {
	    var m = dsnPattern.exec(str),
	        dsn = {},
	        i = 7;

	    try {
	      while (i--) {
	        dsn[dsnKeys[i]] = m[i] || '';
	      }
	    } catch (e) {
	      throw new RavenConfigError$1('Invalid DSN: ' + str);
	    }

	    if (dsn.pass && !this._globalOptions.allowSecretKey) {
	      throw new RavenConfigError$1('Do not specify your secret key in the DSN. See: http://bit.ly/raven-secret-key');
	    }

	    return dsn;
	  },

	  _getGlobalServer: function _getGlobalServer(uri) {
	    // assemble the endpoint from the uri pieces
	    var globalServer = '//' + uri.host + (uri.port ? ':' + uri.port : '');

	    if (uri.protocol) {
	      globalServer = uri.protocol + ':' + globalServer;
	    }
	    return globalServer;
	  },

	  _handleOnErrorStackInfo: function _handleOnErrorStackInfo() {
	    // if we are intentionally ignoring errors via onerror, bail out
	    if (!this._ignoreOnError) {
	      this._handleStackInfo.apply(this, arguments);
	    }
	  },

	  _handleStackInfo: function _handleStackInfo(stackInfo, options) {
	    var frames = this._prepareFrames(stackInfo, options);

	    this._triggerEvent('handle', {
	      stackInfo: stackInfo,
	      options: options
	    });

	    this._processException(stackInfo.name, stackInfo.message, stackInfo.url, stackInfo.lineno, frames, options);
	  },

	  _prepareFrames: function _prepareFrames(stackInfo, options) {
	    var self = this;
	    var frames = [];
	    if (stackInfo.stack && stackInfo.stack.length) {
	      each$1(stackInfo.stack, function (i, stack) {
	        var frame = self._normalizeFrame(stack, stackInfo.url);
	        if (frame) {
	          frames.push(frame);
	        }
	      });

	      // e.g. frames captured via captureMessage throw
	      if (options && options.trimHeadFrames) {
	        for (var j = 0; j < options.trimHeadFrames && j < frames.length; j++) {
	          frames[j].in_app = false;
	        }
	      }
	    }
	    frames = frames.slice(0, this._globalOptions.stackTraceLimit);
	    return frames;
	  },

	  _normalizeFrame: function _normalizeFrame(frame, stackInfoUrl) {
	    // normalize the frames data
	    var normalized = {
	      filename: frame.url,
	      lineno: frame.line,
	      colno: frame.column,
	      function: frame.func || '?'
	    };

	    // Case when we don't have any information about the error
	    // E.g. throwing a string or raw object, instead of an `Error` in Firefox
	    // Generating synthetic error doesn't add any value here
	    //
	    // We should probably somehow let a user know that they should fix their code
	    if (!frame.url) {
	      normalized.filename = stackInfoUrl; // fallback to whole stacks url from onerror handler
	    }

	    normalized.in_app = !( // determine if an exception came from outside of our app
	    // first we check the global includePaths list.
	    !!this._globalOptions.includePaths.test && !this._globalOptions.includePaths.test(normalized.filename) ||
	    // Now we check for fun, if the function name is Raven or TraceKit
	    /(Raven|TraceKit)\./.test(normalized['function']) ||
	    // finally, we do a last ditch effort and check for raven.min.js
	    /raven\.(min\.)?js$/.test(normalized.filename));

	    return normalized;
	  },

	  _processException: function _processException(type, message, fileurl, lineno, frames, options) {
	    var prefixedMessage = (type ? type + ': ' : '') + (message || '');
	    if (!!this._globalOptions.ignoreErrors.test && (this._globalOptions.ignoreErrors.test(message) || this._globalOptions.ignoreErrors.test(prefixedMessage))) {
	      return;
	    }

	    var stacktrace;

	    if (frames && frames.length) {
	      fileurl = frames[0].filename || fileurl;
	      // Sentry expects frames oldest to newest
	      // and JS sends them as newest to oldest
	      frames.reverse();
	      stacktrace = { frames: frames };
	    } else if (fileurl) {
	      stacktrace = {
	        frames: [{
	          filename: fileurl,
	          lineno: lineno,
	          in_app: true
	        }]
	      };
	    }

	    if (!!this._globalOptions.ignoreUrls.test && this._globalOptions.ignoreUrls.test(fileurl)) {
	      return;
	    }

	    if (!!this._globalOptions.whitelistUrls.test && !this._globalOptions.whitelistUrls.test(fileurl)) {
	      return;
	    }

	    var data = objectMerge$1({
	      // sentry.interfaces.Exception
	      exception: {
	        values: [{
	          type: type,
	          value: message,
	          stacktrace: stacktrace
	        }]
	      },
	      transaction: fileurl
	    }, options);

	    // Fire away!
	    this._send(data);
	  },

	  _trimPacket: function _trimPacket(data) {
	    // For now, we only want to truncate the two different messages
	    // but this could/should be expanded to just trim everything
	    var max = this._globalOptions.maxMessageLength;
	    if (data.message) {
	      data.message = truncate$1(data.message, max);
	    }
	    if (data.exception) {
	      var exception = data.exception.values[0];
	      exception.value = truncate$1(exception.value, max);
	    }

	    var request = data.request;
	    if (request) {
	      if (request.url) {
	        request.url = truncate$1(request.url, this._globalOptions.maxUrlLength);
	      }
	      if (request.Referer) {
	        request.Referer = truncate$1(request.Referer, this._globalOptions.maxUrlLength);
	      }
	    }

	    if (data.breadcrumbs && data.breadcrumbs.values) this._trimBreadcrumbs(data.breadcrumbs);

	    return data;
	  },

	  /**
	   * Truncate breadcrumb values (right now just URLs)
	   */
	  _trimBreadcrumbs: function _trimBreadcrumbs(breadcrumbs) {
	    // known breadcrumb properties with urls
	    // TODO: also consider arbitrary prop values that start with (https?)?://
	    var urlProps = ['to', 'from', 'url'],
	        urlProp,
	        crumb,
	        data;

	    for (var i = 0; i < breadcrumbs.values.length; ++i) {
	      crumb = breadcrumbs.values[i];
	      if (!crumb.hasOwnProperty('data') || !isObject$3(crumb.data) || objectFrozen$1(crumb.data)) continue;

	      data = objectMerge$1({}, crumb.data);
	      for (var j = 0; j < urlProps.length; ++j) {
	        urlProp = urlProps[j];
	        if (data.hasOwnProperty(urlProp) && data[urlProp]) {
	          data[urlProp] = truncate$1(data[urlProp], this._globalOptions.maxUrlLength);
	        }
	      }
	      breadcrumbs.values[i].data = data;
	    }
	  },

	  _getHttpData: function _getHttpData() {
	    if (!this._hasNavigator && !this._hasDocument) return;
	    var httpData = {};

	    if (this._hasNavigator && _navigator.userAgent) {
	      httpData.headers = {
	        'User-Agent': _navigator.userAgent
	      };
	    }

	    // Check in `window` instead of `document`, as we may be in ServiceWorker environment
	    if (_window$2.location && _window$2.location.href) {
	      httpData.url = _window$2.location.href;
	    }

	    if (this._hasDocument && _document.referrer) {
	      if (!httpData.headers) httpData.headers = {};
	      httpData.headers.Referer = _document.referrer;
	    }

	    return httpData;
	  },

	  _resetBackoff: function _resetBackoff() {
	    this._backoffDuration = 0;
	    this._backoffStart = null;
	  },

	  _shouldBackoff: function _shouldBackoff() {
	    return this._backoffDuration && now() - this._backoffStart < this._backoffDuration;
	  },

	  /**
	   * Returns true if the in-process data payload matches the signature
	   * of the previously-sent data
	   *
	   * NOTE: This has to be done at this level because TraceKit can generate
	   *       data from window.onerror WITHOUT an exception object (IE8, IE9,
	   *       other old browsers). This can take the form of an "exception"
	   *       data object with a single frame (derived from the onerror args).
	   */
	  _isRepeatData: function _isRepeatData(current) {
	    var last = this._lastData;

	    if (!last || current.message !== last.message || // defined for captureMessage
	    current.transaction !== last.transaction // defined for captureException/onerror
	    ) return false;

	    // Stacktrace interface (i.e. from captureMessage)
	    if (current.stacktrace || last.stacktrace) {
	      return isSameStacktrace$1(current.stacktrace, last.stacktrace);
	    } else if (current.exception || last.exception) {
	      // Exception interface (i.e. from captureException/onerror)
	      return isSameException$1(current.exception, last.exception);
	    }

	    return true;
	  },

	  _setBackoffState: function _setBackoffState(request) {
	    // If we are already in a backoff state, don't change anything
	    if (this._shouldBackoff()) {
	      return;
	    }

	    var status = request.status;

	    // 400 - project_id doesn't exist or some other fatal
	    // 401 - invalid/revoked dsn
	    // 429 - too many requests
	    if (!(status === 400 || status === 401 || status === 429)) return;

	    var retry;
	    try {
	      // If Retry-After is not in Access-Control-Expose-Headers, most
	      // browsers will throw an exception trying to access it
	      if (supportsFetch$1()) {
	        retry = request.headers.get('Retry-After');
	      } else {
	        retry = request.getResponseHeader('Retry-After');
	      }

	      // Retry-After is returned in seconds
	      retry = parseInt(retry, 10) * 1000;
	    } catch (e) {
	      /* eslint no-empty:0 */
	    }

	    this._backoffDuration = retry ? // If Sentry server returned a Retry-After value, use it
	    retry : // Otherwise, double the last backoff duration (starts at 1 sec)
	    this._backoffDuration * 2 || 1000;

	    this._backoffStart = now();
	  },

	  _send: function _send(data) {
	    var globalOptions = this._globalOptions;

	    var baseData = {
	      project: this._globalProject,
	      logger: globalOptions.logger,
	      platform: 'javascript'
	    },
	        httpData = this._getHttpData();

	    if (httpData) {
	      baseData.request = httpData;
	    }

	    // HACK: delete `trimHeadFrames` to prevent from appearing in outbound payload
	    if (data.trimHeadFrames) delete data.trimHeadFrames;

	    data = objectMerge$1(baseData, data);

	    // Merge in the tags and extra separately since objectMerge doesn't handle a deep merge
	    data.tags = objectMerge$1(objectMerge$1({}, this._globalContext.tags), data.tags);
	    data.extra = objectMerge$1(objectMerge$1({}, this._globalContext.extra), data.extra);

	    // Send along our own collected metadata with extra
	    data.extra['session:duration'] = now() - this._startTime;

	    if (this._breadcrumbs && this._breadcrumbs.length > 0) {
	      // intentionally make shallow copy so that additions
	      // to breadcrumbs aren't accidentally sent in this request
	      data.breadcrumbs = {
	        values: [].slice.call(this._breadcrumbs, 0)
	      };
	    }

	    if (this._globalContext.user) {
	      // sentry.interfaces.User
	      data.user = this._globalContext.user;
	    }

	    // Include the environment if it's defined in globalOptions
	    if (globalOptions.environment) data.environment = globalOptions.environment;

	    // Include the release if it's defined in globalOptions
	    if (globalOptions.release) data.release = globalOptions.release;

	    // Include server_name if it's defined in globalOptions
	    if (globalOptions.serverName) data.server_name = globalOptions.serverName;

	    data = this._sanitizeData(data);

	    // Cleanup empty properties before sending them to the server
	    Object.keys(data).forEach(function (key) {
	      if (data[key] == null || data[key] === '' || isEmptyObject$1(data[key])) {
	        delete data[key];
	      }
	    });

	    if (isFunction$2(globalOptions.dataCallback)) {
	      data = globalOptions.dataCallback(data) || data;
	    }

	    // Why??????????
	    if (!data || isEmptyObject$1(data)) {
	      return;
	    }

	    // Check if the request should be filtered or not
	    if (isFunction$2(globalOptions.shouldSendCallback) && !globalOptions.shouldSendCallback(data)) {
	      return;
	    }

	    // Backoff state: Sentry server previously responded w/ an error (e.g. 429 - too many requests),
	    // so drop requests until "cool-off" period has elapsed.
	    if (this._shouldBackoff()) {
	      this._logDebug('warn', 'Raven dropped error due to backoff: ', data);
	      return;
	    }

	    if (typeof globalOptions.sampleRate === 'number') {
	      if (Math.random() < globalOptions.sampleRate) {
	        this._sendProcessedPayload(data);
	      }
	    } else {
	      this._sendProcessedPayload(data);
	    }
	  },

	  _sanitizeData: function _sanitizeData(data) {
	    return sanitize$1(data, this._globalOptions.sanitizeKeys);
	  },

	  _getUuid: function _getUuid() {
	    return uuid4$1();
	  },

	  _sendProcessedPayload: function _sendProcessedPayload(data, callback) {
	    var self = this;
	    var globalOptions = this._globalOptions;

	    if (!this.isSetup()) return;

	    // Try and clean up the packet before sending by truncating long values
	    data = this._trimPacket(data);

	    // ideally duplicate error testing should occur *before* dataCallback/shouldSendCallback,
	    // but this would require copying an un-truncated copy of the data packet, which can be
	    // arbitrarily deep (extra_data) -- could be worthwhile? will revisit
	    if (!this._globalOptions.allowDuplicates && this._isRepeatData(data)) {
	      this._logDebug('warn', 'Raven dropped repeat event: ', data);
	      return;
	    }

	    // Send along an event_id if not explicitly passed.
	    // This event_id can be used to reference the error within Sentry itself.
	    // Set lastEventId after we know the error should actually be sent
	    this._lastEventId = data.event_id || (data.event_id = this._getUuid());

	    // Store outbound payload after trim
	    this._lastData = data;

	    this._logDebug('debug', 'Raven about to send:', data);

	    var auth = {
	      sentry_version: '7',
	      sentry_client: 'raven-js/' + this.VERSION,
	      sentry_key: this._globalKey
	    };

	    if (this._globalSecret) {
	      auth.sentry_secret = this._globalSecret;
	    }

	    var exception = data.exception && data.exception.values[0];

	    // only capture 'sentry' breadcrumb is autoBreadcrumbs is truthy
	    if (this._globalOptions.autoBreadcrumbs && this._globalOptions.autoBreadcrumbs.sentry) {
	      this.captureBreadcrumb({
	        category: 'sentry',
	        message: exception ? (exception.type ? exception.type + ': ' : '') + exception.value : data.message,
	        event_id: data.event_id,
	        level: data.level || 'error' // presume error unless specified
	      });
	    }

	    var url = this._globalEndpoint;
	    (globalOptions.transport || this._makeRequest).call(this, {
	      url: url,
	      auth: auth,
	      data: data,
	      options: globalOptions,
	      onSuccess: function success() {
	        self._resetBackoff();

	        self._triggerEvent('success', {
	          data: data,
	          src: url
	        });
	        callback && callback();
	      },
	      onError: function failure(error) {
	        self._logDebug('error', 'Raven transport failed to send: ', error);

	        if (error.request) {
	          self._setBackoffState(error.request);
	        }

	        self._triggerEvent('failure', {
	          data: data,
	          src: url
	        });
	        error = error || new Error('Raven send failed (no additional details provided)');
	        callback && callback(error);
	      }
	    });
	  },

	  _makeRequest: function _makeRequest(opts) {
	    // Auth is intentionally sent as part of query string (NOT as custom HTTP header) to avoid preflight CORS requests
	    var url = opts.url + '?' + urlencode$1(opts.auth);

	    var evaluatedHeaders = null;
	    var evaluatedFetchParameters = {};

	    if (opts.options.headers) {
	      evaluatedHeaders = this._evaluateHash(opts.options.headers);
	    }

	    if (opts.options.fetchParameters) {
	      evaluatedFetchParameters = this._evaluateHash(opts.options.fetchParameters);
	    }

	    if (supportsFetch$1()) {
	      evaluatedFetchParameters.body = stringify$1(opts.data);

	      var defaultFetchOptions = objectMerge$1({}, this._fetchDefaults);
	      var fetchOptions = objectMerge$1(defaultFetchOptions, evaluatedFetchParameters);

	      if (evaluatedHeaders) {
	        fetchOptions.headers = evaluatedHeaders;
	      }

	      return _window$2.fetch(url, fetchOptions).then(function (response) {
	        if (response.ok) {
	          opts.onSuccess && opts.onSuccess();
	        } else {
	          var error = new Error('Sentry error code: ' + response.status);
	          // It's called request only to keep compatibility with XHR interface
	          // and not add more redundant checks in setBackoffState method
	          error.request = response;
	          opts.onError && opts.onError(error);
	        }
	      })['catch'](function () {
	        opts.onError && opts.onError(new Error('Sentry error code: network unavailable'));
	      });
	    }

	    var request = _window$2.XMLHttpRequest && new _window$2.XMLHttpRequest();
	    if (!request) return;

	    // if browser doesn't support CORS (e.g. IE7), we are out of luck
	    var hasCORS = 'withCredentials' in request || typeof XDomainRequest !== 'undefined';

	    if (!hasCORS) return;

	    if ('withCredentials' in request) {
	      request.onreadystatechange = function () {
	        if (request.readyState !== 4) {
	          return;
	        } else if (request.status === 200) {
	          opts.onSuccess && opts.onSuccess();
	        } else if (opts.onError) {
	          var err = new Error('Sentry error code: ' + request.status);
	          err.request = request;
	          opts.onError(err);
	        }
	      };
	    } else {
	      request = new XDomainRequest();
	      // xdomainrequest cannot go http -> https (or vice versa),
	      // so always use protocol relative
	      url = url.replace(/^https?:/, '');

	      // onreadystatechange not supported by XDomainRequest
	      if (opts.onSuccess) {
	        request.onload = opts.onSuccess;
	      }
	      if (opts.onError) {
	        request.onerror = function () {
	          var err = new Error('Sentry error code: XDomainRequest');
	          err.request = request;
	          opts.onError(err);
	        };
	      }
	    }

	    request.open('POST', url);

	    if (evaluatedHeaders) {
	      each$1(evaluatedHeaders, function (key, value) {
	        request.setRequestHeader(key, value);
	      });
	    }

	    request.send(stringify$1(opts.data));
	  },

	  _evaluateHash: function _evaluateHash(hash) {
	    var evaluated = {};

	    for (var key in hash) {
	      if (hash.hasOwnProperty(key)) {
	        var value = hash[key];
	        evaluated[key] = typeof value === 'function' ? value() : value;
	      }
	    }

	    return evaluated;
	  },

	  _logDebug: function _logDebug(level) {
	    // We allow `Raven.debug` and `Raven.config(DSN, { debug: true })` to not make backward incompatible API change
	    if (this._originalConsoleMethods[level] && (this.debug || this._globalOptions.debug)) {
	      // In IE<10 console methods do not have their own 'apply' method
	      Function.prototype.apply.call(this._originalConsoleMethods[level], this._originalConsole, [].slice.call(arguments, 1));
	    }
	  },

	  _mergeContext: function _mergeContext(key, context) {
	    if (isUndefined$1(context)) {
	      delete this._globalContext[key];
	    } else {
	      this._globalContext[key] = objectMerge$1(this._globalContext[key] || {}, context);
	    }
	  }
	};

	// Deprecations
	Raven.prototype.setUser = Raven.prototype.setUserContext;
	Raven.prototype.setReleaseContext = Raven.prototype.setRelease;

	var raven = Raven;

	var raven$1 = /*#__PURE__*/Object.freeze({
		default: raven,
		__moduleExports: raven
	});

	var RavenConstructor = ( raven$1 && raven ) || raven$1;

	/**
	 * Enforces a single instance of the Raven client, and the
	 * main entry point for Raven. If you are a consumer of the
	 * Raven library, you SHOULD load this file (vs raven.js).
	 **/

	// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
	var _window$3 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};
	var _Raven = _window$3.Raven;

	var Raven$1 = new RavenConstructor();

	/*
	 * Allow multiple versions of Raven to be installed.
	 * Strip Raven from the global context and returns the instance.
	 *
	 * @return {Raven}
	 */
	Raven$1.noConflict = function () {
	  _window$3.Raven = _Raven;
	  return Raven$1;
	};

	Raven$1.afterLoad();

	var singleton = Raven$1;

	/**
	 * DISCLAIMER:
	 *
	 * Expose `Client` constructor for cases where user want to track multiple "sub-applications" in one larger app.
	 * It's not meant to be used by a wide audience, so pleaaase make sure that you know what you're doing before using it.
	 * Accidentally calling `install` multiple times, may result in an unexpected behavior that's very hard to debug.
	 *
	 * It's called `Client' to be in-line with Raven Node implementation.
	 *
	 * HOWTO:
	 *
	 * import Raven from 'raven-js';
	 *
	 * const someAppReporter = new Raven.Client();
	 * const someOtherAppReporter = new Raven.Client();
	 *
	 * someAppReporter.config('__DSN__', {
	 *   ...config goes here
	 * });
	 *
	 * someOtherAppReporter.config('__OTHER_DSN__', {
	 *   ...config goes here
	 * });
	 *
	 * someAppReporter.captureMessage(...);
	 * someAppReporter.captureException(...);
	 * someAppReporter.captureBreadcrumb(...);
	 *
	 * someOtherAppReporter.captureMessage(...);
	 * someOtherAppReporter.captureException(...);
	 * someOtherAppReporter.captureBreadcrumb(...);
	 *
	 * It should "just work".
	 */
	var Client = RavenConstructor;
	singleton.Client = Client;

	var noop$4 = function noop() {};
	function evaluateHash(hash) {
	  var evaluated = {};

	  for (var key in hash) {
	    if (hash.hasOwnProperty(key)) {
	      var value = hash[key];
	      evaluated[key] = typeof value === 'function' ? value() : value;
	    }
	  }

	  return evaluated;
	}

	var Sentry$1 = function () {
	  function Sentry(_ref) {
	    var _ref$key = _ref.key,
	        key = _ref$key === undefined ? 'ed6716196f0742d2bdee626bc665a2fe' : _ref$key,
	        _ref$project = _ref.project,
	        project = _ref$project === undefined ? '325' : _ref$project,
	        _ref$transportCallbac = _ref.transportCallback,
	        transportCallback = _ref$transportCallbac === undefined ? noop$4 : _ref$transportCallbac,
	        _ref$options = _ref.options,
	        options = _ref$options === undefined ? {} : _ref$options;
	    classCallCheck(this, Sentry);

	    var defaultOptions = {
	      method: 'POST'
	    };
	    var newOptions = Object.assign({}, defaultOptions, options);
	    singleton.config('https://' + key + '@m.toutiao.com/log/sentry/v2/' + project, {
	      transport: function transport(opts) {
	        var url = opts.url + '?' + urlEncodeFormData(opts.auth);

	        var evaluatedHeaders = '';
	        if (opts.options.headers) {
	          var _evaluatedHeaders = evaluateHash(opts.options.headers);
	          if (Object.keys(_evaluatedHeaders).length > 0) {
	            evaluatedHeaders = JSON.stringify(_evaluatedHeaders);
	          }
	        }

	        transportCallback({
	          url: url,
	          method: newOptions.method,
	          header: evaluatedHeaders,
	          data: opts.data
	        });
	      },

	      release: getSystemInfoSync().SDKUpdateVersion || '1.0.0.0',
	      allowDuplicates: true,
	      dataCallback: function dataCallback(data) {
	        var stacktrace = data.exception && data.exception.values && data.exception.values[0].stacktrace;

	        if (stacktrace && stacktrace.frames) {
	          stacktrace.frames.forEach(function (frame) {
	            if (frame.filename.endsWith('tma-core.js')) {
	              frame.filename = 'http://tosv.byted.org/obj/tma-sourcemap/tma-core.TOS_FILE_RANDOM.js';
	            }
	          });
	        }
	        return data;
	      }
	    }).install();
	  }

	  Sentry.prototype.report = function report(e, tags) {
	    singleton.captureException(e, {
	      tags: tags
	    });
	  };

	  return Sentry;
	}();

	_global$2.Sentry = Sentry$1;

	var tt$1 = {};
	for (var fnc in ttMethodsMap) {
	  if (typeof ttMethodsMap[fnc] === 'function') {
	    tt$1[fnc] = ttMethodsMap[fnc];
	  }
	}

	exports.tt = tt$1;
	exports.App = App;
	exports.getApp = getApp;
	exports.Page = Page$1;
	exports.getCurrentPages = getCurrentPages$1;
	exports.Component = Component$1;
	exports.Behavior = Behavior;

	return exports;

}({}));
$glob$.tt = $glob$.wx = TMACORE.tt; /* 提供对wxAPI支持 */
$glob$.App = TMACORE.App;
$glob$.Page = TMACORE.Page;
$glob$.getApp = TMACORE.getApp;
$glob$.Component = TMACORE.Component;
$glob$.Behavior = TMACORE.Behavior;
$glob$.getCurrentPages = TMACORE.getCurrentPages;
})(this);
