{"version":3,"sources":["../src/index.js"],"names":["pluginCrop","event","x","y","w","h","cb","throwError","call","Math","round","bitmap","width","start","end","data","slice","Buffer","allocUnsafe","offset","scanQuiet","idx","readUInt32BE","writeUInt32BE","height","class","autocrop","minPixelsPerSide","tolerance","cropOnlyFrames","a","len","length","colorTarget","getPixelColor","rgba1","constructor","intToRGBA","northPixelsToCrop","eastPixelsToCrop","southPixelsToCrop","westPixelsToCrop","north","colorXY","rgba2","colorDiff","east","south","west","widthOfPixelsToCrop","heightOfPixelsToCrop","doCrop","crop"],"mappings":"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","sourcesContent":["/* eslint-disable no-labels */\n\nimport { throwError, isNodePattern } from '@jimp/utils';\n\nexport default function pluginCrop(event) {\n  /**\n   * Crops the image at a given point to a give size\n   * @param {number} x the x coordinate to crop form\n   * @param {number} y the y coordinate to crop form\n   * @param w the width of the crop region\n   * @param h the height of the crop region\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  event('crop', function(x, y, w, h, cb) {\n    if (typeof x !== 'number' || typeof y !== 'number')\n      return throwError.call(this, 'x and y must be numbers', cb);\n    if (typeof w !== 'number' || typeof h !== 'number')\n      return throwError.call(this, 'w and h must be numbers', cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    w = Math.round(w);\n    h = Math.round(h);\n\n    if (x === 0 && w === this.bitmap.width) {\n      // shortcut\n      const start = (w * y + x) << 2;\n      const end = (start + h * w) << (2 + 1);\n\n      this.bitmap.data = this.bitmap.data.slice(start, end);\n    } else {\n      const bitmap = Buffer.allocUnsafe(w * h * 4);\n      let offset = 0;\n\n      this.scanQuiet(x, y, w, h, function(x, y, idx) {\n        const data = this.bitmap.data.readUInt32BE(idx, true);\n        bitmap.writeUInt32BE(data, offset, true);\n        offset += 4;\n      });\n\n      this.bitmap.data = bitmap;\n    }\n\n    this.bitmap.width = w;\n    this.bitmap.height = h;\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  });\n\n  return {\n    class: {\n      /**\n       * Autocrop same color borders from this image\n       * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)\n       * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)\n       * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)\n       * @returns {Jimp} this for chaining of methods\n       */\n      autocrop(...args) {\n        const w = this.bitmap.width;\n        const h = this.bitmap.height;\n        const minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image\n\n        let cb; // callback\n        let tolerance = 0.0002; // percent of color difference tolerance (default value)\n        let cropOnlyFrames = true; // flag to force cropping only if the image has a real \"frame\"\n        // i.e. all 4 sides have some border (default value)\n\n        // parse arguments\n        for (let a = 0, len = args.length; a < len; a++) {\n          if (typeof args[a] === 'number') {\n            // tolerance value passed\n            tolerance = args[a];\n          }\n\n          if (typeof args[a] === 'boolean') {\n            // cropOnlyFrames value passed\n            cropOnlyFrames = args[a];\n          }\n\n          if (typeof args[a] === 'function') {\n            // callback value passed\n            cb = args[a];\n          }\n        }\n\n        /**\n         * All borders must be of the same color as the top left pixel, to be cropped.\n         * It should be possible to crop borders each with a different color,\n         * but since there are many ways for corners to intersect, it would\n         * introduce unnecessary complexity to the algorithm.\n         */\n\n        // scan each side for same color borders\n        const colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color\n        const rgba1 = this.constructor.intToRGBA(colorTarget);\n\n        // for north and east sides\n        let northPixelsToCrop = 0;\n        let eastPixelsToCrop = 0;\n        let southPixelsToCrop = 0;\n        let westPixelsToCrop = 0;\n\n        // north side (scan rows from north to south)\n        north: for (let y = 0; y < h - minPixelsPerSide; y++) {\n          for (let x = 0; x < w; x++) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break north;\n            }\n          }\n          // this row contains all pixels with the same color: increment this side pixels to crop\n          northPixelsToCrop++;\n        }\n\n        // east side (scan columns from east to west)\n        east: for (let x = 0; x < w - minPixelsPerSide; x++) {\n          for (let y = 0 + northPixelsToCrop; y < h; y++) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break east;\n            }\n          }\n          // this column contains all pixels with the same color: increment this side pixels to crop\n          eastPixelsToCrop++;\n        }\n\n        // south side (scan rows from south to north)\n        south: for (\n          let y = h - 1;\n          y >= northPixelsToCrop + minPixelsPerSide;\n          y--\n        ) {\n          for (let x = w - eastPixelsToCrop - 1; x >= 0; x--) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break south;\n            }\n          }\n          // this row contains all pixels with the same color: increment this side pixels to crop\n          southPixelsToCrop++;\n        }\n\n        // west side (scan columns from west to east)\n        west: for (\n          let x = w - 1;\n          x >= 0 + eastPixelsToCrop + minPixelsPerSide;\n          x--\n        ) {\n          for (let y = h - 1; y >= 0 + northPixelsToCrop; y--) {\n            const colorXY = this.getPixelColor(x, y);\n            const rgba2 = this.constructor.intToRGBA(colorXY);\n\n            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {\n              // this pixel is too distant from the first one: abort this side scan\n              break west;\n            }\n          }\n          // this column contains all pixels with the same color: increment this side pixels to crop\n          westPixelsToCrop++;\n        }\n\n        // safety checks\n        const widthOfPixelsToCrop = w - (westPixelsToCrop + eastPixelsToCrop);\n        // widthOfPixelsToCrop >= 0 ? widthOfPixelsToCrop : 0;\n        const heightOfPixelsToCrop =\n          h - (southPixelsToCrop + northPixelsToCrop);\n        // heightOfPixelsToCrop >= 0 ? heightOfPixelsToCrop : 0;\n\n        // decide if a crop is needed\n        let doCrop = false;\n\n        if (cropOnlyFrames) {\n          // crop image if all sides should be cropped\n          doCrop =\n            eastPixelsToCrop !== 0 &&\n            northPixelsToCrop !== 0 &&\n            westPixelsToCrop !== 0 &&\n            southPixelsToCrop !== 0;\n        } else {\n          // crop image if at least one side should be cropped\n          doCrop =\n            eastPixelsToCrop !== 0 ||\n            northPixelsToCrop !== 0 ||\n            westPixelsToCrop !== 0 ||\n            southPixelsToCrop !== 0;\n        }\n\n        if (doCrop) {\n          // do the real crop\n          this.crop(\n            eastPixelsToCrop,\n            northPixelsToCrop,\n            widthOfPixelsToCrop,\n            heightOfPixelsToCrop\n          );\n        }\n\n        if (isNodePattern(cb)) {\n          cb.call(this, null, this);\n        }\n\n        return this;\n      }\n    }\n  };\n}\n"],"file":"index.js"}